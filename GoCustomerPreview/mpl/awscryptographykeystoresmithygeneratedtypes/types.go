// Code generated by smithy-go-codegen DO NOT EDIT.

package awscryptographykeystoresmithygeneratedtypes

import (
	"fmt"
	"unicode/utf8"

	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	"github.com/aws/aws-sdk-go-v2/service/kms"
)

type BeaconKeyMaterials struct {
	BeaconKeyIdentifier string

	EncryptionContext map[string]string

	BeaconKey []byte

	HmacKeys map[string][]byte
}

func (input BeaconKeyMaterials) Validate() error {
	if input.EncryptionContext == nil {
		return fmt.Errorf("input.EncryptionContext is required but has a nil value.")
	}
	if input.Aws_cryptography_keyStore_BeaconKeyMaterials_encryptionContext_Validate() != nil {
		return input.Aws_cryptography_keyStore_BeaconKeyMaterials_encryptionContext_Validate()
	}

	return nil
}

func (input BeaconKeyMaterials) Aws_cryptography_keyStore_BeaconKeyMaterials_encryptionContext_Validate() error {
	for key, value := range input.EncryptionContext {
		if !utf8.ValidString(key) {
			return fmt.Errorf("Invalid UTF bytes %s ", key)
		}
		if !utf8.ValidString(value) {
			return fmt.Errorf("Invalid UTF bytes %s ", value)
		}
	}

	return nil
}

type BranchKeyMaterials struct {
	BranchKey []byte

	BranchKeyIdentifier string

	BranchKeyVersion string

	EncryptionContext map[string]string
}

func (input BranchKeyMaterials) Validate() error {
	if !utf8.ValidString(input.BranchKeyVersion) {
		return fmt.Errorf("Invalid UTF bytes %s ", input.BranchKeyVersion)
	}
	if input.EncryptionContext == nil {
		return fmt.Errorf("input.EncryptionContext is required but has a nil value.")
	}
	if input.Aws_cryptography_keyStore_BranchKeyMaterials_encryptionContext_Validate() != nil {
		return input.Aws_cryptography_keyStore_BranchKeyMaterials_encryptionContext_Validate()
	}

	return nil
}

func (input BranchKeyMaterials) Aws_cryptography_keyStore_BranchKeyMaterials_encryptionContext_Validate() error {
	for key, value := range input.EncryptionContext {
		if !utf8.ValidString(key) {
			return fmt.Errorf("Invalid UTF bytes %s ", key)
		}
		if !utf8.ValidString(value) {
			return fmt.Errorf("Invalid UTF bytes %s ", value)
		}
	}

	return nil
}

type CreateKeyInput struct {
	BranchKeyIdentifier *string

	EncryptionContext map[string]string
}

func (input CreateKeyInput) Validate() error {
	if input.Aws_cryptography_keyStore_CreateKeyInput_encryptionContext_Validate() != nil {
		return input.Aws_cryptography_keyStore_CreateKeyInput_encryptionContext_Validate()
	}

	return nil
}

func (input CreateKeyInput) Aws_cryptography_keyStore_CreateKeyInput_encryptionContext_Validate() error {
	for key, value := range input.EncryptionContext {
		if !utf8.ValidString(key) {
			return fmt.Errorf("Invalid UTF bytes %s ", key)
		}
		if !utf8.ValidString(value) {
			return fmt.Errorf("Invalid UTF bytes %s ", value)
		}
	}

	return nil
}

type CreateKeyOutput struct {
	BranchKeyIdentifier string
}

func (input CreateKeyOutput) Validate() error {

	return nil
}

type CreateKeyStoreInput struct {
}

func (input CreateKeyStoreInput) Validate() error {

	return nil
}

type CreateKeyStoreOutput struct {
	TableArn string
}

func (input CreateKeyStoreOutput) Validate() error {
	if len(input.TableArn) < 1 {
		return fmt.Errorf("TableArn has a minimum length of 1 but has the length of %d.", len(input.TableArn))
	}
	if len(input.TableArn) > 1024 {
		return fmt.Errorf("TableArn has a maximum length of 1024 but has the length of %d.", len(input.TableArn))
	}

	return nil
}

type Discovery struct {
}

func (input Discovery) Validate() error {

	return nil
}

type GetActiveBranchKeyInput struct {
	BranchKeyIdentifier string
}

func (input GetActiveBranchKeyInput) Validate() error {

	return nil
}

type GetActiveBranchKeyOutput struct {
	BranchKeyMaterials BranchKeyMaterials
}

func (input GetActiveBranchKeyOutput) Validate() error {
	if input.BranchKeyMaterials.Validate() != nil {
		return input.BranchKeyMaterials.Validate()
	}

	return nil
}

type GetBeaconKeyInput struct {
	BranchKeyIdentifier string
}

func (input GetBeaconKeyInput) Validate() error {

	return nil
}

type GetBeaconKeyOutput struct {
	BeaconKeyMaterials BeaconKeyMaterials
}

func (input GetBeaconKeyOutput) Validate() error {
	if input.BeaconKeyMaterials.Validate() != nil {
		return input.BeaconKeyMaterials.Validate()
	}

	return nil
}

type GetBranchKeyVersionInput struct {
	BranchKeyIdentifier string

	BranchKeyVersion string
}

func (input GetBranchKeyVersionInput) Validate() error {

	return nil
}

type GetBranchKeyVersionOutput struct {
	BranchKeyMaterials BranchKeyMaterials
}

func (input GetBranchKeyVersionOutput) Validate() error {
	if input.BranchKeyMaterials.Validate() != nil {
		return input.BranchKeyMaterials.Validate()
	}

	return nil
}

type MRDiscovery struct {
	Region string
}

func (input MRDiscovery) Validate() error {
	if len(input.Region) < 1 {
		return fmt.Errorf("RegionType has a minimum length of 1 but has the length of %d.", len(input.Region))
	}
	if len(input.Region) > 32 {
		return fmt.Errorf("RegionType has a maximum length of 32 but has the length of %d.", len(input.Region))
	}

	return nil
}

type GetKeyStoreInfoOutput struct {
	GrantTokens []string

	KeyStoreId string

	KeyStoreName string

	KmsConfiguration KMSConfiguration

	LogicalKeyStoreName string
}

func (input GetKeyStoreInfoOutput) Validate() error {
	if input.GrantTokens == nil {
		return fmt.Errorf("input.GrantTokens is required but has a nil value.")
	}
	if len(input.KeyStoreName) < 3 {
		return fmt.Errorf("TableName has a minimum length of 3 but has the length of %d.", len(input.KeyStoreName))
	}
	if len(input.KeyStoreName) > 255 {
		return fmt.Errorf("TableName has a maximum length of 255 but has the length of %d.", len(input.KeyStoreName))
	}
	if input.KmsConfiguration == nil {
		return fmt.Errorf("input.KmsConfiguration is required but has a nil value.")
	}
	if input.Aws_cryptography_keyStore_GetKeyStoreInfoOutput_kmsConfiguration_Validate() != nil {
		return input.Aws_cryptography_keyStore_GetKeyStoreInfoOutput_kmsConfiguration_Validate()
	}

	return nil
}

func (input GetKeyStoreInfoOutput) Aws_cryptography_keyStore_GetKeyStoreInfoOutput_kmsConfiguration_Validate() error {
	if input.KmsConfiguration == nil {
		return nil
	}
	switch unionType := input.KmsConfiguration.(type) {
	case *KMSConfigurationMemberkmsKeyArn:
		if len(unionType.Value) < 1 {
			return fmt.Errorf("KeyIdType has a minimum length of 1 but has the length of %d.", len(unionType.Value))
		}
		if len(unionType.Value) > 2048 {
			return fmt.Errorf("KeyIdType has a maximum length of 2048 but has the length of %d.", len(unionType.Value))
		}
	case *KMSConfigurationMemberkmsMRKeyArn:
		if len(unionType.Value) < 1 {
			return fmt.Errorf("KeyIdType has a minimum length of 1 but has the length of %d.", len(unionType.Value))
		}
		if len(unionType.Value) > 2048 {
			return fmt.Errorf("KeyIdType has a maximum length of 2048 but has the length of %d.", len(unionType.Value))
		}
	case *KMSConfigurationMemberdiscovery:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KMSConfigurationMembermrDiscovery:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}

type VersionKeyInput struct {
	BranchKeyIdentifier string
}

func (input VersionKeyInput) Validate() error {

	return nil
}

type VersionKeyOutput struct {
}

func (input VersionKeyOutput) Validate() error {

	return nil
}

type DdbClientReference struct {
}

func (input DdbClientReference) Validate() error {

	return nil
}

type KmsClientReference struct {
}

func (input KmsClientReference) Validate() error {

	return nil
}

type KeyStoreConfig struct {
	DdbTableName string

	KmsConfiguration KMSConfiguration

	LogicalKeyStoreName string

	DdbClient *dynamodb.Client

	GrantTokens []string

	Id *string

	KmsClient *kms.Client
}

func (input KeyStoreConfig) Validate() error {
	if len(input.DdbTableName) < 3 {
		return fmt.Errorf("TableName has a minimum length of 3 but has the length of %d.", len(input.DdbTableName))
	}
	if len(input.DdbTableName) > 255 {
		return fmt.Errorf("TableName has a maximum length of 255 but has the length of %d.", len(input.DdbTableName))
	}
	if input.KmsConfiguration == nil {
		return fmt.Errorf("input.KmsConfiguration is required but has a nil value.")
	}
	if input.Aws_cryptography_keyStore_KeyStoreConfig_kmsConfiguration_Validate() != nil {
		return input.Aws_cryptography_keyStore_KeyStoreConfig_kmsConfiguration_Validate()
	}

	return nil
}

func (input KeyStoreConfig) Aws_cryptography_keyStore_KeyStoreConfig_kmsConfiguration_Validate() error {
	if input.KmsConfiguration == nil {
		return nil
	}
	switch unionType := input.KmsConfiguration.(type) {
	case *KMSConfigurationMemberkmsKeyArn:
		if len(unionType.Value) < 1 {
			return fmt.Errorf("KeyIdType has a minimum length of 1 but has the length of %d.", len(unionType.Value))
		}
		if len(unionType.Value) > 2048 {
			return fmt.Errorf("KeyIdType has a maximum length of 2048 but has the length of %d.", len(unionType.Value))
		}
	case *KMSConfigurationMemberkmsMRKeyArn:
		if len(unionType.Value) < 1 {
			return fmt.Errorf("KeyIdType has a minimum length of 1 but has the length of %d.", len(unionType.Value))
		}
		if len(unionType.Value) > 2048 {
			return fmt.Errorf("KeyIdType has a maximum length of 2048 but has the length of %d.", len(unionType.Value))
		}
	case *KMSConfigurationMemberdiscovery:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KMSConfigurationMembermrDiscovery:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}

// KMSConfigurationMemberdiscovery
// KMSConfigurationMemberkmsKeyArn
// KMSConfigurationMemberkmsMRKeyArn
// KMSConfigurationMembermrDiscovery
type KMSConfiguration interface {
	isKMSConfiguration()
}

type KMSConfigurationMemberdiscovery struct {
	Value Discovery
}

func (*KMSConfigurationMemberdiscovery) isKMSConfiguration() {}

type KMSConfigurationMemberkmsKeyArn struct {
	Value string
}

func (*KMSConfigurationMemberkmsKeyArn) isKMSConfiguration() {}

type KMSConfigurationMemberkmsMRKeyArn struct {
	Value string
}

func (*KMSConfigurationMemberkmsMRKeyArn) isKMSConfiguration() {}

type KMSConfigurationMembermrDiscovery struct {
	Value MRDiscovery
}

func (*KMSConfigurationMembermrDiscovery) isKMSConfiguration() {}

type KeyStoreBaseException interface {
	// This is a dummy method to allow type assertion since Go empty interfaces
	// aren't useful for type assertion checks. No concrete class is expected to implement
	// this method. This is also not exported.
	interfaceBindingMethod()
}
