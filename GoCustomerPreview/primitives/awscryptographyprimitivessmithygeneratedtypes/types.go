// Code generated by smithy-go-codegen DO NOT EDIT.

package awscryptographyprimitivessmithygeneratedtypes

import (
	"fmt"
)

type AES_GCM struct {
	IvLength int32

	KeyLength int32

	TagLength int32
}

func (input AES_GCM) Validate() error {
	if input.IvLength < 0 {
		return fmt.Errorf("Uint8Bits has a minimum of 0 but has the value of %d.", input.IvLength)
	}
	if input.IvLength > 255 {
		return fmt.Errorf("Uint8Bits has a maximum of 255 but has the value of %d.", input.IvLength)
	}
	if input.KeyLength < 1 {
		return fmt.Errorf("SymmetricKeyLength has a minimum of 1 but has the value of %d.", input.KeyLength)
	}
	if input.KeyLength > 32 {
		return fmt.Errorf("SymmetricKeyLength has a maximum of 32 but has the value of %d.", input.KeyLength)
	}
	if input.TagLength < 0 {
		return fmt.Errorf("Uint8Bytes has a minimum of 0 but has the value of %d.", input.TagLength)
	}
	if input.TagLength > 32 {
		return fmt.Errorf("Uint8Bytes has a maximum of 32 but has the value of %d.", input.TagLength)
	}

	return nil
}

type AESDecryptInput struct {
	Aad []byte

	AuthTag []byte

	CipherTxt []byte

	EncAlg AES_GCM

	Iv []byte

	Key []byte
}

func (input AESDecryptInput) Validate() error {
	if input.EncAlg.Validate() != nil {
		return input.EncAlg.Validate()
	}

	return nil
}

type AESDecryptOutput struct {
	Plaintext []byte
}

func (input AESDecryptOutput) Validate() error {

	return nil
}

type AESEncryptInput struct {
	Aad []byte

	EncAlg AES_GCM

	Iv []byte

	Key []byte

	Msg []byte
}

func (input AESEncryptInput) Validate() error {
	if input.EncAlg.Validate() != nil {
		return input.EncAlg.Validate()
	}

	return nil
}

type AESEncryptOutput struct {
	AuthTag []byte

	CipherText []byte
}

func (input AESEncryptOutput) Validate() error {

	return nil
}

type AesKdfCtrInput struct {
	ExpectedLength int32

	Ikm []byte

	Nonce []byte
}

func (input AesKdfCtrInput) Validate() error {
	if input.ExpectedLength < 0 {
		return fmt.Errorf("PositiveInteger has a minimum of 0 but has the value of %d.", input.ExpectedLength)
	}

	return nil
}

type AesKdfCtrOutput struct {
	Okm []byte
}

func (input AesKdfCtrOutput) Validate() error {

	return nil
}

type ECCPublicKey struct {
	Der []byte
}

func (input ECCPublicKey) Validate() error {

	return nil
}

type CompressPublicKeyInput struct {
	EccCurve ECDHCurveSpec

	PublicKey ECCPublicKey
}

func (input CompressPublicKeyInput) Validate() error {
	if input.PublicKey.Validate() != nil {
		return input.PublicKey.Validate()
	}

	return nil
}

type CompressPublicKeyOutput struct {
	CompressedPublicKey []byte
}

func (input CompressPublicKeyOutput) Validate() error {

	return nil
}

type DecompressPublicKeyInput struct {
	CompressedPublicKey []byte

	EccCurve ECDHCurveSpec
}

func (input DecompressPublicKeyInput) Validate() error {

	return nil
}

type DecompressPublicKeyOutput struct {
	PublicKey ECCPublicKey
}

func (input DecompressPublicKeyOutput) Validate() error {
	if input.PublicKey.Validate() != nil {
		return input.PublicKey.Validate()
	}

	return nil
}

type ECCPrivateKey struct {
	Pem []byte
}

func (input ECCPrivateKey) Validate() error {

	return nil
}

type DeriveSharedSecretInput struct {
	EccCurve ECDHCurveSpec

	PrivateKey ECCPrivateKey

	PublicKey ECCPublicKey
}

func (input DeriveSharedSecretInput) Validate() error {
	if input.PrivateKey.Validate() != nil {
		return input.PrivateKey.Validate()
	}
	if input.PublicKey.Validate() != nil {
		return input.PublicKey.Validate()
	}

	return nil
}

type DeriveSharedSecretOutput struct {
	SharedSecret []byte
}

func (input DeriveSharedSecretOutput) Validate() error {

	return nil
}

type DigestInput struct {
	DigestAlgorithm DigestAlgorithm

	Message []byte
}

func (input DigestInput) Validate() error {

	return nil
}

type DigestOutput struct {
	Digest []byte
}

func (input DigestOutput) Validate() error {

	return nil
}

type ECDSASignInput struct {
	Message []byte

	SignatureAlgorithm ECDSASignatureAlgorithm

	SigningKey []byte
}

func (input ECDSASignInput) Validate() error {

	return nil
}

type ECDSASignOutput struct {
	Signature []byte
}

func (input ECDSASignOutput) Validate() error {

	return nil
}

type ECDSAVerifyInput struct {
	Message []byte

	Signature []byte

	SignatureAlgorithm ECDSASignatureAlgorithm

	VerificationKey []byte
}

func (input ECDSAVerifyInput) Validate() error {

	return nil
}

type ECDSAVerifyOutput struct {
	Success bool
}

func (input ECDSAVerifyOutput) Validate() error {

	return nil
}

type GenerateECCKeyPairInput struct {
	EccCurve ECDHCurveSpec
}

func (input GenerateECCKeyPairInput) Validate() error {

	return nil
}

type GenerateECCKeyPairOutput struct {
	EccCurve ECDHCurveSpec

	PrivateKey ECCPrivateKey

	PublicKey ECCPublicKey
}

func (input GenerateECCKeyPairOutput) Validate() error {
	if input.PrivateKey.Validate() != nil {
		return input.PrivateKey.Validate()
	}
	if input.PublicKey.Validate() != nil {
		return input.PublicKey.Validate()
	}

	return nil
}

type GenerateECDSASignatureKeyInput struct {
	SignatureAlgorithm ECDSASignatureAlgorithm
}

func (input GenerateECDSASignatureKeyInput) Validate() error {

	return nil
}

type GenerateECDSASignatureKeyOutput struct {
	SignatureAlgorithm ECDSASignatureAlgorithm

	SigningKey []byte

	VerificationKey []byte
}

func (input GenerateECDSASignatureKeyOutput) Validate() error {

	return nil
}

type GenerateRandomBytesInput struct {
	Length int32
}

func (input GenerateRandomBytesInput) Validate() error {
	if input.Length < 0 {
		return fmt.Errorf("PositiveInteger has a minimum of 0 but has the value of %d.", input.Length)
	}

	return nil
}

type GenerateRandomBytesOutput struct {
	Data []byte
}

func (input GenerateRandomBytesOutput) Validate() error {

	return nil
}

type GenerateRSAKeyPairInput struct {
	LengthBits int32
}

func (input GenerateRSAKeyPairInput) Validate() error {
	if input.LengthBits < 81 {
		return fmt.Errorf("RSAModulusLengthBitsToGenerate has a minimum of 81 but has the value of %d.", input.LengthBits)
	}
	if input.LengthBits > 4096 {
		return fmt.Errorf("RSAModulusLengthBitsToGenerate has a maximum of 4096 but has the value of %d.", input.LengthBits)
	}

	return nil
}

type RSAPrivateKey struct {
	LengthBits int32

	Pem []byte
}

func (input RSAPrivateKey) Validate() error {
	if input.LengthBits < 81 {
		return fmt.Errorf("RSAModulusLengthBits has a minimum of 81 but has the value of %d.", input.LengthBits)
	}

	return nil
}

type RSAPublicKey struct {
	LengthBits int32

	Pem []byte
}

func (input RSAPublicKey) Validate() error {
	if input.LengthBits < 81 {
		return fmt.Errorf("RSAModulusLengthBits has a minimum of 81 but has the value of %d.", input.LengthBits)
	}

	return nil
}

type GenerateRSAKeyPairOutput struct {
	PrivateKey RSAPrivateKey

	PublicKey RSAPublicKey
}

func (input GenerateRSAKeyPairOutput) Validate() error {
	if input.PrivateKey.Validate() != nil {
		return input.PrivateKey.Validate()
	}
	if input.PublicKey.Validate() != nil {
		return input.PublicKey.Validate()
	}

	return nil
}

type GetPublicKeyFromPrivateKeyInput struct {
	EccCurve ECDHCurveSpec

	PrivateKey ECCPrivateKey
}

func (input GetPublicKeyFromPrivateKeyInput) Validate() error {
	if input.PrivateKey.Validate() != nil {
		return input.PrivateKey.Validate()
	}

	return nil
}

type GetPublicKeyFromPrivateKeyOutput struct {
	EccCurve ECDHCurveSpec

	PrivateKey ECCPrivateKey

	PublicKey []byte
}

func (input GetPublicKeyFromPrivateKeyOutput) Validate() error {
	if input.PrivateKey.Validate() != nil {
		return input.PrivateKey.Validate()
	}

	return nil
}

type GetRSAKeyModulusLengthInput struct {
	PublicKey []byte
}

func (input GetRSAKeyModulusLengthInput) Validate() error {

	return nil
}

type GetRSAKeyModulusLengthOutput struct {
	Length int32
}

func (input GetRSAKeyModulusLengthOutput) Validate() error {
	if input.Length < 81 {
		return fmt.Errorf("RSAModulusLengthBits has a minimum of 81 but has the value of %d.", input.Length)
	}

	return nil
}

type HkdfInput struct {
	DigestAlgorithm DigestAlgorithm

	ExpectedLength int32

	Ikm []byte

	Info []byte

	Salt []byte
}

func (input HkdfInput) Validate() error {
	if input.ExpectedLength < 0 {
		return fmt.Errorf("PositiveInteger has a minimum of 0 but has the value of %d.", input.ExpectedLength)
	}

	return nil
}

type HkdfOutput struct {
	Okm []byte
}

func (input HkdfOutput) Validate() error {

	return nil
}

type HkdfExpandInput struct {
	DigestAlgorithm DigestAlgorithm

	ExpectedLength int32

	Info []byte

	Prk []byte
}

func (input HkdfExpandInput) Validate() error {
	if input.ExpectedLength < 0 {
		return fmt.Errorf("PositiveInteger has a minimum of 0 but has the value of %d.", input.ExpectedLength)
	}

	return nil
}

type HkdfExpandOutput struct {
	Okm []byte
}

func (input HkdfExpandOutput) Validate() error {

	return nil
}

type HkdfExtractInput struct {
	DigestAlgorithm DigestAlgorithm

	Ikm []byte

	Salt []byte
}

func (input HkdfExtractInput) Validate() error {

	return nil
}

type HkdfExtractOutput struct {
	Prk []byte
}

func (input HkdfExtractOutput) Validate() error {

	return nil
}

type HMacInput struct {
	DigestAlgorithm DigestAlgorithm

	Key []byte

	Message []byte
}

func (input HMacInput) Validate() error {

	return nil
}

type HMacOutput struct {
	Digest []byte
}

func (input HMacOutput) Validate() error {

	return nil
}

type KdfCtrInput struct {
	DigestAlgorithm DigestAlgorithm

	ExpectedLength int32

	Ikm []byte

	Nonce []byte

	Purpose []byte
}

func (input KdfCtrInput) Validate() error {
	if input.ExpectedLength < 0 {
		return fmt.Errorf("PositiveInteger has a minimum of 0 but has the value of %d.", input.ExpectedLength)
	}

	return nil
}

type KdfCtrOutput struct {
	Okm []byte
}

func (input KdfCtrOutput) Validate() error {

	return nil
}

type ParsePublicKeyInput struct {
	PublicKey []byte
}

func (input ParsePublicKeyInput) Validate() error {

	return nil
}

type ParsePublicKeyOutput struct {
	PublicKey ECCPublicKey
}

func (input ParsePublicKeyOutput) Validate() error {
	if input.PublicKey.Validate() != nil {
		return input.PublicKey.Validate()
	}

	return nil
}

type RSADecryptInput struct {
	CipherText []byte

	Padding RSAPaddingMode

	PrivateKey []byte
}

func (input RSADecryptInput) Validate() error {

	return nil
}

type RSADecryptOutput struct {
	Plaintext []byte
}

func (input RSADecryptOutput) Validate() error {

	return nil
}

type RSAEncryptInput struct {
	Padding RSAPaddingMode

	Plaintext []byte

	PublicKey []byte
}

func (input RSAEncryptInput) Validate() error {

	return nil
}

type RSAEncryptOutput struct {
	CipherText []byte
}

func (input RSAEncryptOutput) Validate() error {

	return nil
}

type ValidatePublicKeyInput struct {
	EccCurve ECDHCurveSpec

	PublicKey []byte
}

func (input ValidatePublicKeyInput) Validate() error {

	return nil
}

type ValidatePublicKeyOutput struct {
	Success bool
}

func (input ValidatePublicKeyOutput) Validate() error {

	return nil
}

type AES_CTR struct {
	KeyLength int32

	NonceLength int32
}

func (input AES_CTR) Validate() error {
	if input.KeyLength < 1 {
		return fmt.Errorf("SymmetricKeyLength has a minimum of 1 but has the value of %d.", input.KeyLength)
	}
	if input.KeyLength > 32 {
		return fmt.Errorf("SymmetricKeyLength has a maximum of 32 but has the value of %d.", input.KeyLength)
	}
	if input.NonceLength < 0 {
		return fmt.Errorf("Uint8Bits has a minimum of 0 but has the value of %d.", input.NonceLength)
	}
	if input.NonceLength > 255 {
		return fmt.Errorf("Uint8Bits has a maximum of 255 but has the value of %d.", input.NonceLength)
	}

	return nil
}

type CryptoConfig struct {
}

func (input CryptoConfig) Validate() error {

	return nil
}

type AwsCryptographicPrimitivesBaseException interface {
	// This is a dummy method to allow type assertion since Go empty interfaces
	// aren't useful for type assertion checks. No concrete class is expected to implement
	// this method. This is also not exported.
	interfaceBindingMethod()
}
