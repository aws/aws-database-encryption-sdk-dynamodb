// Dafny program the_program compiled into C#
// To recompile, you will need the libraries
//     System.Runtime.Numerics.dll System.Collections.Immutable.dll
// but the 'dotnet' tool in net6.0 should pick those up automatically.
// Optionally, you may want to include compiler switches like
//     /debug /nowarn:162,164,168,183,219,436,1717,1718

using System;
using System.Numerics;
using System.Collections;
[assembly: DafnyAssembly.DafnySourceAttribute(@"// dafny 4.9.1.0
// Command-line arguments: translate cs --stdin --no-verify --cores 2 --optimize-erasable-datatype-wrapper false --unicode-char false --function-syntax 3 --output runtimes/net/ImplementationFromDafny --allow-warnings --compile-suffix --legacy-module-names --allow-external-contracts --library /Users/rishavkj/Documents/Storage/Team-Repos/aws-database-encryption-sdk-dynamodb/submodules/MaterialProviders/StandardLibrary/src/Index.dfy --library /Users/rishavkj/Documents/Storage/Team-Repos/aws-database-encryption-sdk-dynamodb/submodules/MaterialProviders/AwsCryptographyPrimitives/src/Index.dfy --library /Users/rishavkj/Documents/Storage/Team-Repos/aws-database-encryption-sdk-dynamodb/submodules/MaterialProviders/ComAmazonawsKms/src/Index.dfy --library /Users/rishavkj/Documents/Storage/Team-Repos/aws-database-encryption-sdk-dynamodb/submodules/MaterialProviders/ComAmazonawsDynamodb/src/Index.dfy --library /Users/rishavkj/Documents/Storage/Team-Repos/aws-database-encryption-sdk-dynamodb/submodules/MaterialProviders/AwsCryptographicMaterialProviders/dafny/AwsCryptographicMaterialProviders/src/Index.dfy --library /Users/rishavkj/Documents/Storage/Team-Repos/aws-database-encryption-sdk-dynamodb/submodules/MaterialProviders/AwsCryptographicMaterialProviders/dafny/AwsCryptographyKeyStore/src/Index.dfy
// the_program































































































































module {:extern ""software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny""} StructuredEncryption refines AbstractAwsCryptographyDbEncryptionSdkStructuredEncryptionService {
  function method DefaultStructuredEncryptionConfig(): StructuredEncryptionConfig
  {
    StructuredEncryptionConfig
  }

  method StructuredEncryption(config: StructuredEncryptionConfig := DefaultStructuredEncryptionConfig()) returns (res: Result<StructuredEncryptionClient, Error>)
    ensures res.Success? ==> fresh(res.value) && fresh(res.value.Modifies) && fresh(res.value.History) && res.value.ValidState()
    ensures res.Success? ==> res.value is StructuredEncryptionClient
    decreases config
  {
    var maybePrimitives := Primitives.AtomicPrimitives();
    var primitives :- maybePrimitives.MapFailure((e: Error) => AwsCryptographyPrimitives(e));
    var maybeMatProv := MaterialProviders.MaterialProviders();
    var matProv :- maybeMatProv.MapFailure((e: Error) => AwsCryptographyMaterialProviders(e));
    var client := new StructuredEncryptionClient(Operations.Config(primitives := primitives, materialProviders := matProv));
    return Success(client);
  }

  function method CreateSuccessOfClient(client: IStructuredEncryptionClient): Result<IStructuredEncryptionClient, Error>
    decreases client
  {
    Success(client)
  }

  function method CreateFailureOfError(error: Error): Result<IStructuredEncryptionClient, Error>
    decreases error
  {
    Failure(error)
  }

  import Operations = AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations

  import Primitives = AtomicPrimitives

  import MaterialProviders

  class StructuredEncryptionClient ... {
    predicate ValidState()
      ensures ValidState() ==> Operations.ValidInternalConfig?(config) && History !in Operations.ModifiesInternalConfig(config) && Modifies == Operations.ModifiesInternalConfig(config) + {History}
    {
      Operations.ValidInternalConfig?(config) &&
      History !in Operations.ModifiesInternalConfig(config) &&
      Modifies == Operations.ModifiesInternalConfig(config) + {History}
    }

    constructor (config: Operations.InternalConfig)
      requires Operations.ValidInternalConfig?(config)
      ensures ValidState() && fresh(History) && this.config == config
      decreases config
    {
      this.config := config;
      History := new IStructuredEncryptionClientCallHistory();
      Modifies := Operations.ModifiesInternalConfig(config) + {History};
    }

    const config: Operations.InternalConfig

    predicate EncryptStructureEnsuresPublicly(input: EncryptStructureInput, output: Result<EncryptStructureOutput, Error>)
      decreases input, output
    {
      Operations.EncryptStructureEnsuresPublicly(input, output)
    }

    method EncryptStructure(input: EncryptStructureInput) returns (output: Result<EncryptStructureOutput, Error>)
      requires ValidState() && input.cmm.ValidState() && input.cmm.Modifies !! {History}
      modifies Modifies - {History}, input.cmm.Modifies, History`EncryptStructure
      ensures true && ValidState()
      ensures EncryptStructureEnsuresPublicly(input, output)
      ensures History.EncryptStructure == old(History.EncryptStructure) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.cmm.Modifies
    {
      output := Operations.EncryptStructure(config, input);
      History.EncryptStructure := History.EncryptStructure + [DafnyCallEvent(input, output)];
    }

    predicate DecryptStructureEnsuresPublicly(input: DecryptStructureInput, output: Result<DecryptStructureOutput, Error>)
      decreases input, output
    {
      Operations.DecryptStructureEnsuresPublicly(input, output)
    }

    method DecryptStructure(input: DecryptStructureInput) returns (output: Result<DecryptStructureOutput, Error>)
      requires ValidState() && input.cmm.ValidState() && input.cmm.Modifies !! {History}
      modifies Modifies - {History}, input.cmm.Modifies, History`DecryptStructure
      ensures true && ValidState()
      ensures DecryptStructureEnsuresPublicly(input, output)
      ensures History.DecryptStructure == old(History.DecryptStructure) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.cmm.Modifies
    {
      output := Operations.DecryptStructure(config, input);
      History.DecryptStructure := History.DecryptStructure + [DafnyCallEvent(input, output)];
    }

    predicate EncryptPathStructureEnsuresPublicly(input: EncryptPathStructureInput, output: Result<EncryptPathStructureOutput, Error>)
      decreases input, output
    {
      Operations.EncryptPathStructureEnsuresPublicly(input, output)
    }

    method EncryptPathStructure(input: EncryptPathStructureInput) returns (output: Result<EncryptPathStructureOutput, Error>)
      requires ValidState() && input.cmm.ValidState() && input.cmm.Modifies !! {History}
      modifies Modifies - {History}, input.cmm.Modifies, History`EncryptPathStructure
      ensures true && ValidState()
      ensures EncryptPathStructureEnsuresPublicly(input, output)
      ensures History.EncryptPathStructure == old(History.EncryptPathStructure) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.cmm.Modifies
    {
      output := Operations.EncryptPathStructure(config, input);
      History.EncryptPathStructure := History.EncryptPathStructure + [DafnyCallEvent(input, output)];
    }

    predicate DecryptPathStructureEnsuresPublicly(input: DecryptPathStructureInput, output: Result<DecryptPathStructureOutput, Error>)
      decreases input, output
    {
      Operations.DecryptPathStructureEnsuresPublicly(input, output)
    }

    method DecryptPathStructure(input: DecryptPathStructureInput) returns (output: Result<DecryptPathStructureOutput, Error>)
      requires ValidState() && input.cmm.ValidState() && input.cmm.Modifies !! {History}
      modifies Modifies - {History}, input.cmm.Modifies, History`DecryptPathStructure
      ensures true && ValidState()
      ensures DecryptPathStructureEnsuresPublicly(input, output)
      ensures History.DecryptPathStructure == old(History.DecryptPathStructure) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.cmm.Modifies
    {
      output := Operations.DecryptPathStructure(config, input);
      History.DecryptPathStructure := History.DecryptPathStructure + [DafnyCallEvent(input, output)];
    }

    predicate ResolveAuthActionsEnsuresPublicly(input: ResolveAuthActionsInput, output: Result<ResolveAuthActionsOutput, Error>)
      decreases input, output
    {
      Operations.ResolveAuthActionsEnsuresPublicly(input, output)
    }

    method ResolveAuthActions(input: ResolveAuthActionsInput) returns (output: Result<ResolveAuthActionsOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ResolveAuthActions
      ensures true && ValidState()
      ensures ResolveAuthActionsEnsuresPublicly(input, output)
      ensures History.ResolveAuthActions == old(History.ResolveAuthActions) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.ResolveAuthActions(config, input);
      History.ResolveAuthActions := History.ResolveAuthActions + [DafnyCallEvent(input, output)];
    }
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes
}

module AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations refines AbstractAwsCryptographyDbEncryptionSdkStructuredEncryptionOperations {
  predicate ValidInternalConfig?(config: InternalConfig)
    decreases config
  {
    config.primitives.ValidState() &&
    config.materialProviders.ValidState()
  }

  function ModifiesInternalConfig(config: InternalConfig): set<object>
    decreases config
  {
    config.primitives.Modifies + config.materialProviders.Modifies
  }

  predicate EncryptStructureEnsuresPublicly(input: EncryptStructureInput, output: Result<EncryptStructureOutput, Error>)
    decreases input, output
  {
    output.Success? ==>
      true &&
      ghost var headerSchema: CryptoSchemaMap := output.value.cryptoSchema; true && ghost var inputSchema: CryptoSchemaMap := input.cryptoSchema; true && forall v: CryptoAction {:trigger IsAuthAttr(v)} {:trigger v in headerSchema.Values} :: v in headerSchema.Values ==> IsAuthAttr(v)
  }

  predicate DecryptStructureEnsuresPublicly(input: DecryptStructureInput, output: Result<DecryptStructureOutput, Error>)
    decreases input, output
  {
    output.Success? ==>
      true &&
      ghost var headerSchema: CryptoSchemaMap := output.value.cryptoSchema; true && forall v: CryptoAction {:trigger IsAuthAttr(v)} {:trigger v in headerSchema.Values} :: v in headerSchema.Values ==> IsAuthAttr(v)
  }

  predicate DecryptPathStructureEnsuresPublicly(input: DecryptPathStructureInput, output: Result<DecryptPathStructureOutput, Error>)
    decreases input, output
  {
    output.Success? ==>
      DecryptPathFinal(input.encryptedStructure, output.value.plaintextStructure)
  }

  predicate EncryptPathStructureEnsuresPublicly(input: EncryptPathStructureInput, output: Result<EncryptPathStructureOutput, Error>)
    decreases input, output
  {
    output.Success? ==>
      EncryptPathFinal(input.plaintextStructure, output.value.encryptedStructure)
  }

  predicate ResolveAuthActionsEnsuresPublicly(input: ResolveAuthActionsInput, output: Result<ResolveAuthActionsOutput, Error>)
    decreases input, output
  {
    true
  }

  method ResolveAuthActions(config: InternalConfig, input: ResolveAuthActionsInput) returns (output: Result<ResolveAuthActionsOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ResolveAuthActionsEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    :- Need(AuthListHasNoDuplicatesFromSet(input.authActions), E(""Duplicate Paths""));
    SetSizeImpliesAuthListHasNoDuplicates(input.authActions);
    assert AuthListHasNoDuplicates(input.authActions);
    var head :- Header.PartialDeserialize(input.headerBytes);
    :- Need(ValidString(input.tableName), E(""Bad Table Name""));
    :- Need(exists x: AuthItem {:trigger x.key} {:trigger x in input.authActions} :: x in input.authActions && x.key == HeaderPath, E(""Header Required""));
    :- Need(exists x: AuthItem {:trigger x.key} {:trigger x in input.authActions} :: x in input.authActions && x.key == FooterPath, E(""Footer Required""));
    var canonData :- ForDecrypt(input.tableName, input.authActions, head.legend);
    reveal CanonCryptoMatchesAuthList();
    return Success(ResolveAuthActionsOutput(cryptoActions := UnCanon(canonData)));
  }

  const DBE_COMMITMENT_POLICY := CMP.CommitmentPolicy.DBE(CMP.DBECommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT)

  function method {:opaque} GetBinary(data: AuthList, path: Path): (result: Result<StructuredDataTerminal, Error>)
    ensures result.Success? ==> exists x: AuthItem {:trigger x.key} {:trigger x in data} :: x in data && x.key == path
    decreases data, path
  {
    var data: Option<AuthItem> := FindAuth(data, path);
    if data.None? then
      Failure(E(""The field name "" + Paths.PathToString(path) + "" is required.""))
    else if data.value.data.typeId != BYTES_TYPE_ID then
      Failure(E(Paths.PathToString(path) + "" must be a binary Terminal.""))
    else if data.value.action != DO_NOT_SIGN then
      Failure(E(Paths.PathToString(path) + "" must be DO_NOT_SIGN.""))
    else
      Success(data.value.data)
  }

  function method {:opaque} SumValueSize(fields: CanonCryptoList): nat
    decreases fields
  {
    if |fields| == 0 then
      0
    else if fields[0].action == ENCRYPT_AND_SIGN then
      |fields[0].data.value| + SumValueSize(fields[1..])
    else
      SumValueSize(fields[1..])
  }

  function method {:opaque} GetAlgorithmSuiteId(alg: Option<CMP.DBEAlgorithmSuiteId>): (ret: CMP.AlgorithmSuiteId)
    ensures (alg.Some? ==> ret == CMP.AlgorithmSuiteId.DBE(alg.value)) && (alg.None? ==> ret == CMP.AlgorithmSuiteId.DBE(CMP.ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384_SYMSIG_HMAC_SHA384))
    decreases alg
  {
    if alg.Some? then
      CMP.AlgorithmSuiteId.DBE(alg.value)
    else
      CMP.AlgorithmSuiteId.DBE(CMP.ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384_SYMSIG_HMAC_SHA384)
  }

  method {:opaque} GetStructuredEncryptionMaterials(cmm: CMP.ICryptographicMaterialsManager, encryptionContext: Option<CMP.EncryptionContext>, algorithmSuiteId: Option<CMP.DBEAlgorithmSuiteId>, encryptedTerminalDataNum: nat, totalEncryptedTerminalValuesSize: nat)
      returns (ret: Result<CMP.EncryptionMaterials, Error>)
    requires cmm.ValidState()
    modifies cmm.Modifies
    ensures ret.Success? ==> true && var mat: CMP.EncryptionMaterials := ret.value; Materials.EncryptionMaterialsHasPlaintextDataKey(mat) && ValidSuite(mat.algorithmSuite) && |cmm.History.GetEncryptionMaterials| == |old(cmm.History.GetEncryptionMaterials)| + 1 && Seq.Last(cmm.History.GetEncryptionMaterials).output.Success? && var getEncIn: GetEncryptionMaterialsInput := Seq.Last(cmm.History.GetEncryptionMaterials).input; ((encryptionContext.None? && getEncIn.encryptionContext == map[]) || (encryptionContext.Some? && getEncIn.encryptionContext == encryptionContext.value)) && getEncIn.commitmentPolicy == DBE_COMMITMENT_POLICY && var maxLength: int := encryptedTerminalDataNum * 2 + totalEncryptedTerminalValuesSize; maxLength < INT64_MAX_LIMIT && getEncIn.maxPlaintextLength == Some(maxLength as int64)
    ensures cmm.ValidState()
    decreases cmm, encryptionContext, algorithmSuiteId, encryptedTerminalDataNum, totalEncryptedTerminalValuesSize
  {
    var maxLength := encryptedTerminalDataNum * 2 + totalEncryptedTerminalValuesSize;
    :- Need(maxLength < INT64_MAX_LIMIT, E(""Encrypted Size too long.""));
    var algId := GetAlgorithmSuiteId(algorithmSuiteId);
    var matR := cmm.GetEncryptionMaterials(CMP.GetEncryptionMaterialsInput(encryptionContext := encryptionContext.UnwrapOr(map[]), commitmentPolicy := DBE_COMMITMENT_POLICY, algorithmSuiteId := Some(algId), maxPlaintextLength := Some(maxLength as int64), requiredEncryptionContextKeys := None));
    var matOutput :- matR.MapFailure((e: Error) => AwsCryptographyMaterialProviders(e));
    var mat := matOutput.encryptionMaterials;
    :- Need(Materials.EncryptionMaterialsHasPlaintextDataKey(mat), E(""Encryption material has no key""));
    var alg := mat.algorithmSuite;
    :- Need(ValidSuite(alg), E(""Invalid Algorithm Suite""));
    var key: Key := mat.plaintextDataKey.value;
    return Success(mat);
  }

  method GetV2EncryptionContextCanon(schema: CanonCryptoList) returns (output: Result<CMP.EncryptionContext, Error>)
    decreases schema
  {
    var canonAttrs: CanonCryptoList := Seq.Filter((s: CanonCryptoItem) => s.action == SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT, schema);
    var contextAttrs: CryptoList := Seq.Map((s: CanonCryptoItem) => CryptoItem(key := s.origKey, data := s.data, action := s.action), canonAttrs);
    output := GetV2EncryptionContext2(contextAttrs);
  }

  method GetV2EncryptionContext(schema: CryptoList) returns (output: Result<CMP.EncryptionContext, Error>)
    decreases schema
  {
    var contextAttrs: CryptoList := Seq.Filter((s: CryptoItem) => s.action == SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT, schema);
    output := GetV2EncryptionContext2(contextAttrs);
  }

  function method {:opaque} Find(haystack: CryptoList, needle: Path): Result<CryptoItem, Error>
    decreases haystack, needle
  {
    if |haystack| == 0 then
      Failure(E(""Not Found""))
    else if haystack[0].key == needle then
      Success(haystack[0])
    else
      Find(haystack[1..], needle)
  }

  function method {:opaque} FindAuth(haystack: AuthList, needle: Path): (result: Option<AuthItem>)
    ensures result.Some? ==> exists x: AuthItem {:trigger x.key} {:trigger x in haystack} :: x in haystack && x.key == needle
    decreases haystack, needle
  {
    if |haystack| == 0 then
      None
    else if haystack[0].key == needle then
      Some(haystack[0])
    else
      FindAuth(haystack[1..], needle)
  }

  function method {:opaque} CountEncrypted(list: CanonCryptoList): nat
    decreases list
  {
    if |list| == 0 then
      0
    else if list[0].action == ENCRYPT_AND_SIGN then
      1 + CountEncrypted(list[1..])
    else
      CountEncrypted(list[1..])
  }

  method {:vcs_split_on_every_assert} GetV2EncryptionContext2(fields: CryptoList) returns (output: Result<CMP.EncryptionContext, Error>)
    decreases fields
  {
    var fieldMap: map<ValidUTF8Bytes, Path> := map[];
    for i: int := 0 to |fields| {
      var keyVal := ATTR_PREFIX + Paths.PathToString(fields[i].key);
      var utf8Value :- UTF8.Encode(keyVal).MapFailure((e: string) => E(e));
      if utf8Value in fieldMap {
        return Failure(E(keyVal + "" appears twice in encryption context.""));
      }
      fieldMap := fieldMap[utf8Value := fields[i].key];
    }
    var keys: seq<UTF8.ValidUTF8Bytes> := SortedSets.ComputeSetToOrderedSequence2(fieldMap.Keys, ByteLess);
    var newContext: CMP.EncryptionContext := map[];
    var legend: string := """";
    for i: int := 0 to |keys|
      invariant forall j: int {:trigger keys[j]} | 0 <= j < i :: keys[j] in newContext
      invariant forall k: ValidUTF8Bytes {:trigger k in keys[..i]} {:trigger k in newContext} | k in newContext :: k in keys[..i]
      invariant |legend| == |newContext| == i
    {
      assert keys[i] !in newContext by {
        reveal Seq.HasNoDuplicates();
      }
      var fieldUtf8 := keys[i];
      var fieldStr := fieldMap[fieldUtf8];
      var item :- Find(fields, fieldMap[fieldUtf8]);
      var attr: StructuredDataTerminal := item.data;
      var attrStr: ValidUTF8Bytes;
      var legendChar: char;
      if attr.typeId == NULL {
        legendChar := LEGEND_LITERAL;
        attrStr := NULL_UTF8;
      } else if attr.typeId == STRING {
        legendChar := LEGEND_STRING;
        :- Need(ValidUTF8Seq(attr.value), E(""Internal Error : string was not UTF8.""));
        attrStr := attr.value;
        var yy :- expect UTF8.Decode(attrStr);
      } else if attr.typeId == NUMBER {
        legendChar := LEGEND_NUMBER;
        :- Need(ValidUTF8Seq(attr.value), E(""Internal Error : number was not UTF8.""));
        attrStr := attr.value;
      } else if attr.typeId == BOOLEAN {
        legendChar := LEGEND_LITERAL;
        :- Need(|attr.value| == 1, E(""Internal Error : boolean was not of length 1.""));
        attrStr := if attr.value[0] == 0 then FALSE_UTF8 else TRUE_UTF8;
      } else {
        legendChar := LEGEND_BINARY;
        attrStr := EncodeTerminal(attr);
      }
      assert fieldUtf8 !in newContext;
      newContext := newContext[fieldUtf8 := attrStr];
      legend := legend + [legendChar];
      assert forall j: int {:trigger keys[j]} | 0 <= j < i + 1 :: keys[j] in newContext by {
        assert keys[i] in newContext;
      }
    }
    var utf8Legend :- UTF8.Encode(legend).MapFailure((e: string) => E(e));
    newContext := newContext[LEGEND_UTF8 := utf8Legend];
    return Success(newContext);
  }

  function method {:tailrecursion} BuildCryptoMap2(keys: seq<string>, plaintextStructure: StructuredDataMap, cryptoSchema: CryptoSchemaMap, ghost origKeys: seq<string> := keys, acc: CryptoList := []): (ret: Result<CryptoList, Error>)
    requires forall k: seq<char> {:trigger k in plaintextStructure} {:trigger k in keys} | k in keys :: k in plaintextStructure
    requires forall k: seq<char> {:trigger k in cryptoSchema} {:trigger k in keys} | k in keys :: k in cryptoSchema
    requires forall k: CryptoItem {:trigger k.key} {:trigger k in acc} | k in acc :: |k.key| == 1
    requires CryptoListHasNoDuplicates(acc)
    requires |acc| + |keys| == |origKeys|
    requires keys == origKeys[|acc|..]
    requires forall i: int {:trigger origKeys[i]} {:trigger acc[i]} | 0 <= i < |acc| :: acc[i].key == Paths.StringToUniPath(origKeys[i])
    requires Seq.HasNoDuplicates(keys)
    requires Seq.HasNoDuplicates(origKeys)
    ensures ret.Success? ==> (forall k: CryptoItem {:trigger k.key} {:trigger k in ret.value} | k in ret.value :: |k.key| == 1) && CryptoListHasNoDuplicates(ret.value)
    decreases keys, plaintextStructure, cryptoSchema, origKeys, acc
  {
    reveal Seq.HasNoDuplicates();
    Paths.StringToUniPathUnique();
    if |keys| == 0 then
      Success(acc)
    else
      var key: seq<char> := keys[0]; var path: Path := Paths.StringToUniPath(key); var item: CryptoItem := CryptoItem(key := path, data := plaintextStructure[key], action := cryptoSchema[key]); var newAcc: seq<CryptoItem> := acc + [item]; BuildCryptoMap2(keys[1..], plaintextStructure, cryptoSchema, origKeys, newAcc)
  }

  function method BuildCryptoMap(plaintextStructure: StructuredDataMap, cryptoSchema: CryptoSchemaMap): (ret: Result<CryptoList, Error>)
    requires plaintextStructure.Keys == cryptoSchema.Keys
    ensures ret.Success? ==> (forall k: CryptoItem {:trigger k.key} {:trigger k in ret.value} | k in ret.value :: |k.key| == 1) && CryptoListHasNoDuplicates(ret.value)
    decreases plaintextStructure, cryptoSchema
  {
    var keys: seq<seq<char>> := SortedSets.ComputeSetToOrderedSequence2(plaintextStructure.Keys, CharLess);
    BuildCryptoMap2(keys, plaintextStructure, cryptoSchema)
  }

  function method {:tailrecursion} BuildAuthMap2(keys: seq<string>, plaintextStructure: StructuredDataMap, authSchema: AuthenticateSchemaMap, ghost origKeys: seq<string> := keys, acc: AuthList := []): (ret: Result<AuthList, Error>)
    requires forall k: seq<char> {:trigger k in plaintextStructure} {:trigger k in keys} | k in keys :: k in plaintextStructure
    requires forall k: seq<char> {:trigger k in authSchema} {:trigger k in keys} | k in keys :: k in authSchema
    requires forall k: AuthItem {:trigger k.key} {:trigger k in acc} | k in acc :: |k.key| == 1
    requires AuthListHasNoDuplicates(acc)
    requires |acc| + |keys| == |origKeys|
    requires keys == origKeys[|acc|..]
    requires forall i: int {:trigger origKeys[i]} {:trigger acc[i]} | 0 <= i < |acc| :: acc[i].key == Paths.StringToUniPath(origKeys[i])
    requires Seq.HasNoDuplicates(keys)
    requires Seq.HasNoDuplicates(origKeys)
    ensures ret.Success? ==> (forall k: AuthItem {:trigger k.key} {:trigger k in ret.value} | k in ret.value :: |k.key| == 1) && AuthListHasNoDuplicates(ret.value)
    decreases keys, plaintextStructure, authSchema, origKeys, acc
  {
    reveal Seq.HasNoDuplicates();
    if |keys| == 0 then
      Success(acc)
    else
      var key: seq<char> := keys[0]; var path: Path := Paths.StringToUniPath(key); var item: AuthItem := AuthItem(key := path, data := plaintextStructure[key], action := authSchema[key]); var newAcc: seq<AuthItem> := acc + [item]; BuildAuthMap2(keys[1..], plaintextStructure, authSchema, origKeys, newAcc)
  }

  function method BuildAuthMap(plaintextStructure: StructuredDataMap, authSchema: AuthenticateSchemaMap): (ret: Result<AuthList, Error>)
    requires plaintextStructure.Keys == authSchema.Keys
    ensures ret.Success? ==> (forall k: AuthItem {:trigger k.key} {:trigger k in ret.value} | k in ret.value :: |k.key| == 1) && AuthListHasNoDuplicates(ret.value)
    decreases plaintextStructure, authSchema
  {
    var keys: seq<seq<char>> := SortedSets.ComputeSetToOrderedSequence2(plaintextStructure.Keys, CharLess);
    BuildAuthMap2(keys, plaintextStructure, authSchema)
  }

  function method UnBuildCryptoMap(list: CryptoList, dataSoFar: StructuredDataMap := map[], actionsSoFar: CryptoSchemaMap := map[]): (res: Result<(StructuredDataMap, CryptoSchemaMap), Error>)
    requires forall k: seq<char> {:trigger k in dataSoFar} {:trigger k in actionsSoFar} | k in actionsSoFar :: k in dataSoFar
    requires forall v: CryptoAction {:trigger IsAuthAttr(v)} {:trigger v in actionsSoFar.Values} :: v in actionsSoFar.Values ==> IsAuthAttr(v)
    requires forall k: CryptoItem {:trigger k.key} {:trigger k in list} | k in list :: |k.key| == 1
    ensures res.Success? ==> (forall k: seq<char> {:trigger k in res.value.0} {:trigger k in res.value.1} | k in res.value.1 :: k in res.value.0) && forall v: CryptoAction {:trigger IsAuthAttr(v)} {:trigger v in res.value.1.Values} :: v in res.value.1.Values ==> IsAuthAttr(v)
    decreases list, dataSoFar, actionsSoFar
  {
    if |list| == 0 then
      Success((dataSoFar, actionsSoFar))
    else
      var key: string :- Paths.UniPathToString(list[0].key); :- Need(key !in dataSoFar, E(""Duplicate Key "" + key)); if IsAuthAttr(list[0].action) then UnBuildCryptoMap(list[1..], dataSoFar[key := list[0].data], actionsSoFar[key := list[0].action]) else UnBuildCryptoMap(list[1..], dataSoFar[key := list[0].data], actionsSoFar)
  }

  lemma EncryptStructureOutputHasSinglePaths(origData: CryptoList, finalData: CryptoList)
    requires EncryptPathFinal(origData, finalData)
    requires forall k: CryptoItem {:trigger k.key} {:trigger k in origData} | k in origData :: |k.key| == 1
    ensures forall k: CryptoItem {:trigger k.key} {:trigger k in finalData} | k in finalData :: |k.key| == 1
    decreases origData, finalData
  {
    reveal EncryptPathFinal();
    reveal CryptoUpdatedCryptoListHeader();
    reveal NewCryptoUpdatedCrypto();
  }

  lemma DecryptStructureOutputHasSinglePaths(origData: AuthList, finalData: CryptoList)
    requires DecryptPathFinal(origData, finalData)
    requires forall k: AuthItem {:trigger k.key} {:trigger k in origData} | k in origData :: |k.key| == 1
    ensures forall k: CryptoItem {:trigger k.key} {:trigger k in finalData} | k in finalData :: |k.key| == 1
    decreases origData, finalData
  {
    reveal DecryptPathFinal();
    reveal AuthUpdatedCrypto();
    reveal CryptoUpdatedAuth();
  }

  method {:vcs_split_on_every_assert} EncryptStructure(config: InternalConfig, input: EncryptStructureInput) returns (output: Result<EncryptStructureOutput, Error>)
    requires ValidInternalConfig?(config) && input.cmm.ValidState()
    modifies ModifiesInternalConfig(config), input.cmm.Modifies
    ensures true && ValidInternalConfig?(config)
    ensures EncryptStructureEnsuresPublicly(input, output)
    ensures output.Success? ==> true && var headerSchema: CryptoSchemaMap := output.value.cryptoSchema; true && var inputSchema: CryptoSchemaMap := input.cryptoSchema; true && forall v: CryptoAction {:trigger IsAuthAttr(v)} {:trigger v in headerSchema.Values} :: v in headerSchema.Values ==> IsAuthAttr(v)
    decreases ModifiesInternalConfig(config), input.cmm.Modifies
  {
    :- Need(input.plaintextStructure.Keys == input.cryptoSchema.Keys, E(""Crypto Keys don't match.""));
    var cryptoMap :- BuildCryptoMap(input.plaintextStructure, input.cryptoSchema);
    var pathInput := EncryptPathStructureInput(tableName := input.tableName, plaintextStructure := cryptoMap, cmm := input.cmm, algorithmSuiteId := input.algorithmSuiteId, encryptionContext := input.encryptionContext);
    var pathOutput :- EncryptPathStructure(config, pathInput);
    assert forall k: CryptoItem {:trigger k.key} {:trigger k in pathOutput.encryptedStructure} | k in pathOutput.encryptedStructure :: |k.key| == 1 by {
      EncryptStructureOutputHasSinglePaths(cryptoMap, pathOutput.encryptedStructure);
    }
    :- Need(forall k: CryptoItem {:trigger k.key} {:trigger k in pathOutput.encryptedStructure} | k in pathOutput.encryptedStructure :: |k.key| == 1, E(""Internal Error""));
    var parts :- UnBuildCryptoMap(pathOutput.encryptedStructure);
    var plainOutput := EncryptStructureOutput(encryptedStructure := parts.0, cryptoSchema := parts.1, parsedHeader := pathOutput.parsedHeader);
    return Success(plainOutput);
  }

  lemma AllEncryptPathInputInOutput(origData: CryptoList, finalData: CryptoList)
    requires EncryptPathFinal(origData, finalData)
    ensures forall k: CryptoItem {:trigger k.key} {:trigger k in origData} | k in origData :: exists x: CryptoItem {:trigger x.key} {:trigger x in finalData} :: x in finalData && x.key == k.key
    decreases origData, finalData
  {
    reveal EncryptPathFinal();
    reveal CryptoUpdatedCryptoListHeader();
    reveal CryptoUpdatedNewCrypto();
  }

  lemma AllEncryptPathInputUpdatedInOutput(origData: CryptoList, finalData: CryptoList)
    requires EncryptPathFinal(origData, finalData)
    ensures forall k: CryptoItem {:trigger k in origData} | k in origData :: exists x: CryptoItem {:trigger Updated4(k, x, DoEncrypt)} {:trigger x in finalData} :: x in finalData && Updated4(k, x, DoEncrypt)
    decreases origData, finalData
  {
    reveal EncryptPathFinal();
    reveal CryptoUpdatedCryptoListHeader();
    reveal CryptoUpdatedNewCrypto();
  }

  lemma AllEncryptPathOutputInInput(origData: CryptoList, finalData: CryptoList)
    requires EncryptPathFinal(origData, finalData)
    ensures |finalData| == |origData| + 2
    ensures forall k: CryptoItem {:trigger k.key} | k in finalData[..|finalData| - 2] :: exists x: CryptoItem {:trigger x.key} {:trigger x in origData} :: x in origData && x.key == k.key
    decreases origData, finalData
  {
    reveal EncryptPathFinal();
    reveal CryptoUpdatedCryptoListHeader();
    reveal NewCryptoUpdatedCrypto();
  }

  lemma EncryptPathOutputHasHeader(origData: CryptoList, finalData: CryptoList)
    requires EncryptPathFinal(origData, finalData)
    ensures |finalData| == |origData| + 2
    ensures finalData[|finalData| - 2].key == HeaderPath
    decreases origData, finalData
  {
    reveal EncryptPathFinal();
  }

  lemma EncryptPathOutputHasFooter(origData: CryptoList, finalData: CryptoList)
    requires EncryptPathFinal(origData, finalData)
    ensures |finalData| == |origData| + 2
    ensures finalData[|finalData| - 1].key == FooterPath
    decreases origData, finalData
  {
    reveal EncryptPathFinal();
  }

  method {:vcs_split_on_every_assert} EncryptPathStructure(config: InternalConfig, input: EncryptPathStructureInput) returns (output: Result<EncryptPathStructureOutput, Error>)
    requires ValidInternalConfig?(config) && input.cmm.ValidState()
    modifies ModifiesInternalConfig(config), input.cmm.Modifies
    ensures true && ValidInternalConfig?(config)
    ensures EncryptPathStructureEnsuresPublicly(input, output)
    ensures output.Success? ==> EncryptPathFinal(input.plaintextStructure, output.value.encryptedStructure) && (exists k: CryptoItem {:trigger k.action} {:trigger k in input.plaintextStructure} | k in input.plaintextStructure :: IsAuthAttr(k.action)) && !(exists x: CryptoItem {:trigger x.key} {:trigger x in input.plaintextStructure} | x in input.plaintextStructure :: x.key in HeaderPaths) && CryptoListHasNoDuplicatesFromSet(input.plaintextStructure) && (input.encryptionContext.None? || !exists k: seq<uint8> {:trigger input.encryptionContext.value[k]} {:trigger k in input.encryptionContext.value} | k in input.encryptionContext.value :: ReservedCryptoContextPrefixUTF8 <= input.encryptionContext.value[k])
    decreases ModifiesInternalConfig(config), input.cmm.Modifies
  {
    :- Need(input.encryptionContext.None? || !exists k: seq<uint8> {:trigger input.encryptionContext.value[k]} {:trigger k in input.encryptionContext.value} | k in input.encryptionContext.value :: ReservedCryptoContextPrefixUTF8 <= input.encryptionContext.value[k], E(""Encryption Context must not contain members beginning with "" + ReservedCryptoContextPrefixString));
    :- Need(exists k: CryptoItem {:trigger k.action} {:trigger k in input.plaintextStructure} | k in input.plaintextStructure :: IsAuthAttr(k.action), E(""At least one field in the Crypto Schema must be ENCRYPT_AND_SIGN, SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT or SIGN_ONLY.""));
    :- Need(!exists x: CryptoItem {:trigger x.key} {:trigger x in input.plaintextStructure} | x in input.plaintextStructure :: x.key in HeaderPaths, E(""The paths "" + HeaderField + "" and "" + FooterField + "" are reserved.""));
    :- Need(CryptoListHasNoDuplicatesFromSet(input.plaintextStructure), E(""Duplicate Paths""));
    SetSizeImpliesCryptoListHasNoDuplicates(input.plaintextStructure);
    :- Need(ValidString(input.tableName), E(""Bad Table Name""));
    var canonData :- ForEncrypt(input.tableName, input.plaintextStructure);
    assert forall k: CryptoItem {:trigger k.data} {:trigger k.key} {:trigger k in input.plaintextStructure} | k in input.plaintextStructure :: exists x: CanonCryptoItem {:trigger x.data} {:trigger x.origKey} {:trigger x in canonData} :: x in canonData && x.origKey == k.key && x.data == k.data by {
      reveal CanonCryptoMatchesCryptoList();
      reveal CryptoExistsInCanonCrypto();
    }
    assert |input.plaintextStructure| == |canonData| by {
      reveal CanonCryptoMatchesCryptoList();
    }
    var encryptionContext := input.encryptionContext.UnwrapOr(map[]);
    var cmm := input.cmm;
    if exists x: CryptoItem {:trigger x.action} {:trigger x in input.plaintextStructure} | x in input.plaintextStructure :: x.action == SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT {
      assume {:axiom} input.cmm.Modifies !! {config.materialProviders.History};
      var newEncryptionContext :- GetV2EncryptionContext(input.plaintextStructure);
      if |newEncryptionContext| != 0 {
        :- Need(encryptionContext.Keys !! newEncryptionContext.Keys, E(""Internal Error - Structured Encryption encryption context overlaps with Item Encryptor encryption context.""));
        encryptionContext := encryptionContext + newEncryptionContext;
        assert cmm.Modifies !! {config.materialProviders.History};
        var contextKeysX := SortedSets.ComputeSetToOrderedSequence2(newEncryptionContext.Keys, ByteLess);
        assert forall k: seq<uint8> {:trigger ValidUTF8Seq(k)} {:trigger k in contextKeysX} | k in contextKeysX :: ValidUTF8Seq(k) by {
          assert forall k: seq<uint8> {:trigger ValidUTF8Seq(k)} {:trigger k in newEncryptionContext.Keys} | k in newEncryptionContext.Keys :: ValidUTF8Seq(k);
          assert forall k: seq<uint8> {:trigger k in newEncryptionContext.Keys} {:trigger k in contextKeysX} | k in contextKeysX :: k in newEncryptionContext.Keys;
        }
        var contextKeys: seq<UTF8.ValidUTF8Bytes> := contextKeysX;
        var cmmR := config.materialProviders.CreateRequiredEncryptionContextCMM(CMP.CreateRequiredEncryptionContextCMMInput(underlyingCMM := Some(input.cmm), keyring := None, requiredEncryptionContextKeys := contextKeys));
        cmm :- cmmR.MapFailure((e: Error) => AwsCryptographyMaterialProviders(e));
      }
    }
    var mat :- GetStructuredEncryptionMaterials(cmm, Some(encryptionContext), input.algorithmSuiteId, CountEncrypted(canonData), SumValueSize(canonData));
    var key: Key := mat.plaintextDataKey.value;
    var alg := mat.algorithmSuite;
    :- Need(Header.ValidEncryptionContext(mat.encryptionContext), E(""Bad encryption context""));
    var randBytes := Random.GenerateBytes(MSGID_LEN as int32);
    var msgID :- randBytes.MapFailure((e: Types.Error) => Error.AwsCryptographyPrimitives(e));
    var head :- Header.Create(input.tableName, canonData, msgID, mat);
    var commitKey :- Crypt.GetCommitKey(config.primitives, alg, key, head.msgID);
    var headerSerialized :- Header.Serialize(config.primitives, alg, commitKey, head);
    var headerAttribute := ValueToData(headerSerialized, BYTES_TYPE_ID);
    :- Need(|canonData| < UINT32_LIMIT / 3, E(""Too many encrypted fields""));
    var encryptedItems: CanonCryptoList :- Crypt.Encrypt(config.primitives, alg, key, head, canonData, input.tableName, input.plaintextStructure);
    var smallResult: CryptoList := UnCanonEncrypt(encryptedItems, input.tableName, input.plaintextStructure);
    var footer :- Footer.CreateFooter(config.primitives, mat, encryptedItems, headerSerialized);
    var footerAttribute := footer.makeTerminal();
    var largeResult := AddHeaders(smallResult, headerAttribute, footerAttribute, input.plaintextStructure);
    var headerAlgorithmSuite :- head.GetAlgorithmSuite(config.materialProviders);
    var parsedHeader := ParsedHeader(algorithmSuiteId := headerAlgorithmSuite.id.DBE, encryptedDataKeys := head.dataKeys, storedEncryptionContext := head.encContext, encryptionContext := mat.encryptionContext);
    var encryptOutput := EncryptPathStructureOutput(encryptedStructure := largeResult, parsedHeader := parsedHeader);
    assert EncryptPathFinal(input.plaintextStructure, encryptOutput.encryptedStructure);
    return Success(encryptOutput);
  }

  function method SafeDecode(data: CMP.Utf8Bytes): string
    decreases data
  {
    var x: Result<string, string> := UTF8.Decode(data);
    if x.Success? then
      x.value
    else
      ""[corrupt value]""
  }

  function method {:tailrecursion} DescribeMismatch(inputFields: seq<Bytes>, inputContext: CMP.EncryptionContext, headContext: Header.CMP.EncryptionContext): string
    requires forall k: seq<uint8> {:trigger k in inputContext} {:trigger k in inputFields} | k in inputFields :: k in inputContext
    decreases inputFields, inputContext, headContext
  {
    if |inputFields| == 0 then
      """"
    else
      var key: seq<uint8> := inputFields[0]; if key in headContext && headContext[key] != inputContext[key] then var keyStr: string := SafeDecode(key); var headStr: string := SafeDecode(headContext[key]); var inputStr: string := SafeDecode(inputContext[key]); var msg: seq<char> := ""input context for "" + keyStr + "" was "" + inputStr + "" but stored context had "" + headStr + ""\n""; msg + DescribeMismatch(inputFields[1..], inputContext, headContext) else DescribeMismatch(inputFields[1..], inputContext, headContext)
  }

  function method DetectMismatch(inputContext: CMP.EncryptionContext, headContext: CMP.EncryptionContext): Outcome<Error>
    decreases inputContext, headContext
  {
    var inputFields: seq<seq<uint8>> := SortedSets.ComputeSetToOrderedSequence2(inputContext.Keys, ByteLess);
    var str: string := DescribeMismatch(inputFields, inputContext, headContext);
    if |str| == 0 then
      Pass
    else
      Fail(E(""Encryption Context Mismatch\n"" + str))
  }

  method NewCmm(config: InternalConfig, cmm: CMP.ICryptographicMaterialsManager, context: CMP.EncryptionContext)
      returns (ret: Result<CMP.ICryptographicMaterialsManager, Error>)
    requires |context| != 0
    requires ValidInternalConfig?(config)
    requires cmm.ValidState()
    requires cmm.Modifies !! {config.materialProviders.History}
    modifies ModifiesInternalConfig(config), cmm.Modifies
    ensures ValidInternalConfig?(config)
    ensures cmm.ValidState()
    ensures ret.Success? ==> ret.value.ValidState() && fresh(ret.value)
    decreases config, cmm, context
  {
    var contextKeysX := SortedSets.ComputeSetToOrderedSequence2(context.Keys, ByteLess);
    assert forall k: seq<uint8> {:trigger ValidUTF8Seq(k)} {:trigger k in contextKeysX} | k in contextKeysX :: ValidUTF8Seq(k) by {
      assert forall k: seq<uint8> {:trigger ValidUTF8Seq(k)} {:trigger k in context.Keys} | k in context.Keys :: ValidUTF8Seq(k);
      assert forall k: seq<uint8> {:trigger k in context.Keys} {:trigger k in contextKeysX} | k in contextKeysX :: k in context.Keys;
    }
    var contextKeys: seq<UTF8.ValidUTF8Bytes> := contextKeysX;
    var cmmR := config.materialProviders.CreateRequiredEncryptionContextCMM(CMP.CreateRequiredEncryptionContextCMMInput(underlyingCMM := Some(cmm), keyring := None, requiredEncryptionContextKeys := contextKeys));
    var newCmm :- cmmR.MapFailure((e: Error) => AwsCryptographyMaterialProviders(e));
    return Success(newCmm);
  }

  method {:vcs_split_on_every_assert} DecryptStructure(config: InternalConfig, input: DecryptStructureInput) returns (output: Result<DecryptStructureOutput, Error>)
    requires ValidInternalConfig?(config) && input.cmm.ValidState()
    modifies ModifiesInternalConfig(config), input.cmm.Modifies
    ensures true && ValidInternalConfig?(config)
    ensures DecryptStructureEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), input.cmm.Modifies
  {
    :- Need(input.encryptedStructure.Keys == input.authenticateSchema.Keys, E(""DecryptStructure requires encryptedStructure and authenticateSchema have the same keys.""));
    var cryptoMap :- BuildAuthMap(input.encryptedStructure, input.authenticateSchema);
    var pathInput := DecryptPathStructureInput(tableName := input.tableName, encryptedStructure := cryptoMap, cmm := input.cmm, encryptionContext := input.encryptionContext);
    var pathOutput :- DecryptPathStructure(config, pathInput);
    assert forall k: CryptoItem {:trigger k.key} {:trigger k in pathOutput.plaintextStructure} | k in pathOutput.plaintextStructure :: |k.key| == 1 by {
      DecryptStructureOutputHasSinglePaths(pathInput.encryptedStructure, pathOutput.plaintextStructure);
    }
    var parts :- UnBuildCryptoMap(pathOutput.plaintextStructure);
    var plainOutput := DecryptStructureOutput(plaintextStructure := parts.0, cryptoSchema := parts.1, parsedHeader := pathOutput.parsedHeader);
    return Success(plainOutput);
  }

  lemma AllDecryptPathInputInOutput(origData: AuthList, finalData: CryptoList)
    requires DecryptPathFinal(origData, finalData)
    ensures forall k: AuthItem {:trigger k.key} {:trigger k in origData} | k in origData :: k.key in [HeaderPath, FooterPath] || exists x: CryptoItem {:trigger x in finalData} :: x in finalData
    decreases origData, finalData
  {
    reveal DecryptPathFinal();
    reveal AuthUpdatedCrypto();
  }

  lemma AllDecryptPathOutputInInput(origData: AuthList, finalData: CryptoList)
    requires DecryptPathFinal(origData, finalData)
    ensures forall k: CryptoItem {:trigger k in finalData} | k in finalData :: exists x: AuthItem {:trigger x in origData} :: x in origData
    decreases origData, finalData
  {
    reveal DecryptPathFinal();
    reveal CryptoUpdatedAuth();
  }

  lemma AllDecryptPathOutputUpdatesInput(origData: AuthList, finalData: CryptoList)
    requires DecryptPathFinal(origData, finalData)
    ensures forall k: CryptoItem {:trigger k.data} {:trigger k.action} {:trigger k in finalData} | k in finalData :: exists x: AuthItem {:trigger x.data} {:trigger x in origData} :: (x in origData && (k.action != ENCRYPT_AND_SIGN <==> x.data == k.data) && (k.action == ENCRYPT_AND_SIGN <==> x.data != k.data) && !(k.action == ENCRYPT_AND_SIGN)) || (x in origData && (k.action != ENCRYPT_AND_SIGN <==> x.data == k.data) && (k.action == ENCRYPT_AND_SIGN <==> x.data != k.data) && |x.data.value| >= 2 && k.data.typeId == x.data.value[..2])
    decreases origData, finalData
  {
    reveal DecryptPathFinal();
    reveal CryptoUpdatedAuth();
  }

  lemma DecryptPathRemovesHeaders(origData: AuthList, finalData: CryptoList)
    requires DecryptPathFinal(origData, finalData)
    ensures !exists x: CryptoItem {:trigger x.key} {:trigger x in finalData} :: x in finalData && x.key == HeaderPath
    ensures !exists x: CryptoItem {:trigger x.key} {:trigger x in finalData} :: x in finalData && x.key == FooterPath
    decreases origData, finalData
  {
    reveal DecryptPathFinal();
  }

  method {:vcs_split_on_every_assert} DecryptPathStructure(config: InternalConfig, input: DecryptPathStructureInput) returns (output: Result<DecryptPathStructureOutput, Error>)
    requires ValidInternalConfig?(config) && input.cmm.ValidState()
    modifies ModifiesInternalConfig(config), input.cmm.Modifies
    ensures true && ValidInternalConfig?(config)
    ensures DecryptPathStructureEnsuresPublicly(input, output)
    ensures output.Success? ==> DecryptPathFinal(input.encryptedStructure, output.value.plaintextStructure) && var encRecord: AuthList := input.encryptedStructure; GetBinary(encRecord, HeaderPath).Success? && var headerSerialized: StructuredDataTerminal := GetBinary(encRecord, HeaderPath).value; GetBinary(encRecord, FooterPath).Success? && var footerSerialized: StructuredDataTerminal := GetBinary(encRecord, FooterPath).value; (exists x: AuthItem {:trigger x.action} {:trigger x in encRecord} :: x in encRecord && x.action == SIGN) && Header.PartialDeserialize(headerSerialized.value).Success? && AuthListHasNoDuplicatesFromSet(input.encryptedStructure)
    decreases ModifiesInternalConfig(config), input.cmm.Modifies
  {
    :- Need(exists x: AuthItem {:trigger x.action} {:trigger x in input.encryptedStructure} :: x in input.encryptedStructure && x.action == SIGN, E(""At least one Authenticate Action must be SIGN""));
    :- Need(AuthListHasNoDuplicatesFromSet(input.encryptedStructure), E(""Duplicate Paths""));
    SetSizeImpliesAuthListHasNoDuplicates(input.encryptedStructure);
    var headerSerialized :- GetBinary(input.encryptedStructure, HeaderPath);
    var footerSerialized :- GetBinary(input.encryptedStructure, FooterPath);
    assert exists x: AuthItem {:trigger x.key} {:trigger x in input.encryptedStructure} :: x in input.encryptedStructure && x.key == HeaderPath;
    assert exists x: AuthItem {:trigger x.key} {:trigger x in input.encryptedStructure} :: x in input.encryptedStructure && x.key == FooterPath;
    var head :- Header.PartialDeserialize(headerSerialized.value);
    var headerAlgorithmSuite :- head.GetAlgorithmSuite(config.materialProviders);
    :- Need(ValidString(input.tableName), E(""Bad Table Name""));
    var canonData :- ForDecrypt(input.tableName, input.encryptedStructure, head.legend);
    assume {:axiom} input.cmm.Modifies !! {config.materialProviders.History};
    var encryptionContext := input.encryptionContext.UnwrapOr(map[]);
    var cmm := input.cmm;
    if head.version == 2 {
      var newEncryptionContext :- GetV2EncryptionContext(UnCanon(canonData));
      if |newEncryptionContext| != 0 {
        :- Need(encryptionContext.Keys !! newEncryptionContext.Keys, E(""Internal Error - Structured Encryption encryption context overlaps with Item Encryptor encryption context.""));
        encryptionContext := encryptionContext + newEncryptionContext;
        assert cmm.Modifies !! {config.materialProviders.History};
        var contextKeysX := SortedSets.ComputeSetToOrderedSequence2(newEncryptionContext.Keys, ByteLess);
        assert forall k: seq<uint8> {:trigger ValidUTF8Seq(k)} {:trigger k in contextKeysX} | k in contextKeysX :: ValidUTF8Seq(k) by {
          assert forall k: seq<uint8> {:trigger ValidUTF8Seq(k)} {:trigger k in newEncryptionContext.Keys} | k in newEncryptionContext.Keys :: ValidUTF8Seq(k);
          assert forall k: seq<uint8> {:trigger k in newEncryptionContext.Keys} {:trigger k in contextKeysX} | k in contextKeysX :: k in newEncryptionContext.Keys;
        }
        var contextKeys: seq<UTF8.ValidUTF8Bytes> := contextKeysX;
        var cmmR := config.materialProviders.CreateRequiredEncryptionContextCMM(CMP.CreateRequiredEncryptionContextCMMInput(underlyingCMM := Some(input.cmm), keyring := None, requiredEncryptionContextKeys := contextKeys));
        cmm :- cmmR.MapFailure((e: Error) => AwsCryptographyMaterialProviders(e));
      }
    }
    var matR := cmm.DecryptMaterials(CMP.DecryptMaterialsInput(algorithmSuiteId := headerAlgorithmSuite.id, commitmentPolicy := DBE_COMMITMENT_POLICY, encryptedDataKeys := head.dataKeys, encryptionContext := head.encContext, reproducedEncryptionContext := Some(encryptionContext)));
    var matOutput :- matR.MapFailure((e: Error) => AwsCryptographyMaterialProviders(e));
    var mat := matOutput.decryptionMaterials;
    :- Need(Header.ValidEncryptionContext(mat.encryptionContext), E(""Bad encryption context""));
    :- Need(Materials.DecryptionMaterialsWithPlaintextDataKey(mat), E(""Encryption material has no key""));
    :- Need(ValidSuite(mat.algorithmSuite), E(""Invalid Algorithm Suite""));
    var postCMMAlg := mat.algorithmSuite;
    var key: Key := mat.plaintextDataKey.value;
    var commitKey :- Crypt.GetCommitKey(config.primitives, postCMMAlg, key, head.msgID);
    var ok :- head.verifyCommitment(config.primitives, postCMMAlg, commitKey, headerSerialized.value);
    var footer :- Footer.DeserializeFooter(footerSerialized.value, postCMMAlg.signature.ECDSA?);
    var _ /* _v0 */ :- footer.validate(config.primitives, mat, head.dataKeys, canonData, headerSerialized.value);
    var decryptedItems: CanonCryptoList :- Crypt.Decrypt(config.primitives, postCMMAlg, key, head, canonData, input.tableName, input.encryptedStructure);
    var largeResult := UnCanonDecrypt(decryptedItems, input.tableName, input.encryptedStructure);
    var smallResult := RemoveHeaders(largeResult, input.encryptedStructure);
    var parsedHeader := ParsedHeader(algorithmSuiteId := headerAlgorithmSuite.id.DBE, encryptedDataKeys := head.dataKeys, storedEncryptionContext := head.encContext, encryptionContext := mat.encryptionContext);
    var decryptOutput := DecryptPathStructureOutput(plaintextStructure := smallResult, parsedHeader := parsedHeader);
    assert DecryptPathFinal(input.encryptedStructure, decryptOutput.plaintextStructure);
    output := Success(decryptOutput);
  }

  predicate {:opaque} Contains<X, Y>(big: map<X, Y>, small: map<X, Y>)
    decreases big, small
  {
    small.Keys <= big.Keys &&
    forall x: X {:trigger big[x]} {:trigger small[x]} {:trigger x in small} | x in small :: 
      small[x] == big[x]
  }

  lemma LemmaContainsPreservesInjectivity<X, Y>(big: map<X, Y>, small: map<X, Y>)
    requires Contains(big, small)
    requires Maps.Injective(big)
    ensures Maps.Injective(small)
    decreases big, small
  {
    reveal Contains();
    reveal Maps.Injective();
  }

  lemma LemmaInjectiveImpliesUniqueValues<X(!new), Y>(m: map<X, Y>)
    requires Maps.Injective(m)
    ensures |m.Keys| == |m.Values|
    decreases m
  {
    if |m| > 0 {
      ghost var x: X :| x in m;
      ghost var y := m[x];
      ghost var m' := Maps.Remove(m, x);
      reveal Contains();
      assert Contains(m, m');
      reveal Maps.Injective();
      assert m'.Values == m.Values - {y};
      LemmaContainsPreservesInjectivity(m, m');
      LemmaInjectiveImpliesUniqueValues(m');
    }
  }

  import opened StructuredEncryptionUtil

  import opened AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes

  import Base64

  import CMP = AwsCryptographyMaterialProvidersTypes

  import Prim = AwsCryptographyPrimitivesTypes

  import StructuredEncryptionHeader

  import Random

  import Primitives = AtomicPrimitives

  import Header = StructuredEncryptionHeader

  import Footer = StructuredEncryptionFooter

  import MaterialProviders

  import Materials

  import Crypt = StructuredEncryptionCrypt

  import Paths = StructuredEncryptionPaths

  import SortedSets

  import Seq

  import Digest

  import Defaults

  import HKDF

  import AlgorithmSuites

  import Maps

  import opened Canonize

  datatype Config = Config(primitives: Primitives.AtomicPrimitivesClient, materialProviders: MaterialProviders.MaterialProvidersClient)

  type InternalConfig = Config

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes
}

module {:options ""/functionSyntax:4""} Canonize {
  opaque predicate IsValidPath(path: Path)
    decreases path
  {
    Paths.ValidPath(path)
  }

  predicate Updated(oldVal: CanonCryptoItem, newVal: CanonCryptoItem, mode: EncryptionSelector)
    decreases oldVal, newVal, mode
  {
    oldVal.key == newVal.key &&
    oldVal.origKey == newVal.origKey &&
    oldVal.action == newVal.action &&
    (newVal.action != ENCRYPT_AND_SIGN <==> oldVal.data == newVal.data) &&
    (newVal.action == ENCRYPT_AND_SIGN <==> oldVal.data != newVal.data) &&
    (mode == DoEncrypt ==>
      newVal.action == ENCRYPT_AND_SIGN ==>
        newVal.data.typeId == BYTES_TYPE_ID) &&
    (mode == DoDecrypt ==>
      newVal.action == ENCRYPT_AND_SIGN ==>
        |oldVal.data.value| >= 2 &&
        newVal.data.typeId == oldVal.data.value[..2])
  }

  predicate Updated2(oldVal: AuthItem, newVal: CanonCryptoItem, mode: EncryptionSelector)
    decreases oldVal, newVal, mode
  {
    oldVal.key == newVal.origKey &&
    (newVal.action != ENCRYPT_AND_SIGN <==> oldVal.data == newVal.data) &&
    (newVal.action == ENCRYPT_AND_SIGN <==> oldVal.data != newVal.data) &&
    (mode == DoEncrypt ==>
      newVal.action == ENCRYPT_AND_SIGN ==>
        newVal.data.typeId == BYTES_TYPE_ID) &&
    (mode == DoDecrypt ==>
      newVal.action == ENCRYPT_AND_SIGN ==>
        |oldVal.data.value| >= 2 &&
        newVal.data.typeId == oldVal.data.value[..2])
  }

  predicate Updated3(oldVal: AuthItem, newVal: CryptoItem, mode: EncryptionSelector)
    decreases oldVal, newVal, mode
  {
    oldVal.key == newVal.key &&
    (newVal.action != ENCRYPT_AND_SIGN <==> oldVal.data == newVal.data) &&
    (newVal.action == ENCRYPT_AND_SIGN <==> oldVal.data != newVal.data) &&
    (mode == DoEncrypt ==>
      newVal.action == ENCRYPT_AND_SIGN ==>
        newVal.data.typeId == BYTES_TYPE_ID) &&
    (mode == DoDecrypt ==>
      newVal.action == ENCRYPT_AND_SIGN ==>
        |oldVal.data.value| >= 2 &&
        newVal.data.typeId == oldVal.data.value[..2])
  }

  predicate Updated4(oldVal: CryptoItem, newVal: CryptoItem, mode: EncryptionSelector)
    decreases oldVal, newVal, mode
  {
    oldVal.key == newVal.key &&
    oldVal.action == newVal.action &&
    (newVal.action != ENCRYPT_AND_SIGN <==> oldVal.data == newVal.data) &&
    (newVal.action == ENCRYPT_AND_SIGN <==> oldVal.data != newVal.data) &&
    (mode == DoEncrypt ==>
      newVal.action == ENCRYPT_AND_SIGN ==>
        newVal.data.typeId == BYTES_TYPE_ID) &&
    (mode == DoDecrypt ==>
      newVal.action == ENCRYPT_AND_SIGN ==>
        |oldVal.data.value| >= 2 &&
        newVal.data.typeId == oldVal.data.value[..2])
  }

  predicate Updated5(oldVal: CryptoItem, newVal: CanonCryptoItem, mode: EncryptionSelector)
    decreases oldVal, newVal, mode
  {
    oldVal.key == newVal.origKey &&
    oldVal.action == newVal.action &&
    (newVal.action != ENCRYPT_AND_SIGN <==> oldVal.data == newVal.data) &&
    (newVal.action == ENCRYPT_AND_SIGN <==> oldVal.data != newVal.data) &&
    (mode == DoEncrypt ==>
      newVal.action == ENCRYPT_AND_SIGN ==>
        newVal.data.typeId == BYTES_TYPE_ID) &&
    (mode == DoDecrypt ==>
      newVal.action == ENCRYPT_AND_SIGN ==>
        |oldVal.data.value| >= 2 &&
        newVal.data.typeId == oldVal.data.value[..2])
  }

  opaque predicate method IsCanonPath(table: GoodString, origKey: Path, key: CanonicalPath)
    requires IsValidPath(origKey)
    decreases table, origKey, key
  {
    reveal IsValidPath();
    key == Paths.CanonPath(table, origKey)
  }

  opaque function method MakeCanon(tableName: GoodString, data: CryptoItem): (result: CanonCryptoItem)
    requires Paths.ValidPath(data.key)
    requires IsValidPath(data.key)
    ensures result.origKey == data.key
    ensures result.data == data.data
    ensures result.action == data.action
    ensures IsValidPath(result.origKey)
    ensures result.key == Paths.CanonPath(tableName, data.key)
    ensures IsCanonPath(tableName, data.key, result.key)
    ensures IsCanonPath(tableName, result.origKey, result.key)
    decreases tableName, data
  {
    reveal IsValidPath();
    reveal IsCanonPath();
    CanonCryptoItem(Paths.CanonPath(tableName, data.key), data.key, data.data, data.action)
  }

  opaque function method MakeCanonAuth(tableName: GoodString, data: AuthItem): (result: CanonAuthItem)
    requires Paths.ValidPath(data.key)
    requires IsValidPath(data.key)
    ensures result.origKey == data.key
    ensures result.data == data.data
    ensures result.action == data.action
    ensures IsValidPath(result.origKey)
    ensures result.key == Paths.CanonPath(tableName, data.key)
    ensures IsCanonPath(tableName, data.key, result.key)
    ensures IsCanonPath(tableName, result.origKey, result.key)
    decreases tableName, data
  {
    reveal IsValidPath();
    reveal IsCanonPath();
    CanonAuthItem(Paths.CanonPath(tableName, data.key), data.key, data.data, data.action)
  }

  predicate method Same(x: CanonAuthItem, y: CanonCryptoItem)
    decreases x, y
  {
    x.key == y.key &&
    x.origKey == y.origKey &&
    x.data == y.data
  }

  function method MakeCryptoItem(x: CanonAuthItem, action: CryptoAction): (ret: CanonCryptoItem)
    ensures Same(x, ret)
    decreases x, action
  {
    CanonCryptoItem(x.key, x.origKey, x.data, action)
  }

  function method LegendToAction(v: Header.LegendByte): CryptoAction
    decreases v
  {
    if v == Header.ENCRYPT_AND_SIGN_LEGEND then
      ENCRYPT_AND_SIGN
    else if v == Header.SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT_LEGEND then
      SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT
    else
      SIGN_ONLY
  }

  opaque function method {:tailrecursion} ResolveLegend(fields: CanonAuthList, legend: Header.Legend, ghost origFields: CanonAuthList, acc: CanonCryptoList): (ret: Result<CanonCryptoList, Error>)
    requires |fields| + |acc| == |origFields|
    requires forall i: int {:trigger acc[i]} {:trigger origFields[i]} | 0 <= i < |acc| :: Same(origFields[i], acc[i])
    requires forall i: int {:trigger origFields[i]} | |acc| <= i < |origFields| :: origFields[i] == fields[i - |acc|]
    ensures ret.Success? ==> |origFields| == |ret.value| && forall i: int {:trigger ret.value[i]} {:trigger origFields[i]} | 0 <= i < |origFields| :: Same(origFields[i], ret.value[i])
    decreases fields, legend, origFields, acc
  {
    if |fields| == 0 then
      :- Need(|legend| == 0, E(""Schema changed : something that was signed is now unsigned."")); Success(acc)
    else if fields[0].action == DO_NOT_SIGN then
      ResolveLegend(fields[1..], legend, origFields, acc + [MakeCryptoItem(fields[0], DO_NOTHING)])
    else
      :- Need(0 < |legend|, E(""Schema changed : something that was unsigned is now signed."")); ResolveLegend(fields[1..], legend[1..], origFields, acc + [MakeCryptoItem(fields[0], LegendToAction(legend[0]))])
  }

  opaque function method ForEncrypt(tableName: GoodString, data: CryptoList): (ret: Result<CanonCryptoList, Error>)
    requires CryptoListHasNoDuplicates(data)
    requires !exists x: CryptoItem {:trigger x.key} {:trigger x in data} | x in data :: x.key in HeaderPaths
    ensures ret.Success? ==> CanonCryptoMatchesCryptoList(tableName, data, ret.value) && IsCryptoSorted(ret.value)
    decreases tableName, data
  {
    reveal IsValidPath();
    :- Need(forall k: CryptoItem {:trigger k.key} {:trigger k in data} | k in data :: _default.ValidPath(k.key), E(""Invalid Paths"")); var canonList: CanonCryptoList := CryptoToCanonCrypto(tableName, data); Success(CryptoSort(canonList, tableName, data))
  }

  opaque predicate AuthExistsInCanonAuth(k: AuthItem, list: CanonAuthList)
    decreases k, list
  {
    exists x: CanonAuthItem {:trigger x.action} {:trigger x.data} {:trigger x.origKey} {:trigger x in list} :: 
      x in list &&
      k.key == x.origKey &&
      k.data == x.data &&
      k.action == x.action
  }

  opaque predicate AuthExistsInCrypto(k: AuthItem, list: CryptoList)
    decreases k, list
  {
    exists x: CryptoItem {:trigger x.key} {:trigger x in list} :: 
      x in list &&
      k.key == x.key
  }

  opaque predicate CryptoExistsInAuth(k: CryptoItem, list: AuthList)
    decreases k, list
  {
    exists x: AuthItem {:trigger x.key} {:trigger x in list} :: 
      x in list &&
      k.key == x.key
  }

  opaque predicate AuthExistsInCanonCrypto(k: AuthItem, list: CanonCryptoList)
    decreases k, list
  {
    exists x: CanonCryptoItem {:trigger x.data} {:trigger x.origKey} {:trigger x in list} :: 
      x in list &&
      k.key == x.origKey &&
      k.data == x.data
  }

  predicate SameStuff1(k: CryptoItem, x: CanonCryptoItem)
    decreases k, x
  {
    k.key == x.origKey &&
    k.data == x.data &&
    k.action == x.action
  }

  opaque predicate CryptoExistsInCanonCrypto(k: CryptoItem, list: CanonCryptoList)
    decreases k, list
  {
    exists x: CanonCryptoItem {:trigger SameStuff1(k, x)} {:trigger x in list} :: 
      x in list &&
      SameStuff1(k, x)
  }

  opaque predicate CanonAuthExistsInAuth(k: CanonAuthItem, list: AuthList)
    decreases k, list
  {
    exists x: AuthItem {:trigger x.action} {:trigger x.data} {:trigger x.key} {:trigger x in list} :: 
      x in list &&
      k.origKey == x.key &&
      k.data == x.data &&
      k.action == x.action
  }

  opaque predicate CanonCryptoExistsInAuth(k: CanonCryptoItem, list: AuthList)
    decreases k, list
  {
    exists x: AuthItem {:trigger x.data} {:trigger x.key} {:trigger x in list} :: 
      x in list &&
      k.origKey == x.key &&
      k.data == x.data
  }

  opaque predicate CanonCryptoExistsInCrypto(k: CanonCryptoItem, list: CryptoList)
    decreases k, list
  {
    exists x: CryptoItem {:trigger x.action} {:trigger x.data} {:trigger x.key} {:trigger x in list} :: 
      x in list &&
      k.origKey == x.key &&
      k.data == x.data &&
      k.action == x.action
  }

  opaque predicate CanonAuthExistsInCanonAuth(k: CanonAuthItem, list: CanonAuthList)
    decreases k, list
  {
    exists x: CanonAuthItem {:trigger x.action} {:trigger x.data} {:trigger x.origKey} {:trigger x in list} :: 
      x in list &&
      k.origKey == x.origKey &&
      k.data == x.data &&
      k.action == x.action
  }

  opaque predicate CanonAuthExistsInCanonCrypto(k: CanonAuthItem, list: CanonCryptoList)
    decreases k, list
  {
    exists x: CanonCryptoItem {:trigger x.data} {:trigger x.origKey} {:trigger x in list} :: 
      x in list &&
      k.origKey == x.origKey &&
      k.data == x.data
  }

  opaque predicate CanonCryptoExistsInCanonAuth(k: CanonCryptoItem, list: CanonAuthList)
    decreases k, list
  {
    exists x: CanonAuthItem {:trigger x.data} {:trigger x.origKey} {:trigger x in list} :: 
      x in list &&
      k.origKey == x.origKey &&
      k.data == x.data
  }

  opaque predicate CanonCryptoExistsInCanonCrypto(k: CanonCryptoItem, list: CanonCryptoList)
    decreases k, list
  {
    exists x: CanonCryptoItem {:trigger x.action} {:trigger x.data} {:trigger x.origKey} {:trigger x in list} :: 
      x in list &&
      k.origKey == x.origKey &&
      k.data == x.data &&
      k.action == x.action
  }

  opaque predicate CanonAuthMatchesAuthList(tableName: GoodString, data: AuthList, canonList: CanonAuthList)
    decreases tableName, data, canonList
  {
    (exists x: AuthItem {:trigger x.key} {:trigger x in data} :: 
      x in data &&
      x.key == HeaderPath) &&
    (exists x: AuthItem {:trigger x.key} {:trigger x in data} :: 
      x in data &&
      x.key == FooterPath) &&
    (forall k: AuthItem {:trigger AuthExistsInCanonAuth(k, canonList)} {:trigger k in data} | k in data :: 
      AuthExistsInCanonAuth(k, canonList)) &&
    (forall k: CanonAuthItem {:trigger CanonAuthExistsInAuth(k, data)} {:trigger k in canonList} | k in canonList :: 
      CanonAuthExistsInAuth(k, data)) &&
    |data| == |canonList| &&
    (forall k: CanonAuthItem {:trigger k.origKey} {:trigger k in canonList} | k in canonList :: 
      IsValidPath(k.origKey)) &&
    (forall k: CanonAuthItem {:trigger k.key} {:trigger k.origKey} {:trigger k in canonList} | k in canonList :: 
      IsCanonPath(tableName, k.origKey, k.key)) &&
    CanonAuthListHasNoDuplicates(canonList)
  }

  opaque predicate CanonCryptoMatchesAuthList(tableName: GoodString, data: AuthList, canonList: CanonCryptoList)
    decreases tableName, data, canonList
  {
    (exists x: AuthItem {:trigger x.key} {:trigger x in data} :: 
      x in data &&
      x.key == HeaderPath) &&
    (exists x: AuthItem {:trigger x.key} {:trigger x in data} :: 
      x in data &&
      x.key == FooterPath) &&
    (forall k: AuthItem {:trigger AuthExistsInCanonCrypto(k, canonList)} {:trigger k in data} | k in data :: 
      AuthExistsInCanonCrypto(k, canonList)) &&
    (forall k: CanonCryptoItem {:trigger CanonCryptoExistsInAuth(k, data)} {:trigger k in canonList} | k in canonList :: 
      CanonCryptoExistsInAuth(k, data)) &&
    |data| == |canonList| &&
    (forall k: CanonCryptoItem {:trigger k.origKey} {:trigger k in canonList} | k in canonList :: 
      IsValidPath(k.origKey)) &&
    (forall k: CanonCryptoItem {:trigger k.key} {:trigger k.origKey} {:trigger k in canonList} | k in canonList :: 
      IsCanonPath(tableName, k.origKey, k.key)) &&
    CanonCryptoListHasNoDuplicates(canonList)
  }

  opaque predicate CanonCryptoUpdatedAuth(k: CanonCryptoItem, list: AuthList)
    decreases k, list
  {
    exists x: AuthItem {:trigger Updated2(x, k, DoDecrypt)} {:trigger x in list} :: 
      x in list &&
      Updated2(x, k, DoDecrypt)
  }

  opaque predicate AuthUpdatedCanonCrypto(k: AuthItem, list: CanonCryptoList)
    decreases k, list
  {
    exists x: CanonCryptoItem {:trigger Updated2(k, x, DoDecrypt)} {:trigger x in list} :: 
      x in list &&
      Updated2(k, x, DoDecrypt)
  }

  opaque predicate CryptoUpdatedAuth(k: CryptoItem, list: AuthList)
    decreases k, list
  {
    exists x: AuthItem {:trigger Updated3(x, k, DoDecrypt)} {:trigger x in list} :: 
      x in list &&
      Updated3(x, k, DoDecrypt)
  }

  opaque predicate AuthUpdatedCrypto(k: AuthItem, list: CryptoList)
    decreases k, list
  {
    exists x: CryptoItem {:trigger Updated3(k, x, DoDecrypt)} {:trigger x in list} :: 
      x in list &&
      Updated3(k, x, DoDecrypt)
  }

  opaque predicate CanonCryptoUpdatedCrypto(k: CanonCryptoItem, list: CryptoList)
    decreases k, list
  {
    exists x: CryptoItem {:trigger Updated5(x, k, DoEncrypt)} {:trigger x in list} :: 
      x in list &&
      Updated5(x, k, DoEncrypt)
  }

  opaque predicate CryptoUpdatedCanonCrypto(k: CryptoItem, list: CanonCryptoList)
    decreases k, list
  {
    exists x: CanonCryptoItem {:trigger Updated5(k, x, DoEncrypt)} {:trigger x in list} :: 
      x in list &&
      Updated5(k, x, DoEncrypt)
  }

  opaque predicate NewCryptoUpdatedCrypto(k: CryptoItem, list: CryptoList)
    decreases k, list
  {
    exists x: CryptoItem {:trigger Updated4(x, k, DoEncrypt)} {:trigger x in list} :: 
      x in list &&
      Updated4(x, k, DoEncrypt)
  }

  opaque predicate CryptoUpdatedNewCrypto(k: CryptoItem, list: CryptoList)
    decreases k, list
  {
    exists x: CryptoItem {:trigger Updated4(k, x, DoEncrypt)} {:trigger x in list} :: 
      x in list &&
      Updated4(k, x, DoEncrypt)
  }

  opaque predicate CanonCryptoUpdatedAuthList(tableName: GoodString, data: AuthList, canonList: CanonCryptoList)
    decreases tableName, data, canonList
  {
    (exists x: AuthItem {:trigger x.key} {:trigger x in data} :: 
      x in data &&
      x.key == HeaderPath) &&
    (exists x: AuthItem {:trigger x.key} {:trigger x in data} :: 
      x in data &&
      x.key == FooterPath) &&
    (forall k: AuthItem {:trigger AuthUpdatedCanonCrypto(k, canonList)} {:trigger k in data} | k in data :: 
      AuthUpdatedCanonCrypto(k, canonList)) &&
    (forall k: CanonCryptoItem {:trigger CanonCryptoUpdatedAuth(k, data)} {:trigger k in canonList} | k in canonList :: 
      CanonCryptoUpdatedAuth(k, data)) &&
    |data| == |canonList| &&
    (forall k: CanonCryptoItem {:trigger k.origKey} {:trigger k in canonList} | k in canonList :: 
      IsValidPath(k.origKey)) &&
    (forall k: CanonCryptoItem {:trigger k.key} {:trigger k.origKey} {:trigger k in canonList} | k in canonList :: 
      IsCanonPath(tableName, k.origKey, k.key)) &&
    CanonCryptoListHasNoDuplicates(canonList)
  }

  opaque predicate CryptoUpdatedAuthList(data: AuthList, canonList: CryptoList)
    decreases data, canonList
  {
    (exists x: AuthItem {:trigger x.key} {:trigger x in data} :: 
      x in data &&
      x.key == HeaderPath) &&
    (exists x: AuthItem {:trigger x.key} {:trigger x in data} :: 
      x in data &&
      x.key == FooterPath) &&
    (forall k: AuthItem {:trigger AuthUpdatedCrypto(k, canonList)} {:trigger k in data} | k in data :: 
      AuthUpdatedCrypto(k, canonList)) &&
    (forall k: CryptoItem {:trigger CryptoUpdatedAuth(k, data)} {:trigger k in canonList} | k in canonList :: 
      CryptoUpdatedAuth(k, data)) &&
    |data| == |canonList| &&
    (forall k: CryptoItem {:trigger k.key} {:trigger k in canonList} | k in canonList :: 
      IsValidPath(k.key)) &&
    CryptoListHasNoDuplicates(canonList)
  }

  opaque predicate CryptoMatchesAuthList(tableName: GoodString, data: AuthList, canonList: CryptoList)
    decreases tableName, data, canonList
  {
    (forall k: AuthItem {:trigger AuthExistsInCrypto(k, canonList)} {:trigger k in data} | k in data :: 
      AuthExistsInCrypto(k, canonList)) &&
    (forall k: CryptoItem {:trigger CryptoExistsInAuth(k, data)} {:trigger k in canonList} | k in canonList :: 
      CryptoExistsInAuth(k, data)) &&
    |data| == |canonList| &&
    (forall k: CryptoItem {:trigger k.key} {:trigger k in canonList} | k in canonList :: 
      IsValidPath(k.key)) &&
    CryptoListHasNoDuplicates(canonList)
  }

  opaque predicate CanonCryptoMatchesCryptoList(tableName: GoodString, data: CryptoList, canonList: CanonCryptoList)
    decreases tableName, data, canonList
  {
    !(exists x: CryptoItem {:trigger x.key} {:trigger x in data} | x in data :: x.key in HeaderPaths) &&
    (forall k: CryptoItem {:trigger CryptoExistsInCanonCrypto(k, canonList)} {:trigger k in data} | k in data :: 
      CryptoExistsInCanonCrypto(k, canonList)) &&
    (forall k: CanonCryptoItem {:trigger CanonCryptoExistsInCrypto(k, data)} {:trigger k in canonList} | k in canonList :: 
      CanonCryptoExistsInCrypto(k, data)) &&
    |data| == |canonList| &&
    (forall k: CanonCryptoItem {:trigger k.origKey} {:trigger k in canonList} | k in canonList :: 
      IsValidPath(k.origKey)) &&
    (forall k: CanonCryptoItem {:trigger k.key} {:trigger k.origKey} {:trigger k in canonList} | k in canonList :: 
      IsCanonPath(tableName, k.origKey, k.key)) &&
    CanonCryptoListHasNoDuplicates(canonList)
  }

  opaque predicate CanonCryptoUpdatedCryptoList(tableName: GoodString, data: CryptoList, canonList: CanonCryptoList)
    decreases tableName, data, canonList
  {
    !(exists x: CryptoItem {:trigger x.key} {:trigger x in data} | x in data :: x.key in HeaderPaths) &&
    (forall k: CryptoItem {:trigger CryptoUpdatedCanonCrypto(k, canonList)} {:trigger k in data} | k in data :: 
      CryptoUpdatedCanonCrypto(k, canonList)) &&
    (forall k: CanonCryptoItem {:trigger CanonCryptoUpdatedCrypto(k, data)} {:trigger k in canonList} | k in canonList :: 
      CanonCryptoUpdatedCrypto(k, data)) &&
    |data| == |canonList| &&
    (forall k: CanonCryptoItem {:trigger k.origKey} {:trigger k in canonList} | k in canonList :: 
      IsValidPath(k.origKey)) &&
    (forall k: CanonCryptoItem {:trigger k.key} {:trigger k.origKey} {:trigger k in canonList} | k in canonList :: 
      IsCanonPath(tableName, k.origKey, k.key)) &&
    CanonCryptoListHasNoDuplicates(canonList)
  }

  opaque predicate CryptoUpdatedCryptoList(data: CryptoList, canonList: CryptoList)
    decreases data, canonList
  {
    !(exists x: CryptoItem {:trigger x.key} {:trigger x in data} | x in data :: x.key in HeaderPaths) &&
    (forall k: CryptoItem {:trigger CryptoUpdatedNewCrypto(k, canonList)} {:trigger k in data} | k in data :: 
      CryptoUpdatedNewCrypto(k, canonList)) &&
    (forall k: CryptoItem {:trigger NewCryptoUpdatedCrypto(k, data)} {:trigger k in canonList} | k in canonList :: 
      NewCryptoUpdatedCrypto(k, data)) &&
    |data| == |canonList| &&
    (forall k: CryptoItem {:trigger k.key} {:trigger k in canonList} | k in canonList :: 
      IsValidPath(k.key)) &&
    CryptoListHasNoDuplicates(canonList)
  }

  opaque predicate CryptoUpdatedCryptoListHeader(data: CryptoList, canonList: CryptoList)
    decreases data, canonList
  {
    (forall k: CryptoItem {:trigger CryptoUpdatedNewCrypto(k, canonList)} {:trigger k in data} | k in data :: 
      CryptoUpdatedNewCrypto(k, canonList)) &&
    (forall k: CryptoItem {:trigger NewCryptoUpdatedCrypto(k, data)} {:trigger k in canonList} | k in canonList :: 
      NewCryptoUpdatedCrypto(k, data)) &&
    |data| == |canonList| &&
    (forall k: CryptoItem {:trigger k.key} {:trigger k in canonList} | k in canonList :: 
      IsValidPath(k.key)) &&
    CryptoListHasNoDuplicates(canonList)
  }

  opaque function method AuthToCanonAuth(tableName: GoodString, data: AuthList): (ret: CanonAuthList)
    requires forall k: AuthItem {:trigger k.key} {:trigger k in data} | k in data :: IsValidPath(k.key)
    requires exists x: AuthItem {:trigger x.key} {:trigger x in data} :: x in data && x.key == HeaderPath
    requires exists x: AuthItem {:trigger x.key} {:trigger x in data} :: x in data && x.key == FooterPath
    requires AuthListHasNoDuplicates(data)
    ensures CanonAuthMatchesAuthList(tableName, data, ret)
    decreases tableName, data
  {
    reveal CanonAuthMatchesAuthList();
    reveal Seq.Map();
    reveal IsValidPath();
    var canonList: CanonAuthList := Seq.Map((s: AuthItem) requires IsValidPath(s.key) => MakeCanonAuth(tableName, s), data);
    assert |data| == |canonList|;
    assert forall i: int {:trigger data[i]} {:trigger canonList[i]} | 0 <= i < |data| :: canonList[i] == MakeCanonAuth(tableName, data[i]);
    assert forall k: AuthItem {:trigger AuthExistsInCanonAuth(k, canonList)} {:trigger k in data} | k in data :: AuthExistsInCanonAuth(k, canonList) by {
      reveal AuthExistsInCanonAuth();
    }
    assert forall k: CanonAuthItem {:trigger CanonAuthExistsInAuth(k, data)} {:trigger k in canonList} | k in canonList :: CanonAuthExistsInAuth(k, data) by {
      reveal CanonAuthExistsInAuth();
    }
    assert forall k: CanonAuthItem {:trigger k.origKey} {:trigger k in canonList} | k in canonList :: IsValidPath(k.origKey);
    assert forall k: CanonAuthItem {:trigger k.key} {:trigger k.origKey} {:trigger k in canonList} | k in canonList :: IsCanonPath(tableName, k.origKey, k.key);
    assert CanonAuthListHasNoDuplicates(canonList) by {
      assert forall i: int {:trigger canonList[i]} {:trigger data[i]} | 0 <= i < |canonList| :: data[i].key == canonList[i].origKey;
    }
    assert CanonAuthMatchesAuthList(tableName, data, canonList);
    canonList
  }

  opaque function method CryptoToCanonCrypto(tableName: GoodString, data: CryptoList): (ret: CanonCryptoList)
    requires forall k: CryptoItem {:trigger k.key} {:trigger k in data} | k in data :: IsValidPath(k.key)
    requires CryptoListHasNoDuplicates(data)
    requires !exists x: CryptoItem {:trigger x.key} {:trigger x in data} | x in data :: x.key in HeaderPaths
    ensures CanonCryptoMatchesCryptoList(tableName, data, ret)
    decreases tableName, data
  {
    reveal CanonCryptoMatchesCryptoList();
    reveal Seq.Map();
    reveal IsValidPath();
    var canonList: CanonCryptoList := Seq.Map((s: CryptoItem) requires IsValidPath(s.key) => MakeCanon(tableName, s), data);
    assert |data| == |canonList|;
    assert forall i: int {:trigger data[i]} {:trigger canonList[i]} | 0 <= i < |data| :: canonList[i] == MakeCanon(tableName, data[i]);
    assert forall k: CryptoItem {:trigger CryptoExistsInCanonCrypto(k, canonList)} {:trigger k in data} | k in data :: CryptoExistsInCanonCrypto(k, canonList) by {
      reveal CryptoExistsInCanonCrypto();
      assert forall k: CryptoItem {:trigger k.action} {:trigger k.data} {:trigger k.key} {:trigger k in data} | k in data :: exists x: CanonCryptoItem {:trigger x.action} {:trigger x.data} {:trigger x.origKey} {:trigger x in canonList} :: x in canonList && k.key == x.origKey && k.data == x.data && k.action == x.action;
      assert forall k: CryptoItem {:trigger k in data} | k in data :: exists x: CanonCryptoItem {:trigger SameStuff1(k, x)} {:trigger x in canonList} :: x in canonList && SameStuff1(k, x);
    }
    assert forall k: CanonCryptoItem {:trigger CanonCryptoExistsInCrypto(k, data)} {:trigger k in canonList} | k in canonList :: CanonCryptoExistsInCrypto(k, data) by {
      reveal CanonCryptoExistsInCrypto();
    }
    assert forall k: CanonCryptoItem {:trigger k.origKey} {:trigger k in canonList} | k in canonList :: IsValidPath(k.origKey);
    assert forall k: CanonCryptoItem {:trigger k.key} {:trigger k.origKey} {:trigger k in canonList} | k in canonList :: IsCanonPath(tableName, k.origKey, k.key);
    assert CanonCryptoListHasNoDuplicates(canonList) by {
      assert forall i: int {:trigger canonList[i]} {:trigger data[i]} | 0 <= i < |canonList| :: data[i].key == canonList[i].origKey;
    }
    assert CanonCryptoMatchesCryptoList(tableName, data, canonList);
    canonList
  }

  lemma SameMultisetSameStuff<T>(x: seq<T>, y: seq<T>)
    requires multiset(x) == multiset(y)
    ensures forall k: T {:trigger k in y} {:trigger k in x} | k in x :: k in y
    ensures forall k: T {:trigger k in x} {:trigger k in y} | k in y :: k in x
    decreases x, y
  {
    assert forall k: T {:trigger multiset(x)[k]} {:trigger k in x} | k in x :: k in multiset(x);
    assert forall k: T {:trigger multiset(y)[k]} {:trigger k in y} | k in y :: k in multiset(y);
    assert multiset(y) == multiset(x);
  }

  opaque function method AuthSort(canonList: CanonAuthList, ghost tableName: GoodString, ghost data: AuthList): (ret: CanonAuthList)
    requires forall k: AuthItem {:trigger k.key} {:trigger k in data} | k in data :: IsValidPath(k.key)
    requires CanonAuthMatchesAuthList(tableName, data, canonList)
    ensures CanonAuthMatchesAuthList(tableName, data, ret)
    ensures Relations.SortedBy(ret, SortCanon.AuthBelow)
    decreases canonList, tableName, data
  {
    reveal CanonAuthMatchesAuthList();
    reveal IsCryptoSorted();
    var canonSorted: CanonAuthList := SortCanon.AuthSort(canonList);
    assert |data| == |canonSorted|;
    assert forall k: CanonAuthItem {:trigger k in canonSorted} {:trigger k in canonList} | k in canonList :: k in canonSorted by {
      SameMultisetSameStuff(canonList, canonSorted);
    }
    assert forall k: CanonAuthItem {:trigger k in canonList} {:trigger k in canonSorted} | k in canonSorted :: k in canonList by {
      SameMultisetSameStuff(canonList, canonSorted);
    }
    assert forall k: CanonAuthItem {:trigger CanonAuthExistsInCanonAuth(k, canonSorted)} {:trigger k in canonList} | k in canonList :: CanonAuthExistsInCanonAuth(k, canonSorted) by {
      reveal CanonAuthExistsInCanonAuth();
    }
    assert forall k: CanonAuthItem {:trigger CanonAuthExistsInCanonAuth(k, canonList)} {:trigger k in canonSorted} | k in canonSorted :: CanonAuthExistsInCanonAuth(k, canonList) by {
      reveal CanonAuthExistsInCanonAuth();
    }
    assert forall k: AuthItem {:trigger AuthExistsInCanonAuth(k, canonSorted)} {:trigger k in data} | k in data :: AuthExistsInCanonAuth(k, canonSorted) by {
      reveal AuthExistsInCanonAuth();
    }
    assert forall k: CanonAuthItem {:trigger CanonAuthExistsInAuth(k, data)} {:trigger k in canonSorted} | k in canonSorted :: CanonAuthExistsInAuth(k, data);
    assert |data| == |canonSorted|;
    assert forall k: CanonAuthItem {:trigger k.origKey} {:trigger k in canonSorted} | k in canonSorted :: IsValidPath(k.origKey);
    assert forall k: CanonAuthItem {:trigger k.key} {:trigger k.origKey} {:trigger k in canonSorted} | k in canonSorted :: IsCanonPath(tableName, k.origKey, k.key);
    assert CanonAuthListHasNoDuplicates(canonSorted);
    assert CanonAuthMatchesAuthList(tableName, data, canonSorted);
    canonSorted
  }

  opaque function method CryptoSort(canonList: CanonCryptoList, ghost tableName: GoodString, ghost data: CryptoList): (ret: CanonCryptoList)
    requires forall k: CryptoItem {:trigger k.key} {:trigger k in data} | k in data :: IsValidPath(k.key)
    requires CanonCryptoMatchesCryptoList(tableName, data, canonList)
    ensures CanonCryptoMatchesCryptoList(tableName, data, ret)
    ensures IsCryptoSorted(ret)
    decreases canonList, tableName, data
  {
    reveal CanonCryptoMatchesCryptoList();
    reveal IsCryptoSorted();
    var canonSorted: CanonCryptoList := SortCanon.CryptoSort(canonList);
    assert |data| == |canonSorted|;
    assert forall k: CanonCryptoItem {:trigger k in canonSorted} {:trigger k in canonList} | k in canonList :: k in canonSorted by {
      SameMultisetSameStuff(canonList, canonSorted);
    }
    assert forall k: CanonCryptoItem {:trigger k in canonList} {:trigger k in canonSorted} | k in canonSorted :: k in canonList by {
      SameMultisetSameStuff(canonList, canonSorted);
    }
    assert forall k: CanonCryptoItem {:trigger CanonCryptoExistsInCanonCrypto(k, canonSorted)} {:trigger k in canonList} | k in canonList :: CanonCryptoExistsInCanonCrypto(k, canonSorted) by {
      reveal CanonCryptoExistsInCanonCrypto();
    }
    assert forall k: CanonCryptoItem {:trigger CanonCryptoExistsInCanonCrypto(k, canonList)} {:trigger k in canonSorted} | k in canonSorted :: CanonCryptoExistsInCanonCrypto(k, canonList) by {
      reveal CanonCryptoExistsInCanonCrypto();
    }
    assert forall k: CryptoItem {:trigger CryptoExistsInCanonCrypto(k, canonSorted)} {:trigger k in data} | k in data :: CryptoExistsInCanonCrypto(k, canonSorted) by {
      reveal CryptoExistsInCanonCrypto();
    }
    assert forall k: CanonCryptoItem {:trigger CanonCryptoExistsInCrypto(k, data)} {:trigger k in canonSorted} | k in canonSorted :: CanonCryptoExistsInCrypto(k, data);
    assert |data| == |canonSorted|;
    assert forall k: CanonCryptoItem {:trigger k.origKey} {:trigger k in canonSorted} | k in canonSorted :: IsValidPath(k.origKey);
    assert forall k: CanonCryptoItem {:trigger k.key} {:trigger k.origKey} {:trigger k in canonSorted} | k in canonSorted :: IsCanonPath(tableName, k.origKey, k.key);
    assert CanonCryptoListHasNoDuplicates(canonSorted);
    assert CanonCryptoMatchesCryptoList(tableName, data, canonSorted);
    canonSorted
  }

  lemma IsValidPathTransfers(canonSorted: CanonAuthList, canonResolved: CanonCryptoList)
    requires forall k: CanonAuthItem {:trigger k.origKey} {:trigger k in canonSorted} | k in canonSorted :: IsValidPath(k.origKey)
    requires |canonSorted| == |canonResolved|
    requires forall i: int {:trigger canonResolved[i]} {:trigger canonSorted[i]} | 0 <= i < |canonSorted| :: Same(canonSorted[i], canonResolved[i])
    ensures forall k: CanonCryptoItem {:trigger k.origKey} {:trigger k in canonResolved} | k in canonResolved :: IsValidPath(k.origKey)
    decreases canonSorted, canonResolved
  {
  }

  lemma IsCanonPathTransfers(canonSorted: CanonAuthList, canonResolved: CanonCryptoList, tableName: GoodString)
    requires forall k: CanonAuthItem {:trigger k.origKey} {:trigger k in canonSorted} | k in canonSorted :: IsValidPath(k.origKey)
    requires forall k: CanonAuthItem {:trigger k.key} {:trigger k.origKey} {:trigger k in canonSorted} | k in canonSorted :: IsCanonPath(tableName, k.origKey, k.key)
    requires |canonSorted| == |canonResolved|
    requires forall i: int {:trigger canonResolved[i]} {:trigger canonSorted[i]} | 0 <= i < |canonSorted| :: Same(canonSorted[i], canonResolved[i])
    ensures forall k: CanonCryptoItem {:trigger k.origKey} {:trigger k in canonResolved} | k in canonResolved :: IsValidPath(k.origKey)
    ensures forall k: CanonCryptoItem {:trigger k.key} {:trigger k.origKey} {:trigger k in canonResolved} | k in canonResolved :: IsCanonPath(tableName, k.origKey, k.key)
    decreases canonSorted, canonResolved, tableName
  {
  }

  lemma NoDupsTransfers(canonSorted: CanonAuthList, canonResolved: CanonCryptoList)
    requires CanonAuthListHasNoDuplicates(canonSorted)
    requires |canonSorted| == |canonResolved|
    requires forall i: int {:trigger canonResolved[i]} {:trigger canonSorted[i]} | 0 <= i < |canonSorted| :: Same(canonSorted[i], canonResolved[i])
    ensures CanonCryptoListHasNoDuplicates(canonResolved)
    decreases canonSorted, canonResolved
  {
  }

  opaque function method {:vcs_split_on_every_assert} DoResolveLegend(canonSorted: CanonAuthList, legend: Header.Legend, ghost tableName: GoodString, ghost data: AuthList): (ret: Result<CanonCryptoList, Error>)
    requires CanonAuthMatchesAuthList(tableName, data, canonSorted)
    requires Relations.SortedBy(canonSorted, SortCanon.AuthBelow)
    ensures ret.Success? ==> CanonCryptoMatchesAuthList(tableName, data, ret.value) && IsCryptoSorted(ret.value)
    decreases canonSorted, legend, tableName, data
  {
    reveal CanonAuthMatchesAuthList();
    reveal CanonCryptoMatchesAuthList();
    reveal IsCryptoSorted();
    var canonResolved: CanonCryptoList :- ResolveLegend(canonSorted, legend, canonSorted, []); assert forall k: AuthItem {:trigger AuthExistsInCanonCrypto(k, canonResolved)} {:trigger k in data} | k in data :: AuthExistsInCanonCrypto(k, canonResolved) by {
    reveal AuthExistsInCanonCrypto();
    reveal AuthExistsInCanonAuth();
  } assert forall k: CanonCryptoItem {:trigger CanonCryptoExistsInAuth(k, data)} {:trigger k in canonResolved} | k in canonResolved :: CanonCryptoExistsInAuth(k, data) by {
    reveal CanonCryptoExistsInAuth();
    reveal CanonAuthExistsInAuth();
    reveal AuthExistsInCanonAuth();
    assert forall k: CanonAuthItem {:trigger CanonAuthExistsInAuth(k, data)} {:trigger k in canonSorted} | k in canonSorted :: CanonAuthExistsInAuth(k, data);
  } assert |data| == |canonResolved|; assert forall k: CanonCryptoItem {:trigger k.origKey} {:trigger k in canonResolved} | k in canonResolved :: IsValidPath(k.origKey) by {
    IsValidPathTransfers(canonSorted, canonResolved);
  } assert forall k: CanonCryptoItem {:trigger k.key} {:trigger k.origKey} {:trigger k in canonResolved} | k in canonResolved :: IsCanonPath(tableName, k.origKey, k.key) by {
    IsCanonPathTransfers(canonSorted, canonResolved, tableName);
  } assert CanonCryptoListHasNoDuplicates(canonResolved) by {
    NoDupsTransfers(canonSorted, canonResolved);
  } assert Relations.SortedBy(canonResolved, SortCanon.CryptoBelow) by {
    assert Relations.SortedBy(canonSorted, SortCanon.AuthBelow);
    SortCanon.AuthSortIsCryptoSort(canonSorted, canonResolved);
  } assert CanonCryptoMatchesAuthList(tableName, data, canonResolved); Success(canonResolved)
  }

  opaque predicate IsCryptoSorted(list: CanonCryptoList)
    decreases list
  {
    Relations.SortedBy(list, SortCanon.CryptoBelow)
  }

  opaque function method ForDecrypt(tableName: GoodString, data: AuthList, legend: Header.Legend): (ret: Result<CanonCryptoList, Error>)
    requires AuthListHasNoDuplicates(data)
    requires exists x: AuthItem {:trigger x.key} {:trigger x in data} :: x in data && x.key == HeaderPath
    requires exists x: AuthItem {:trigger x.key} {:trigger x in data} :: x in data && x.key == FooterPath
    ensures ret.Success? ==> CanonCryptoMatchesAuthList(tableName, data, ret.value) && IsCryptoSorted(ret.value)
    decreases tableName, data, legend
  {
    reveal IsValidPath();
    :- Need(forall k: AuthItem {:trigger k.key} {:trigger k in data} | k in data :: _default.ValidPath(k.key), E(""Invalid Paths"")); var canonList: CanonAuthList := AuthToCanonAuth(tableName, data); var canonSorted: CanonAuthList := AuthSort(canonList, tableName, data); DoResolveLegend(canonSorted, legend, tableName, data)
  }

  predicate method SameUnCanon(x: CanonCryptoItem, y: CryptoItem)
    decreases x, y
  {
    x.origKey == y.key &&
    x.data == y.data &&
    x.action == y.action
  }

  function method UnCanon(input: CanonCryptoList): (ret: CryptoList)
    ensures |ret| == |input| && forall i: int {:trigger ret[i]} {:trigger input[i]} | 0 <= i < |input| :: SameUnCanon(input[i], ret[i])
    decreases input
  {
    if |input| == 0 then
      []
    else
      var newItem: CryptoItem := CryptoItem(key := input[0].origKey, data := input[0].data, action := input[0].action); assert SameUnCanon(input[0], newItem); [newItem] + UnCanon(input[1..])
  }

  lemma Update2ImpliesUpdate3()
    ensures forall oldVal: AuthItem, x: CanonCryptoItem, y: CryptoItem {:trigger Updated3(oldVal, y, DoDecrypt), Updated2(oldVal, x, DoDecrypt)} {:trigger Updated2(oldVal, x, DoDecrypt), SameUnCanon(x, y)} :: SameUnCanon(x, y) && Updated2(oldVal, x, DoDecrypt) ==> Updated3(oldVal, y, DoDecrypt)
  {
  }

  lemma Update5ImpliesUpdate4()
    ensures forall oldVal: CryptoItem, x: CanonCryptoItem, y: CryptoItem {:trigger Updated4(oldVal, y, DoEncrypt), Updated5(oldVal, x, DoEncrypt)} {:trigger Updated5(oldVal, x, DoEncrypt), SameUnCanon(x, y)} :: SameUnCanon(x, y) && Updated5(oldVal, x, DoEncrypt) ==> Updated4(oldVal, y, DoEncrypt)
  {
  }

  lemma AuthUpdatedCryptoMaps(origData: AuthList, input: CanonCryptoList, output: CryptoList)
    requires |input| == |output|
    requires forall k: AuthItem {:trigger AuthUpdatedCanonCrypto(k, input)} {:trigger k in origData} | k in origData :: AuthUpdatedCanonCrypto(k, input)
    requires forall i: int {:trigger output[i]} {:trigger input[i]} | 0 <= i < |input| :: SameUnCanon(input[i], output[i])
    ensures forall k: AuthItem {:trigger AuthUpdatedCrypto(k, output)} {:trigger k in origData} | k in origData :: AuthUpdatedCrypto(k, output)
    decreases origData, input, output
  {
    reveal AuthUpdatedCanonCrypto();
    reveal AuthUpdatedCrypto();
    assert forall k: AuthItem {:trigger k in origData} | k in origData :: exists x: CryptoItem {:trigger Updated3(k, x, DoDecrypt)} {:trigger x in output} :: x in output && Updated3(k, x, DoDecrypt) by {
      Update2ImpliesUpdate3();
    }
  }

  predicate Updated2Exists(origData: AuthList, item: CanonCryptoItem)
    decreases origData, item
  {
    exists x: AuthItem {:trigger Updated2(x, item, DoDecrypt)} {:trigger x in origData} :: 
      x in origData &&
      Updated2(x, item, DoDecrypt)
  }

  predicate Updated5Exists(origData: CryptoList, item: CanonCryptoItem)
    decreases origData, item
  {
    exists x: CryptoItem {:trigger Updated5(x, item, DoEncrypt)} {:trigger x in origData} :: 
      x in origData &&
      Updated5(x, item, DoEncrypt)
  }

  lemma InputIsInput(origData: AuthList, input: CanonCryptoList)
    requires forall val: CanonCryptoItem {:trigger Updated2Exists(origData, val)} {:trigger val in input} | val in input :: Updated2Exists(origData, val)
    ensures forall i: int {:trigger input[i]} | 0 <= i < |input| :: Updated2Exists(origData, input[i])
    decreases origData, input
  {
  }

  lemma InputIsInput2(origData: CryptoList, input: CanonCryptoList)
    requires forall val: CanonCryptoItem {:trigger Updated5Exists(origData, val)} {:trigger val in input} | val in input :: Updated5Exists(origData, val)
    ensures forall i: int {:trigger input[i]} | 0 <= i < |input| :: Updated5Exists(origData, input[i])
    decreases origData, input
  {
  }

  lemma CryptoUpdatedAuthMaps(origData: AuthList, input: CanonCryptoList, output: CryptoList)
    requires |input| == |output|
    requires forall k: CanonCryptoItem {:trigger CanonCryptoUpdatedAuth(k, origData)} {:trigger k in input} | k in input :: CanonCryptoUpdatedAuth(k, origData)
    requires forall i: int {:trigger output[i]} {:trigger input[i]} | 0 <= i < |input| :: SameUnCanon(input[i], output[i])
    ensures forall k: CryptoItem {:trigger CryptoUpdatedAuth(k, origData)} {:trigger k in output} | k in output :: CryptoUpdatedAuth(k, origData)
    decreases origData, input, output
  {
    reveal CanonCryptoUpdatedAuth();
    reveal CryptoUpdatedAuth();
    assert forall k: CryptoItem {:trigger k in output} | k in output :: exists x: AuthItem {:trigger Updated3(x, k, DoDecrypt)} {:trigger x in origData} :: x in origData && Updated3(x, k, DoDecrypt) by {
      Update2ImpliesUpdate3();
      assert forall val: CanonCryptoItem {:trigger val in input} | val in input :: exists x: AuthItem {:trigger Updated2(x, val, DoDecrypt)} {:trigger x in origData} :: x in origData && Updated2(x, val, DoDecrypt);
      assume {:axiom} forall i: int {:trigger input[i]} | 0 <= i < |input| :: exists x: AuthItem {:trigger Updated2(x, input[i], DoDecrypt)} {:trigger x in origData} :: x in origData && Updated2(x, input[i], DoDecrypt);
      assert forall newVal: CryptoItem {:trigger newVal in output} | newVal in output :: exists x: AuthItem {:trigger Updated3(x, newVal, DoDecrypt)} {:trigger x in origData} :: x in origData && Updated3(x, newVal, DoDecrypt);
    }
  }

  function method UnCanonDecrypt(input: CanonCryptoList, ghost tableName: GoodString, ghost origData: AuthList): (ret: CryptoList)
    requires CanonCryptoUpdatedAuthList(tableName, origData, input)
    ensures CryptoUpdatedAuthList(origData, ret)
    decreases input, tableName, origData
  {
    reveal CanonCryptoUpdatedAuthList();
    reveal CryptoUpdatedAuthList();
    var results: CryptoList := UnCanon(input);
    assert forall k: AuthItem {:trigger AuthUpdatedCrypto(k, results)} {:trigger k in origData} | k in origData :: AuthUpdatedCrypto(k, results) by {
      AuthUpdatedCryptoMaps(origData, input, results);
    }
    assert forall k: CryptoItem {:trigger CryptoUpdatedAuth(k, origData)} {:trigger k in results} | k in results :: CryptoUpdatedAuth(k, origData) by {
      CryptoUpdatedAuthMaps(origData, input, results);
    }
    results
  }

  lemma CryptoUpdatedCryptoMaps(origData: CryptoList, input: CanonCryptoList, output: CryptoList)
    requires |input| == |output|
    requires forall k: CryptoItem {:trigger CryptoUpdatedCanonCrypto(k, input)} {:trigger k in origData} | k in origData :: CryptoUpdatedCanonCrypto(k, input)
    requires forall i: int {:trigger output[i]} {:trigger input[i]} | 0 <= i < |input| :: SameUnCanon(input[i], output[i])
    ensures forall k: CryptoItem {:trigger CryptoUpdatedNewCrypto(k, output)} {:trigger k in origData} | k in origData :: CryptoUpdatedNewCrypto(k, output)
    decreases origData, input, output
  {
    reveal CryptoUpdatedCanonCrypto();
    reveal CryptoUpdatedNewCrypto();
    assert forall k: CryptoItem {:trigger k in origData} | k in origData :: exists x: CryptoItem {:trigger Updated4(k, x, DoEncrypt)} {:trigger x in output} :: x in output && Updated4(k, x, DoEncrypt) by {
      Update5ImpliesUpdate4();
    }
  }

  lemma CryptoUpdatedCryptoMaps2(origData: CryptoList, input: CanonCryptoList, output: CryptoList)
    requires |input| == |output|
    requires forall k: CanonCryptoItem {:trigger CanonCryptoUpdatedCrypto(k, origData)} {:trigger k in input} | k in input :: CanonCryptoUpdatedCrypto(k, origData)
    requires forall i: int {:trigger output[i]} {:trigger input[i]} | 0 <= i < |input| :: SameUnCanon(input[i], output[i])
    ensures forall k: CryptoItem {:trigger NewCryptoUpdatedCrypto(k, origData)} {:trigger k in output} | k in output :: NewCryptoUpdatedCrypto(k, origData)
    decreases origData, input, output
  {
    assert forall i: int {:trigger input[i]} | 0 <= i < |input| :: input[i] in input;
    assert forall i: int {:trigger output[i]} | 0 <= i < |output| :: output[i] in output;
    forall i: int | 0 <= i < |output|
      ensures NewCryptoUpdatedCrypto(output[i], origData)
    {
      reveal CanonCryptoUpdatedCrypto();
      reveal NewCryptoUpdatedCrypto();
      Update5ImpliesUpdate4();
    }
  }

  function method UnCanonEncrypt(input: CanonCryptoList, ghost tableName: GoodString, ghost origData: CryptoList): (ret: CryptoList)
    requires CanonCryptoUpdatedCryptoList(tableName, origData, input)
    ensures CryptoUpdatedCryptoList(origData, ret)
    decreases input, tableName, origData
  {
    reveal CanonCryptoUpdatedCryptoList();
    reveal CryptoUpdatedCryptoList();
    var results: CryptoList := UnCanon(input);
    assert forall k: CryptoItem {:trigger CryptoUpdatedNewCrypto(k, results)} {:trigger k in origData} | k in origData :: CryptoUpdatedNewCrypto(k, results) by {
      CryptoUpdatedCryptoMaps(origData, input, results);
    }
    assert forall k: CryptoItem {:trigger NewCryptoUpdatedCrypto(k, origData)} {:trigger k in results} | k in results :: NewCryptoUpdatedCrypto(k, origData) by {
      CryptoUpdatedCryptoMaps2(origData, input, results);
    }
    results
  }

  opaque predicate EncryptPathFinal(origData: CryptoList, finalData: CryptoList)
    decreases origData, finalData
  {
    |finalData| == |origData| + 2 &&
    CryptoUpdatedCryptoListHeader(origData, finalData[..|finalData| - 2]) &&
    finalData[|finalData| - 2].key == HeaderPath &&
    finalData[|finalData| - 1].key == FooterPath
  }

  opaque function method AddHeaders(input: CryptoList, headerData: StructuredDataTerminal, footerData: StructuredDataTerminal, ghost origData: CryptoList): (ret: CryptoList)
    requires CryptoUpdatedCryptoList(origData, input)
    ensures EncryptPathFinal(origData, ret)
    decreases input, headerData, footerData, origData
  {
    reveal EncryptPathFinal();
    reveal CryptoUpdatedCryptoList();
    reveal CryptoUpdatedCryptoListHeader();
    var headItem: CryptoItem := Types.CryptoItem(key := HeaderPath, data := headerData, action := DO_NOTHING);
    var footItem: CryptoItem := Types.CryptoItem(key := FooterPath, data := footerData, action := DO_NOTHING);
    var largeResult: seq<CryptoItem> := input + [headItem, footItem];
    largeResult
  }

  opaque predicate DecryptPathFinal(origData: AuthList, finalData: CryptoList)
    decreases origData, finalData
  {
    !(exists x: CryptoItem {:trigger x.key} {:trigger x in finalData} :: x in finalData && x.key == HeaderPath) &&
    !(exists x: CryptoItem {:trigger x.key} {:trigger x in finalData} :: x in finalData && x.key == FooterPath) &&
    (forall k: AuthItem {:trigger AuthUpdatedCrypto(k, finalData)} {:trigger k.key} {:trigger k in origData} | k in origData :: 
      k.key in [HeaderPath, FooterPath] || AuthUpdatedCrypto(k, finalData)) &&
    (forall k: CryptoItem {:trigger CryptoUpdatedAuth(k, origData)} {:trigger k in finalData} | k in finalData :: 
      CryptoUpdatedAuth(k, origData)) &&
    (forall k: CryptoItem {:trigger k.key} {:trigger k in finalData} | k in finalData :: 
      IsValidPath(k.key)) &&
    CryptoListHasNoDuplicates(finalData)
  }

  opaque function method RemoveHeaderPaths(xs: CryptoList): (ret: CryptoList)
    requires CryptoListHasNoDuplicates(xs)
    ensures !exists x: CryptoItem {:trigger x.key} {:trigger x in ret} :: x in ret && x.key in [HeaderPath, FooterPath]
    ensures !exists x: CryptoItem {:trigger x.key} {:trigger x in ret} :: x in ret && x.key == HeaderPath
    ensures !exists x: CryptoItem {:trigger x.key} {:trigger x in ret} :: x in ret && x.key == FooterPath
    ensures forall x: CryptoItem {:trigger x in xs} {:trigger x in ret} | x in ret :: x in xs
    ensures forall x: CryptoItem {:trigger x in ret} {:trigger x.key} {:trigger x in xs} | x in xs :: x.key in [HeaderPath, FooterPath] || x in ret
    ensures CryptoListHasNoDuplicates(ret)
    decreases xs
  {
    if |xs| == 0 then
      []
    else
      (if xs[0].key in [HeaderPath, FooterPath] then [] else [xs[0]]) + RemoveHeaderPaths(xs[1..])
  }

  opaque function method RemoveHeaders(input: CryptoList, ghost origData: AuthList): (ret: CryptoList)
    requires CryptoUpdatedAuthList(origData, input)
    ensures DecryptPathFinal(origData, ret)
    decreases input, origData
  {
    reveal CryptoUpdatedAuthList();
    reveal DecryptPathFinal();
    reveal AuthUpdatedCrypto();
    var finalData: CryptoList := RemoveHeaderPaths(input);
    assert forall k: AuthItem {:trigger AuthUpdatedCrypto(k, finalData)} {:trigger k.key} {:trigger k in origData} | k in origData :: k.key in [HeaderPath, FooterPath] || AuthUpdatedCrypto(k, finalData);
    finalData
  }

  import opened StructuredEncryptionUtil

  import opened Types = AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes

  import opened Wrappers

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import Header = StructuredEncryptionHeader

  import Paths = StructuredEncryptionPaths

  import SortCanon

  import Relations

  datatype EncryptionSelector = DoEncrypt | DoDecrypt
}

module SortCanon {
  predicate method AuthBelow(x: CanonAuthItem, y: CanonAuthItem)
    decreases x, y
  {
    Below(x.key, y.key)
  }

  predicate method CryptoBelow(x: CanonCryptoItem, y: CanonCryptoItem)
    decreases x, y
  {
    Below(x.key, y.key)
  }

  lemma SameBelow2(x1: CanonAuthItem, x2: CanonAuthItem, y1: CanonCryptoItem, y2: CanonCryptoItem)
    requires x1.key == y1.key
    requires x2.key == y2.key
    ensures AuthBelow(x1, x2) == CryptoBelow(y1, y2)
    decreases x1, x2, y1, y2
  {
  }

  lemma SameBelow()
    ensures forall x1: CanonAuthItem, x2: CanonAuthItem, y1: CanonCryptoItem, y2: CanonCryptoItem {:trigger CryptoBelow(y1, y2), AuthBelow(x1, x2)} {:trigger CryptoBelow(y1, y2), x2.key, x1.key} {:trigger AuthBelow(x1, x2), y2.key, y1.key} {:trigger y2.key, x2.key, y1.key, x1.key} | x1.key == y1.key && x2.key == y2.key :: AuthBelow(x1, x2) == CryptoBelow(y1, y2)
  {
  }

  lemma AuthBelowIsReflexive(x: CanonAuthItem)
    ensures AuthBelow(x, x)
    decreases x
  {
    BelowIsReflexive(x.key);
  }

  lemma CryptoBelowIsReflexive(x: CanonCryptoItem)
    ensures CryptoBelow(x, x)
    decreases x
  {
    BelowIsReflexive(x.key);
  }

  lemma {:axiom} AuthBelowIsAntiSymmetric(x: CanonAuthItem, y: CanonAuthItem)
    requires AuthBelow(x, y) && AuthBelow(y, x)
    ensures x == y
    decreases x, y

  lemma {:axiom} CryptoBelowIsAntiSymmetric(x: CanonCryptoItem, y: CanonCryptoItem)
    requires CryptoBelow(x, y) && CryptoBelow(y, x)
    ensures x == y
    decreases x, y

  lemma AuthBelowIsTransitive(x: CanonAuthItem, y: CanonAuthItem, z: CanonAuthItem)
    requires AuthBelow(x, y) && AuthBelow(y, z)
    ensures AuthBelow(x, z)
    decreases x, y, z
  {
    BelowIsTransitive(x.key, y.key, z.key);
  }

  lemma CryptoBelowIsTransitive(x: CanonCryptoItem, y: CanonCryptoItem, z: CanonCryptoItem)
    requires CryptoBelow(x, y) && CryptoBelow(y, z)
    ensures CryptoBelow(x, z)
    decreases x, y, z
  {
    BelowIsTransitive(x.key, y.key, z.key);
  }

  lemma AuthBelowIsStronglyConnected(x: CanonAuthItem, y: CanonAuthItem)
    ensures AuthBelow(x, y) || AuthBelow(y, x)
    decreases x, y
  {
    BelowIsStronglyConnected(x.key, y.key);
  }

  lemma CryptoBelowIsStronglyConnected(x: CanonCryptoItem, y: CanonCryptoItem)
    ensures CryptoBelow(x, y) || CryptoBelow(y, x)
    decreases x, y
  {
    BelowIsStronglyConnected(x.key, y.key);
  }

  lemma AuthBelowIsTotal()
    ensures TotalOrdering(AuthBelow)
  {
    BelowIsTotal();
    assert TotalOrdering(Below);
    assert Reflexive(AuthBelow) by {
      forall x: CanonAuthItem | true {
        AuthBelowIsReflexive(x);
      }
    }
    assert AntiSymmetric(AuthBelow) by {
      forall x: CanonAuthItem, y: CanonAuthItem | AuthBelow(x, y) && AuthBelow(y, x) {
        AuthBelowIsAntiSymmetric(x, y);
      }
    }
    assert Relations.Transitive(AuthBelow) by {
      forall x: CanonAuthItem, y: CanonAuthItem, z: CanonAuthItem | AuthBelow(x, y) && AuthBelow(y, z) {
        AuthBelowIsTransitive(x, y, z);
      }
    }
    assert StronglyConnected(AuthBelow) by {
      forall x: CanonAuthItem, y: CanonAuthItem | true {
        AuthBelowIsStronglyConnected(x, y);
      }
    }
  }

  lemma CryptoBelowIsTotal()
    ensures TotalOrdering(CryptoBelow)
  {
    BelowIsTotal();
    assert TotalOrdering(Below);
    assert Reflexive(CryptoBelow) by {
      forall x: CanonCryptoItem | true {
        CryptoBelowIsReflexive(x);
      }
    }
    assert AntiSymmetric(CryptoBelow) by {
      forall x: CanonCryptoItem, y: CanonCryptoItem | CryptoBelow(x, y) && CryptoBelow(y, x) {
        CryptoBelowIsAntiSymmetric(x, y);
      }
    }
    assert Relations.Transitive(CryptoBelow) by {
      forall x: CanonCryptoItem, y: CanonCryptoItem, z: CanonCryptoItem | CryptoBelow(x, y) && CryptoBelow(y, z) {
        CryptoBelowIsTransitive(x, y, z);
      }
    }
    assert StronglyConnected(CryptoBelow) by {
      forall x: CanonCryptoItem, y: CanonCryptoItem | true {
        CryptoBelowIsStronglyConnected(x, y);
      }
    }
  }

  predicate method Below(x: seq<uint8>, y: seq<uint8>)
    decreases x, y
  {
    |x| != 0 ==>
      |y| != 0 &&
      x[0] <= y[0] &&
      (x[0] == y[0] ==>
        Below(x[1..], y[1..]))
  }

  lemma BelowIsTotal()
    ensures TotalOrdering(Below)
  {
    assert Reflexive(Below) by {
      forall x: seq<uint8> | true {
        BelowIsReflexive(x);
      }
    }
    assert AntiSymmetric(Below) by {
      forall x: seq<uint8>, y: seq<uint8> | Below(x, y) && Below(y, x) {
        BelowIsAntiSymmetric(x, y);
      }
    }
    assert Relations.Transitive(Below) by {
      forall x: seq<uint8>, y: seq<uint8>, z: seq<uint8> | Below(x, y) && Below(y, z) {
        BelowIsTransitive(x, y, z);
      }
    }
    assert StronglyConnected(Below) by {
      forall x: seq<uint8>, y: seq<uint8> | true {
        BelowIsStronglyConnected(x, y);
      }
    }
  }

  lemma /*{:_inductionTrigger Below(x, x)}*/ /*{:_induction x}*/ BelowIsReflexive(x: seq<uint8>)
    ensures Below(x, x)
    decreases x
  {
  }

  lemma /*{:_inductionTrigger Below(y, x)}*/ /*{:_inductionTrigger Below(x, y)}*/ /*{:_induction x, y}*/ BelowIsAntiSymmetric(x: seq<uint8>, y: seq<uint8>)
    requires Below(x, y) && Below(y, x)
    ensures x == y
    decreases x, y
  {
  }

  lemma /*{:_inductionTrigger Below(x, z), Below(y, z)}*/ /*{:_inductionTrigger Below(y, z), Below(x, y)}*/ /*{:_induction x, y, z}*/ BelowIsTransitive(x: seq<uint8>, y: seq<uint8>, z: seq<uint8>)
    requires Below(x, y) && Below(y, z)
    ensures Below(x, z)
    decreases x, y, z
  {
  }

  lemma /*{:_inductionTrigger Below(y, x)}*/ /*{:_inductionTrigger Below(x, y)}*/ /*{:_induction x, y}*/ BelowIsStronglyConnected(x: seq<uint8>, y: seq<uint8>)
    ensures Below(x, y) || Below(y, x)
    decreases x, y
  {
  }

  lemma AuthSortIsCryptoSort(x: CanonAuthList, y: CanonCryptoList)
    requires SortedBy(x, AuthBelow)
    requires |x| == |y|
    requires forall i: int {:trigger y[i]} {:trigger x[i]} | 0 <= i < |x| :: x[i].key == y[i].key
    ensures SortedBy(y, CryptoBelow)
    decreases x, y
  {
  }

  lemma SortedIsSorted(x: CanonCryptoList, y: CanonCryptoList)
    requires SortedBy(x, CryptoBelow)
    requires |x| == |y|
    requires forall i: int {:trigger y[i]} {:trigger x[i]} | 0 <= i < |x| :: x[i].key == y[i].key
    ensures SortedBy(y, CryptoBelow)
    decreases x, y
  {
  }

  function method AuthSort(x: CanonAuthList): (result: CanonAuthList)
    requires CanonAuthListHasNoDuplicates(x)
    ensures multiset(x) == multiset(result)
    ensures SortedBy(result, AuthBelow)
    ensures CanonAuthListHasNoDuplicates(result)
    ensures |result| == |x|
    decreases x
  {
    AuthBelowIsTotal();
    var ret: seq<CanonAuthItem> := MergeSortBy(x, AuthBelow);
    CanonAuthListMultiNoDup(x, ret);
    assert CanonAuthListHasNoDuplicates(ret);
    ret
  }

  function method CryptoSort(x: CanonCryptoList): (result: CanonCryptoList)
    requires CanonCryptoListHasNoDuplicates(x)
    ensures multiset(x) == multiset(result)
    ensures multiset(result) == multiset(x)
    ensures SortedBy(result, CryptoBelow)
    ensures CanonCryptoListHasNoDuplicates(result)
    ensures |result| == |x|
    decreases x
  {
    CryptoBelowIsTotal();
    var ret: seq<CanonCryptoItem> := MergeSortBy(x, CryptoBelow);
    CanonCryptoListMultiNoDup(x, ret);
    assert CanonCryptoListHasNoDuplicates(ret);
    ret
  }

  lemma MultisetHasNoDuplicates(xs: CanonCryptoList)
    requires CanonCryptoListHasNoDuplicates(xs)
    ensures forall x: CanonCryptoItem {:trigger multiset(xs)[x]} | x in multiset(xs) :: multiset(xs)[x] == 1
    decreases xs
  {
    if |xs| == 0 {
    } else {
      assert xs == Seq.DropLast(xs) + [Seq.Last(xs)];
      assert Seq.Last(xs) !in Seq.DropLast(xs);
      assert CanonCryptoListHasNoDuplicates(Seq.DropLast(xs));
      MultisetHasNoDuplicates(Seq.DropLast(xs));
    }
  }

  lemma MultisetHasNoDuplicates2(xs: CanonAuthList)
    requires CanonAuthListHasNoDuplicates(xs)
    ensures forall x: CanonAuthItem {:trigger multiset(xs)[x]} | x in multiset(xs) :: multiset(xs)[x] == 1
    decreases xs
  {
    if |xs| == 0 {
    } else {
      assert xs == Seq.DropLast(xs) + [Seq.Last(xs)];
      assert Seq.Last(xs) !in Seq.DropLast(xs);
      assert CanonAuthListHasNoDuplicates(Seq.DropLast(xs));
      MultisetHasNoDuplicates2(Seq.DropLast(xs));
    }
  }

  lemma CanonCryptoListMultiNoDup(a: CanonCryptoList, b: CanonCryptoList)
    requires CanonCryptoListHasNoDuplicates(a) && multiset(a) == multiset(b)
    ensures CanonCryptoListHasNoDuplicates(b)
    decreases a, b
  {
    forall i: int, j: int | 0 <= i < j < |b|
      ensures b[i].origKey != b[j].origKey
    {
      assert b[i] in multiset(a);
      assert b[j] in multiset(a);
      if b[i] == b[j] {
        assert b[i].origKey == b[j].origKey;
        MultisetHasNoDuplicates(a);
        assert multiset(b)[b[i]] == 1;
        assert b == b[..i] + [b[i]] + b[i + 1 .. j] + [b[j]] + b[j + 1..];
      } else {
        assert b[i].origKey != b[j].origKey;
      }
    }
  }

  lemma CanonAuthListMultiNoDup(a: CanonAuthList, b: CanonAuthList)
    requires CanonAuthListHasNoDuplicates(a) && multiset(a) == multiset(b)
    ensures CanonAuthListHasNoDuplicates(b)
    decreases a, b
  {
    forall i: int, j: int | 0 <= i < j < |b|
      ensures b[i].origKey != b[j].origKey
    {
      assert b[i] in multiset(a);
      assert b[j] in multiset(a);
      if b[i] == b[j] {
        assert b[i].origKey == b[j].origKey;
        MultisetHasNoDuplicates2(a);
        assert multiset(b)[b[i]] == 1;
        assert b == b[..i] + [b[i]] + b[i + 1 .. j] + [b[j]] + b[j + 1..];
      } else {
        assert b[i].origKey != b[j].origKey;
      }
    }
  }

  export
    provides AuthSort, CryptoSort, AuthBelow, CryptoBelow, StructuredEncryptionUtil, Relations, AuthSortIsCryptoSort, SortedIsSorted


  import opened Wrappers

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import opened Relations

  import opened MergeSort = Seq.MergeSort

  import opened StructuredEncryptionUtil
}

module StructuredEncryptionUtil {
  const ReservedPrefix := ""aws_dbe_""
  const HeaderField := ReservedPrefix + ""head""
  const FooterField := ReservedPrefix + ""foot""
  const HeaderPath: Path := [member(StructureSegment(key := HeaderField))]
  const FooterPath: Path := [member(StructureSegment(key := FooterField))]
  const HeaderPaths: seq<Path> := [HeaderPath, FooterPath]
  const ReservedCryptoContextPrefixString := ""aws-crypto-""
  const ReservedCryptoContextPrefixUTF8 := UTF8.EncodeAscii(ReservedCryptoContextPrefixString)
  const ATTR_PREFIX := ReservedCryptoContextPrefixString + ""attr.""
  const EC_ATTR_PREFIX: UTF8.ValidUTF8Bytes := UTF8.EncodeAscii(ATTR_PREFIX)
  const LEGEND := ReservedCryptoContextPrefixString + ""legend""
  const LEGEND_UTF8: UTF8.ValidUTF8Bytes := UTF8.EncodeAscii(LEGEND)
  const LEGEND_STRING: char := 'S'
  const LEGEND_NUMBER: char := 'N'
  const LEGEND_LITERAL: char := 'L'
  const LEGEND_BINARY: char := 'B'
  const NULL_STR: string := ""null""
  const NULL_UTF8: UTF8.ValidUTF8Bytes := UTF8.EncodeAscii(NULL_STR)
  const TRUE_STR: string := ""true""
  const TRUE_UTF8: UTF8.ValidUTF8Bytes := UTF8.EncodeAscii(TRUE_STR)
  const FALSE_STR: string := ""false""
  const FALSE_UTF8: UTF8.ValidUTF8Bytes := UTF8.EncodeAscii(FALSE_STR)

  function method CryptoListToSet(xs: CryptoList): (ret: set<Path>)
    ensures |xs| == 0 ==> |ret| == 0
    ensures |xs| == 1 ==> ret == {xs[0].key}
    ensures |xs| == 1 ==> |ret| == 1
    decreases xs
  {
    set k: CryptoItem {:trigger k.key} {:trigger k in xs} | k in xs :: k.key
  }

  function method CanonCryptoListToSet(xs: CanonCryptoList): (ret: set<Path>)
    ensures |xs| == 0 ==> |ret| == 0
    ensures |xs| == 1 ==> ret == {xs[0].origKey}
    ensures |xs| == 1 ==> |ret| == 1
    decreases xs
  {
    set k: CanonCryptoItem {:trigger k.origKey} {:trigger k in xs} | k in xs :: k.origKey
  }

  function method AuthListToSet(xs: AuthList): (ret: set<Path>)
    ensures |xs| == 0 ==> |ret| == 0
    ensures |xs| == 1 ==> ret == {xs[0].key}
    ensures |xs| == 1 ==> |ret| == 1
    decreases xs
  {
    set k: AuthItem {:trigger k.key} {:trigger k in xs} | k in xs :: k.key
  }

  predicate method CryptoListHasNoDuplicatesFromSet(xs: CryptoList)
    decreases xs
  {
    |CryptoListToSet(xs)| == |xs|
  }

  predicate method AuthListHasNoDuplicatesFromSet(xs: AuthList)
    decreases xs
  {
    |AuthListToSet(xs)| == |xs|
  }

  predicate CryptoListHasNoDuplicates(xs: CryptoList)
    decreases xs
  {
    forall i: int, j: int {:trigger xs[j], xs[i]} :: 
      0 <= i < j < |xs| ==>
        xs[i].key != xs[j].key
  }

  predicate AuthListHasNoDuplicates(xs: AuthList)
    decreases xs
  {
    forall i: int, j: int {:trigger xs[j], xs[i]} :: 
      0 <= i < j < |xs| ==>
        xs[i].key != xs[j].key
  }

  predicate CanonCryptoListHasNoDuplicates(xs: CanonCryptoList)
    decreases xs
  {
    forall i: int, j: int {:trigger xs[j], xs[i]} :: 
      0 <= i < j < |xs| ==>
        xs[i].origKey != xs[j].origKey
  }

  predicate CanonAuthListHasNoDuplicates(xs: CanonAuthList)
    decreases xs
  {
    forall i: int, j: int {:trigger xs[j], xs[i]} :: 
      0 <= i < j < |xs| ==>
        xs[i].origKey != xs[j].origKey
  }

  lemma CheckNames()
    ensures HeaderField == ""aws_dbe_head""
    ensures FooterField == ""aws_dbe_foot""
  {
  }

  const TYPEID_LEN := 2
  const BYTES_TYPE_ID: seq<uint8> := [255, 255]

  lemma BYTES_TYPE_ID_OK()
    ensures |BYTES_TYPE_ID| == TYPEID_LEN
  {
  }

  const KeySize := 32
  const NonceSize := 12
  const AuthTagSize := 16
  const MSGID_LEN := 32
  const DbeAlgorithmFamily: uint8 := 103

  lemma ValidSuiteSizes(alg: CMP.AlgorithmSuiteInfo)
    requires ValidSuite(alg)
    ensures AlgorithmSuites.GetEncryptKeyLength(alg) as int == KeySize
    ensures alg.encrypt.AES_GCM.keyLength as int == KeySize
    ensures alg.encrypt.AES_GCM.tagLength as int == AuthTagSize
    ensures alg.encrypt.AES_GCM.ivLength as int == NonceSize
    decreases alg
  {
  }

  predicate method ValidString(x: string)
    decreases x
  {
    |x| < UINT64_LIMIT &&
    UTF8.Encode(x).Success?
  }

  predicate method ValidSuite(alg: CMP.AlgorithmSuiteInfo)
    decreases alg
  {
    alg.id.DBE? &&
    AlgorithmSuites.DBEAlgorithmSuite?(alg)
  }

  function method E(s: string): Error
    decreases s
  {
    StructuredEncryptionException(message := s)
  }

  function method {:tailrecursion} ConstantTimeCompare(a: Bytes, b: Bytes, acc: bv8 := 0): bv8
    requires |a| == |b|
    decreases a, b, acc
  {
    if |a| == 0 then
      acc
    else
      var x: bv8 := a[0] as bv8 ^ b[0] as bv8; ConstantTimeCompare(a[1..], b[1..], x | acc)
  }

  predicate method ConstantTimeEquals(a: Bytes, b: Bytes)
    requires |a| == |b|
    decreases a, b
  {
    ConstantTimeCompare(a, b) == 0
  }

  predicate method IsAuthAttr(x: CryptoAction)
    decreases x
  {
    x.ENCRYPT_AND_SIGN? || x.SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT? || x.SIGN_ONLY?
  }

  function method ValueToData(value: Bytes, typeId: Bytes): StructuredDataTerminal
    requires IsValid_TerminalTypeId(typeId)
    decreases value, typeId
  {
    StructuredDataTerminal(typeId := typeId, value := value)
  }

  function method GetValue(data: StructuredDataTerminal): Bytes
    decreases data
  {
    data.value
  }

  predicate method ByteLess(x: uint8, y: uint8)
    decreases x, y
  {
    x < y
  }

  predicate method CharLess(x: char, y: char)
    decreases x, y
  {
    x < y
  }

  const TERM_T: uint8 := 0
  const SET_T: uint8 := 1
  const MAP_T: uint8 := 2
  const LIST_T: uint8 := 3
  const NULL_T: uint8 := 0
  const STRING_T: uint8 := 1
  const NUMBER_T: uint8 := 2
  const BINARY_T: uint8 := 255
  const BOOLEAN_T: uint8 := 4
  const NULL: TerminalTypeId := [TERM_T, NULL_T]
  const STRING: TerminalTypeId := [TERM_T, STRING_T]
  const NUMBER: TerminalTypeId := [TERM_T, NUMBER_T]
  const BINARY: TerminalTypeId := [255, 255]
  const BOOLEAN: TerminalTypeId := [TERM_T, BOOLEAN_T]
  const STRING_SET: TerminalTypeId := [SET_T, STRING_T]
  const NUMBER_SET: TerminalTypeId := [SET_T, NUMBER_T]
  const BINARY_SET: TerminalTypeId := [SET_T, BINARY_T]
  const MAP: TerminalTypeId := [MAP_T, NULL_T]
  const LIST: TerminalTypeId := [LIST_T, NULL_T]

  method EcAsString(ec: CMP.EncryptionContext) returns (output: map<string, string>)
    decreases ec
  {
    var keys: seq<UTF8.ValidUTF8Bytes> := SortedSets.ComputeSetToOrderedSequence2(ec.Keys, ByteLess);
    var ret: map<string, string> := map[];
    for i: int := 0 to |keys| {
      var key :- expect UTF8.Decode(keys[i]);
      var value :- expect UTF8.Decode(ec[keys[i]]);
      ret := ret[key := value];
    }
    return ret;
  }

  method PrintEncryptionContext(ec: CMP.EncryptionContext, name: string)
    decreases ec, name
  {
    var keys: seq<UTF8.ValidUTF8Bytes> := SortedSets.ComputeSetToOrderedSequence2(ec.Keys, ByteLess);
    print name, "" := {\n"";
    for i: int := 0 to |keys| {
      var key :- expect UTF8.Decode(keys[i]);
      var value :- expect UTF8.Decode(ec[keys[i]]);
      print ""  "", key, "" := "", value, ""\n"";
    }
    print ""}\n"";
  }

  function method EncodeTerminal(t: StructuredDataTerminal): (ret: UTF8.ValidUTF8Bytes)
    ensures ret == UTF8.EncodeAscii(Base64.Encode(t.typeId + t.value))
    decreases t
  {
    UTF8.EncodeAscii(Base64.Encode(t.typeId + t.value))
  }

  function method DecodeTerminal(t: UTF8.ValidUTF8Bytes): (ret: Result<StructuredDataTerminal, string>)
    decreases t
  {
    var utf8DecodedVal: string :- UTF8.Decode(t); var base64DecodedVal: seq<uint8> :- Base64.Decode(utf8DecodedVal); :- Need(|base64DecodedVal| >= 2, ""Invalid serialization of DDB Attribute in encryption context.""); var typeId: seq<BoundedInts.uint8> := base64DecodedVal[..2]; var serializedValue: seq<BoundedInts.uint8> := base64DecodedVal[2..]; Success(StructuredDataTerminal(value := serializedValue, typeId := typeId))
  }

  lemma CryptoListNoDupFromMap(xs: seq<CryptoItem>)
    requires HasNoDuplicates(Map((x: CryptoItem) => x.key, xs))
    ensures CryptoListHasNoDuplicates(xs)
    decreases xs
  {
    ghost var ys := Map((x: CryptoItem) => x.key, xs);
    assert forall i: int, j: int {:trigger ys[j], ys[i]} | 0 <= i < j < |xs| :: ys[i] != ys[j] by {
      reveal HasNoDuplicates();
    }
    assert forall i: int {:trigger xs[i]} {:trigger ys[i]} | 0 <= i < |xs| :: ys[i] == xs[i].key;
  }

  lemma AuthListNoDupFromMap(xs: seq<AuthItem>)
    requires HasNoDuplicates(Map((x: AuthItem) => x.key, xs))
    ensures AuthListHasNoDuplicates(xs)
    decreases xs
  {
    ghost var ys := Map((x: AuthItem) => x.key, xs);
    assert forall i: int, j: int {:trigger ys[j], ys[i]} | 0 <= i < j < |xs| :: ys[i] != ys[j] by {
      reveal HasNoDuplicates();
    }
    assert forall i: int {:trigger xs[i]} {:trigger ys[i]} | 0 <= i < |xs| :: ys[i] == xs[i].key;
  }

  lemma CryptoListCard(xs: seq<CryptoItem>)
    ensures |ToSet(Map((x: CryptoItem) => x.key, xs))| == |CryptoListToSet(xs)|
    decreases xs
  {
    reveal ToSet();
    ghost var ys := Map((x: CryptoItem) => x.key, xs);
    forall x: seq<PathSegment> | true
      ensures x in ToSet(ys) <==> x in CryptoListToSet(xs)
    {
      assert x in ToSet(ys) ==> x in CryptoListToSet(xs);
      assert x in CryptoListToSet(xs) ==> x in ToSet(ys) by {
        if x in CryptoListToSet(xs) {
          ghost var i :| 0 <= i < |xs| && xs[i].key == x;
          assert ys[i] == x by {
            calc == {
              ys[i];
              Map((x: CryptoItem) => x.key, xs)[i];
              xs[i].key;
              x;
            }
          }
        } else {
        }
      }
    }
    assert ToSet(ys) == CryptoListToSet(xs);
  }

  lemma AuthListCard(xs: seq<AuthItem>)
    ensures |ToSet(Map((x: AuthItem) => x.key, xs))| == |AuthListToSet(xs)|
    decreases xs
  {
    reveal ToSet();
    ghost var ys := Map((x: AuthItem) => x.key, xs);
    forall x: seq<PathSegment> | true
      ensures x in ToSet(ys) <==> x in AuthListToSet(xs)
    {
      assert x in ToSet(ys) ==> x in AuthListToSet(xs);
      assert x in AuthListToSet(xs) ==> x in ToSet(ys) by {
        if x in AuthListToSet(xs) {
          ghost var i :| 0 <= i < |xs| && xs[i].key == x;
          assert ys[i] == x by {
            calc == {
              ys[i];
              Map((x: AuthItem) => x.key, xs)[i];
              xs[i].key;
              x;
            }
          }
        } else {
        }
      }
    }
    assert ToSet(ys) == AuthListToSet(xs);
  }

  lemma SetSizeImpliesCryptoListHasNoDuplicates(xs: seq<CryptoItem>)
    requires CryptoListHasNoDuplicatesFromSet(xs)
    ensures CryptoListHasNoDuplicates(xs)
    decreases xs
  {
    ghost var ys := Map((x: CryptoItem) => x.key, xs);
    CryptoListCard(xs);
    LemmaNoDuplicatesCardinalityOfSet(ys);
    CryptoListNoDupFromMap(xs);
  }

  lemma SetSizeImpliesAuthListHasNoDuplicates(xs: seq<AuthItem>)
    requires AuthListHasNoDuplicatesFromSet(xs)
    ensures AuthListHasNoDuplicates(xs)
    decreases xs
  {
    ghost var ys := Map((x: AuthItem) => x.key, xs);
    AuthListCard(xs);
    LemmaNoDuplicatesCardinalityOfSet(ys);
    AuthListNoDupFromMap(xs);
  }

  import opened AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes

  import opened Wrappers

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import UTF8

  import CMP = AwsCryptographyMaterialProvidersTypes

  import CSE = AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes

  import AlgorithmSuites

  import SortedSets

  import Base64

  import opened Seq

  datatype CanonCryptoItem = CanonCryptoItem(key: CanonicalPath, origKey: Path, data: StructuredDataTerminal, action: CryptoAction)

  datatype CanonAuthItem = CanonAuthItem(key: CanonicalPath, origKey: Path, data: StructuredDataTerminal, action: AuthenticateAction)

  type CanonCryptoList = seq<CanonCryptoItem>

  type CanonAuthList = seq<CanonAuthItem>

  type Key = x: seq<uint8>
    | |x| == KeySize
    witness *

  type Nonce = x: seq<uint8>
    | |x| == NonceSize
    witness *

  type AuthTag = x: seq<uint8>
    | |x| == AuthTagSize
    witness *

  type MessageID = x: Bytes
    | |x| == MSGID_LEN
    witness *

  type Bytes = seq<uint8>

  type CanonicalPath = seq<uint8>

  type GoodString = x: string
    | ValidString(x)
}

module {:extern ""software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types""} AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes {
  predicate method IsValid_TerminalTypeId(x: seq<uint8>)
    decreases x
  {
    2 <= |x| <= 2
  }

  predicate method IsDummySubsetType(x: int)
    decreases x
  {
    0 < x
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import AwsCryptographyMaterialProvidersTypes

  import AwsCryptographyPrimitivesTypes

  datatype DafnyCallEvent<I, O> = DafnyCallEvent(input: I, output: O)

  datatype AuthenticateAction = SIGN | DO_NOT_SIGN

  type AuthenticateSchemaMap = map<string, AuthenticateAction>

  datatype AuthItem = AuthItem(nameonly key: Path, nameonly data: StructuredDataTerminal, nameonly action: AuthenticateAction)

  type AuthList = seq<AuthItem>

  datatype CryptoAction = ENCRYPT_AND_SIGN | SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT | SIGN_ONLY | DO_NOTHING

  datatype CryptoItem = CryptoItem(nameonly key: Path, nameonly data: StructuredDataTerminal, nameonly action: CryptoAction)

  type CryptoList = seq<CryptoItem>

  type CryptoSchemaMap = map<string, CryptoAction>

  datatype DecryptPathStructureInput = DecryptPathStructureInput(nameonly tableName: string, nameonly encryptedStructure: AuthList, nameonly cmm: AwsCryptographyMaterialProvidersTypes.ICryptographicMaterialsManager, nameonly encryptionContext: Option<AwsCryptographyMaterialProvidersTypes.EncryptionContext> := Option.None)

  datatype DecryptPathStructureOutput = DecryptPathStructureOutput(nameonly plaintextStructure: CryptoList, nameonly parsedHeader: ParsedHeader)

  datatype DecryptStructureInput = DecryptStructureInput(nameonly tableName: string, nameonly encryptedStructure: StructuredDataMap, nameonly authenticateSchema: AuthenticateSchemaMap, nameonly cmm: AwsCryptographyMaterialProvidersTypes.ICryptographicMaterialsManager, nameonly encryptionContext: Option<AwsCryptographyMaterialProvidersTypes.EncryptionContext> := Option.None)

  datatype DecryptStructureOutput = DecryptStructureOutput(nameonly plaintextStructure: StructuredDataMap, nameonly cryptoSchema: CryptoSchemaMap, nameonly parsedHeader: ParsedHeader)

  datatype EncryptPathStructureInput = EncryptPathStructureInput(nameonly tableName: string, nameonly plaintextStructure: CryptoList, nameonly cmm: AwsCryptographyMaterialProvidersTypes.ICryptographicMaterialsManager, nameonly algorithmSuiteId: Option<AwsCryptographyMaterialProvidersTypes.DBEAlgorithmSuiteId> := Option.None, nameonly encryptionContext: Option<AwsCryptographyMaterialProvidersTypes.EncryptionContext> := Option.None)

  datatype EncryptPathStructureOutput = EncryptPathStructureOutput(nameonly encryptedStructure: CryptoList, nameonly parsedHeader: ParsedHeader)

  datatype EncryptStructureInput = EncryptStructureInput(nameonly tableName: string, nameonly plaintextStructure: StructuredDataMap, nameonly cryptoSchema: CryptoSchemaMap, nameonly cmm: AwsCryptographyMaterialProvidersTypes.ICryptographicMaterialsManager, nameonly algorithmSuiteId: Option<AwsCryptographyMaterialProvidersTypes.DBEAlgorithmSuiteId> := Option.None, nameonly encryptionContext: Option<AwsCryptographyMaterialProvidersTypes.EncryptionContext> := Option.None)

  datatype EncryptStructureOutput = EncryptStructureOutput(nameonly encryptedStructure: StructuredDataMap, nameonly cryptoSchema: CryptoSchemaMap, nameonly parsedHeader: ParsedHeader)

  datatype ParsedHeader = ParsedHeader(nameonly algorithmSuiteId: AwsCryptographyMaterialProvidersTypes.DBEAlgorithmSuiteId, nameonly encryptedDataKeys: AwsCryptographyMaterialProvidersTypes.EncryptedDataKeyList, nameonly storedEncryptionContext: AwsCryptographyMaterialProvidersTypes.EncryptionContext, nameonly encryptionContext: AwsCryptographyMaterialProvidersTypes.EncryptionContext)

  type Path = seq<PathSegment>

  datatype PathSegment = member(member: StructureSegment)

  datatype ResolveAuthActionsInput = ResolveAuthActionsInput(nameonly tableName: string, nameonly authActions: AuthList, nameonly headerBytes: seq<uint8>)

  datatype ResolveAuthActionsOutput = ResolveAuthActionsOutput(nameonly cryptoActions: CryptoList)

  type StructuredDataMap = map<string, StructuredDataTerminal>

  datatype StructuredDataTerminal = StructuredDataTerminal(nameonly value: TerminalValue, nameonly typeId: TerminalTypeId)

  class IStructuredEncryptionClientCallHistory {
    ghost constructor ()
    {
      EncryptStructure := [];
      DecryptStructure := [];
      EncryptPathStructure := [];
      DecryptPathStructure := [];
      ResolveAuthActions := [];
    }

    ghost var EncryptStructure: seq<DafnyCallEvent<EncryptStructureInput, Result<EncryptStructureOutput, Error>>>
    ghost var DecryptStructure: seq<DafnyCallEvent<DecryptStructureInput, Result<DecryptStructureOutput, Error>>>
    ghost var EncryptPathStructure: seq<DafnyCallEvent<EncryptPathStructureInput, Result<EncryptPathStructureOutput, Error>>>
    ghost var DecryptPathStructure: seq<DafnyCallEvent<DecryptPathStructureInput, Result<DecryptPathStructureOutput, Error>>>
    ghost var ResolveAuthActions: seq<DafnyCallEvent<ResolveAuthActionsInput, Result<ResolveAuthActionsOutput, Error>>>
  }

  trait {:termination false} IStructuredEncryptionClient {
    ghost const Modifies: set<object>

    predicate ValidState()
      ensures ValidState() ==> History in Modifies

    ghost const History: IStructuredEncryptionClientCallHistory

    predicate EncryptStructureEnsuresPublicly(input: EncryptStructureInput, output: Result<EncryptStructureOutput, Error>)
      decreases input, output

    method EncryptStructure(input: EncryptStructureInput) returns (output: Result<EncryptStructureOutput, Error>)
      requires ValidState() && input.cmm.ValidState() && input.cmm.Modifies !! {History}
      modifies Modifies - {History}, input.cmm.Modifies, History`EncryptStructure
      ensures true && ValidState()
      ensures EncryptStructureEnsuresPublicly(input, output)
      ensures History.EncryptStructure == old(History.EncryptStructure) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.cmm.Modifies

    predicate DecryptStructureEnsuresPublicly(input: DecryptStructureInput, output: Result<DecryptStructureOutput, Error>)
      decreases input, output

    method DecryptStructure(input: DecryptStructureInput) returns (output: Result<DecryptStructureOutput, Error>)
      requires ValidState() && input.cmm.ValidState() && input.cmm.Modifies !! {History}
      modifies Modifies - {History}, input.cmm.Modifies, History`DecryptStructure
      ensures true && ValidState()
      ensures DecryptStructureEnsuresPublicly(input, output)
      ensures History.DecryptStructure == old(History.DecryptStructure) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.cmm.Modifies

    predicate EncryptPathStructureEnsuresPublicly(input: EncryptPathStructureInput, output: Result<EncryptPathStructureOutput, Error>)
      decreases input, output

    method EncryptPathStructure(input: EncryptPathStructureInput) returns (output: Result<EncryptPathStructureOutput, Error>)
      requires ValidState() && input.cmm.ValidState() && input.cmm.Modifies !! {History}
      modifies Modifies - {History}, input.cmm.Modifies, History`EncryptPathStructure
      ensures true && ValidState()
      ensures EncryptPathStructureEnsuresPublicly(input, output)
      ensures History.EncryptPathStructure == old(History.EncryptPathStructure) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.cmm.Modifies

    predicate DecryptPathStructureEnsuresPublicly(input: DecryptPathStructureInput, output: Result<DecryptPathStructureOutput, Error>)
      decreases input, output

    method DecryptPathStructure(input: DecryptPathStructureInput) returns (output: Result<DecryptPathStructureOutput, Error>)
      requires ValidState() && input.cmm.ValidState() && input.cmm.Modifies !! {History}
      modifies Modifies - {History}, input.cmm.Modifies, History`DecryptPathStructure
      ensures true && ValidState()
      ensures DecryptPathStructureEnsuresPublicly(input, output)
      ensures History.DecryptPathStructure == old(History.DecryptPathStructure) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.cmm.Modifies

    predicate ResolveAuthActionsEnsuresPublicly(input: ResolveAuthActionsInput, output: Result<ResolveAuthActionsOutput, Error>)
      decreases input, output

    method ResolveAuthActions(input: ResolveAuthActionsInput) returns (output: Result<ResolveAuthActionsOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ResolveAuthActions
      ensures true && ValidState()
      ensures ResolveAuthActionsEnsuresPublicly(input, output)
      ensures History.ResolveAuthActions == old(History.ResolveAuthActions) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
  }

  datatype StructuredEncryptionConfig = StructuredEncryptionConfig

  datatype StructureSegment = StructureSegment(nameonly key: string)

  type TerminalTypeId = x: seq<uint8>
    | IsValid_TerminalTypeId(x)
    witness *

  type TerminalValue = seq<uint8>

  datatype Error = StructuredEncryptionException(nameonly message: string) | AwsCryptographyMaterialProviders(AwsCryptographyMaterialProviders: AwsCryptographyMaterialProvidersTypes.Error) | AwsCryptographyPrimitives(AwsCryptographyPrimitives: AwsCryptographyPrimitivesTypes.Error) | CollectionOfErrors(list: seq<Error>, nameonly message: string) | Opaque(obj: object) | OpaqueWithText(obj: object, objMessage: string)

  type OpaqueError = e: Error
    | e.Opaque? || e.OpaqueWithText?
    witness *

  type DummySubsetType = x: int
    | IsDummySubsetType(x)
    witness 1
}

abstract module AbstractAwsCryptographyDbEncryptionSdkStructuredEncryptionService {
  function method DefaultStructuredEncryptionConfig(): StructuredEncryptionConfig

  method StructuredEncryption(config: StructuredEncryptionConfig := DefaultStructuredEncryptionConfig()) returns (res: Result<StructuredEncryptionClient, Error>)
    ensures res.Success? ==> fresh(res.value) && fresh(res.value.Modifies) && fresh(res.value.History) && res.value.ValidState()
    decreases config

  function method CreateSuccessOfClient(client: IStructuredEncryptionClient): Result<IStructuredEncryptionClient, Error>
    decreases client
  {
    Success(client)
  }

  function method CreateFailureOfError(error: Error): Result<IStructuredEncryptionClient, Error>
    decreases error
  {
    Failure(error)
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes

  import Operations : AbstractAwsCryptographyDbEncryptionSdkStructuredEncryptionOperations

  class StructuredEncryptionClient extends IStructuredEncryptionClient {
    constructor (config: Operations.InternalConfig)
      requires Operations.ValidInternalConfig?(config)
      ensures ValidState() && fresh(History) && this.config == config

    const config: Operations.InternalConfig

    predicate ValidState()
      ensures ValidState() ==> Operations.ValidInternalConfig?(config) && History !in Operations.ModifiesInternalConfig(config) && Modifies == Operations.ModifiesInternalConfig(config) + {History}

    predicate EncryptStructureEnsuresPublicly(input: EncryptStructureInput, output: Result<EncryptStructureOutput, Error>)
      decreases input, output
    {
      Operations.EncryptStructureEnsuresPublicly(input, output)
    }

    method EncryptStructure(input: EncryptStructureInput) returns (output: Result<EncryptStructureOutput, Error>)
      requires ValidState() && input.cmm.ValidState() && input.cmm.Modifies !! {History}
      modifies Modifies - {History}, input.cmm.Modifies, History`EncryptStructure
      ensures true && ValidState()
      ensures EncryptStructureEnsuresPublicly(input, output)
      ensures History.EncryptStructure == old(History.EncryptStructure) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.cmm.Modifies
    {
      output := Operations.EncryptStructure(config, input);
      History.EncryptStructure := History.EncryptStructure + [DafnyCallEvent(input, output)];
    }

    predicate DecryptStructureEnsuresPublicly(input: DecryptStructureInput, output: Result<DecryptStructureOutput, Error>)
      decreases input, output
    {
      Operations.DecryptStructureEnsuresPublicly(input, output)
    }

    method DecryptStructure(input: DecryptStructureInput) returns (output: Result<DecryptStructureOutput, Error>)
      requires ValidState() && input.cmm.ValidState() && input.cmm.Modifies !! {History}
      modifies Modifies - {History}, input.cmm.Modifies, History`DecryptStructure
      ensures true && ValidState()
      ensures DecryptStructureEnsuresPublicly(input, output)
      ensures History.DecryptStructure == old(History.DecryptStructure) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.cmm.Modifies
    {
      output := Operations.DecryptStructure(config, input);
      History.DecryptStructure := History.DecryptStructure + [DafnyCallEvent(input, output)];
    }

    predicate EncryptPathStructureEnsuresPublicly(input: EncryptPathStructureInput, output: Result<EncryptPathStructureOutput, Error>)
      decreases input, output
    {
      Operations.EncryptPathStructureEnsuresPublicly(input, output)
    }

    method EncryptPathStructure(input: EncryptPathStructureInput) returns (output: Result<EncryptPathStructureOutput, Error>)
      requires ValidState() && input.cmm.ValidState() && input.cmm.Modifies !! {History}
      modifies Modifies - {History}, input.cmm.Modifies, History`EncryptPathStructure
      ensures true && ValidState()
      ensures EncryptPathStructureEnsuresPublicly(input, output)
      ensures History.EncryptPathStructure == old(History.EncryptPathStructure) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.cmm.Modifies
    {
      output := Operations.EncryptPathStructure(config, input);
      History.EncryptPathStructure := History.EncryptPathStructure + [DafnyCallEvent(input, output)];
    }

    predicate DecryptPathStructureEnsuresPublicly(input: DecryptPathStructureInput, output: Result<DecryptPathStructureOutput, Error>)
      decreases input, output
    {
      Operations.DecryptPathStructureEnsuresPublicly(input, output)
    }

    method DecryptPathStructure(input: DecryptPathStructureInput) returns (output: Result<DecryptPathStructureOutput, Error>)
      requires ValidState() && input.cmm.ValidState() && input.cmm.Modifies !! {History}
      modifies Modifies - {History}, input.cmm.Modifies, History`DecryptPathStructure
      ensures true && ValidState()
      ensures DecryptPathStructureEnsuresPublicly(input, output)
      ensures History.DecryptPathStructure == old(History.DecryptPathStructure) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.cmm.Modifies
    {
      output := Operations.DecryptPathStructure(config, input);
      History.DecryptPathStructure := History.DecryptPathStructure + [DafnyCallEvent(input, output)];
    }

    predicate ResolveAuthActionsEnsuresPublicly(input: ResolveAuthActionsInput, output: Result<ResolveAuthActionsOutput, Error>)
      decreases input, output
    {
      Operations.ResolveAuthActionsEnsuresPublicly(input, output)
    }

    method ResolveAuthActions(input: ResolveAuthActionsInput) returns (output: Result<ResolveAuthActionsOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ResolveAuthActions
      ensures true && ValidState()
      ensures ResolveAuthActionsEnsuresPublicly(input, output)
      ensures History.ResolveAuthActions == old(History.ResolveAuthActions) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.ResolveAuthActions(config, input);
      History.ResolveAuthActions := History.ResolveAuthActions + [DafnyCallEvent(input, output)];
    }
  }
}

abstract module AbstractAwsCryptographyDbEncryptionSdkStructuredEncryptionOperations {
  predicate ValidInternalConfig?(config: InternalConfig)

  function ModifiesInternalConfig(config: InternalConfig): set<object>

  predicate EncryptStructureEnsuresPublicly(input: EncryptStructureInput, output: Result<EncryptStructureOutput, Error>)
    decreases input, output

  method EncryptStructure(config: InternalConfig, input: EncryptStructureInput) returns (output: Result<EncryptStructureOutput, Error>)
    requires ValidInternalConfig?(config) && input.cmm.ValidState()
    modifies ModifiesInternalConfig(config), input.cmm.Modifies
    ensures true && ValidInternalConfig?(config)
    ensures EncryptStructureEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), input.cmm.Modifies

  predicate DecryptStructureEnsuresPublicly(input: DecryptStructureInput, output: Result<DecryptStructureOutput, Error>)
    decreases input, output

  method DecryptStructure(config: InternalConfig, input: DecryptStructureInput) returns (output: Result<DecryptStructureOutput, Error>)
    requires ValidInternalConfig?(config) && input.cmm.ValidState()
    modifies ModifiesInternalConfig(config), input.cmm.Modifies
    ensures true && ValidInternalConfig?(config)
    ensures DecryptStructureEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), input.cmm.Modifies

  predicate EncryptPathStructureEnsuresPublicly(input: EncryptPathStructureInput, output: Result<EncryptPathStructureOutput, Error>)
    decreases input, output

  method EncryptPathStructure(config: InternalConfig, input: EncryptPathStructureInput) returns (output: Result<EncryptPathStructureOutput, Error>)
    requires ValidInternalConfig?(config) && input.cmm.ValidState()
    modifies ModifiesInternalConfig(config), input.cmm.Modifies
    ensures true && ValidInternalConfig?(config)
    ensures EncryptPathStructureEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), input.cmm.Modifies

  predicate DecryptPathStructureEnsuresPublicly(input: DecryptPathStructureInput, output: Result<DecryptPathStructureOutput, Error>)
    decreases input, output

  method DecryptPathStructure(config: InternalConfig, input: DecryptPathStructureInput) returns (output: Result<DecryptPathStructureOutput, Error>)
    requires ValidInternalConfig?(config) && input.cmm.ValidState()
    modifies ModifiesInternalConfig(config), input.cmm.Modifies
    ensures true && ValidInternalConfig?(config)
    ensures DecryptPathStructureEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), input.cmm.Modifies

  predicate ResolveAuthActionsEnsuresPublicly(input: ResolveAuthActionsInput, output: Result<ResolveAuthActionsOutput, Error>)
    decreases input, output

  method ResolveAuthActions(config: InternalConfig, input: ResolveAuthActionsInput) returns (output: Result<ResolveAuthActionsOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ResolveAuthActionsEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes

  type InternalConfig
}

module StructuredEncryptionHeader {
  const VERSION_LEN := 1
  const FLAVOR_LEN := 1
  const COMMITMENT_LEN := 32
  const PREFIX_LEN := VERSION_LEN + FLAVOR_LEN + MSGID_LEN
  const UINT8_LIMIT := 256
  const ENCRYPT_AND_SIGN_LEGEND: uint8 := 101
  const SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT_LEGEND: uint8 := 99
  const SIGN_ONLY_LEGEND: uint8 := 115

  predicate method ValidVersion(x: uint8)
    decreases x
  {
    x == 1 || x == 2
  }

  predicate method IsVersion2Schema(data: CanonCryptoList)
    decreases data
  {
    exists x: CanonCryptoItem {:trigger x.action} {:trigger x in data} | x in data :: 
      x.action == SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT
  }

  function method VersionFromSchema(data: CanonCryptoList): (ret: Version)
    ensures (exists x: CanonCryptoItem {:trigger x.action} {:trigger x in data} | x in data :: x.action == SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT) <==> ret == 2
    ensures !(exists x: CanonCryptoItem {:trigger x.action} {:trigger x in data} | x in data :: x.action == SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT) <==> ret == 1
    decreases data
  {
    if IsVersion2Schema(data) then
      2
    else
      1
  }

  predicate method ValidFlavor(x: uint8)
    decreases x
  {
    x in [0, 1]
  }

  predicate method ValidLegendByte(x: uint8)
    decreases x
  {
    x in [ENCRYPT_AND_SIGN_LEGEND, SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT_LEGEND, SIGN_ONLY_LEGEND]
  }

  predicate method ValidEncryptionContext(x: CMP.EncryptionContext)
    decreases x
  {
    |x| < UINT16_LIMIT &&
    (forall k: seq<uint8> {:trigger |k|} {:trigger k in x} | k in x :: 
      |k| < UINT16_LIMIT) &&
    forall k: seq<uint8> {:trigger x[k]} {:trigger k in x} | k in x :: 
      |x[k]| < UINT16_LIMIT
  }

  predicate method ValidEncryptedDataKey(x: CMP.EncryptedDataKey)
    decreases x
  {
    |x.keyProviderId| < UINT16_LIMIT &&
    |x.keyProviderInfo| < UINT16_LIMIT &&
    |x.ciphertext| < UINT16_LIMIT
  }

  function method Serialize(client: Prim.IAwsCryptographicPrimitivesClient, alg: CMP.AlgorithmSuiteInfo, commitKey: Bytes, PartialHeader: PartialHeader): (ret: Result<Bytes, Error>)
    requires ValidSuite(alg)
    requires client.ValidState()
    ensures ret.Success? ==> PREFIX_LEN <= |ret.value| && CalculateHeaderCommitment(client, alg, commitKey, ret.value[..|ret.value| - COMMITMENT_LEN]).Success? && ret.value[|ret.value| - COMMITMENT_LEN..] == CalculateHeaderCommitment(client, alg, commitKey, ret.value[..|ret.value| - COMMITMENT_LEN]).value && ret.value == PartialHeader.serialize() + CalculateHeaderCommitment(client, alg, commitKey, ret.value[..|ret.value| - COMMITMENT_LEN]).value
    ensures client.ValidState()
    decreases client, alg, commitKey, PartialHeader
  {
    var body: Bytes := PartialHeader.serialize();
    var commitment: Bytes :- CalculateHeaderCommitment(client, alg, commitKey, body); Success(body + commitment)
  }

  function method Create(tableName: string, schema: CanonCryptoList, msgID: MessageID, mat: CMP.EncryptionMaterials): (ret: Result<PartialHeader, Error>)
    ensures ret.Success? ==> ret.value.version == VersionFromSchema(schema)
    decreases tableName, schema, msgID, mat
  {
    :- Need(ValidEncryptionContext(mat.encryptionContext), E(""Invalid Encryption Context"")); :- Need(0 < |mat.encryptedDataKeys|, E(""There must be at least one data key"")); :- Need(|mat.encryptedDataKeys| < UINT8_LIMIT, E(""Too many data keys."")); :- Need(forall x: CMP.EncryptedDataKey {:trigger ValidEncryptedDataKey(x)} {:trigger x in mat.encryptedDataKeys} | x in mat.encryptedDataKeys :: ValidEncryptedDataKey(x), E(""Invalid Data Key"")); :- Need(|mat.algorithmSuite.binaryId| == 2, E(""Invalid Algorithm Suite Binary ID"")); :- Need(mat.algorithmSuite.binaryId[0] == DbeAlgorithmFamily, E(""Algorithm Suite not suitable for structured encryption."")); :- Need(ValidFlavor(mat.algorithmSuite.binaryId[1]), E(""Algorithm Suite has unexpected flavor."")); var legend: Legend :- MakeLegend(schema); var storedEC: map<ValidUTF8Bytes, ValidUTF8Bytes> := map k: ValidUTF8Bytes {:trigger mat.encryptionContext[k]} {:trigger k in mat.requiredEncryptionContextKeys} {:trigger k in mat.encryptionContext} | k in mat.encryptionContext && k !in mat.requiredEncryptionContextKeys :: k := mat.encryptionContext[k]; :- Need(ValidEncryptionContext(storedEC), E(""Invalid Encryption Context"")); Success(PartialHeader(version := VersionFromSchema(schema), flavor := mat.algorithmSuite.binaryId[1], msgID := msgID, legend := legend, encContext := storedEC, dataKeys := mat.encryptedDataKeys))
  }

  function method {:opaque} PartialDeserialize(data: Bytes): (ret: Result<PartialHeader, Error>)
    ensures ret.Success? ==> PREFIX_LEN <= |data| && var v: PartialHeader := ret.value; v.version == data[0] && ValidVersion(v.version) && v.flavor == data[1] && ValidFlavor(v.flavor) && v.msgID == data[VERSION_LEN + FLAVOR_LEN .. PREFIX_LEN] && var legendData: seq<BoundedInts.uint8> := data[PREFIX_LEN..]; GetLegend(legendData).Success? && var legendAndLen: (Legend, nat) := GetLegend(legendData).value; v.legend == legendAndLen.0 && var contextData: seq<BoundedInts.uint8> := legendData[legendAndLen.1..]; GetContext(contextData).Success? && var contextAndLen: (CMPEncryptionContext, nat) := GetContext(contextData).value; true && v.encContext == contextAndLen.0
    decreases data
  {
    :- Need(PREFIX_LEN <= |data|, E(""Serialized PartialHeader too short."")); var version: BoundedInts.uint8 := data[0]; :- Need(ValidVersion(version), E(""Invalid Version Number"")); var flavor: BoundedInts.uint8 := data[1]; :- Need(ValidFlavor(flavor), E(""Invalid Flavor"")); var msgID: seq<BoundedInts.uint8> := data[2 .. PREFIX_LEN]; var legendData: seq<BoundedInts.uint8> := data[PREFIX_LEN..]; var legendAndLen: (Legend, nat) :- GetLegend(legendData); var legend: Legend := legendAndLen.0; var contextData: seq<BoundedInts.uint8> := legendData[legendAndLen.1..]; var contextAndLen: (CMPEncryptionContext, nat) :- GetContext(contextData); var encContext: CMPEncryptionContext := contextAndLen.0; var keysData: seq<BoundedInts.uint8> := contextData[contextAndLen.1..]; var keysAndLen: (CMPEncryptedDataKeyList, nat) :- GetDataKeys(keysData); var dataKeys: CMPEncryptedDataKeyList := keysAndLen.0; var trailingData: seq<BoundedInts.uint8> := keysData[keysAndLen.1..]; :- Need(|trailingData| >= COMMITMENT_LEN, E(""Invalid header serialization: unexpected end of data."")); :- Need(|trailingData| <= COMMITMENT_LEN, E(""Invalid header serialization: unexpected bytes."")); assert |trailingData| == COMMITMENT_LEN; Success(PartialHeader(version := version, flavor := flavor, msgID := msgID, legend := legend, encContext := encContext, dataKeys := dataKeys))
  }

  function method CalculateHeaderCommitment(client: Prim.IAwsCryptographicPrimitivesClient, alg: CMP.AlgorithmSuiteInfo, commitKey: Bytes, data: Bytes): (ret: Result<Bytes, Error>)
    requires ValidSuite(alg)
    requires client.ValidState()
    ensures ret.Success? ==> |ret.value| == COMMITMENT_LEN && var input: HMacInput := Prim.HMacInput(digestAlgorithm := alg.commitment.HKDF.hmac, key := commitKey, message := data); client.HMac(input).Success? && |client.HMac(input).value| >= 32 && ret.value == client.HMac(input).value[0 .. 32]
    ensures client.ValidState()
    decreases client, alg, commitKey, data
  {
    var input: HMacInput := Prim.HMacInput(digestAlgorithm := alg.commitment.HKDF.hmac, key := commitKey, message := data);
    var outputR: Result<seq<uint8>, Error> := client.HMac(input);
    var output: seq<uint8> :- outputR.MapFailure((e: Error) => AwsCryptographyPrimitives(e)); if |output| < COMMITMENT_LEN then Failure(E(""HMAC did not produce enough bits"")) else Success(output[..COMMITMENT_LEN])
  }

  function method ToUInt16(x: nat): (ret: Result<uint16, Error>)
    ensures x < UINT16_LIMIT ==> ret.Success?
    decreases x
  {
    :- Need(x < UINT16_LIMIT, E(""Value too big for 16 bits"")); Success(x as uint16)
  }

  function method MyMap<X, Y, Z>(f: X -> Y, m: map<X, Z>): map<Y, Z>
    requires forall a: X, b: X {:trigger f(b), f(a)} {:trigger f(b), a in m} {:trigger f(a), b in m} {:trigger b in m, a in m} | a in m && b in m :: a != b ==> f(a) != f(b)
    decreases m
  {
    map k: X {:trigger m[k]} {:trigger f(k)} {:trigger k in m} | k in m :: f(k) := m[k]
  }

  function method MakeLegend(schema: CanonCryptoList): (ret: Result<Legend, Error>)
    ensures ret.Success? ==> true && |ret.value| == CountAuthAttrs(schema)
    decreases schema
  {
    var legend: Legend :- MakeLegend2(schema); var authCount: nat := CountAuthAttrs(schema); :- Need(authCount == |legend|, E(""Internal Error : bad legend calculation."")); Success(legend)
  }

  const EmptyLegend: Legend := []

  function method {:tailrecursion} MakeLegend2(data: CanonCryptoList, serialized: Legend := EmptyLegend): (ret: Result<Legend, Error>)
    decreases data, serialized
  {
    if |data| == 0 then
      Success(serialized)
    else if IsAuthAttr(data[0].action) then
      :- Need(|serialized| + 1 < UINT16_LIMIT, E(""Legend Too Long."")); var legendChar: uint8 := GetActionLegend(data[0].action); MakeLegend2(data[1..], serialized + [legendChar])
    else
      MakeLegend2(data[1..], serialized)
  }

  function method GetActionLegend(x: CryptoAction): (ret: uint8)
    requires IsAuthAttr(x)
    ensures match x { case ENCRYPT_AND_SIGN() => ret == ENCRYPT_AND_SIGN_LEGEND case SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT() => ret == SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT_LEGEND case SIGN_ONLY() => ret == SIGN_ONLY_LEGEND }
    decreases x
  {
    match x {
      case ENCRYPT_AND_SIGN() =>
        ENCRYPT_AND_SIGN_LEGEND
      case SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT() =>
        SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT_LEGEND
      case SIGN_ONLY() =>
        SIGN_ONLY_LEGEND
    }
  }

  function method CountAuthAttrs(data: CanonCryptoList): nat
    decreases data
  {
    if |data| == 0 then
      0
    else if IsAuthAttr(data[0].action) then
      1 + CountAuthAttrs(data[1..])
    else
      CountAuthAttrs(data[1..])
  }

  function method {:opaque} SerializeLegend(x: Legend): (ret: Bytes)
    ensures |ret| == 2 + |x| && SeqToUInt16(ret[0 .. 2]) == |x| as uint16 && ret[2..] == x
    decreases x
  {
    UInt16ToSeq(|x| as uint16) + x
  }

  function method GetLegend(data: Bytes): (ret: Result<(Legend, nat), Error>)
    ensures ret.Success? ==> ret.value.1 <= |data| && ret.value.1 == |ret.value.0| + 2 && ret.value.0 == data[2 .. ret.value.1]
    decreases data
  {
    :- Need(2 <= |data|, E(""Unexpected end of header data."")); var len: uint16 := SeqToUInt16(data[0 .. 2]); var size: int := len as nat + 2; :- Need(size <= |data|, E(""Unexpected end of header data."")); :- Need(forall x: BoundedInts.uint8 {:trigger ValidLegendByte(x)} {:trigger x in data[2 .. size]} | x in data[2 .. size] :: ValidLegendByte(x), E(""Invalid byte in stored legend"")); Success((data[2 .. size], size))
  }

  function method GetContext(data: Bytes): (ret: Result<(CMPEncryptionContext, nat), Error>)
    ensures ret.Success? ==> true && ret.value.1 <= |data|
    ensures 2 <= |data| && GetContext2(SeqToUInt16(data[0 .. 2]) as nat, data, data[2..], (map[], 2)).Success? ==> ret.Success?
    decreases data
  {
    :- Need(2 <= |data|, E(""Unexpected end of header data."")); var count: nat := SeqToUInt16(data[0 .. 2]) as nat; var context: (CMPEncryptionContext, nat) :- GetContext2(count, data, data[2..], (map[], 2)); Success(context)
  }

  function method GetOneKVPair(data: Bytes): (ret: Result<(CMPUtf8Bytes, CMPUtf8Bytes, nat), Error>)
    ensures ret.Success? ==> ret.value.2 <= |data| && SerializeOneKVPair(ret.value.0, ret.value.1) == data[..ret.value.2]
    ensures 2 <= |data| && (var keyLen: nat := SeqToUInt16(data[0 .. 2]) as nat; keyLen + 4 <= |data| && UTF8.ValidUTF8Seq(data[2 .. keyLen + 2]) && var valueLen: nat := SeqToUInt16(data[keyLen + 2 .. keyLen + 4]) as nat; keyLen + valueLen + 4 <= |data| && UTF8.ValidUTF8Seq(data[keyLen + 4 .. keyLen + valueLen + 4])) <==> ret.Success? && SerializeOneKVPair(ret.value.0, ret.value.1) == data[..ret.value.2]
    decreases data
  {
    :- Need(2 <= |data|, E(""Unexpected end of header data."")); var keyLen: nat := SeqToUInt16(data[0 .. 2]) as nat; :- Need(keyLen + 4 <= |data|, E(""Unexpected end of header data."")); var key: seq<BoundedInts.uint8> := data[2 .. keyLen + 2]; :- Need(UTF8.ValidUTF8Seq(key), E(""Invalid UTF8 found in header."")); var valueLen: nat := SeqToUInt16(data[keyLen + 2 .. keyLen + 4]) as nat; var kvLen: int := 2 + keyLen + 2 + valueLen; :- Need(kvLen <= |data|, E(""Unexpected end of header data."")); var value: seq<BoundedInts.uint8> := data[keyLen + 4 .. kvLen]; :- Need(UTF8.ValidUTF8Seq(value), E(""Invalid UTF8 found in header."")); Success((key, value, kvLen))
  }

  predicate method {:tailrecursion} BytesLess(a: Bytes, b: Bytes)
    decreases a, b
  {
    if a == b then
      false
    else if |a| == 0 then
      true
    else if |b| == 0 then
      false
    else if a[0] != b[0] then
      a[0] < b[0]
    else
      BytesLess(a[1..], b[1..])
  }

  function method {:tailrecursion} GetContext2(count: nat, origData: Bytes, data: Bytes, deserialized: (CMPEncryptionContext, nat), prevKey: CMPUtf8Bytes := []): (ret: Result<(CMPEncryptionContext, nat), Error>)
    requires deserialized.1 <= |origData|
    requires deserialized.1 + |data| == |origData|
    requires data == origData[deserialized.1..]
    ensures ret.Success? ==> ret.value.1 <= |origData| && (count > 0 ==> GetOneKVPair(data).Success?)
    decreases count, origData, data, deserialized, prevKey
  {
    if count == 0 then
      Success(deserialized)
    else
      :- Need(|deserialized.0| + 1 < UINT16_LIMIT, E(""Too much context"")); var kv: (CMPUtf8Bytes, CMPUtf8Bytes, nat) :- GetOneKVPair(data); :- Need(BytesLess(prevKey, kv.0), E(""Context keys out of order."")); GetContext2(count - 1, origData, data[2 + |kv.0| + 2 + |kv.1|..], (deserialized.0[kv.0 := kv.1], deserialized.1 + kv.2), kv.0)
  }

  function method {:opaque} SerializeContext(x: CMPEncryptionContext): (ret: Bytes)
    ensures |ret| >= 2 && var keys: seq<seq<uint8>> := SortedSets.ComputeSetToOrderedSequence2(x.Keys, ByteLess); true && ret == UInt16ToSeq(|x| as uint16) + SerializeContext2(keys, x)
    decreases x
  {
    var keys: seq<seq<uint8>> := SortedSets.ComputeSetToOrderedSequence2(x.Keys, ByteLess);
    UInt16ToSeq(|x| as uint16) + SerializeContext2(keys, x)
  }

  function method SerializeOneKVPair(key: CMPUtf8Bytes, value: CMPUtf8Bytes): (ret: Bytes)
    ensures ret == UInt16ToSeq(|key| as uint16) + key + UInt16ToSeq(|value| as uint16) + value
    decreases key, value
  {
    UInt16ToSeq(|key| as uint16) + key + UInt16ToSeq(|value| as uint16) + value
  }

  function method SerializeOneDataKey(k: CMPEncryptedDataKey): (ret: Bytes)
    ensures true && var provIdSize: uint16 := ToUInt16(|k.keyProviderId|).value; true && var provInfoSize: uint16 := ToUInt16(|k.keyProviderInfo|).value; true && var cipherSize: uint16 := ToUInt16(|k.ciphertext|).value; true && ret == UInt16ToSeq(provIdSize) + k.keyProviderId + UInt16ToSeq(provInfoSize) + k.keyProviderInfo + UInt16ToSeq(cipherSize) + k.ciphertext
    decreases k
  {
    UInt16ToSeq(|k.keyProviderId| as uint16) + k.keyProviderId + UInt16ToSeq(|k.keyProviderInfo| as uint16) + k.keyProviderInfo + UInt16ToSeq(|k.ciphertext| as uint16) + k.ciphertext
  }

  function method {:vcs_split_on_every_assert} GetOneDataKey(data: Bytes): (ret: Result<(CMPEncryptedDataKey, nat), Error>)
    ensures ret.Success? ==> ret.value.1 <= |data| && |SerializeOneDataKey(ret.value.0)| == ret.value.1 && SerializeOneDataKey(ret.value.0) == data[0 .. ret.value.1]
    decreases data
  {
    :- Need(2 < |data|, E(""Unexpected end of header data."")); var provIdSize: nat := SeqToUInt16(data[0 .. 2]) as nat; :- Need(provIdSize + 2 < |data|, E(""Unexpected end of header data."")); var provId: seq<BoundedInts.uint8> := data[2 .. 2 + provIdSize]; :- Need(UTF8.ValidUTF8Seq(provId), E(""Invalid UTF8 found in header."")); var part1Size: int := 2 + provIdSize; :- Need(part1Size + 2 <= |data|, E(""Unexpected end of header data."")); var provInfoSize: nat := SeqToUInt16(data[part1Size .. part1Size + 2]) as nat; :- Need(part1Size + provInfoSize + 2 < |data|, E(""Unexpected end of header data."")); var provInfo: seq<BoundedInts.uint8> := data[part1Size + 2 .. part1Size + 2 + provInfoSize]; var part2Size: int := part1Size + 2 + provInfoSize; :- Need(part2Size + 2 <= |data|, E(""Unexpected end of header data."")); var cipherSize: nat := SeqToUInt16(data[part2Size .. part2Size + 2]) as nat; :- Need(part2Size + cipherSize + 2 <= |data|, E(""Unexpected end of header data."")); var cipher: seq<BoundedInts.uint8> := data[part2Size + 2 .. part2Size + 2 + cipherSize]; var part3Size: int := part2Size + 2 + cipherSize; var edk: EncryptedDataKey := CMP.EncryptedDataKey(keyProviderId := provId, keyProviderInfo := provInfo, ciphertext := cipher); Success((edk, part3Size))
  }

  function method {:tailrecursion} SerializeContext2(keys: seq<CMPUtf8Bytes>, x: CMPEncryptionContext): (ret: Bytes)
    requires forall k: CMPUtf8Bytes {:trigger k in x} {:trigger k in keys} | k in keys :: k in x
    decreases keys, x
  {
    if |keys| == 0 then
      []
    else
      SerializeOneKVPair(keys[0], x[keys[0]]) + SerializeContext2(keys[1..], x)
  }

  function method SerializeDataKeys(x: CMPEncryptedDataKeyList): (ret: Bytes)
    ensures 1 <= |ret| && ret[0] as nat == |x| && ret == [|x| as uint8] + SerializeDataKeys2(x)
    decreases x
  {
    var body: Bytes := SerializeDataKeys2(x);
    [|x| as uint8] + body
  }

  function method {:tailrecursion} SerializeDataKeys2(x: CMPEncryptedDataKeyListEmptyOK): (ret: Bytes)
    decreases x
  {
    if |x| == 0 then
      []
    else
      SerializeOneDataKey(x[0]) + SerializeDataKeys2(x[1..])
  }

  function method GetDataKeys(data: Bytes): (ret: Result<(CMPEncryptedDataKeyList, nat), Error>)
    ensures ret.Success? ==> ret.value.1 <= |data| && 1 <= |data| && 1 <= ret.value.1 && |ret.value.0| == data[0] as nat && GetDataKeys2(|ret.value.0|, |ret.value.0|, data, data[1..], ([], 1)).Success?
    decreases data
  {
    :- Need(1 <= |data|, E(""Unexpected end of header data."")); var count: nat := data[0] as nat; var keys: (CMPEncryptedDataKeyListEmptyOK, nat) :- GetDataKeys2(count, count, data, data[1..], ([], 1)); if |keys.0| == 0 then Failure(E(""At least one Data Key required"")) else Success(keys)
  }

  function method {:tailrecursion} GetDataKeys2(count: nat, origCount: nat, origData: Bytes, data: Bytes, deserialized: (CMPEncryptedDataKeyListEmptyOK, nat)): (ret: Result<(CMPEncryptedDataKeyListEmptyOK, nat), Error>)
    requires deserialized.1 <= |origData|
    requires deserialized.1 + |data| == |origData|
    requires origCount == count + |deserialized.0|
    ensures ret.Success? ==> ret.value.1 <= |origData| && ret.value.1 >= deserialized.1 && (count > 0 ==> GetOneDataKey(data).Success?) && |ret.value.0| == origCount
    decreases count, origCount, origData, data, deserialized
  {
    if count == 0 then
      Success(deserialized)
    else if |deserialized.0| >= 255 then
      Failure(E(""Too Many Data Keys""))
    else
      var edk: (CMPEncryptedDataKey, nat) :- GetOneDataKey(data); assert SerializeOneDataKey(edk.0) == data[..edk.1]; GetDataKeys2(count - 1, origCount, origData, data[edk.1..], (deserialized.0 + [edk.0], deserialized.1 + edk.1))
  }

  lemma MapKeepsCount<Y, Z>(m: map<Path, Y>, f: Path -> Z)
    requires forall a: Path, b: Path {:trigger f(b), f(a)} :: a != b ==> f(a) != f(b)
    requires Functions.Injective(f)
    ensures |m.Keys| == |MyMap(f, m).Keys|
    ensures |m| == |MyMap(f, m)|
    decreases m
  {
    Sets.LemmaMapSize(m.Keys, MyMap(f, m).Keys, f);
  }

  lemma SerializeLegendRoundTrip(x: Legend)
    ensures GetLegend(SerializeLegend(x)).Success?
    ensures ghost var ret: (Legend, nat) := GetLegend(SerializeLegend(x)).value; ret.0 == x && ret.1 == |x| + 2 && ret.1 == |SerializeLegend(x)|
    decreases x
  {
  }

  lemma GetLegendRoundTrip(x: Bytes)
    requires GetLegend(x).Success?
    ensures true && ghost var ret: Bytes := SerializeLegend(GetLegend(x).value.0); true && ret == x[..GetLegend(x).value.1]
    decreases x
  {
  }

  lemma SerializeOneKVPairRoundTrip(key: CMPUtf8Bytes, value: CMPUtf8Bytes)
    ensures GetOneKVPair(SerializeOneKVPair(key, value)).Success?
    decreases key, value
  {
    ghost var data := SerializeOneKVPair(key, value);
    assert 2 <= |data|;
    ghost var keyLen := SeqToUInt16(data[0 .. 2]) as nat;
    assert keyLen + 4 <= |data|;
    assert data[2 .. keyLen + 2] == key;
    assert UTF8.ValidUTF8Seq(data[2 .. keyLen + 2]);
    ghost var valueLen := SeqToUInt16(data[keyLen + 2 .. keyLen + 4]) as nat;
    assert keyLen + valueLen + 4 <= |data|;
    assert data[keyLen + 4 .. keyLen + valueLen + 4] == value;
    assert UTF8.ValidUTF8Seq(data[keyLen + 4 .. keyLen + valueLen + 4]);
  }

  lemma GetOneKVPairRoundTrip(data: Bytes)
    requires GetOneKVPair(data).Success?
    ensures true && ghost var cont: (CMPUtf8Bytes, CMPUtf8Bytes, nat) := GetOneKVPair(data).value; true && SerializeOneKVPair(cont.0, cont.1) == data[..cont.2]
    decreases data
  {
  }

  lemma SerializeOneDataKeyRoundTrip(k: CMPEncryptedDataKey)
    ensures true && ghost var data: Bytes := SerializeOneDataKey(k); GetOneDataKey(data).Success? && GetOneDataKey(data).value.0 == k && GetOneDataKey(data).value.1 == |data|
    decreases k
  {
    ghost var data := SerializeOneDataKey(k);
    assert 2 <= |data|;
    ghost var provIdSize := SeqToUInt16(data[0 .. 2]) as nat;
    assert provIdSize + 2 < |data|;
    ghost var provId := data[2 .. 2 + provIdSize];
    assert provId == k.keyProviderId;
    ghost var part1Size := 2 + provIdSize;
    assert part1Size + 2 <= |data|;
    ghost var provInfoSize := SeqToUInt16(data[part1Size .. part1Size + 2]) as nat;
    assert part1Size + provInfoSize + 2 < |data|;
    ghost var provInfo := data[part1Size + 2 .. part1Size + 2 + provInfoSize];
    assert provInfo == k.keyProviderInfo;
  }

  lemma GetOneDataKeyRoundTrip(data: Bytes)
    requires GetOneDataKey(data).Success?
    ensures true && ghost var cont: (CMPEncryptedDataKey, nat) := GetOneDataKey(data).value; true && SerializeOneDataKey(cont.0) == data[..cont.1]
    decreases data
  {
  }

  lemma GetOneKVPairExt(x: Bytes, y: Bytes)
    requires x <= y
    requires GetOneKVPair(x).Success?
    ensures GetOneKVPair(y).Success? && GetOneKVPair(x).value == GetOneKVPair(y).value
    decreases x, y
  {
    assert 2 <= |y|;
    ghost var keyLen := SeqToUInt16(y[0 .. 2]) as nat;
    assert keyLen + 4 <= |y|;
    ghost var key := y[2 .. keyLen + 2];
    assert x[2 .. keyLen + 2] == y[2 .. keyLen + 2];
    assert UTF8.ValidUTF8Seq(key);
    ghost var valueLen := SeqToUInt16(y[keyLen + 2 .. keyLen + 4]) as nat;
    ghost var kvLen := 2 + keyLen + 2 + valueLen;
    assert kvLen <= |y|;
    ghost var value := y[keyLen + 4 .. kvLen];
    assert keyLen + 4 <= kvLen;
    assert x[keyLen + 4 .. kvLen] == y[keyLen + 4 .. kvLen];
    assert UTF8.ValidUTF8Seq(value);
  }

  import opened Wrappers

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import opened AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes

  import opened StructuredEncryptionUtil

  import CMP = AwsCryptographyMaterialProvidersTypes

  import Prim = AwsCryptographyPrimitivesTypes

  import SortedSets

  import Sets

  import Seq

  import UTF8

  import Paths = StructuredEncryptionPaths

  import Random

  import Functions

  import MaterialProviders

  type Version = x: uint8
    | ValidVersion(x)
    witness 1

  type Flavor = x: uint8
    | ValidFlavor(x)

  type CMPEncryptedDataKeyList = x: seq<CMPEncryptedDataKey>
    | 0 < |x| < UINT8_LIMIT
    witness *

  type Commitment = x: Bytes
    | |x| == COMMITMENT_LEN
    witness *

  type CMPEncryptedDataKey = x: CMP.EncryptedDataKey
    | ValidEncryptedDataKey(x)
    witness *

  type CMPEncryptionContext = x: CMP.EncryptionContext
    | ValidEncryptionContext(x)
    witness *

  type CMPEncryptedDataKeyListEmptyOK = x: seq<CMPEncryptedDataKey>
    | |x| < UINT8_LIMIT

  type LegendByte = x: uint8
    | ValidLegendByte(x)
    witness SIGN_ONLY_LEGEND

  type Legend = x: seq<LegendByte>
    | |x| < UINT16_LIMIT

  type CMPUtf8Bytes = x: CMP.Utf8Bytes
    | |x| < UINT16_LIMIT

  datatype PartialHeader = PartialHeader(nameonly version: Version, nameonly flavor: Flavor, nameonly msgID: MessageID, nameonly legend: Legend, nameonly encContext: CMPEncryptionContext, nameonly dataKeys: CMPEncryptedDataKeyList) {
    function method {:opaque} serialize(): (ret: Bytes)
      ensures PREFIX_LEN <= |ret| && ret == [version] + [flavor] + msgID + SerializeLegend(legend) + SerializeContext(encContext) + SerializeDataKeys(dataKeys)
      decreases this
    {
      var context: Bytes := SerializeContext(encContext);
      var keys: Bytes := SerializeDataKeys(dataKeys);
      var leg: Bytes := SerializeLegend(legend);
      [version] + [flavor] + msgID + leg + context + keys
    }

    function method verifyCommitment(client: Prim.IAwsCryptographicPrimitivesClient, alg: CMP.AlgorithmSuiteInfo, commitKey: Bytes, data: Bytes): (ret: Result<bool, Error>)
      requires ValidSuite(alg)
      requires client.ValidState()
      ensures client.ValidState()
      ensures ret.Success? ==> COMMITMENT_LEN < |data| && var storedCommitment: seq<BoundedInts.uint8> := data[|data| - COMMITMENT_LEN..]; CalculateHeaderCommitment(client, alg, commitKey, data[..|data| - COMMITMENT_LEN]).Success? && var calcCommitment: Bytes := CalculateHeaderCommitment(client, alg, commitKey, data[..|data| - COMMITMENT_LEN]).value; true && ConstantTimeEquals(storedCommitment, calcCommitment)
      decreases this, client, alg, commitKey, data
    {
      :- Need(COMMITMENT_LEN < |data|, E(""Serialized header too short"")); var storedCommitment: seq<BoundedInts.uint8> := data[|data| - COMMITMENT_LEN..]; var calcCommitment: Bytes :- CalculateHeaderCommitment(client, alg, commitKey, data[..|data| - COMMITMENT_LEN]); :- Need(ConstantTimeEquals(storedCommitment, calcCommitment), E(""Key commitment mismatch."")); Success(true)
    }

    method GetAlgorithmSuite(matProv: MaterialProviders.MaterialProvidersClient) returns (ret: Result<CMP.AlgorithmSuiteInfo, Error>)
      ensures ret.Success? ==> ValidSuite(ret.value)
      decreases this, matProv
    {
      var algorithmSuiteR := matProv.GetAlgorithmSuiteInfo([DbeAlgorithmFamily, flavor as uint8]);
      if algorithmSuiteR.Success? {
        :- Need(ValidSuite(algorithmSuiteR.value), E(""Invalid Algorithm Suite""));
        return Success(algorithmSuiteR.value);
      } else {
        return algorithmSuiteR.MapFailure((e: Error) => AwsCryptographyMaterialProviders(e));
      }
    }
  }
}

module {:options ""-functionSyntax:4""} Sets {
  lemma LemmaSubset<T>(x: set<T>, y: set<T>)
    requires forall e: T {:trigger e in y} :: e in x ==> e in y
    ensures x <= y
    decreases x, y
  {
  }

  lemma LemmaSubsetSize<T>(x: set<T>, y: set<T>)
    ensures x < y ==> |x| < |y|
    ensures x <= y ==> |x| <= |y|
    decreases x, y
  {
    if x != {} {
      ghost var e :| e in x;
      LemmaSubsetSize(x - {e}, y - {e});
    }
  }

  lemma LemmaSubsetEquality<T>(x: set<T>, y: set<T>)
    requires x <= y
    requires |x| == |y|
    ensures x == y
    decreases x, y
  {
    if x == {} {
    } else {
      ghost var e :| e in x;
      LemmaSubsetEquality(x - {e}, y - {e});
    }
  }

  lemma LemmaSingletonSize<T>(x: set<T>, e: T)
    requires x == {e}
    ensures |x| == 1
    decreases x
  {
  }

  lemma LemmaSingletonEquality<T>(x: set<T>, a: T, b: T)
    requires |x| == 1
    requires a in x
    requires b in x
    ensures a == b
    decreases x
  {
    if a != b {
      assert {a} < x;
      LemmaSubsetSize({a}, x);
      assert |{a}| < |x|;
      assert |x| > 1;
      assert false;
    }
  }

  predicate IsSingleton<T>(s: set<T>)
    decreases s
  {
    (exists x: T {:trigger x in s} :: 
      x in s) &&
    forall x: T, y: T {:trigger y in s, x in s} | x in s && y in s :: 
      x == y
  }

  lemma LemmaIsSingleton<T>(s: set<T>)
    ensures |s| == 1 <==> IsSingleton(s)
    decreases s
  {
    if |s| == 1 {
      forall x: T, y: T | x in s && y in s
        ensures x == y
      {
        LemmaSingletonEquality(s, x, y);
      }
    }
    if IsSingleton(s) {
      ghost var x :| x in s;
      assert s == {x};
      assert |s| == 1;
    }
  }

  function ExtractFromNonEmptySet<T>(s: set<T>): (x: T)
    requires |s| != 0
    ensures x in s
    decreases s
  {
    ghost var x: T :| x in s;
    x
  }

  function method ExtractFromSingleton<T>(s: set<T>): (x: T)
    requires |s| == 1
    ensures s == {x}
    decreases s
  {
    LemmaIsSingleton(s);
    var x: T :| x in s;
    x
  }

  lemma LemmaMapSize<X(!new), Y>(xs: set<X>, ys: set<Y>, f: X --> Y)
    requires forall x: X {:trigger f.requires(x)} :: f.requires(x)
    requires Injective(f)
    requires forall x: X {:trigger f(x)} :: x in xs <==> f(x) in ys
    requires forall y: Y {:trigger y in ys} :: y in ys ==> exists x: X {:trigger f(x)} {:trigger x in xs} :: x in xs && y == f(x)
    ensures |xs| == |ys|
    decreases xs, ys
  {
    if xs != {} {
      ghost var x :| x in xs;
      ghost var xs' := xs - {x};
      ghost var ys' := ys - {f(x)};
      LemmaMapSize(xs', ys', f);
    }
  }

  function method {:opaque} Map<X(!new), Y>(xs: set<X>, f: X --> Y): (ys: set<Y>)
    requires forall x: X {:trigger f.requires(x)} :: f.requires(x)
    requires Injective(f)
    reads set _x0: X, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj
    ensures forall x: X {:trigger f(x)} :: x in xs <==> f(x) in ys
    ensures |xs| == |ys|
    decreases set _x0: X, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj, xs
  {
    var ys: set<Y> := set x: X {:trigger f(x)} {:trigger x in xs} | x in xs :: f(x);
    LemmaMapSize(xs, ys, f);
    ys
  }

  lemma LemmaFilterSize<X>(xs: set<X>, ys: set<X>, f: X ~> bool)
    requires forall x: X {:trigger f.requires(x)} {:trigger x in xs} :: x in xs ==> f.requires(x)
    requires forall y: X {:trigger f(y)} {:trigger y in xs} :: (y in ys ==> y in xs) && (y in ys ==> f(y))
    ensures |ys| <= |xs|
    decreases xs, ys
  {
    if ys != {} {
      ghost var y :| y in ys;
      ghost var xs' := xs - {y};
      ghost var ys' := ys - {y};
      LemmaFilterSize(xs', ys', f);
    }
  }

  function method {:opaque} Filter<X(!new)>(xs: set<X>, f: X ~> bool): (ys: set<X>)
    requires forall x: X {:trigger f.requires(x)} {:trigger x in xs} :: x in xs ==> f.requires(x)
    reads set x: X, o: object? {:trigger o in f.reads(x)} | x in xs && o in f.reads(x) :: o
    ensures forall y: X {:trigger f(y)} {:trigger y in xs} :: y in ys <==> y in xs && f(y)
    ensures |ys| <= |xs|
    decreases set x: X, o: object? {:trigger o in f.reads(x)} | x in xs && o in f.reads(x) :: o, xs
  {
    var ys: set<X> := set x: X {:trigger f(x)} {:trigger x in xs} | x in xs && f(x);
    LemmaFilterSize(xs, ys, f);
    ys
  }

  lemma LemmaUnionSize<X>(xs: set<X>, ys: set<X>)
    ensures |xs + ys| >= |xs|
    ensures |xs + ys| >= |ys|
    decreases xs, ys
  {
    if ys == {} {
    } else {
      ghost var y :| y in ys;
      if y in xs {
        ghost var xr := xs - {y};
        ghost var yr := ys - {y};
        assert xr + yr == xs + ys - {y};
        LemmaUnionSize(xr, yr);
      } else {
        ghost var yr := ys - {y};
        assert xs + yr == xs + ys - {y};
        LemmaUnionSize(xs, yr);
      }
    }
  }

  function method {:opaque} SetRange(a: int, b: int): (s: set<int>)
    requires a <= b
    ensures forall i: int {:trigger i in s} :: a <= i < b <==> i in s
    ensures |s| == b - a
    decreases b - a
  {
    if a == b then
      {}
    else
      {a} + SetRange(a + 1, b)
  }

  function method {:opaque} SetRangeZeroBound(n: int): (s: set<int>)
    requires n >= 0
    ensures forall i: int {:trigger i in s} :: 0 <= i < n <==> i in s
    ensures |s| == n
    decreases n
  {
    SetRange(0, n)
  }

  lemma LemmaBoundedSetSize(x: set<int>, a: int, b: int)
    requires forall i: int {:trigger i in x} :: (i in x ==> a <= i) && (i in x ==> i < b)
    requires a <= b
    ensures |x| <= b - a
    decreases x, a, b
  {
    ghost var range := SetRange(a, b);
    forall e: int {:trigger e in range} {:trigger e in x} | e in x
      ensures e in range
    {
    }
    assert x <= range;
    LemmaSubsetSize(x, range);
  }

  lemma LemmaGreatestImpliesMaximal<T(!new)>(R: (T, T) -> bool, max: T, s: set<T>)
    requires PreOrdering(R)
    ensures IsGreatest(R, max, s) ==> IsMaximal(R, max, s)
    decreases s
  {
  }

  lemma LemmaLeastImpliesMinimal<T(!new)>(R: (T, T) -> bool, min: T, s: set<T>)
    requires PreOrdering(R)
    ensures IsLeast(R, min, s) ==> IsMinimal(R, min, s)
    decreases s
  {
  }

  lemma LemmaMaximalEquivalentGreatest<T(!new)>(R: (T, T) -> bool, max: T, s: set<T>)
    requires TotalOrdering(R)
    ensures IsGreatest(R, max, s) <==> IsMaximal(R, max, s)
    decreases s
  {
  }

  lemma LemmaMinimalEquivalentLeast<T(!new)>(R: (T, T) -> bool, min: T, s: set<T>)
    requires TotalOrdering(R)
    ensures IsLeast(R, min, s) <==> IsMinimal(R, min, s)
    decreases s
  {
  }

  lemma LemmaLeastIsUnique<T(!new)>(R: (T, T) -> bool, s: set<T>)
    requires PartialOrdering(R)
    ensures forall min: T, min': T {:trigger IsLeast(R, min', s), IsLeast(R, min, s)} | IsLeast(R, min, s) && IsLeast(R, min', s) :: min == min'
    decreases s
  {
  }

  lemma LemmaGreatestIsUnique<T(!new)>(R: (T, T) -> bool, s: set<T>)
    requires PartialOrdering(R)
    ensures forall max: T, max': T {:trigger IsGreatest(R, max', s), IsGreatest(R, max, s)} | IsGreatest(R, max, s) && IsGreatest(R, max', s) :: max == max'
    decreases s
  {
  }

  lemma LemmaMinimalIsUnique<T(!new)>(R: (T, T) -> bool, s: set<T>)
    requires TotalOrdering(R)
    ensures forall min: T, min': T {:trigger IsMinimal(R, min', s), IsMinimal(R, min, s)} | IsMinimal(R, min, s) && IsMinimal(R, min', s) :: min == min'
    decreases s
  {
  }

  lemma LemmaMaximalIsUnique<T(!new)>(R: (T, T) -> bool, s: set<T>)
    requires TotalOrdering(R)
    ensures forall max: T, max': T {:trigger IsMaximal(R, max', s), IsMaximal(R, max, s)} | IsMaximal(R, max, s) && IsMaximal(R, max', s) :: max == max'
    decreases s
  {
  }

  lemma LemmaFindUniqueMinimal<T(!new)>(R: (T, T) -> bool, s: set<T>) returns (min: T)
    requires |s| > 0 && TotalOrdering(R)
    ensures IsMinimal(R, min, s) && forall min': T {:trigger IsMinimal(R, min', s)} | IsMinimal(R, min', s) :: min == min'
    decreases s
  {
    ghost var x :| x in s;
    if s == {x} {
      min := x;
    } else {
      ghost var min' := LemmaFindUniqueMinimal(R, s - {x});
      if
      case R(min', x) =>
        min := min';
      case R(x, min') =>
        min := x;
    }
  }

  lemma LemmaFindUniqueMaximal<T(!new)>(R: (T, T) -> bool, s: set<T>) returns (max: T)
    requires |s| > 0 && TotalOrdering(R)
    ensures IsMaximal(R, max, s) && forall max': T {:trigger IsMaximal(R, max', s)} | IsMaximal(R, max', s) :: max == max'
    decreases s
  {
    ghost var x :| x in s;
    if s == {x} {
      max := x;
    } else {
      ghost var max' := LemmaFindUniqueMaximal(R, s - {x});
      if
      case R(max', x) =>
        max := x;
      case R(x, max') =>
        max := max';
    }
  }

  import opened Functions

  import opened Relations
}

module StructuredEncryptionPaths {
  predicate method ValidTerminalSelector(s: seq<Selector>)
    decreases s
  {
    0 < |s| < UINT64_LIMIT &&
    s[0].Map?
  }

  function method StringToUniPath(x: string): (ret: Path)
    ensures |ret| == 1
    decreases x
  {
    [member(StructureSegment(key := x))]
  }

  lemma StringToUniPathUnique()
    ensures forall x: string, y: string {:trigger StringToUniPath(y), StringToUniPath(x)} :: x != y ==> StringToUniPath(x) != StringToUniPath(y)
  {
  }

  function method UniPathToString(x: Path): Result<string, Error>
    requires |x| == 1
    decreases x
  {
    Success(x[0].member.key)
  }

  predicate method ValidPath(path: Path)
    decreases path
  {
    |path| < UINT64_LIMIT &&
    forall x: PathSegment {:trigger x.member} {:trigger x in path} | x in path :: 
      ValidString(x.member.key)
  }

  function method CanonPath(table: GoodString, path: Path): (ret: CanonicalPath)
    requires ValidPath(path)
    ensures ret == UTF8.Encode(table).value + UInt64ToSeq(|path| as uint64) + MakeCanonicalPath(path)
    decreases table, path
  {
    var tableName: ValidUTF8Bytes := UTF8.Encode(table).value;
    var depth: seq<uint8> := UInt64ToSeq(|path| as uint64);
    var path: CanonicalPath := MakeCanonicalPath(path);
    tableName + depth + path
  }

  function method TermLocMap?(attr: string): Result<Path, Error>
    decreases attr
  {
    :- Need(ValidString(attr), E(""invalid string : "" + attr)); Success([member(StructureSegment(key := attr))])
  }

  function method TermLocMap(attr: GoodString): Path
    decreases attr
  {
    [member(StructureSegment(key := attr))]
  }

  function method {:opaque} SimpleCanon(table: GoodString, attr: GoodString): CanonicalPath
    decreases table, attr
  {
    CanonPath(table, TermLocMap(attr))
  }

  const ARRAY_TAG: uint8 := '#' as uint8
  const MAP_TAG: uint8 := '$' as uint8

  function method CanonicalPart(s: PathSegment): (ret: Bytes)
    requires ValidString(s.member.key)
    ensures ret == [MAP_TAG] + UInt64ToSeq(|s.member.key| as uint64) + UTF8.Encode(s.member.key).value
    ensures |ret| == 9 + |UTF8.Encode(s.member.key).value|
    decreases s
  {
    [MAP_TAG] + UInt64ToSeq(|s.member.key| as uint64) + UTF8.Encode(s.member.key).value
  }

  function method {:tailrecursion} MakeCanonicalPath(path: Path): (ret: CanonicalPath)
    requires ValidPath(path)
    ensures |path| == 0 ==> ret == []
    ensures |path| == 1 ==> ret == CanonicalPart(path[0])
    decreases path
  {
    if |path| == 0 then
      []
    else
      CanonicalPart(path[0]) + MakeCanonicalPath(path[1..])
  }

  function method PathToString(path: Path): string
    decreases path
  {
    if |path| == 0 then
      """"
    else if |path| == 1 then
      path[0].member.key
    else
      path[0].member.key + ""."" + PathToString(path[1..])
  }

  lemma CanonPathUnique(table: GoodString)
    ensures forall x: Path, y: Path {:trigger CanonPath(table, y), CanonPath(table, x)} {:trigger CanonPath(table, y), ValidPath(x)} {:trigger CanonPath(table, x), ValidPath(y)} {:trigger ValidPath(y), ValidPath(x)} | ValidPath(x) && ValidPath(y) :: x != y ==> CanonPath(table, x) != CanonPath(table, y)
    decreases table
  {
    forall x: Path, y: Path | ValidPath(x) && ValidPath(y)
      ensures x != y ==> CanonPath(table, x) != CanonPath(table, y)
    {
      if x != y {
        CanonPathUnique2(table, x, y);
      }
    }
  }

  lemma CanonPathUnique2(table: GoodString, x: Path, y: Path)
    requires x != y
    requires ValidPath(x) && ValidPath(y)
    ensures CanonPath(table, x) != CanonPath(table, y)
    decreases table, x, y
  {
    PathUnique2(x, y);
    ghost var cpX := CanonPath(table, x);
    ghost var cpY := CanonPath(table, y);
    ghost var tableName := UTF8.Encode(table).value;
    assert tableName < cpX;
    assert tableName < cpY;
    if |x| == |y| {
      ghost var prefix := tableName + UInt64ToSeq(|x| as uint64);
      assert cpX == prefix + MakeCanonicalPath(x);
      assert cpY == prefix + MakeCanonicalPath(y);
      PathUnique2(x, y);
      OnePlusOne(prefix, MakeCanonicalPath(x), MakeCanonicalPath(y));
      assert cpX != cpY;
    } else {
      assert UInt64ToSeq(|x| as uint64) != UInt64ToSeq(|y| as uint64);
      assert tableName + UInt64ToSeq(|x| as uint64) <= cpX;
      assert tableName + UInt64ToSeq(|y| as uint64) <= cpY;
      OnePlusOne(tableName, UInt64ToSeq(|x| as uint64), UInt64ToSeq(|y| as uint64));
      assert tableName + UInt64ToSeq(|x| as uint64) != tableName + UInt64ToSeq(|y| as uint64);
      assert cpX != cpY;
    }
  }

  lemma PathUnique()
    ensures forall x: Path, y: Path {:trigger MakeCanonicalPath(y), MakeCanonicalPath(x)} {:trigger MakeCanonicalPath(y), ValidPath(x)} {:trigger MakeCanonicalPath(x), ValidPath(y)} {:trigger ValidPath(y), ValidPath(x)} | ValidPath(x) && ValidPath(y) :: x != y ==> MakeCanonicalPath(x) != MakeCanonicalPath(y)
  {
    forall x: Path, y: Path | ValidPath(x) && ValidPath(y)
      ensures x != y ==> MakeCanonicalPath(x) != MakeCanonicalPath(y)
    {
      if x != y {
        PathUnique2(x, y);
      }
    }
  }

  lemma /*{:_inductionTrigger MakeCanonicalPath(y), MakeCanonicalPath(x)}*/ /*{:_inductionTrigger MakeCanonicalPath(y), ValidPath(x)}*/ /*{:_inductionTrigger MakeCanonicalPath(x), ValidPath(y)}*/ /*{:_inductionTrigger ValidPath(y), ValidPath(x)}*/ /*{:_induction x, y}*/ PathUnique2(x: Path, y: Path)
    requires ValidPath(x) && ValidPath(y)
    requires x != y
    ensures MakeCanonicalPath(x) != MakeCanonicalPath(y)
    decreases x, y
  {
    if |x| == 0 || |y| == 0 {
    } else if x[0] != y[0] {
      CanonicalPartMapUnique(x[0], y[0]);
      assert CanonicalPart(x[0]) != CanonicalPart(y[0]);
      SelectorNeverPrefix(x[0], y[0]);
      assert CanonicalPart(x[0]) <= MakeCanonicalPath(x);
      assert CanonicalPart(y[0]) <= MakeCanonicalPath(y);
      assert MakeCanonicalPath(x) == CanonicalPart(x[0]) + MakeCanonicalPath(x[1..]);
      assert MakeCanonicalPath(y) == CanonicalPart(y[0]) + MakeCanonicalPath(y[1..]);
      assert MakeCanonicalPath(x) != MakeCanonicalPath(y);
    } else {
      assert x[1..] != y[1..];
      PathUnique2(x[1..], y[1..]);
      assert CanonicalPart(x[0]) == CanonicalPart(y[0]);
      assert MakeCanonicalPath(x[1..]) != MakeCanonicalPath(y[1..]);
      OnePlusOne(CanonicalPart(x[0]), MakeCanonicalPath(x[1..]), MakeCanonicalPath(y[1..]));
      assert CanonicalPart(x[0]) + MakeCanonicalPath(x[1..]) != CanonicalPart(x[0]) + MakeCanonicalPath(y[1..]);
      assert CanonicalPart(x[0]) + MakeCanonicalPath(x[1..]) != CanonicalPart(y[0]) + MakeCanonicalPath(y[1..]);
      assert MakeCanonicalPath(x) != MakeCanonicalPath(y);
    }
  }

  lemma {:axiom} Utf8EncodeUnique(x: string, y: string)
    requires UTF8.Encode(x).Success?
    requires UTF8.Encode(y).Success?
    ensures !(x <= y) ==> !(UTF8.Encode(x).value <= UTF8.Encode(y).value)
    decreases x, y

  lemma SelectorNeverPrefixMap(x: PathSegment, y: PathSegment)
    requires x != y
    requires ValidString(x.member.key) && ValidString(y.member.key)
    ensures !(CanonicalPart(x) <= CanonicalPart(y))
    ensures !(CanonicalPart(y) <= CanonicalPart(x))
    decreases x, y
  {
    if |x.member.key| != |y.member.key| {
      assert CanonicalPart(x)[1 .. 9] != CanonicalPart(y)[1 .. 9];
    } else {
      assert |x.member.key| == |y.member.key|;
      assert x.member.key != y.member.key;
      assert !(x.member.key <= y.member.key);
      assert !(y.member.key <= x.member.key);
      Utf8EncodeUnique(x.member.key, y.member.key);
      Utf8EncodeUnique(y.member.key, x.member.key);
      assert !(UTF8.Encode(x.member.key).value <= UTF8.Encode(y.member.key).value);
      assert !(UTF8.Encode(y.member.key).value <= UTF8.Encode(x.member.key).value);
      assert CanonicalPart(x) == [MAP_TAG] + UInt64ToSeq(|x.member.key| as uint64) + UTF8.Encode(x.member.key).value;
      assert CanonicalPart(y) == [MAP_TAG] + UInt64ToSeq(|y.member.key| as uint64) + UTF8.Encode(y.member.key).value;
      assert CanonicalPart(x)[0 .. 9] == CanonicalPart(y)[0 .. 9];
    }
  }

  lemma SelectorNeverPrefix(x: PathSegment, y: PathSegment)
    requires x != y
    requires ValidString(x.member.key) && ValidString(y.member.key)
    ensures !(CanonicalPart(x) <= CanonicalPart(y))
    ensures !(CanonicalPart(y) <= CanonicalPart(x))
    decreases x, y
  {
    SelectorNeverPrefixMap(x, y);
  }

  lemma CanonicalPartMapUnique(x: PathSegment, y: PathSegment)
    requires x != y
    requires ValidString(x.member.key) && ValidString(y.member.key)
    ensures CanonicalPart(x) != CanonicalPart(y)
    decreases x, y
  {
    SelectorNeverPrefix(x, y);
  }

  lemma /*{:_inductionTrigger src[0]}*/ /*{:_inductionTrigger MakeCanonicalPath(src)}*/ /*{:_inductionTrigger ValidPath(src)}*/ /*{:_inductionTrigger |src|}*/ /*{:_induction src}*/ OnePart(src: Path)
    requires |src| == 1
    requires ValidPath(src)
    ensures MakeCanonicalPath(src) == CanonicalPart(src[0])
    decreases src
  {
  }

  lemma SubstrNE<T>(x: seq<T>, y: seq<T>, len: nat)
    requires len <= |x|
    requires len <= |y|
    requires x[len..] != y[len..]
    ensures x != y
    decreases x, y, len
  {
  }

  lemma OnePlusOne<T>(x: seq<T>, y: seq<T>, z: seq<T>)
    requires y != z
    ensures x + y != x + z
    decreases x, y, z
  {
    ghost var newY := x + y;
    ghost var newZ := x + z;
    SubstrNE(newY, newZ, |x|);
  }

  lemma SimpleCanonUnique2(table: GoodString, x: GoodString, y: GoodString)
    requires x != y
    ensures SimpleCanon(table, x) != SimpleCanon(table, y)
    decreases table, x, y
  {
    reveal SimpleCanon();
    CanonPathUnique(table);
  }

  lemma SimpleCanonUnique(table: GoodString)
    ensures forall x: GoodString, y: GoodString {:trigger SimpleCanon(table, y), SimpleCanon(table, x)} :: x != y ==> SimpleCanon(table, x) != SimpleCanon(table, y)
    decreases table
  {
    reveal SimpleCanon();
    forall x: GoodString, y: GoodString | true
      ensures x != y ==> SimpleCanon(table, x) != SimpleCanon(table, y)
    {
      if x != y {
        SimpleCanonUnique2(table, x, y);
      }
    }
  }

  import opened Wrappers

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import opened StructuredEncryptionUtil

  import opened AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes

  import opened DafnyLibraries

  datatype Selector = List(pos: uint64) | Map(key: GoodString)

  type SelectorList = x: seq<Selector>
    | |x| < UINT64_LIMIT

  type TerminalSelector = x: seq<Selector>
    | ValidTerminalSelector(x)
    witness *
}

module StructuredEncryptionCrypt {
  function method FieldKey(HKDFOutput: Bytes, offset: uint32): (ret: Result<Bytes, Error>)
    requires |HKDFOutput| == KeySize
    ensures ret.Success? ==> offset as nat * 3 < UINT32_LIMIT && |ret.value| == KeySize + NonceSize && |ret.value| == 44 && AesKdfCtr.Stream(FieldKeyNonce(offset * 3), HKDFOutput, (KeySize + NonceSize) as uint32).Success? && ret.value == AesKdfCtr.Stream(FieldKeyNonce(offset * 3), HKDFOutput, (KeySize + NonceSize) as uint32).value
    decreases HKDFOutput, offset
  {
    :- Need(offset as nat * 3 < UINT32_LIMIT, E(""Too many encrypted fields."")); var keyR: Result<seq<uint8>, Types.OpaqueError> := AesKdfCtr.Stream(FieldKeyNonce(offset * 3), HKDFOutput, (KeySize + NonceSize) as uint32); keyR.MapFailure((e: Types.OpaqueError) => AwsCryptographyPrimitives(e))
  }

  function method FieldKeyNonce(offset: uint32): (ret: Bytes)
    ensures |ret| == 16
    ensures ret == UTF8.EncodeAscii(""AwsDbeField"") + [(KeySize + NonceSize) as uint8] + UInt32ToSeq(offset)
    decreases offset
  {
    UTF8.EncodeAscii(""AwsDbeField"") + [(KeySize + NonceSize) as uint8] + UInt32ToSeq(offset)
  }

  const LABEL_COMMITMENT_KEY := UTF8.EncodeAscii(""AWS_DBE_COMMIT_KEY"")
  const LABEL_ENCRYPTION_KEY := UTF8.EncodeAscii(""AWS_DBE_DERIVE_KEY"")

  method GetCommitKey(client: Primitives.AtomicPrimitivesClient, alg: CMP.AlgorithmSuiteInfo, key: Key, msgID: MessageID)
      returns (ret: Result<Key, Error>)
    requires ValidSuite(alg)
    requires client.ValidState()
    modifies client.Modifies
    ensures ret.Success? ==> |ret.value| == AlgorithmSuites.GetEncryptKeyLength(alg) as int && var history: seq<DafnyCallEvent<HkdfInput, Result<seq<uint8>, Error>>> := client.History.Hkdf; 0 < |history| && var hkdfInput: HkdfInput := Seq.Last(history).input; hkdfInput.digestAlgorithm == alg.commitment.HKDF.hmac && hkdfInput.info == LABEL_COMMITMENT_KEY + msgID && hkdfInput.ikm == key && hkdfInput.salt == None
    ensures client.ValidState()
    decreases client, alg, key, msgID
  {
    var commitKey := client.Hkdf(Prim.HkdfInput(digestAlgorithm := alg.commitment.HKDF.hmac, salt := None, ikm := key, info := LABEL_COMMITMENT_KEY + msgID, expectedLength := alg.commitment.HKDF.outputKeyLength));
    return commitKey.MapFailure((e: Error) => AwsCryptographyPrimitives(e));
  }

  lemma EncryptDataUpdated(origData: CryptoList, data: CanonCryptoList, finalData: CanonCryptoList)
    requires forall k: CryptoItem {:trigger CryptoExistsInCanonCrypto(k, data)} {:trigger k in origData} | k in origData :: CryptoExistsInCanonCrypto(k, data)
    requires |finalData| == |origData| == |data|
    requires forall i: int {:trigger finalData[i]} {:trigger data[i]} | 0 <= i < |origData| :: Updated(data[i], finalData[i], DoEncrypt)
    ensures forall k: CryptoItem {:trigger CryptoUpdatedCanonCrypto(k, finalData)} {:trigger k in origData} | k in origData :: CryptoUpdatedCanonCrypto(k, finalData)
    decreases origData, data, finalData
  {
    reveal CryptoExistsInCanonCrypto();
    reveal CryptoUpdatedCanonCrypto();
    assert forall oldVal: CryptoItem {:trigger oldVal in origData} | oldVal in origData :: exists i: int {:trigger finalData[i]} :: 0 <= i < |finalData| && Updated5(oldVal, finalData[i], DoEncrypt);
    assert forall oldVal: CryptoItem {:trigger oldVal in origData} | oldVal in origData :: exists x: CanonCryptoItem {:trigger Updated5(oldVal, x, DoEncrypt)} {:trigger x in finalData} :: x in finalData && Updated5(oldVal, x, DoEncrypt);
  }

  lemma EncryptFinalUpdated(origData: CryptoList, data: CanonCryptoList, finalData: CanonCryptoList)
    requires forall k: CanonCryptoItem {:trigger CanonCryptoExistsInCrypto(k, origData)} {:trigger k in data} | k in data :: CanonCryptoExistsInCrypto(k, origData)
    requires |finalData| == |origData| == |data|
    requires forall i: int {:trigger finalData[i]} {:trigger data[i]} | 0 <= i < |origData| :: Updated(data[i], finalData[i], DoEncrypt)
    ensures forall k: CanonCryptoItem {:trigger CanonCryptoUpdatedCrypto(k, origData)} {:trigger k in finalData} | k in finalData :: CanonCryptoUpdatedCrypto(k, origData)
    decreases origData, data, finalData
  {
    reveal CanonCryptoExistsInCrypto();
    reveal CanonCryptoUpdatedCrypto();
    assert forall val: CanonCryptoItem {:trigger val.action} {:trigger val.data} {:trigger val.origKey} {:trigger val in data} | val in data :: exists x: CryptoItem {:trigger x.action} {:trigger x.data} {:trigger x.key} {:trigger x in origData} :: x in origData && x.key == val.origKey && x.data == val.data && x.action == val.action;
    assert forall newVal: CanonCryptoItem {:trigger newVal in finalData} | newVal in finalData :: exists x: CryptoItem {:trigger Updated5(x, newVal, DoEncrypt)} {:trigger x in origData} :: x in origData && Updated5(x, newVal, DoEncrypt);
  }

  lemma EncryptMaintains(tableName: GoodString, origData: CryptoList, data: CanonCryptoList, finalData: CanonCryptoList)
    requires CanonCryptoMatchesCryptoList(tableName, origData, data)
    requires |finalData| == |data|
    requires forall i: int {:trigger finalData[i]} {:trigger data[i]} | 0 <= i < |data| :: Updated(data[i], finalData[i], DoEncrypt)
    ensures CanonCryptoUpdatedCryptoList(tableName, origData, finalData)
    decreases tableName, origData, data, finalData
  {
    reveal CanonCryptoMatchesCryptoList();
    reveal CanonCryptoUpdatedCryptoList();
    assert forall k: CryptoItem {:trigger CryptoUpdatedCanonCrypto(k, finalData)} {:trigger k in origData} | k in origData :: CryptoUpdatedCanonCrypto(k, finalData) by {
      EncryptDataUpdated(origData, data, finalData);
    }
    assert forall k: CanonCryptoItem {:trigger CanonCryptoUpdatedCrypto(k, origData)} {:trigger k in finalData} | k in finalData :: CanonCryptoUpdatedCrypto(k, origData) by {
      EncryptFinalUpdated(origData, data, finalData);
    }
  }

  method Encrypt(client: Primitives.AtomicPrimitivesClient, alg: CMP.AlgorithmSuiteInfo, key: Key, head: Header.PartialHeader, data: CanonCryptoList, ghost tableName: GoodString, ghost origData: CryptoList)
      returns (ret: Result<CanonCryptoList, Error>)
    requires ValidSuite(alg)
    requires IsCryptoSorted(data)
    requires CanonCryptoMatchesCryptoList(tableName, origData, data)
    requires client.ValidState()
    modifies client.Modifies
    ensures client.ValidState()
    ensures ret.Success? ==> |ret.value| == |data| && (forall i: int {:trigger ret.value[i]} {:trigger data[i]} | 0 <= i < |data| :: Updated(data[i], ret.value[i], DoEncrypt)) && CanonCryptoListHasNoDuplicates(ret.value) && IsCryptoSorted(ret.value) && CanonCryptoUpdatedCryptoList(tableName, origData, ret.value)
    decreases client, alg, key, head, data, tableName, origData
  {
    reveal CanonCryptoMatchesCryptoList();
    var result :- Crypt(DoEncrypt, client, alg, key, head, data);
    assert CanonCryptoUpdatedCryptoList(tableName, origData, result) by {
      EncryptMaintains(tableName, origData, data, result);
    }
    return Success(result);
  }

  lemma DecryptDataUpdated(origData: AuthList, data: CanonCryptoList, finalData: CanonCryptoList)
    requires forall k: AuthItem {:trigger AuthExistsInCanonCrypto(k, data)} {:trigger k in origData} | k in origData :: AuthExistsInCanonCrypto(k, data)
    requires |finalData| == |origData| == |data|
    requires forall i: int {:trigger finalData[i]} {:trigger data[i]} | 0 <= i < |origData| :: Updated(data[i], finalData[i], DoDecrypt)
    ensures forall k: AuthItem {:trigger AuthUpdatedCanonCrypto(k, finalData)} {:trigger k in origData} | k in origData :: AuthUpdatedCanonCrypto(k, finalData)
    decreases origData, data, finalData
  {
    reveal AuthExistsInCanonCrypto();
    reveal AuthUpdatedCanonCrypto();
    assert forall oldVal: AuthItem {:trigger oldVal in origData} | oldVal in origData :: exists i: int {:trigger finalData[i]} :: 0 <= i < |finalData| && Updated2(oldVal, finalData[i], DoDecrypt);
    assert forall oldVal: AuthItem {:trigger oldVal in origData} | oldVal in origData :: exists x: CanonCryptoItem {:trigger Updated2(oldVal, x, DoDecrypt)} {:trigger x in finalData} :: x in finalData && Updated2(oldVal, x, DoDecrypt);
  }

  lemma DecryptFinalUpdated(origData: AuthList, data: CanonCryptoList, finalData: CanonCryptoList)
    requires forall k: CanonCryptoItem {:trigger CanonCryptoExistsInAuth(k, origData)} {:trigger k in data} | k in data :: CanonCryptoExistsInAuth(k, origData)
    requires |finalData| == |origData| == |data|
    requires forall i: int {:trigger finalData[i]} {:trigger data[i]} | 0 <= i < |origData| :: Updated(data[i], finalData[i], DoDecrypt)
    ensures forall k: CanonCryptoItem {:trigger CanonCryptoUpdatedAuth(k, origData)} {:trigger k in finalData} | k in finalData :: CanonCryptoUpdatedAuth(k, origData)
    decreases origData, data, finalData
  {
    reveal CanonCryptoExistsInAuth();
    reveal CanonCryptoUpdatedAuth();
    assert forall val: CanonCryptoItem {:trigger val.data} {:trigger val.origKey} {:trigger val in data} | val in data :: exists x: AuthItem {:trigger x.data} {:trigger x.key} {:trigger x in origData} :: x in origData && x.key == val.origKey && x.data == val.data;
    assert forall newVal: CanonCryptoItem {:trigger newVal in finalData} | newVal in finalData :: exists x: AuthItem {:trigger Updated2(x, newVal, DoDecrypt)} {:trigger x in origData} :: x in origData && Updated2(x, newVal, DoDecrypt);
  }

  lemma DecryptMaintains(tableName: GoodString, origData: AuthList, data: CanonCryptoList, finalData: CanonCryptoList)
    requires CanonCryptoMatchesAuthList(tableName, origData, data)
    requires |finalData| == |data|
    requires forall i: int {:trigger finalData[i]} {:trigger data[i]} | 0 <= i < |data| :: Updated(data[i], finalData[i], DoDecrypt)
    ensures CanonCryptoUpdatedAuthList(tableName, origData, finalData)
    decreases tableName, origData, data, finalData
  {
    reveal CanonCryptoMatchesAuthList();
    reveal CanonCryptoUpdatedAuthList();
    assert forall k: AuthItem {:trigger AuthUpdatedCanonCrypto(k, finalData)} {:trigger k in origData} | k in origData :: AuthUpdatedCanonCrypto(k, finalData) by {
      DecryptDataUpdated(origData, data, finalData);
    }
    assert forall k: CanonCryptoItem {:trigger CanonCryptoUpdatedAuth(k, origData)} {:trigger k in finalData} | k in finalData :: CanonCryptoUpdatedAuth(k, origData) by {
      DecryptFinalUpdated(origData, data, finalData);
    }
  }

  method Decrypt(client: Primitives.AtomicPrimitivesClient, alg: CMP.AlgorithmSuiteInfo, key: Key, head: Header.PartialHeader, data: CanonCryptoList, ghost tableName: GoodString, ghost origData: AuthList)
      returns (ret: Result<CanonCryptoList, Error>)
    requires ValidSuite(alg)
    requires IsCryptoSorted(data)
    requires CanonCryptoMatchesAuthList(tableName, origData, data)
    requires client.ValidState()
    modifies client.Modifies
    ensures client.ValidState()
    ensures ret.Success? ==> |ret.value| == |data| && (forall i: int {:trigger ret.value[i]} {:trigger data[i]} | 0 <= i < |data| :: Updated(data[i], ret.value[i], DoDecrypt)) && IsCryptoSorted(ret.value) && CanonCryptoUpdatedAuthList(tableName, origData, ret.value)
    decreases client, alg, key, head, data, tableName, origData
  {
    reveal CanonCryptoMatchesAuthList();
    var result :- Crypt(DoDecrypt, client, alg, key, head, data);
    assert CanonCryptoUpdatedAuthList(tableName, origData, result) by {
      DecryptMaintains(tableName, origData, data, result);
    }
    return Success(result);
  }

  lemma MaintainSorted(data: CanonCryptoList, result: CanonCryptoList, mode: EncryptionSelector)
    requires IsCryptoSorted(data)
    requires |result| == |data|
    requires forall i: int {:trigger result[i]} {:trigger data[i]} | 0 <= i < |data| :: Updated(data[i], result[i], mode)
    ensures IsCryptoSorted(result)
    decreases data, result, mode
  {
    reveal IsCryptoSorted();
    assert forall i: int {:trigger result[i]} {:trigger data[i]} | 0 <= i < |data| :: data[i].key == result[i].key;
    SortCanon.SortedIsSorted(data, result);
  }

  method Crypt(mode: EncryptionSelector, client: Primitives.AtomicPrimitivesClient, alg: CMP.AlgorithmSuiteInfo, key: Key, head: Header.PartialHeader, data: CanonCryptoList)
      returns (ret: Result<CanonCryptoList, Error>)
    requires ValidSuite(alg)
    requires CanonCryptoListHasNoDuplicates(data)
    requires IsCryptoSorted(data)
    requires client.ValidState()
    modifies client.Modifies
    ensures ret.Success? ==> true && var history: seq<DafnyCallEvent<HkdfInput, Result<seq<uint8>, Error>>> := client.History.Hkdf; 0 < |history| && var hkdfInput: HkdfInput := Seq.Last(history).input; hkdfInput.digestAlgorithm == alg.kdf.HKDF.hmac && hkdfInput.info == LABEL_ENCRYPTION_KEY + head.msgID && hkdfInput.salt == None && hkdfInput.ikm == key
    ensures client.ValidState()
    ensures ret.Success? ==> |ret.value| == |data| && (forall i: int {:trigger ret.value[i]} {:trigger data[i]} | 0 <= i < |data| :: Updated(data[i], ret.value[i], mode)) && CanonCryptoListHasNoDuplicates(ret.value) && IsCryptoSorted(ret.value)
    decreases mode, client, alg, key, head, data
  {
    var fieldRootKeyR := client.Hkdf(Prim.HkdfInput(digestAlgorithm := alg.kdf.HKDF.hmac, salt := None, ikm := key, info := LABEL_ENCRYPTION_KEY + head.msgID, expectedLength := alg.kdf.HKDF.outputKeyLength));
    var fieldRootKey :- fieldRootKeyR.MapFailure((e: Error) => AwsCryptographyPrimitives(e));
    assert |fieldRootKey| == AlgorithmSuites.GetEncryptKeyLength(alg) as int;
    var result :- CryptList(mode, client, alg, fieldRootKey, data);
    assert IsCryptoSorted(result) by {
      MaintainSorted(data, result, mode);
    }
    return Success(result);
  }

  method CryptList(mode: EncryptionSelector, client: Primitives.AtomicPrimitivesClient, alg: CMP.AlgorithmSuiteInfo, fieldRootKey: Key, data: CanonCryptoList)
      returns (ret: Result<CanonCryptoList, Error>)
    requires client.ValidState()
    modifies client.Modifies - {client.History}, client.History`AESEncrypt, client.History`AESDecrypt
    ensures client.ValidState()
    ensures ret.Success? ==> |ret.value| == |data| && forall i: int {:trigger ret.value[i]} {:trigger data[i]} | 0 <= i < |data| :: Updated(data[i], ret.value[i], mode)
    decreases mode, client, alg, fieldRootKey, data
  {
    var result: CanonCryptoList := [];
    var pos: uint32 := 0;
    :- Need(|data| < UINT32_LIMIT, E(""Too many fields.""));
    for i: int := 0 to |data|
      invariant pos <= i as uint32
      invariant |result| == i
      invariant forall x: int {:trigger result[x]} {:trigger data[x]} | 0 <= x < |result| :: Updated(data[x], result[x], mode)
    {
      if data[i].action == ENCRYPT_AND_SIGN {
        var newTerminal;
        if mode == DoEncrypt {
          newTerminal :- EncryptTerminal(client, alg, fieldRootKey, pos, data[i].key, data[i].data);
          assert newTerminal.typeId == BYTES_TYPE_ID;
        } else {
          newTerminal :- DecryptTerminal(client, alg, fieldRootKey, pos, data[i].key, data[i].data);
        }
        pos := pos + 1;
        var newItem := data[i].(data := newTerminal);
        result := result + [newItem];
        assert Updated(data[i], result[i], mode);
      } else {
        result := result + [data[i]];
        assert Updated(data[i], result[i], mode);
      }
      assert Updated(data[i], result[i], mode);
    }
    return Success(result);
  }

  method EncryptTerminal(client: Primitives.AtomicPrimitivesClient, alg: CMP.AlgorithmSuiteInfo, fieldRootKey: Key, offset: uint32, path: CanonicalPath, data: StructuredDataTerminal)
      returns (ret: Result<StructuredDataTerminal, Error>)
    requires client.ValidState()
    modifies client.Modifies - {client.History}, client.History`AESEncrypt, client.History`AESDecrypt
    ensures ret.Success? ==> ret.value != data
    ensures ret.Success? ==> ret.value.typeId == BYTES_TYPE_ID && |ret.value.value| >= 2 && ret.value.value[..2] == data.typeId && var history: seq<DafnyCallEvent<AESEncryptInput, Result<AESEncryptOutput, Error>>> := client.History.AESEncrypt; 0 < |history| && var encryptInput: AESEncryptInput := Seq.Last(history).input; encryptInput.encAlg == alg.encrypt.AES_GCM && FieldKey(fieldRootKey, offset).Success? && var fieldKey: Bytes := FieldKey(fieldRootKey, offset).value; KeySize == 32 && encryptInput.key == fieldKey[0 .. KeySize] && NonceSize == 12 && |fieldKey| - KeySize == 12 && encryptInput.iv == fieldKey[KeySize..]
    ensures client.ValidState()
    decreases client, alg, fieldRootKey, offset, path, data
  {
    var fieldKey :- FieldKey(fieldRootKey, offset);
    var cipherkey: Key := fieldKey[0 .. KeySize];
    var nonce: Nonce := fieldKey[KeySize..];
    var value := data.value;
    var encInput := Prim.AESEncryptInput(encAlg := alg.encrypt.AES_GCM, iv := nonce, key := cipherkey, msg := value, aad := path);
    var encOutR := client.AESEncrypt(encInput);
    var encOut :- encOutR.MapFailure((e: Error) => AwsCryptographyPrimitives(e));
    :- Need(|encOut.authTag| == AuthTagSize, E(""Auth Tag Wrong Size.""));
    return Success(ValueToData(data.typeId + encOut.cipherText + encOut.authTag, BYTES_TYPE_ID));
  }

  method DecryptTerminal(client: Primitives.AtomicPrimitivesClient, alg: CMP.AlgorithmSuiteInfo, fieldRootKey: Key, offset: uint32, path: CanonicalPath, data: StructuredDataTerminal)
      returns (ret: Result<StructuredDataTerminal, Error>)
    requires client.ValidState()
    modifies client.Modifies - {client.History}, client.History`AESEncrypt, client.History`AESDecrypt
    ensures ret.Success? ==> |data.value| >= AuthTagSize + 2 && ret.value.typeId == data.value[0 .. TYPEID_LEN] && ret.value != data
    ensures client.ValidState()
    decreases client, alg, fieldRootKey, offset, path, data
  {
    var dataKey :- FieldKey(fieldRootKey, offset);
    var encryptionKey: Key := dataKey[0 .. KeySize];
    var nonce: Nonce := dataKey[KeySize..];
    var value := data.value;
    :- Need(AuthTagSize + 2 <= |value|, E(""cipherTxt too short.""));
    var decInput := Prim.AESDecryptInput(encAlg := alg.encrypt.AES_GCM, iv := nonce, key := encryptionKey, cipherTxt := value[TYPEID_LEN .. |value| - AuthTagSize], aad := path, authTag := value[|value| - AuthTagSize..]);
    var decOutR := client.AESDecrypt(decInput);
    var decOut :- decOutR.MapFailure((e: Error) => AwsCryptographyPrimitives(e));
    return Success(ValueToData(decOut, value[..TYPEID_LEN]));
  }

  import opened Wrappers

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import opened AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes

  import opened StructuredEncryptionUtil

  import opened DafnyLibraries

  import CMP = AwsCryptographyMaterialProvidersTypes

  import Prim = AwsCryptographyPrimitivesTypes

  import Primitives = AtomicPrimitives

  import UTF8

  import Header = StructuredEncryptionHeader

  import HKDF

  import AesKdfCtr

  import Seq

  import SortCanon

  import opened Canonize
}

module StructuredEncryptionFooter {
  const RecipientTagSize := 48
  const SignatureSize := 103

  function method GetCanonicalType(value: StructuredDataTerminal, isEncrypted: bool): Result<Bytes, Error>
    decreases value, isEncrypted
  {
    if isEncrypted then
      :- Need(2 <= |value.value| < UINT64_LIMIT, E(""Bad length."")); Success(UInt64ToSeq((|value.value| - 2) as uint64) + UTF8.EncodeAscii(""ENCRYPTED""))
    else
      :- Need(|value.value| < UINT64_LIMIT, E(""Bad length."")); Success(UInt64ToSeq(|value.value| as uint64) + UTF8.EncodeAscii(""PLAINTEXT"") + value.typeId)
  }

  function method GetCanonicalEncryptedField(fieldName: CanonicalPath, value: StructuredDataTerminal): (ret: Result<Bytes, Error>)
    ensures ret.Success? ==> 2 <= |value.value| < UINT64_LIMIT && ret.value == fieldName + UInt64ToSeq((|value.value| - 2) as uint64) + UTF8.EncodeAscii(""ENCRYPTED"") + value.value
    decreases fieldName, value
  {
    :- Need(2 <= |value.value| < UINT64_LIMIT, E(""Bad length."")); Success(fieldName + UInt64ToSeq((|value.value| - 2) as uint64) + UTF8.EncodeAscii(""ENCRYPTED"") + value.value)
  }

  function method GetCanonicalPlaintextField(fieldName: CanonicalPath, value: StructuredDataTerminal): (ret: Result<Bytes, Error>)
    ensures ret.Success? ==> |value.value| < UINT64_LIMIT && ret.value == fieldName + UInt64ToSeq(|value.value| as uint64) + UTF8.EncodeAscii(""PLAINTEXT"") + value.typeId + value.value
    decreases fieldName, value
  {
    :- Need(|value.value| < UINT64_LIMIT, E(""Bad length."")); Success(fieldName + UInt64ToSeq(|value.value| as uint64) + UTF8.EncodeAscii(""PLAINTEXT"") + value.typeId + value.value)
  }

  function method GetCanonicalItem(data: CanonCryptoItem): (ret: Result<Bytes, Error>)
    decreases data
  {
    if data.action == ENCRYPT_AND_SIGN then
      GetCanonicalEncryptedField(data.key, data.data)
    else
      GetCanonicalPlaintextField(data.key, data.data)
  }

  function method CanonContent(data: CanonCryptoList, canonized: Bytes := []): Result<Bytes, Error>
    decreases data, canonized
  {
    if |data| == 0 then
      Success(canonized)
    else if data[0].action == DO_NOTHING then
      CanonContent(data[1..], canonized)
    else
      var newPart: Bytes :- GetCanonicalItem(data[0]); CanonContent(data[1..], canonized + newPart)
  }

  function method CanonRecord(data: CanonCryptoList, header: Bytes, enc: Header.CMPEncryptionContext): (ret: Result<Bytes, Error>)
    ensures ret.Success? ==> CanonContent(data).Success? && var canon: Bytes := CanonContent(data).value; true && var AAD: Bytes := Header.SerializeContext(enc); |AAD| < UINT64_LIMIT && var len: seq<uint8> := UInt64ToSeq(|AAD| as uint64); true && ret.value == header + len + AAD + canon
    decreases data, header, enc
  {
    var canon: Bytes :- CanonContent(data); var AAD: Bytes := Header.SerializeContext(enc); :- Need(|AAD| < UINT64_LIMIT, E(""AAD too long."")); var len: seq<uint8> := UInt64ToSeq(|AAD| as uint64); Success(header + len + AAD + canon)
  }

  method CanonHash(data: CanonCryptoList, header: Bytes, enc: Header.CMPEncryptionContext)
      returns (ret: Result<Bytes, Error>)
    ensures ret.Success? ==> |ret.value| == 48
    decreases data, header, enc
  {
    var data :- CanonRecord(data, header, enc);
    var resultR := Digest.Digest(Prim.DigestInput(digestAlgorithm := Prim.SHA_384, message := data));
    return resultR.MapFailure((e: Types.Error) => AwsCryptographyPrimitives(e));
  }

  method CreateFooter(client: Primitives.AtomicPrimitivesClient, mat: CMP.EncryptionMaterials, data: CanonCryptoList, header: Bytes)
      returns (ret: Result<Footer, Error>)
    requires ValidSuite(mat.algorithmSuite)
    requires Materials.EncryptionMaterialsHasPlaintextDataKey(mat)
    requires Header.ValidEncryptionContext(mat.encryptionContext)
    requires client.ValidState()
    modifies client.Modifies
    ensures ret.Success? && mat.algorithmSuite.signature.ECDSA? ==> true && var history: seq<DafnyCallEvent<ECDSASignInput, Result<seq<uint8>, Error>>> := client.History.ECDSASign; 0 < |history| && var signInput: ECDSASignInput := Seq.Last(history).input; true && signInput.signatureAlgorithm == mat.algorithmSuite.signature.ECDSA.curve
    ensures client.ValidState()
    decreases client, mat, data, header
  {
    var canonicalHash :- CanonHash(data, header, mat.encryptionContext);
    var tags: seq<RecipientTag> := [];
    for i: int := 0 to |mat.encryptedDataKeys|
      invariant |tags| == i
    {
      var input := Prim.HMacInput(digestAlgorithm := mat.algorithmSuite.symmetricSignature.HMAC, key := mat.symmetricSigningKeys.value[i], message := canonicalHash);
      var hashR := client.HMac(input);
      var hash :- hashR.MapFailure((e: Error) => AwsCryptographyPrimitives(e));
      :- Need(|hash| == 48, E(""Bad hash length""));
      tags := tags + [hash];
    }
    assert |tags| == |mat.encryptedDataKeys|;
    if mat.algorithmSuite.signature.ECDSA? {
      var verInput := Prim.ECDSASignInput(signatureAlgorithm := mat.algorithmSuite.signature.ECDSA.curve, signingKey := mat.signingKey.value, message := canonicalHash);
      var sigR := client.ECDSASign(verInput);
      var sig :- sigR.MapFailure((e: Error) => AwsCryptographyPrimitives(e));
      :- Need(|sig| == SignatureSize, E(""Signature is "" + String.Base10Int2String(|sig|) + "" bytes, should have been "" + String.Base10Int2String(SignatureSize) + "" bytes.""));
      return Success(Footer(tags, Some(sig)));
    } else {
      return Success(Footer(tags, None));
    }
  }

  function method SerializeTags(tags: seq<RecipientTag>): Bytes
    decreases tags
  {
    if |tags| == 0 then
      []
    else
      tags[0] + SerializeTags(tags[1..])
  }

  function method SerializeSig(sig: Option<Signature>): Bytes
    decreases sig
  {
    if sig.Some? then
      sig.value
    else
      []
  }

  function method GatherTags(data: Bytes): seq<RecipientTag>
    requires |data| % RecipientTagSize == 0
    decreases data
  {
    if |data| == 0 then
      []
    else
      [data[0 .. RecipientTagSize]] + GatherTags(data[RecipientTagSize..])
  }

  function method DeserializeFooter(data: Bytes, hasSig: bool): Result<Footer, Error>
    decreases data, hasSig
  {
    if hasSig then
      :- Need((|data| - SignatureSize) % RecipientTagSize == 0, E(""Mangled signed footer has strange size"")); :- Need(|data| >= RecipientTagSize + SignatureSize, E(""Footer too short."")); Success(Footer(GatherTags(data[..|data| - SignatureSize]), Some(data[|data| - SignatureSize..])))
    else
      :- Need(|data| % RecipientTagSize == 0, E(""Mangled unsigned footer has strange size"")); :- Need(|data| >= RecipientTagSize, E(""Footer too short."")); Success(Footer(GatherTags(data), None))
  }

  import opened Wrappers

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import opened AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes

  import opened StructuredEncryptionUtil

  import Primitives = AtomicPrimitives

  import Materials

  import Header = StructuredEncryptionHeader

  import CMP = AwsCryptographyMaterialProvidersTypes

  import Prim = AwsCryptographyPrimitivesTypes

  import UTF8

  import Digest

  import String = StandardLibrary.String

  import Seq

  type RecipientTag = x: Bytes
    | |x| == RecipientTagSize
    witness *

  type Signature = x: Bytes
    | |x| == SignatureSize
    witness *

  datatype Footer = Footer(tags: seq<RecipientTag>, sig: Option<Signature>) {
    function method serialize(): Bytes
      decreases this
    {
      SerializeTags(tags) + SerializeSig(sig)
    }

    function method makeTerminal(): (ret: StructuredDataTerminal)
      ensures ret.typeId == BYTES_TYPE_ID
      ensures ret.value == serialize()
      decreases this
    {
      ValueToData(serialize(), BYTES_TYPE_ID)
    }

    method validate(client: Primitives.AtomicPrimitivesClient, mat: CMP.DecryptionMaterials, edks: CMP.EncryptedDataKeyList, data: CanonCryptoList, header: Bytes)
        returns (ret: Result<bool, Error>)
      requires Materials.DecryptionMaterialsWithPlaintextDataKey(mat)
      requires ValidSuite(mat.algorithmSuite)
      requires Header.ValidEncryptionContext(mat.encryptionContext)
      requires client.ValidState()
      modifies client.Modifies
      ensures ret.Success? ==> |edks| == |tags|
      ensures client.ValidState()
      decreases this, client, mat, edks, data, header
    {
      :- Need(|edks| == |tags|, E(""There are a different number of recipient tags in the stored header than there are in the decryption materials.""));
      var canonicalHash :- CanonHash(data, header, mat.encryptionContext);
      var input := Prim.HMacInput(digestAlgorithm := mat.algorithmSuite.symmetricSignature.HMAC, key := mat.symmetricSigningKey.value, message := canonicalHash);
      var hashR := client.HMac(input);
      var hash :- hashR.MapFailure((e: Error) => AwsCryptographyPrimitives(e));
      :- Need(|hash| == 48, E(""Bad hash length""));
      var foundTag := false;
      for i: int := 0 to |tags| {
        if ConstantTimeEquals(hash, tags[i]) {
          foundTag := true;
          break;
        }
      }
      :- Need(foundTag, E(""Signature of record does not match the signature computed when the record was encrypted.""));
      :- Need(sig.Some? == mat.algorithmSuite.signature.ECDSA?, E(""Internal error. Signature both does and does not exist.""));
      if sig.Some? {
        var verInput := Prim.ECDSAVerifyInput(signatureAlgorithm := mat.algorithmSuite.signature.ECDSA.curve, verificationKey := mat.verificationKey.value, message := canonicalHash, signature := sig.value);
        var verR := client.ECDSAVerify(verInput);
        var ver :- verR.MapFailure((e: Error) => AwsCryptographyPrimitives(e));
        :- Need(ver, E(""Signature did not verify""));
      }
      return Success(true);
    }
  }
}

module {:options ""-functionSyntax:4""} Maps {
  function method Get<X, Y>(m: map<X, Y>, x: X): Option<Y>
    decreases m
  {
    if x in m then
      Some(m[x])
    else
      None
  }

  function method {:opaque} ToImap<X, Y>(m: map<X, Y>): (m': imap<X, Y>)
    ensures forall x: X {:trigger m'[x]} :: (x in m ==> x in m') && (x in m ==> m'[x] == m[x])
    ensures forall x: X {:trigger x in m'} :: x in m' ==> x in m
    decreases m
  {
    imap x: X {:trigger m[x]} {:trigger x in m} | x in m :: m[x]
  }

  function method {:opaque} RemoveKeys<X, Y>(m: map<X, Y>, xs: set<X>): (m': map<X, Y>)
    ensures forall x: X {:trigger m'[x]} :: (x in m && x !in xs ==> x in m') && (x in m && x !in xs ==> m'[x] == m[x])
    ensures forall x: X {:trigger x in m'} :: (x in m' ==> x in m) && (x in m' ==> x !in xs)
    ensures m'.Keys == m.Keys - xs
    decreases m, xs
  {
    m - xs
  }

  function method {:opaque} Remove<X, Y>(m: map<X, Y>, x: X): (m': map<X, Y>)
    ensures m' == RemoveKeys(m, {x})
    ensures |m'.Keys| <= |m.Keys|
    ensures x in m ==> |m'| == |m| - 1
    ensures x !in m ==> |m'| == |m|
    decreases m
  {
    var m': map<X, Y> := map x': X {:trigger m[x']} {:trigger x' in m} | x' in m && x' != x :: m[x'];
    assert m'.Keys == m.Keys - {x};
    m'
  }

  function method {:opaque} Restrict<X, Y>(m: map<X, Y>, xs: set<X>): (m': map<X, Y>)
    ensures m' == RemoveKeys(m, m.Keys - xs)
    decreases m, xs
  {
    map x: X {:trigger m[x]} {:trigger x in m} {:trigger x in xs} | x in xs && x in m :: m[x]
  }

  predicate EqualOnKey<X, Y>(m: map<X, Y>, m': map<X, Y>, x: X)
    decreases m, m'
  {
    (x !in m && x !in m') || (x in m && x in m' && m[x] == m'[x])
  }

  predicate IsSubset<X, Y>(m: map<X, Y>, m': map<X, Y>)
    decreases m, m'
  {
    m.Keys <= m'.Keys &&
    forall x: X {:trigger EqualOnKey(m, m', x)} {:trigger x in m} :: 
      x in m ==>
        EqualOnKey(m, m', x)
  }

  function method {:opaque} Union<X, Y>(m: map<X, Y>, m': map<X, Y>): (r: map<X, Y>)
    ensures r.Keys == m.Keys + m'.Keys
    ensures forall x: X {:trigger r[x]} :: x in m' ==> r[x] == m'[x]
    ensures forall x: X {:trigger r[x]} :: x in m && x !in m' ==> r[x] == m[x]
    decreases m, m'
  {
    m + m'
  }

  lemma LemmaDisjointUnionSize<X, Y>(m: map<X, Y>, m': map<X, Y>)
    requires m.Keys !! m'.Keys
    ensures |Union(m, m')| == |m| + |m'|
    decreases m, m'
  {
    ghost var u := Union(m, m');
    assert |u.Keys| == |m.Keys| + |m'.Keys|;
  }

  predicate {:opaque} Injective<X, Y>(m: map<X, Y>)
    decreases m
  {
    forall x: X, x': X {:trigger m[x], m[x']} :: 
      x != x' &&
      x in m &&
      x' in m ==>
        m[x] != m[x']
  }

  function {:opaque} Invert<X, Y>(m: map<X, Y>): map<Y, X>
    decreases m
  {
    map y: Y {:trigger y in m.Values} | y in m.Values :: ghost var x: X :| x in m.Keys && m[x] == y; x
  }

  lemma LemmaInvertIsInjective<X, Y>(m: map<X, Y>)
    ensures Injective(Invert(m))
    decreases m
  {
    reveal Injective();
    reveal Invert();
  }

  predicate {:opaque} Total<X(!new), Y>(m: map<X, Y>)
    decreases m
  {
    forall i: X {:trigger m[i]} {:trigger i in m} :: 
      i in m
  }

  predicate {:opaque} Monotonic(m: map<int, int>)
    decreases m
  {
    forall x: int, x': int {:trigger m[x], m[x']} :: 
      x in m &&
      x' in m &&
      x <= x' ==>
        m[x] <= m[x']
  }

  predicate {:opaque} MonotonicFrom(m: map<int, int>, start: int)
    decreases m, start
  {
    forall x: int, x': int {:trigger m[x], m[x']} :: 
      x in m &&
      x' in m &&
      start <= x <= x' ==>
        m[x] <= m[x']
  }

  import opened Wrappers
}

module {:extern ""software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny""} DynamoDbItemEncryptor refines AbstractAwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorService {
  function method DefaultDynamoDbItemEncryptorConfig(): DynamoDbItemEncryptorConfig
  {
    DynamoDbItemEncryptorConfig(logicalTableName := ""foo"", partitionKeyName := ""bar"", sortKeyName := None(), attributeActionsOnEncrypt := map[], allowedUnsignedAttributes := None(), allowedUnsignedAttributePrefix := None(), keyring := None(), cmm := None(), algorithmSuiteId := None(), legacyOverride := None(), plaintextOverride := None())
  }

  predicate method UnreservedPrefix(attr: string)
    decreases attr
  {
    !(ReservedPrefix <= attr) &&
    !(SE.ReservedCryptoContextPrefixString <= attr)
  }

  method {:vcs_split_on_every_assert} DynamoDbItemEncryptor(config: DynamoDbItemEncryptorConfig := DefaultDynamoDbItemEncryptorConfig()) returns (res: Result<DynamoDbItemEncryptorClient, Error>)
    requires config.keyring.Some? ==> config.keyring.value.ValidState()
    requires config.cmm.Some? ==> config.cmm.value.ValidState()
    requires config.legacyOverride.Some? ==> config.legacyOverride.value.encryptor.ValidState()
    modifies if config.keyring.Some? then config.keyring.value.Modifies else {}, if config.cmm.Some? then config.cmm.value.Modifies else {}, if config.legacyOverride.Some? then config.legacyOverride.value.encryptor.Modifies else {}
    ensures res.Success? ==> fresh(res.value) && fresh(res.value.Modifies - (if config.keyring.Some? then config.keyring.value.Modifies else {}) - (if config.cmm.Some? then config.cmm.value.Modifies else {}) - if config.legacyOverride.Some? then config.legacyOverride.value.encryptor.Modifies else {}) && fresh(res.value.History) && res.value.ValidState()
    ensures config.keyring.Some? ==> config.keyring.value.ValidState()
    ensures config.cmm.Some? ==> config.cmm.value.ValidState()
    ensures config.legacyOverride.Some? ==> config.legacyOverride.value.encryptor.ValidState()
    ensures res.Success? ==> res.value is DynamoDbItemEncryptorClient && var rconfig: Operations.InternalConfig := (res.value as DynamoDbItemEncryptorClient).config; rconfig.logicalTableName == config.logicalTableName && rconfig.partitionKeyName == config.partitionKeyName && rconfig.sortKeyName == config.sortKeyName && rconfig.attributeActionsOnEncrypt == config.attributeActionsOnEncrypt && rconfig.allowedUnsignedAttributes == config.allowedUnsignedAttributes && rconfig.allowedUnsignedAttributePrefix == config.allowedUnsignedAttributePrefix && rconfig.algorithmSuiteId == config.algorithmSuiteId && rconfig.version == Operations.VersionFromActions(config.attributeActionsOnEncrypt) && config.partitionKeyName in config.attributeActionsOnEncrypt && config.attributeActionsOnEncrypt[config.partitionKeyName] == Operations.KeyActionFromVersion(rconfig.version) && (config.sortKeyName.Some? ==> config.sortKeyName.value in config.attributeActionsOnEncrypt && config.attributeActionsOnEncrypt[config.sortKeyName.value] == Operations.KeyActionFromVersion(rconfig.version))
    ensures res.Success? && config.plaintextOverride.None? ==> true && var config: Operations.InternalConfig := (res.value as DynamoDbItemEncryptorClient).config; true && config.plaintextOverride.FORBID_PLAINTEXT_WRITE_FORBID_PLAINTEXT_READ?
    decreases config
  {
    :- Need(config.keyring.None? || config.cmm.None?, DynamoDbItemEncryptorException(message := ""Cannot provide both a keyring and a CMM""));
    :- Need(config.keyring.Some? || config.cmm.Some?, DynamoDbItemEncryptorException(message := ""Must provide either a keyring or a CMM""));
    var version := Operations.VersionFromActions(config.attributeActionsOnEncrypt);
    var keyAction := Operations.KeyActionFromVersion(version);
    var keyActionStr := Operations.KeyActionStringFromVersion(version);
    :- Need(config.partitionKeyName in config.attributeActionsOnEncrypt && config.attributeActionsOnEncrypt[config.partitionKeyName] == keyAction, DynamoDbItemEncryptorException(message := ""Partition key attribute action MUST be "" + keyActionStr));
    :- Need(config.sortKeyName.Some? ==> config.sortKeyName.value in config.attributeActionsOnEncrypt && config.attributeActionsOnEncrypt[config.sortKeyName.value] == keyAction, DynamoDbItemEncryptorException(message := ""Sort key attribute action MUST be "" + keyActionStr));
    var attributeNames: seq<DDB.AttributeName> := SortedSets.ComputeSetToOrderedSequence2(config.attributeActionsOnEncrypt.Keys, CharLess);
    for i: int := 0 to |attributeNames|
      invariant forall j: int {:trigger attributeNames[j]} | 0 <= j < i :: UnreservedPrefix(attributeNames[j]) && _default.ForwardCompatibleAttributeAction(attributeNames[j], config.attributeActionsOnEncrypt[attributeNames[j]], config.allowedUnsignedAttributes, config.allowedUnsignedAttributePrefix)
    {
      var attributeName := attributeNames[i];
      var action := config.attributeActionsOnEncrypt[attributeName];
      if !Operations.ForwardCompatibleAttributeAction(attributeName, action, config.allowedUnsignedAttributes, config.allowedUnsignedAttributePrefix) {
        return Failure(DynamoDbItemEncryptorException(message := Operations.ExplainNotForwardCompatible(attributeName, action, config.allowedUnsignedAttributes, config.allowedUnsignedAttributePrefix)));
      }
      if !UnreservedPrefix(attributeName) {
        return Failure(DynamoDbItemEncryptorException(message := ""Attribute: "" + attributeName + "" is reserved, and may not be configured.""));
      }
      assert UnreservedPrefix(attributeName);
      assert UnreservedPrefix(attributeNames[i]);
    }
    assert forall attribute: string {:trigger UnreservedPrefix(attribute)} {:trigger attribute in attributeNames} | attribute in attributeNames :: UnreservedPrefix(attribute);
    assert forall attribute: string {:trigger UnreservedPrefix(attribute)} {:trigger attribute in config.attributeActionsOnEncrypt.Keys} | attribute in config.attributeActionsOnEncrypt.Keys :: UnreservedPrefix(attribute);
    assert forall attribute: seq<char> {:trigger attribute in config.attributeActionsOnEncrypt.Keys} | attribute in config.attributeActionsOnEncrypt.Keys :: !(ReservedPrefix <= attribute);
    var structuredEncryptionRes := StructuredEncryption.StructuredEncryption();
    var structuredEncryptionX: CSE.IStructuredEncryptionClient :- structuredEncryptionRes.MapFailure((e: Error) => AwsCryptographyDbEncryptionSdkDynamoDb(DDBE.AwsCryptographyDbEncryptionSdkStructuredEncryption(e)));
    assert structuredEncryptionX is StructuredEncryption.StructuredEncryptionClient;
    var structuredEncryption := structuredEncryptionX as StructuredEncryption.StructuredEncryptionClient;
    var cmm;
    if config.cmm.Some? {
      cmm := config.cmm.value;
    } else {
      var keyring := config.keyring.value;
      var matProv :- expect MaterialProviders.MaterialProviders();
      var maybeCmm := matProv.CreateDefaultCryptographicMaterialsManager(AwsCryptographyMaterialProvidersTypes.CreateDefaultCryptographicMaterialsManagerInput(keyring := keyring));
      cmm :- maybeCmm.MapFailure((e: Error) => AwsCryptographyMaterialProviders(e));
    }
    var maybeCmpClient := MaterialProviders.MaterialProviders();
    var internalLegacyOverride :- InternalLegacyOverride.InternalLegacyOverride.Build(config);
    var cmpClient :- maybeCmpClient.MapFailure((e: Error) => AwsCryptographyMaterialProviders(e));
    if !(internalLegacyOverride.None? || config.plaintextOverride.None?) {
      return Failure(DynamoDbItemEncryptorException(message := ""Cannot configure both a plaintext policy and a legacy config.""));
    }
    var plaintextOverride := if config.plaintextOverride.Some? then config.plaintextOverride.value else DDBE.PlaintextOverride.FORBID_PLAINTEXT_WRITE_FORBID_PLAINTEXT_READ;
    var internalConfig := Operations.Config(version := version, cmpClient := cmpClient, logicalTableName := config.logicalTableName, partitionKeyName := config.partitionKeyName, sortKeyName := config.sortKeyName, attributeActionsOnEncrypt := config.attributeActionsOnEncrypt, allowedUnsignedAttributes := config.allowedUnsignedAttributes, allowedUnsignedAttributePrefix := config.allowedUnsignedAttributePrefix, algorithmSuiteId := config.algorithmSuiteId, cmm := cmm, structuredEncryption := structuredEncryption as StructuredEncryption.StructuredEncryptionClient, internalLegacyOverride := internalLegacyOverride, plaintextOverride := plaintextOverride);
    assert forall attribute: string {:trigger UnreservedPrefix(attribute)} {:trigger attribute in internalConfig.attributeActionsOnEncrypt.Keys} | attribute in internalConfig.attributeActionsOnEncrypt.Keys :: UnreservedPrefix(attribute);
    assert forall attribute: seq<char> {:trigger attribute in internalConfig.attributeActionsOnEncrypt.Keys} | attribute in internalConfig.attributeActionsOnEncrypt.Keys :: !(ReservedPrefix <= attribute);
    assert Operations.ValidInternalConfig?(internalConfig);
    var client := new DynamoDbItemEncryptorClient(internalConfig);
    assert fresh(client.History);
    assert client.Modifies == Operations.ModifiesInternalConfig(internalConfig) + {client.History};
    assert Operations.ModifiesInternalConfig(internalConfig) == internalConfig.cmm.Modifies + internalConfig.structuredEncryption.Modifies + internalConfig.cmpClient.Modifies;
    assume {:axiom} fresh(client.Modifies - (if config.keyring.Some? then config.keyring.value.Modifies else {}) - (if config.cmm.Some? then config.cmm.value.Modifies else {}) - if config.legacyOverride.Some? then config.legacyOverride.value.encryptor.Modifies else {});
    return Success(client);
  }

  function method CreateSuccessOfClient(client: IDynamoDbItemEncryptorClient): Result<IDynamoDbItemEncryptorClient, Error>
    decreases client
  {
    Success(client)
  }

  function method CreateFailureOfError(error: Error): Result<IDynamoDbItemEncryptorClient, Error>
    decreases error
  {
    Failure(error)
  }

  import opened DynamoDbItemEncryptorUtil

  import StructuredEncryption

  import StructuredEncryptionHeader

  import CSE = AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes

  import DDBE = AwsCryptographyDbEncryptionSdkDynamoDbTypes

  import MaterialProviders

  import Operations = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations

  import SE = StructuredEncryptionUtil

  import InternalLegacyOverride

  import SortedSets

  import DDB = ComAmazonawsDynamodbTypes

  class DynamoDbItemEncryptorClient ... {
    predicate ValidState()
      ensures ValidState() ==> Operations.ValidInternalConfig?(config) && History !in Operations.ModifiesInternalConfig(config) && Modifies == Operations.ModifiesInternalConfig(config) + {History}
    {
      Operations.ValidInternalConfig?(config) &&
      History !in Operations.ModifiesInternalConfig(config) &&
      Modifies == Operations.ModifiesInternalConfig(config) + {History}
    }

    constructor (config: Operations.InternalConfig)
      requires Operations.ValidInternalConfig?(config)
      ensures ValidState() && fresh(History) && this.config == config
      decreases config
    {
      this.config := config;
      History := new IDynamoDbItemEncryptorClientCallHistory();
      Modifies := Operations.ModifiesInternalConfig(config) + {History};
    }

    const config: Operations.InternalConfig

    predicate EncryptItemEnsuresPublicly(input: EncryptItemInput, output: Result<EncryptItemOutput, Error>)
      decreases input, output
    {
      Operations.EncryptItemEnsuresPublicly(input, output)
    }

    method EncryptItem(input: EncryptItemInput) returns (output: Result<EncryptItemOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`EncryptItem
      ensures true && ValidState()
      ensures EncryptItemEnsuresPublicly(input, output)
      ensures History.EncryptItem == old(History.EncryptItem) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.EncryptItem(config, input);
      History.EncryptItem := History.EncryptItem + [DafnyCallEvent(input, output)];
    }

    predicate DecryptItemEnsuresPublicly(input: DecryptItemInput, output: Result<DecryptItemOutput, Error>)
      decreases input, output
    {
      Operations.DecryptItemEnsuresPublicly(input, output)
    }

    method DecryptItem(input: DecryptItemInput) returns (output: Result<DecryptItemOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DecryptItem
      ensures true && ValidState()
      ensures DecryptItemEnsuresPublicly(input, output)
      ensures History.DecryptItem == old(History.DecryptItem) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.DecryptItem(config, input);
      History.DecryptItem := History.DecryptItem + [DafnyCallEvent(input, output)];
    }
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes
}

module DynamoDbItemEncryptorUtil {
  const ReservedPrefix := ""aws_dbe_""
  const BeaconPrefix := ReservedPrefix + ""b_""
  const VersionPrefix := ReservedPrefix + ""v_""
  const MAX_ATTRIBUTE_COUNT := 100

  function method E(msg: string): Error
    decreases msg
  {
    DynamoDbItemEncryptorException(message := msg)
  }

  predicate method ByteLess(x: uint8, y: uint8)
    decreases x, y
  {
    x < y
  }

  predicate method CharLess(x: char, y: char)
    decreases x, y
  {
    x < y
  }

  const TABLE_NAME: UTF8.ValidUTF8Bytes := UTF8.EncodeAscii(""aws-crypto-table-name"")
  const PARTITION_NAME: UTF8.ValidUTF8Bytes := UTF8.EncodeAscii(""aws-crypto-partition-name"")
  const SORT_NAME: UTF8.ValidUTF8Bytes := UTF8.EncodeAscii(""aws-crypto-sort-name"")
  const SELECTOR_TABLE_NAME: DDB.AttributeName := ""aws_dbe_table_name""
  const SELECTOR_PARTITION_NAME: DDB.AttributeName := ""aws_dbe_partition_name""
  const SELECTOR_SORT_NAME: DDB.AttributeName := ""aws_dbe_sort_name""

  function method GetLiteralValue(x: seq<uint8>): (ret: Result<DDB.AttributeValue, string>)
    decreases x
  {
    var str: string :- UTF8.Decode(x); if str == SE.TRUE_STR then Success(DDB.AttributeValue.BOOL(true)) else if str == SE.FALSE_STR then Success(DDB.AttributeValue.BOOL(false)) else if str == SE.NULL_STR then Success(DDB.AttributeValue.NULL(true)) else Failure(""Encryption Context literal value has unexpected value : '"" + str + ""'."")
  }

  function method GetSortKey(context: MPL.EncryptionContext): Result<Option<UTF8.ValidUTF8Bytes>, string>
    decreases context
  {
    if SORT_NAME in context.Keys then
      var sortName: seq<uint8> := SE.EC_ATTR_PREFIX + context[SORT_NAME];
      :- Need(UTF8.ValidUTF8Seq(sortName), ""Internal Error : bad utf8 in sortName""); Success(Some(sortName))
    else
      Success(None)
  }

  function method ConvertContextForSelector(context: MPL.EncryptionContext): (output: Result<DDB.Key, string>)
    ensures PARTITION_NAME !in context.Keys ==> output.Failure?
    ensures output.Success? ==> PARTITION_NAME in context.Keys && var partitionName: ValidUTF8Bytes := context[PARTITION_NAME]; true && var partitionValueKey: seq<uint8> := SE.EC_ATTR_PREFIX + partitionName; true && partitionValueKey in context.Keys
    ensures PARTITION_NAME in context.Keys ==> true && var partitionName: ValidUTF8Bytes := context[PARTITION_NAME]; true && var partitionValueKey: seq<uint8> := SE.EC_ATTR_PREFIX + partitionName; true && partitionValueKey !in context.Keys ==> output.Failure?
    ensures output.Success? && SORT_NAME in context.Keys ==> true && var sortName: ValidUTF8Bytes := context[SORT_NAME]; true && var sortValueKey: seq<uint8> := SE.EC_ATTR_PREFIX + sortName; true && sortValueKey in context.Keys
    ensures SORT_NAME in context.Keys ==> true && var sortName: ValidUTF8Bytes := context[SORT_NAME]; true && var sortValueKey: seq<uint8> := SE.EC_ATTR_PREFIX + sortName; true && (sortValueKey !in context.Keys ==> output.Failure?)
    decreases context
  {
    :- Need(PARTITION_NAME in context.Keys, ""Invalid encryption context: Missing partition name""); var partitionName: ValidUTF8Bytes := context[PARTITION_NAME]; var partitionValueKey: seq<uint8> := SE.EC_ATTR_PREFIX + partitionName; :- Need(partitionValueKey in context.Keys, ""Invalid encryption context: Missing partition value""); var sortValueKey: Option<UTF8.ValidUTF8Bytes> :- GetSortKey(context); :- Need(sortValueKey.None? || sortValueKey.value in context, ""Invalid encryption context: Missing sort value""); var keys: seq<UTF8.ValidUTF8Bytes> := SortedSets.ComputeSetToOrderedSequence2(context.Keys, SE.ByteLess); if SE.LEGEND_UTF8 in context then var legend: string :- UTF8.Decode(context[SE.LEGEND_UTF8]); var attrMap: DDB.AttributeMap :- GetV2AttrMap(keys, context, legend); :- Need(TABLE_NAME in context, ""Internal error, table name not in encryption context.""); var tableName: string :- UTF8.Decode(context[TABLE_NAME]); var attrMap2: map<seq<char>, AttributeValue> := attrMap[SELECTOR_TABLE_NAME := DDB.AttributeValue.S(tableName)]; :- Need(PARTITION_NAME in context, ""Internal error, table name not in encryption context.""); var partitionName: string :- UTF8.Decode(context[PARTITION_NAME]); var attrMap3: map<seq<char>, AttributeValue> := attrMap2[SELECTOR_PARTITION_NAME := DDB.AttributeValue.S(partitionName)]; if SORT_NAME in context then var sortName: string :- UTF8.Decode(context[SORT_NAME]); Success(attrMap3[SELECTOR_SORT_NAME := DDB.AttributeValue.S(sortName)]) else Success(attrMap3) else if sortValueKey.None? then AddAttributeToMap(partitionValueKey, context[partitionValueKey], map[]) else var attrMap: DDB.AttributeMap :- AddAttributeToMap(partitionValueKey, context[partitionValueKey], map[]); AddAttributeToMap(sortValueKey.value, context[sortValueKey.value], attrMap)
  }

  function method GetAttrValue(ecValue: UTF8.ValidUTF8Bytes, legend: char): Result<DDB.AttributeValue, string>
    decreases ecValue, legend
  {
    if legend == SE.LEGEND_STRING then
      var value: string :- UTF8.Decode(ecValue); Success(DDB.AttributeValue.S(value))
    else if legend == SE.LEGEND_NUMBER then
      var value: string :- UTF8.Decode(ecValue); Success(DDB.AttributeValue.N(value))
    else if legend == SE.LEGEND_LITERAL then
      var value: DDB.AttributeValue :- GetLiteralValue(ecValue); Success(value)
    else if legend == SE.LEGEND_BINARY then
      var terminal: StructuredDataTerminal :- SE.DecodeTerminal(ecValue); var ddbAttrValue: AttrValueAndLength :- DynamoToStruct.BytesToAttr(terminal.value, terminal.typeId, false); Success(ddbAttrValue.val)
    else
      Failure(""Encryption Context Legend has unexpected character : '"" + [legend] + ""'."")
  }

  function method GetV2AttrMap(keys: seq<UTF8.ValidUTF8Bytes>, context: MPL.EncryptionContext, legend: string, attrMap: DDB.AttributeMap := map[]): Result<DDB.AttributeMap, string>
    requires forall k: UTF8.ValidUTF8Bytes {:trigger k in context} {:trigger k in keys} | k in keys :: k in context
    decreases keys, context, legend, attrMap
  {
    if |keys| == 0 then
      if |legend| == 0 then
        Success(attrMap)
      else
        Failure(""Encryption Context Legend is too long."")
    else
      var key: UTF8.ValidUTF8Bytes := keys[0]; if SE.EC_ATTR_PREFIX < key then :- Need(0 < |legend|, ""Encryption Context Legend is too short.""); var attrName: DDB.AttributeName :- GetAttributeName(key); var attrValue: DDB.AttributeValue :- GetAttrValue(context[key], legend[0]); GetV2AttrMap(keys[1..], context, legend[1..], attrMap[attrName := attrValue]) else GetV2AttrMap(keys[1..], context, legend, attrMap)
  }

  function method GetAttributeName(ddbAttrKey: UTF8.ValidUTF8Bytes): (res: Result<DDB.AttributeName, string>)
    requires |ddbAttrKey| >= |SE.EC_ATTR_PREFIX|
    decreases ddbAttrKey
  {
    var ddbAttrNameBytes: seq<BoundedInts.uint8> := ddbAttrKey[|SE.EC_ATTR_PREFIX|..];
    var ddbAttrName: string :- UTF8.Decode(ddbAttrNameBytes); :- Need(DDB.IsValid_AttributeName(ddbAttrName), ""Invalid serialization of DDB Attribute in encryption context.""); Success(ddbAttrName)
  }

  function method AddAttributeToMap(ddbAttrKey: UTF8.ValidUTF8Bytes, encodedAttrValue: UTF8.ValidUTF8Bytes, attrMap: DDB.AttributeMap): (res: Result<DDB.AttributeMap, string>)
    requires |ddbAttrKey| >= |SE.EC_ATTR_PREFIX|
    decreases ddbAttrKey, encodedAttrValue, attrMap
  {
    var ddbAttrName: DDB.AttributeName :- GetAttributeName(ddbAttrKey); var terminal: StructuredDataTerminal :- SE.DecodeTerminal(encodedAttrValue); var ddbAttrValue: AttrValueAndLength :- DynamoToStruct.BytesToAttr(terminal.value, terminal.typeId, false); Success(attrMap[ddbAttrName := ddbAttrValue.val])
  }

  import opened AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes

  import opened Wrappers

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import UTF8

  import MPL = AwsCryptographyMaterialProvidersTypes

  import DDB = ComAmazonawsDynamodbTypes

  import SortedSets

  import SE = StructuredEncryptionUtil

  import DynamoToStruct
}

module {:extern ""software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types""} AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes {
  predicate method IsDummySubsetType(x: int)
    decreases x
  {
    0 < x
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import AwsCryptographyDbEncryptionSdkDynamoDbTypes

  import AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes

  import AwsCryptographyMaterialProvidersTypes

  import AwsCryptographyPrimitivesTypes

  import ComAmazonawsDynamodbTypes

  datatype DafnyCallEvent<I, O> = DafnyCallEvent(input: I, output: O)

  datatype DecryptItemInput = DecryptItemInput(nameonly encryptedItem: ComAmazonawsDynamodbTypes.AttributeMap)

  datatype DecryptItemOutput = DecryptItemOutput(nameonly plaintextItem: ComAmazonawsDynamodbTypes.AttributeMap, nameonly parsedHeader: Option<ParsedHeader> := Option.None)

  class IDynamoDbItemEncryptorClientCallHistory {
    ghost constructor ()
    {
      EncryptItem := [];
      DecryptItem := [];
    }

    ghost var EncryptItem: seq<DafnyCallEvent<EncryptItemInput, Result<EncryptItemOutput, Error>>>
    ghost var DecryptItem: seq<DafnyCallEvent<DecryptItemInput, Result<DecryptItemOutput, Error>>>
  }

  trait {:termination false} IDynamoDbItemEncryptorClient {
    ghost const Modifies: set<object>

    predicate ValidState()
      ensures ValidState() ==> History in Modifies

    ghost const History: IDynamoDbItemEncryptorClientCallHistory

    predicate EncryptItemEnsuresPublicly(input: EncryptItemInput, output: Result<EncryptItemOutput, Error>)
      decreases input, output

    method EncryptItem(input: EncryptItemInput) returns (output: Result<EncryptItemOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`EncryptItem
      ensures true && ValidState()
      ensures EncryptItemEnsuresPublicly(input, output)
      ensures History.EncryptItem == old(History.EncryptItem) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DecryptItemEnsuresPublicly(input: DecryptItemInput, output: Result<DecryptItemOutput, Error>)
      decreases input, output

    method DecryptItem(input: DecryptItemInput) returns (output: Result<DecryptItemOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DecryptItem
      ensures true && ValidState()
      ensures DecryptItemEnsuresPublicly(input, output)
      ensures History.DecryptItem == old(History.DecryptItem) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
  }

  datatype DynamoDbItemEncryptorConfig = DynamoDbItemEncryptorConfig(nameonly logicalTableName: string, nameonly partitionKeyName: ComAmazonawsDynamodbTypes.KeySchemaAttributeName, nameonly sortKeyName: Option<ComAmazonawsDynamodbTypes.KeySchemaAttributeName> := Option.None, nameonly attributeActionsOnEncrypt: AwsCryptographyDbEncryptionSdkDynamoDbTypes.AttributeActions, nameonly allowedUnsignedAttributes: Option<ComAmazonawsDynamodbTypes.AttributeNameList> := Option.None, nameonly allowedUnsignedAttributePrefix: Option<string> := Option.None, nameonly algorithmSuiteId: Option<AwsCryptographyMaterialProvidersTypes.DBEAlgorithmSuiteId> := Option.None, nameonly keyring: Option<AwsCryptographyMaterialProvidersTypes.IKeyring> := Option.None, nameonly cmm: Option<AwsCryptographyMaterialProvidersTypes.ICryptographicMaterialsManager> := Option.None, nameonly legacyOverride: Option<AwsCryptographyDbEncryptionSdkDynamoDbTypes.LegacyOverride> := Option.None, nameonly plaintextOverride: Option<AwsCryptographyDbEncryptionSdkDynamoDbTypes.PlaintextOverride> := Option.None)

  datatype EncryptItemInput = EncryptItemInput(nameonly plaintextItem: ComAmazonawsDynamodbTypes.AttributeMap)

  datatype EncryptItemOutput = EncryptItemOutput(nameonly encryptedItem: ComAmazonawsDynamodbTypes.AttributeMap, nameonly parsedHeader: Option<ParsedHeader> := Option.None)

  datatype ParsedHeader = ParsedHeader(nameonly attributeActionsOnEncrypt: AwsCryptographyDbEncryptionSdkDynamoDbTypes.AttributeActions, nameonly algorithmSuiteId: AwsCryptographyMaterialProvidersTypes.DBEAlgorithmSuiteId, nameonly encryptedDataKeys: AwsCryptographyMaterialProvidersTypes.EncryptedDataKeyList, nameonly storedEncryptionContext: AwsCryptographyMaterialProvidersTypes.EncryptionContext, nameonly encryptionContext: AwsCryptographyMaterialProvidersTypes.EncryptionContext, nameonly selectorContext: ComAmazonawsDynamodbTypes.Key)

  datatype Error = DynamoDbItemEncryptorException(nameonly message: string) | AwsCryptographyDbEncryptionSdkDynamoDb(AwsCryptographyDbEncryptionSdkDynamoDb: AwsCryptographyDbEncryptionSdkDynamoDbTypes.Error) | AwsCryptographyDbEncryptionSdkStructuredEncryption(AwsCryptographyDbEncryptionSdkStructuredEncryption: AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.Error) | AwsCryptographyMaterialProviders(AwsCryptographyMaterialProviders: AwsCryptographyMaterialProvidersTypes.Error) | AwsCryptographyPrimitives(AwsCryptographyPrimitives: AwsCryptographyPrimitivesTypes.Error) | ComAmazonawsDynamodb(ComAmazonawsDynamodb: ComAmazonawsDynamodbTypes.Error) | CollectionOfErrors(list: seq<Error>, nameonly message: string) | Opaque(obj: object) | OpaqueWithText(obj: object, objMessage: string)

  type OpaqueError = e: Error
    | e.Opaque? || e.OpaqueWithText?
    witness *

  type DummySubsetType = x: int
    | IsDummySubsetType(x)
    witness 1
}

abstract module AbstractAwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorService {
  function method DefaultDynamoDbItemEncryptorConfig(): DynamoDbItemEncryptorConfig

  method DynamoDbItemEncryptor(config: DynamoDbItemEncryptorConfig := DefaultDynamoDbItemEncryptorConfig()) returns (res: Result<DynamoDbItemEncryptorClient, Error>)
    requires config.keyring.Some? ==> config.keyring.value.ValidState()
    requires config.cmm.Some? ==> config.cmm.value.ValidState()
    requires config.legacyOverride.Some? ==> config.legacyOverride.value.encryptor.ValidState()
    modifies if config.keyring.Some? then config.keyring.value.Modifies else {}, if config.cmm.Some? then config.cmm.value.Modifies else {}, if config.legacyOverride.Some? then config.legacyOverride.value.encryptor.Modifies else {}
    ensures res.Success? ==> fresh(res.value) && fresh(res.value.Modifies - (if config.keyring.Some? then config.keyring.value.Modifies else {}) - (if config.cmm.Some? then config.cmm.value.Modifies else {}) - if config.legacyOverride.Some? then config.legacyOverride.value.encryptor.Modifies else {}) && fresh(res.value.History) && res.value.ValidState()
    ensures config.keyring.Some? ==> config.keyring.value.ValidState()
    ensures config.cmm.Some? ==> config.cmm.value.ValidState()
    ensures config.legacyOverride.Some? ==> config.legacyOverride.value.encryptor.ValidState()
    decreases config

  function method CreateSuccessOfClient(client: IDynamoDbItemEncryptorClient): Result<IDynamoDbItemEncryptorClient, Error>
    decreases client
  {
    Success(client)
  }

  function method CreateFailureOfError(error: Error): Result<IDynamoDbItemEncryptorClient, Error>
    decreases error
  {
    Failure(error)
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes

  import Operations : AbstractAwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations

  class DynamoDbItemEncryptorClient extends IDynamoDbItemEncryptorClient {
    constructor (config: Operations.InternalConfig)
      requires Operations.ValidInternalConfig?(config)
      ensures ValidState() && fresh(History) && this.config == config

    const config: Operations.InternalConfig

    predicate ValidState()
      ensures ValidState() ==> Operations.ValidInternalConfig?(config) && History !in Operations.ModifiesInternalConfig(config) && Modifies == Operations.ModifiesInternalConfig(config) + {History}

    predicate EncryptItemEnsuresPublicly(input: EncryptItemInput, output: Result<EncryptItemOutput, Error>)
      decreases input, output
    {
      Operations.EncryptItemEnsuresPublicly(input, output)
    }

    method EncryptItem(input: EncryptItemInput) returns (output: Result<EncryptItemOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`EncryptItem
      ensures true && ValidState()
      ensures EncryptItemEnsuresPublicly(input, output)
      ensures History.EncryptItem == old(History.EncryptItem) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.EncryptItem(config, input);
      History.EncryptItem := History.EncryptItem + [DafnyCallEvent(input, output)];
    }

    predicate DecryptItemEnsuresPublicly(input: DecryptItemInput, output: Result<DecryptItemOutput, Error>)
      decreases input, output
    {
      Operations.DecryptItemEnsuresPublicly(input, output)
    }

    method DecryptItem(input: DecryptItemInput) returns (output: Result<DecryptItemOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DecryptItem
      ensures true && ValidState()
      ensures DecryptItemEnsuresPublicly(input, output)
      ensures History.DecryptItem == old(History.DecryptItem) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.DecryptItem(config, input);
      History.DecryptItem := History.DecryptItem + [DafnyCallEvent(input, output)];
    }
  }
}

abstract module AbstractAwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations {
  predicate ValidInternalConfig?(config: InternalConfig)

  function ModifiesInternalConfig(config: InternalConfig): set<object>

  predicate EncryptItemEnsuresPublicly(input: EncryptItemInput, output: Result<EncryptItemOutput, Error>)
    decreases input, output

  method EncryptItem(config: InternalConfig, input: EncryptItemInput) returns (output: Result<EncryptItemOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures EncryptItemEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DecryptItemEnsuresPublicly(input: DecryptItemInput, output: Result<DecryptItemOutput, Error>)
    decreases input, output

  method DecryptItem(config: InternalConfig, input: DecryptItemInput) returns (output: Result<DecryptItemOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DecryptItemEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes

  type InternalConfig
}

module {:extern ""software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny""} DynamoDbEncryption refines AbstractAwsCryptographyDbEncryptionSdkDynamoDbService {
  function method DefaultDynamoDbEncryptionConfig(): DynamoDbEncryptionConfig
  {
    DynamoDbEncryptionConfig()
  }

  method DynamoDbEncryption(config: DynamoDbEncryptionConfig := DefaultDynamoDbEncryptionConfig()) returns (res: Result<DynamoDbEncryptionClient, Error>)
    ensures res.Success? ==> fresh(res.value) && fresh(res.value.Modifies) && fresh(res.value.History) && res.value.ValidState()
    ensures res.Success? ==> res.value is DynamoDbEncryptionClient
    decreases config
  {
    var internalConfig := Operations.Config();
    var client := new DynamoDbEncryptionClient(internalConfig);
    return Success(client);
  }

  function method CreateSuccessOfClient(client: IDynamoDbEncryptionClient): Result<IDynamoDbEncryptionClient, Error>
    decreases client
  {
    Success(client)
  }

  function method CreateFailureOfError(error: Error): Result<IDynamoDbEncryptionClient, Error>
    decreases error
  {
    Failure(error)
  }

  import Operations = AwsCryptographyDbEncryptionSdkDynamoDbOperations

  class DynamoDbEncryptionClient ... {
    predicate ValidState()
      ensures ValidState() ==> Operations.ValidInternalConfig?(config) && History !in Operations.ModifiesInternalConfig(config) && Modifies == Operations.ModifiesInternalConfig(config) + {History}
    {
      Operations.ValidInternalConfig?(config) &&
      History !in Operations.ModifiesInternalConfig(config) &&
      Modifies == Operations.ModifiesInternalConfig(config) + {History}
    }

    constructor (config: Operations.InternalConfig)
      requires Operations.ValidInternalConfig?(config)
      ensures ValidState() && fresh(History) && this.config == config
      decreases config
    {
      this.config := config;
      History := new IDynamoDbEncryptionClientCallHistory();
      Modifies := Operations.ModifiesInternalConfig(config) + {History};
    }

    const config: Operations.InternalConfig

    predicate CreateDynamoDbEncryptionBranchKeyIdSupplierEnsuresPublicly(input: CreateDynamoDbEncryptionBranchKeyIdSupplierInput, output: Result<CreateDynamoDbEncryptionBranchKeyIdSupplierOutput, Error>)
      decreases input, output
    {
      Operations.CreateDynamoDbEncryptionBranchKeyIdSupplierEnsuresPublicly(input, output)
    }

    method CreateDynamoDbEncryptionBranchKeyIdSupplier(input: CreateDynamoDbEncryptionBranchKeyIdSupplierInput) returns (output: Result<CreateDynamoDbEncryptionBranchKeyIdSupplierOutput, Error>)
      requires ValidState() && input.ddbKeyBranchKeyIdSupplier.ValidState() && input.ddbKeyBranchKeyIdSupplier.Modifies !! {History}
      modifies Modifies - {History}, input.ddbKeyBranchKeyIdSupplier.Modifies, History`CreateDynamoDbEncryptionBranchKeyIdSupplier
      ensures ValidState() && (output.Success? ==> output.value.branchKeyIdSupplier.ValidState() && output.value.branchKeyIdSupplier.Modifies !! {History} && fresh(output.value.branchKeyIdSupplier) && fresh(output.value.branchKeyIdSupplier.Modifies - Modifies - {History} - input.ddbKeyBranchKeyIdSupplier.Modifies))
      ensures CreateDynamoDbEncryptionBranchKeyIdSupplierEnsuresPublicly(input, output)
      ensures History.CreateDynamoDbEncryptionBranchKeyIdSupplier == old(History.CreateDynamoDbEncryptionBranchKeyIdSupplier) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.ddbKeyBranchKeyIdSupplier.Modifies
    {
      output := Operations.CreateDynamoDbEncryptionBranchKeyIdSupplier(config, input);
      History.CreateDynamoDbEncryptionBranchKeyIdSupplier := History.CreateDynamoDbEncryptionBranchKeyIdSupplier + [DafnyCallEvent(input, output)];
    }

    predicate GetEncryptedDataKeyDescriptionEnsuresPublicly(input: GetEncryptedDataKeyDescriptionInput, output: Result<GetEncryptedDataKeyDescriptionOutput, Error>)
      decreases input, output
    {
      Operations.GetEncryptedDataKeyDescriptionEnsuresPublicly(input, output)
    }

    method GetEncryptedDataKeyDescription(input: GetEncryptedDataKeyDescriptionInput) returns (output: Result<GetEncryptedDataKeyDescriptionOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetEncryptedDataKeyDescription
      ensures true && ValidState()
      ensures GetEncryptedDataKeyDescriptionEnsuresPublicly(input, output)
      ensures History.GetEncryptedDataKeyDescription == old(History.GetEncryptedDataKeyDescription) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.GetEncryptedDataKeyDescription(config, input);
      History.GetEncryptedDataKeyDescription := History.GetEncryptedDataKeyDescription + [DafnyCallEvent(input, output)];
    }
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyDbEncryptionSdkDynamoDbTypes
}

module DdbVirtualFields {
  function method ParseVirtualFieldConfig(vf: VirtualField): Result<VirtField, Error>
    decreases vf
  {
    var parts: seq<VirtPart> :- Seq.MapWithResult((p: VirtualPart) => ParseVirtualPartConfig(p), vf.parts); Success(VirtField(vf.name, parts))
  }

  function method ParseVirtualPartConfig(part: VirtualPart): Result<VirtPart, Error>
    decreases part
  {
    var loc: TermLoc :- TermLoc.MakeTermLoc(part.loc); if part.trans.None? then Success(VirtPart(loc, [])) else Success(VirtPart(loc, part.trans.value))
  }

  predicate IsValidVirtualFieldMap(m: map<string, VirtField>)
    decreases m
  {
    forall x: seq<char> {:trigger m[x]} {:trigger x in m} | x in m :: 
      x == m[x].name
  }

  function method {:opaque} Examine(parts: seq<VirtPart>, exam: Examiner): (ret: bool)
    ensures !ret ==> forall s: VirtPart {:trigger s.loc} {:trigger s in parts} | s in parts :: !exam(s.loc)
    decreases parts
  {
    if |parts| == 0 then
      false
    else if exam(parts[0].loc) then
      true
    else
      Examine(parts[1..], exam)
  }

  function method Min(x: nat, y: nat): (ret: nat)
    ensures ret <= y
    decreases x, y
  {
    if y < x then
      y
    else
      x
  }

  function method GetPrefix(s: string, length: int): (ret: string)
    ensures 0 <= length <= |s| ==> ret == s[..length]
    ensures |s| < length ==> ret == s
    ensures length < 0 && 0 <= -length <= |s| ==> ret == s[..|s| + length]
    ensures length < 0 && |s| < -length ==> ret == """"
    decreases s, length
  {
    if length >= 0 then
      s[..Min(length, |s|)]
    else
      s[..|s| - Min(-length, |s|)]
  }

  function method GetSuffix(s: string, length: int): (ret: string)
    ensures 0 <= length <= |s| ==> ret == s[|s| - length..]
    ensures |s| < length ==> ret == s
    ensures length < 0 && 0 <= -length <= |s| ==> ret == s[-length..]
    ensures length < 0 && |s| < -length ==> ret == """"
    decreases s, length
  {
    if length >= 0 then
      s[|s| - Min(length, |s|)..]
    else
      s[Min(-length, |s|)..]
  }

  function method GetPos(pos: int, limit: nat): (ret: nat)
    ensures limit == 0 || ret < limit
    ensures limit == 0 ==> ret == 0
    ensures 0 < limit ==> (0 <= pos < limit ==> ret == pos) && (limit <= pos ==> ret == limit - 1) && (0 < -pos < limit ==> ret == limit + pos) && (limit <= -pos ==> ret == 0)
    decreases pos, limit
  {
    if limit == 0 then
      0
    else if pos >= 0 then
      Min(pos, limit - 1)
    else if limit + pos < 0 then
      0
    else
      limit + pos
  }

  lemma GetPosTest()
    ensures GetPos(0, 5) == 0
    ensures GetPos(1, 5) == 1
    ensures GetPos(2, 5) == 2
    ensures GetPos(3, 5) == 3
    ensures GetPos(4, 5) == 4
    ensures GetPos(5, 5) == 4
    ensures GetPos(-1, 5) == 4
    ensures GetPos(-2, 5) == 3
    ensures GetPos(-3, 5) == 2
    ensures GetPos(-4, 5) == 1
    ensures GetPos(-5, 5) == 0
    ensures GetPos(-6, 5) == 0
  {
  }

  function method GetSubstring(s: string, low: int, high: int): (ret: string)
    ensures true && var lo: nat := GetPos(low, |s|); true && var hi: nat := GetPos(high, |s|); (lo < hi ==> ret == s[lo .. hi]) && (lo >= hi ==> ret == """")
    decreases s, low, high
  {
    var lo: nat := GetPos(low, |s|);
    var hi: nat := GetPos(high, |s|);
    if lo < hi then
      s[lo .. hi]
    else
      """"
  }

  function method UpperChar(ch: char): char
    decreases ch
  {
    if 'a' <= ch <= 'z' then
      ch - 'a' + 'A'
    else
      ch
  }

  function method UpperCase(s: string): (ret: string)
    ensures ret == Seq.Map((c: char) => UpperChar(c), s)
    decreases s
  {
    Seq.Map((c: char) => UpperChar(c), s)
  }

  function method LowerChar(ch: char): char
    decreases ch
  {
    if 'A' <= ch <= 'Z' then
      ch - 'A' + 'a'
    else
      ch
  }

  function method LowerCase(s: string): (ret: string)
    ensures ret == Seq.Map((c: char) => LowerChar(c), s)
    decreases s
  {
    Seq.Map((c: char) => LowerChar(c), s)
  }

  function method GetSegment(s: string, split: char, index: int): (ret: string)
    ensures true && var parts: seq<seq<char>> := Split(s, split); (index >= |parts| || -index > |parts| ==> ret == """") && (index < |parts| && -index <= |parts| ==> ret == parts[GetPos(index, |parts|)])
    decreases s, split, index
  {
    var parts: seq<seq<char>> := Split(s, split);
    if index >= |parts| || -index > |parts| then
      """"
    else
      parts[GetPos(index, |parts|)]
  }

  function method GetSegments(s: string, split: char, low: int, high: int): (ret: string)
    ensures true && var parts: seq<seq<char>> := Split(s, split); true && var lo: nat := GetPos(low, |parts|); true && var hi: nat := GetPos(high, |parts|); (lo < hi ==> ret == Join(parts[lo .. hi], [split])) && (lo >= hi ==> ret == """")
    decreases s, split, low, high
  {
    var parts: seq<seq<char>> := Split(s, split);
    var lo: nat := GetPos(low, |parts|);
    var hi: nat := GetPos(high, |parts|);
    if lo < hi then
      Join(parts[lo .. hi], [split])
    else
      """"
  }

  function method DoTransform(t: VirtualTransform, s: string): (ret: string)
    ensures t.insert? ==> ret == s + t.insert.literal
    decreases t, s
  {
    match t {
      case upper(up) =>
        UpperCase(s)
      case lower(lo) =>
        LowerCase(s)
      case insert(ins) =>
        s + ins.literal
      case prefix(pre) =>
        GetPrefix(s, pre.length as int)
      case suffix(suf) =>
        GetSuffix(s, suf.length as int)
      case substring(sub) =>
        GetSubstring(s, sub.low as int, sub.high as int)
      case segment(seg) =>
        GetSegment(s, seg.split[0], seg.index as int)
      case segments(seg) =>
        GetSegments(s, seg.split[0], seg.low as int, seg.high as int)
    }
  }

  function method FullTransform(t: seq<VirtualTransform>, s: string): string
    decreases t, s
  {
    if |t| == 0 then
      s
    else
      FullTransform(t[1..], DoTransform(t[0], s))
  }

  function method GetVirtField(vf: VirtField, item: DDB.AttributeMap): Result<Option<string>, Error>
    decreases vf, item
  {
    GetVirtField2(vf.parts, item)
  }

  function method {:tailrecursion} GetVirtField2(parts: seq<VirtPart>, item: DDB.AttributeMap, acc: string := """"): (ret: Result<Option<string>, Error>)
    ensures ret.Success? && 0 < |parts| ==> TermLoc.TermToString(parts[0].loc, item).Success? && (TermLoc.TermToString(parts[0].loc, item).value.None? ==> ret.value.None?)
    decreases parts, item, acc
  {
    if |parts| == 0 then
      Success(Some(acc))
    else
      var value: Option<string> :- TermLoc.TermToString(parts[0].loc, item); if value.None? then Success(None) else var trans: string := FullTransform(parts[0].trans, value.value); GetVirtField2(parts[1..], item, acc + trans)
  }

  function method VirtToAttr(loc: TermLoc.TermLoc, item: DDB.AttributeMap, vf: VirtualFieldMap): Result<Option<DDB.AttributeValue>, Error>
    decreases loc, item, vf
  {
    if |loc| == 1 && loc[0].key in vf then
      var str: Option<string> :- GetVirtField(vf[loc[0].key], item); if str.None? then Success(None) else Success(Some(DS(str.value)))
    else
      Success(TermLoc.TermToAttr(loc, item, None))
  }

  function method VirtToBytes(loc: TermLoc.TermLoc, item: DDB.AttributeMap, vf: VirtualFieldMap): Result<Option<Bytes>, Error>
    decreases loc, item, vf
  {
    if |loc| == 1 && loc[0].key in vf then
      var str: Option<string> :- GetVirtField(vf[loc[0].key], item); if str.None? then Success(None) else var ustr: ValidUTF8Bytes :- UTF8.Encode(str.value).MapFailure((e: string) => E(e)); Success(Some(ustr))
    else
      TermLoc.TermToBytes(loc, item)
  }

  function method VirtToString(loc: TermLoc.TermLoc, item: DDB.AttributeMap, vf: VirtualFieldMap): Result<Option<string>, Error>
    decreases loc, item, vf
  {
    if |loc| == 1 && loc[0].key in vf then
      GetVirtField(vf[loc[0].key], item)
    else
      TermLoc.TermToString(loc, item)
  }

  function method DS(s: string): DDB.AttributeValue
    decreases s
  {
    DDB.AttributeValue.S(s)
  }

  import opened Wrappers

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import opened AwsCryptographyDbEncryptionSdkDynamoDbTypes

  import opened DynamoDbEncryptionUtil

  import DDB = ComAmazonawsDynamodbTypes

  import Seq

  import TermLoc

  type VirtualFieldMap = x: map<string, ValidVirtualField>
    | IsValidVirtualFieldMap(x)

  type Examiner = TermLoc.TermLoc -> bool

  type ValidVirtualField = x: VirtField
    | x.ValidState()
    witness *

  datatype VirtField = VirtField(name: string, parts: seq<VirtPart>) {
    function method {:opaque} examine(exam: Examiner): (ret: bool)
      ensures !ret ==> forall s: VirtPart {:trigger s.loc} {:trigger s in parts} | s in parts :: !exam(s.loc)
      decreases this
    {
      Examine(parts, exam)
    }

    predicate ValidState()
      decreases this
    {
      true
    }

    function method GetFields(): seq<string>
      decreases this
    {
      Seq.Map((p: VirtPart) => p.loc[0].key, parts)
    }

    function method GetLocs(): set<TermLoc.TermLoc>
      decreases this
    {
      set p: VirtPart {:trigger p.loc} {:trigger p in parts} | p in parts :: p.loc
    }

    predicate method HasSingleLoc(loc: TermLoc.TermLoc)
      decreases this, loc
    {
      |parts| == 1 &&
      parts[0].loc == loc
    }
  }

  datatype VirtPart = VirtPart(loc: TermLoc.TermLoc, trans: seq<VirtualTransform>)
}

module TermLoc {
  predicate method ValidTermLoc(s: seq<Selector>)
    decreases s
  {
    0 < |s| < UINT64_LIMIT &&
    s[0].Map?
  }

  function method TermLocToString(t: TermLoc): string
    decreases t
  {
    t[0].key + SelectorListToString(t[1..])
  }

  function method SelectorListToString(s: SelectorList): string
    decreases s
  {
    if |s| == 0 then
      """"
    else if s[0].Map? then
      ""."" + s[0].key + SelectorListToString(s[1..])
    else
      ""["" + String.Base10Int2String(s[0].pos as int) + ""]"" + SelectorListToString(s[1..])
  }

  predicate method LacksAttribute(t: TermLoc, item: DDB.AttributeMap)
    decreases t, item
  {
    t[0].key !in item
  }

  function method TermToAttr(t: TermLoc, item: DDB.AttributeMap, names: Option<DDB.ExpressionAttributeNameMap>): Option<DDB.AttributeValue>
    decreases t, item, names
  {
    if t[0].key !in item then
      None
    else
      var res: Result<DDB.AttributeValue, Error> := GetTerminal(item[t[0].key], t[1..], names); if res.Success? then Some(res.value) else None
  }

  function method TermToString(t: TermLoc, item: DDB.AttributeMap): Result<Option<string>, Error>
    decreases t, item
  {
    var part: Option<DDB.AttributeValue> := TermToAttr(t, item, None);
    if part.None? then
      Success(None)
    else
      var res: string :- AttrValueToString(part.value); Success(Some(res))
  }

  function method TermToBytes(t: TermLoc, item: DDB.AttributeMap): Result<Option<Bytes>, Error>
    decreases t, item
  {
    var part: Option<DDB.AttributeValue> := TermToAttr(t, item, None);
    if part.None? then
      Success(None)
    else
      var res: seq<uint8> :- DynamoToStruct.TopLevelAttributeToBytes(part.value).MapFailure((e: string) => E(e)); Success(Some(res))
  }

  function method {:tailrecursion} {:opaque} GetTerminal(v: DDB.AttributeValue, parts: seq<Selector>, names: Option<DDB.ExpressionAttributeNameMap>): Result<DDB.AttributeValue, Error>
    decreases v, parts, names
  {
    if |parts| == 0 then
      Success(v)
    else
      match v { case S(s) => Failure(E(""Found string with parts left over."")) case N(s) => Failure(E(""Found number with parts left over."")) case B(b) => Failure(E(""Found binary with parts left over."")) case SS(s) => Failure(E(""Found string set with parts left over."")) case NS(s) => Failure(E(""Found number set with parts left over."")) case BS(s) => Failure(E(""Found binary set with parts left over."")) case BOOL(b) => Failure(E(""Found boolean with parts left over."")) case NULL(n) => Failure(E(""Found null with parts left over."")) case L(l) => (if !parts[0].List? then Failure(E(""Tried to access list with key"")) else if |l| <= parts[0].pos as int then Failure(E(""Tried to access beyond the end of the list"")) else GetTerminal(l[parts[0].pos], parts[1..], names)) case M(m) => if !parts[0].Map? then Failure(E(""Tried to access map with index"")) else if parts[0].key !in m then if names.Some? && parts[0].key in names.value && names.value[parts[0].key] in m then GetTerminal(m[names.value[parts[0].key]], parts[1..], names) else Failure(E(""Tried to access "" + parts[0].key + "" which is not in the map."")) else GetTerminal(m[parts[0].key], parts[1..], names) }
  }

  function method {:opaque} AttrValueToString(v: DDB.AttributeValue): Result<string, Error>
    decreases v
  {
    match v {
      case S(s) =>
        Success(s)
      case N(s) =>
        Success(s)
      case B(b) =>
        Failure(E(""Can't convert Binary to string""))
      case SS(s) =>
        Failure(E(""Can't convert String Set to string.""))
      case NS(s) =>
        Failure(E(""Can't convert Number Set to string.""))
      case BS(s) =>
        Failure(E(""Can't convert Binary Set to string.""))
      case BOOL(b) =>
        Success(if b then ""true"" else ""false"")
      case NULL(n) =>
        Success(""null"")
      case L(l) =>
        Failure(E(""Can't convert List to string.""))
      case M(m) =>
        Failure(E(""Can't convert Map to string.""))
    }
  }

  predicate AllStrings(item: DDB.AttributeMap)
    decreases item
  {
    forall x: seq<char> {:trigger item[x]} {:trigger x in item} | x in item :: 
      item[x].S?
  }

  function method {:opaque} FindStartOfNext(s: string): (index: Option<nat>)
    ensures index.Some? ==> index.value < |s| && (s[index.value] == '.' || s[index.value] == '[') && '.' !in s[..index.value] && '[' !in s[..index.value]
    ensures index.None? ==> '.' !in s && '[' !in s
    decreases s
  {
    var dot: Option<nat> := FindIndexMatching(s, '.', 0);
    var bracket: Option<nat> := FindIndexMatching(s, '[', 0);
    if dot.None? && bracket.None? then
      None
    else if dot.Some? && bracket.Some? then
      if dot.value < bracket.value then
        dot
      else
        bracket
    else if dot.Some? then
      dot
    else
      bracket
  }

  function method {:opaque} GetNumber(s: string, acc: nat := 0): Result<nat, Error>
    decreases s, acc
  {
    if |s| == 0 then
      Success(acc)
    else if '0' <= s[0] <= '9' then
      GetNumber(s[1..], acc * 10 + s[0] as nat - '0' as nat)
    else
      Failure(E(""Unexpected character in number : "" + [s[0]]))
  }

  function method {:opaque} GetSelector(s: string): (ret: Result<Selector, Error>)
    requires |s| > 0 && (s[0] == '.' || s[0] == '[')
    ensures ret.Success? ==> (s[0] == '.' ==> ret.value.Map?) && (s[0] == '[' ==> ret.value.List?)
    decreases s
  {
    if s[0] == '.' then
      Success(Map(s[1..]))
    else if s[|s| - 1] != ']' then
      Failure(E(""List index must end with ]""))
    else
      var num: nat :- GetNumber(s[1 .. |s| - 1]); :- Need(num < UINT64_LIMIT, E(""Array selector exceeds maximum."")); Success(List(num as uint64))
  }

  function method {:tailrecursion} {:opaque} GetSelectors(s: string, acc: SelectorList := []): Result<SelectorList, Error>
    requires |s| > 0 && (s[0] == '.' || s[0] == '[')
    decreases s, acc
  {
    var pos: Option<nat> := FindStartOfNext(s[1..]);
    var end: int := if pos.None? then |s| else pos.value + 1;
    var sel: Selector :- GetSelector(s[..end]); :- Need(|acc| + 1 < UINT64_LIMIT, E(""Selector Overflow"")); if pos.None? then Success(acc + [sel]) else GetSelectors(s[end..], acc + [sel])
  }

  function method {:opaque} MakeTermLoc(s: string): (ret: Result<TermLoc, Error>)
    ensures ret.Success? ==> 0 < |ret.value|
    decreases s
  {
    :- Need(0 < |s|, E(""Path specification must not be empty."")); var pos: Option<nat> := FindStartOfNext(s); if pos.None? then var m: Selector := Map(s); Success([Map(s)]) else var name: seq<char> := s[..pos.value]; var selectors: SelectorList :- GetSelectors(s[pos.value..]); :- Need(|selectors| + 1 < UINT64_LIMIT, E(""Selector Overflow"")); Success([Map(name)] + selectors)
  }

  function method TermLocMap(attr: string): TermLoc
    decreases attr
  {
    [Map(attr)]
  }

  import opened Wrappers

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import opened AwsCryptographyDbEncryptionSdkDynamoDbTypes

  import opened DynamoDbEncryptionUtil

  import String = StandardLibrary.String

  import DDB = ComAmazonawsDynamodbTypes

  import Seq

  import DynamoToStruct

  datatype Selector = List(pos: uint64) | Map(key: string)

  type Bytes = seq<uint8>

  type SelectorList = x: seq<Selector>
    | |x| < UINT64_LIMIT

  type TermLoc = x: seq<Selector>
    | ValidTermLoc(x)
    witness *
}

module DynamoToStruct {
  function method {:opaque} ItemToStructured(item: AttributeMap): (ret: Result<TerminalDataMap, Error>)
    ensures ret.Success? ==> ret.value.Keys == item.Keys
    ensures ret.Success? ==> forall kv: (AttributeName, StructuredDataTerminal) {:trigger kv.0} {:trigger kv.1} {:trigger kv in ret.value.Items} | kv in ret.value.Items :: kv.1.typeId == AttrToTypeId(item[kv.0])
    ensures ret.Success? ==> forall kv: (AttributeName, StructuredDataTerminal) {:trigger kv.1} {:trigger kv.0} {:trigger kv in ret.value.Items} | kv in ret.value.Items :: TopLevelAttributeToBytes(item[kv.0]).Success? && kv.1.value == TopLevelAttributeToBytes(item[kv.0]).value
    decreases item
  {
    var structuredMap: map<AttributeName, Result<StructuredDataTerminal, string>> := map k: AttributeName {:trigger item[k]} {:trigger k in item} | k in item :: k := AttrToStructured(item[k]);
    MapKeysMatchItems(item);
    MapError(SimplifyMapValue(structuredMap))
  }

  function method {:opaque} StructuredToItem(s: TerminalDataMap): (ret: Result<AttributeMap, Error>)
    ensures ret.Success? ==> ret.value.Keys == s.Keys
    ensures ret.Success? ==> forall k: string {:trigger IsValid_AttributeName(k)} {:trigger k in s.Keys} | k in s.Keys :: IsValid_AttributeName(k)
    ensures ret.Success? ==> forall kv: (AttributeName, AttributeValue) {:trigger kv.1} {:trigger kv.0} {:trigger kv in ret.value.Items} | kv in ret.value.Items :: StructuredToAttr(s[kv.0]).Success? && kv.1 == StructuredToAttr(s[kv.0]).value
    decreases s
  {
    if forall k: string {:trigger IsValid_AttributeName(k)} {:trigger k in s.Keys} | k in s.Keys :: IsValid_AttributeName(k) then
      var structuredData: map<AttributeName, Result<AttributeValue, string>> := map k: AttributeName {:trigger s[k]} {:trigger k in s} | k in s :: k := StructuredToAttr(s[k]);
      MapKeysMatchItems(s);
      MapError(SimplifyMapValue(structuredData))
    else
      var badNames: set<seq<char>> := set k: seq<char> {:trigger IsValid_AttributeName(k)} {:trigger k in s} | k in s && !IsValid_AttributeName(k) :: k; OneBadKey(s, badNames, IsValid_AttributeName); var orderedAttrNames: seq<seq<char>> := SetToOrderedSequence(badNames, CharLess); var attrNameList: seq<char> := Join(orderedAttrNames, "",""); MakeError(""Not valid attribute names : "" + attrNameList)
  }

  lemma RoundTripFromItem(item: AttributeValue)
    ensures item.B? && AttrToStructured(item).Success? ==> StructuredToAttr(AttrToStructured(item).value).Success?
    ensures item.NULL? && AttrToStructured(item).Success? ==> true && StructuredToAttr(AttrToStructured(item).value).Success?
    ensures item.BOOL? && AttrToStructured(item).Success? ==> StructuredToAttr(AttrToStructured(item).value).Success?
    decreases item
  {
    reveal AttrToStructured();
    reveal StructuredToAttr();
    reveal TopLevelAttributeToBytes();
    reveal AttrToBytes();
    reveal BytesToAttr();
  }

  lemma RoundTripFromStructured(s: StructuredDataTerminal)
    ensures StructuredToAttr(s).Success? && s.typeId == SE.BINARY ==> true && AttrToStructured(StructuredToAttr(s).value).Success?
    ensures StructuredToAttr(s).Success? && s.typeId == SE.BOOLEAN ==> true && AttrToStructured(StructuredToAttr(s).value).Success?
    ensures StructuredToAttr(s).Success? && s.typeId == SE.NULL ==> true && AttrToStructured(StructuredToAttr(s).value).Success?
    decreases s
  {
    reveal AttrToStructured();
    reveal StructuredToAttr();
    reveal TopLevelAttributeToBytes();
    reveal AttrToBytes();
    reveal BytesToAttr();
  }

  function method MakeError<T>(s: string): Result<T, Error>
    decreases s
  {
    Failure(Error.DynamoDbEncryptionException(message := s))
  }

  function method MapError<T>(r: Result<T, string>): Result<T, Error>
    decreases r
  {
    if r.Success? then
      Success(r.value)
    else
      MakeError(r.error)
  }

  function method {:opaque} TopLevelAttributeToBytes(a: AttributeValue): Result<seq<uint8>, string>
    decreases a
  {
    AttrToBytes(a, false)
  }

  function method {:opaque} AttrToStructured(item: AttributeValue): (ret: Result<StructuredDataTerminal, string>)
    ensures ret.Success? ==> ret.value.typeId == AttrToTypeId(item)
    ensures ret.Success? ==> TopLevelAttributeToBytes(item).Success? && ret.value.value == TopLevelAttributeToBytes(item).value
    decreases item
  {
    var body: seq<uint8> :- TopLevelAttributeToBytes(item); Success(StructuredDataTerminal(value := body, typeId := AttrToTypeId(item)))
  }

  function method {:opaque} StructuredToAttr(s: StructuredDataTerminal): (ret: Result<AttributeValue, string>)
    decreases s
  {
    :- Need(|s.typeId| == 2, ""Type ID must be two bytes""); var attrValueAndLength: AttrValueAndLength :- BytesToAttr(s.value, s.typeId, false); :- Need(attrValueAndLength.len == |s.value|, ""Mismatch between length of encoded data and length of data""); Success(attrValueAndLength.val)
  }

  const BOOL_LEN: nat := 1
  const TYPEID_LEN: nat := 2
  const LENGTH_LEN: nat := 4
  const PREFIX_LEN: nat := 6

  function method AttrToTypeId(a: AttributeValue): TerminalTypeId
    decreases a
  {
    match a {
      case S(s) =>
        SE.STRING
      case N(n) =>
        SE.NUMBER
      case B(b) =>
        SE.BINARY
      case SS(ss) =>
        SE.STRING_SET
      case NS(ns) =>
        SE.NUMBER_SET
      case BS(bs) =>
        SE.BINARY_SET
      case M(m) =>
        SE.MAP
      case L(l) =>
        SE.LIST
      case NULL(n) =>
        SE.NULL
      case BOOL(b) =>
        SE.BOOLEAN
    }
  }

  predicate method CharLess(x: char, y: char)
    decreases x, y
  {
    x < y
  }

  function method {:opaque} AttrToBytes(a: AttributeValue, prefix: bool, depth: nat := 1): (ret: Result<seq<uint8>, string>)
    ensures ret.Success? && prefix ==> 6 <= |ret.value|
    ensures MAX_STRUCTURE_DEPTH < depth ==> ret.Failure?
    ensures a.BOOL? && !prefix && depth <= MAX_STRUCTURE_DEPTH ==> (a.BOOL ==> ret.Success? && |ret.value| == BOOL_LEN && ret.value[0] == 1) && (!a.BOOL ==> ret.Success? && |ret.value| == BOOL_LEN && ret.value[0] == 0)
    ensures a.BOOL? && prefix && depth <= MAX_STRUCTURE_DEPTH ==> (a.BOOL ==> ret.Success? && |ret.value| == PREFIX_LEN + BOOL_LEN && ret.value[PREFIX_LEN] == 1 && ret.value[0 .. TYPEID_LEN] == SE.BOOLEAN && ret.value[TYPEID_LEN .. PREFIX_LEN] == [0, 0, 0, 1]) && (!a.BOOL ==> ret.Success? && |ret.value| == PREFIX_LEN + BOOL_LEN && ret.value[PREFIX_LEN] == 0 && ret.value[0 .. TYPEID_LEN] == SE.BOOLEAN && ret.value[TYPEID_LEN .. PREFIX_LEN] == [0, 0, 0, 1])
    ensures a.B? && !prefix && depth <= MAX_STRUCTURE_DEPTH ==> ret.Success? && ret.value == a.B
    ensures a.B? && prefix && ret.Success? && depth <= MAX_STRUCTURE_DEPTH ==> ret.value[PREFIX_LEN..] == a.B && ret.value[0 .. TYPEID_LEN] == SE.BINARY && U32ToBigEndian(|a.B|).Success? && ret.value[TYPEID_LEN .. PREFIX_LEN] == U32ToBigEndian(|a.B|).value && BigEndianToU32(ret.value[TYPEID_LEN .. PREFIX_LEN]).value == |a.B|
    ensures a.NULL? && !prefix && depth <= MAX_STRUCTURE_DEPTH ==> ret.Success? && |ret.value| == 0
    ensures a.NULL? && prefix && depth <= MAX_STRUCTURE_DEPTH ==> ret.Success? && |ret.value| == PREFIX_LEN && ret.value[0 .. TYPEID_LEN] == SE.NULL && ret.value[TYPEID_LEN .. PREFIX_LEN] == [0, 0, 0, 0]
    ensures a.S? && ret.Success? && !prefix ==> UTF8.Decode(ret.value).Success? && UTF8.Decode(ret.value).value == a.S
    ensures a.S? && ret.Success? && prefix ==> UTF8.Decode(ret.value[PREFIX_LEN..]).Success? && UTF8.Decode(ret.value[PREFIX_LEN..]).value == a.S && ret.value[0 .. TYPEID_LEN] == SE.STRING && UTF8.Encode(a.S).Success? && U32ToBigEndian(|UTF8.Encode(a.S).value|).Success? && ret.value[TYPEID_LEN .. PREFIX_LEN] == U32ToBigEndian(|UTF8.Encode(a.S).value|).value
    ensures a.N? && ret.Success? && !prefix ==> Norm.NormalizeNumber(a.N).Success? && var nn: string := Norm.NormalizeNumber(a.N).value; UTF8.Decode(ret.value).Success? && UTF8.Decode(ret.value).value == nn
    ensures a.N? && ret.Success? && prefix ==> Norm.NormalizeNumber(a.N).Success? && var nn: string := Norm.NormalizeNumber(a.N).value; UTF8.Decode(ret.value[PREFIX_LEN..]).Success? && UTF8.Decode(ret.value[PREFIX_LEN..]).value == nn && ret.value[0 .. TYPEID_LEN] == SE.NUMBER && UTF8.Encode(nn).Success? && U32ToBigEndian(|UTF8.Encode(nn).value|).Success? && ret.value[TYPEID_LEN .. PREFIX_LEN] == U32ToBigEndian(|UTF8.Encode(nn).value|).value
    ensures a.BS? && ret.Success? ==> Seq.HasNoDuplicates(a.BS)
    ensures a.BS? && ret.Success? && !prefix ==> U32ToBigEndian(|a.BS|).Success? && |ret.value| >= LENGTH_LEN && ret.value[0 .. LENGTH_LEN] == U32ToBigEndian(|a.BS|).value && BigEndianToU32(ret.value[0 .. LENGTH_LEN]).value == |a.BS| && (|a.BS| == 0 ==> |ret.value| == LENGTH_LEN)
    ensures a.BS? && ret.Success? && prefix ==> U32ToBigEndian(|a.BS|).Success? && |ret.value| >= PREFIX_LEN + LENGTH_LEN && ret.value[0 .. TYPEID_LEN] == SE.BINARY_SET && ret.value[PREFIX_LEN .. PREFIX_LEN + LENGTH_LEN] == U32ToBigEndian(|a.BS|).value && (|a.BS| == 0 ==> |ret.value| == PREFIX_LEN + LENGTH_LEN)
    ensures a.SS? && ret.Success? ==> Seq.HasNoDuplicates(a.SS)
    ensures a.SS? && ret.Success? && !prefix ==> U32ToBigEndian(|a.SS|).Success? && |ret.value| >= LENGTH_LEN && ret.value[0 .. LENGTH_LEN] == U32ToBigEndian(|a.SS|).value && BigEndianToU32(ret.value[0 .. LENGTH_LEN]).value == |a.SS|
    ensures a.SS? && ret.Success? && prefix ==> U32ToBigEndian(|a.SS|).Success? && |ret.value| >= PREFIX_LEN + LENGTH_LEN && ret.value[0 .. TYPEID_LEN] == SE.STRING_SET && ret.value[PREFIX_LEN .. PREFIX_LEN + LENGTH_LEN] == U32ToBigEndian(|a.SS|).value
    ensures a.NS? && ret.Success? ==> Seq.HasNoDuplicates(a.NS)
    ensures a.NS? && ret.Success? && !prefix ==> U32ToBigEndian(|a.NS|).Success? && |ret.value| >= LENGTH_LEN && ret.value[0 .. LENGTH_LEN] == U32ToBigEndian(|a.NS|).value
    ensures a.NS? && ret.Success? && prefix ==> U32ToBigEndian(|a.NS|).Success? && |ret.value| >= PREFIX_LEN + LENGTH_LEN && ret.value[0 .. TYPEID_LEN] == SE.NUMBER_SET && ret.value[PREFIX_LEN .. PREFIX_LEN + LENGTH_LEN] == U32ToBigEndian(|a.NS|).value
    ensures a.L? && ret.Success? && !prefix ==> U32ToBigEndian(|a.L|).Success? && |ret.value| >= LENGTH_LEN && ret.value[0 .. LENGTH_LEN] == U32ToBigEndian(|a.L|).value && BigEndianToU32(ret.value[0 .. LENGTH_LEN]).value == |a.L| && (|a.L| == 0 ==> |ret.value| == LENGTH_LEN)
    ensures a.L? && ret.Success? && prefix ==> U32ToBigEndian(|a.L|).Success? && |ret.value| >= PREFIX_LEN + LENGTH_LEN && ret.value[0 .. TYPEID_LEN] == SE.LIST && ListAttrToBytes(a.L, depth).Success? && ret.value[PREFIX_LEN..] == ListAttrToBytes(a.L, depth).value && ListAttrToBytes(a.L, depth).value[..LENGTH_LEN] == U32ToBigEndian(|a.L|).value && ret.value[PREFIX_LEN .. PREFIX_LEN + LENGTH_LEN] == U32ToBigEndian(|a.L|).value && (|a.L| == 0 ==> |ret.value| == PREFIX_LEN + LENGTH_LEN)
    ensures a.M? && ret.Success? && !prefix ==> U32ToBigEndian(|a.M|).Success? && |ret.value| >= LENGTH_LEN && ret.value[0 .. LENGTH_LEN] == U32ToBigEndian(|a.M|).value && BigEndianToU32(ret.value[0 .. LENGTH_LEN]).value == |a.M| && (|a.M| == 0 ==> |ret.value| == LENGTH_LEN)
    ensures a.M? && ret.Success? && prefix ==> U32ToBigEndian(|a.M|).Success? && |ret.value| >= PREFIX_LEN + LENGTH_LEN && ret.value[0 .. TYPEID_LEN] == AttrToTypeId(a) && (|a.M| == 0 ==> |ret.value| == PREFIX_LEN + LENGTH_LEN)
    decreases a
  {
    :- Need(depth <= MAX_STRUCTURE_DEPTH, ""Depth of attribute structure to serialize exceeds limit of "" + MAX_STRUCTURE_DEPTH_STR); var baseBytes: seq<uint8> :- match a { case S(s) => UTF8.Encode(s) case N(n) => (var nn: string :- Norm.NormalizeNumber(n); UTF8.Encode(nn)) case B(b) => Success(b) case SS(ss) => StringSetAttrToBytes(ss) case NS(ns) => NumberSetAttrToBytes(ns) case BS(bs) => BinarySetAttrToBytes(bs) case M(m) => MapAttrToBytes(a, m, depth) case L(l) => ListAttrToBytes(l, depth) case NULL(n) => Success([]) case BOOL(b) => Success([BoolToUint8(b)]) }; if prefix then var len: seq<uint8> :- U32ToBigEndian(|baseBytes|); Success(AttrToTypeId(a) + len + baseBytes) else Success(baseBytes)
  }

  function method StringSetAttrToBytes(ss: StringSetAttributeValue): (ret: Result<seq<uint8>, string>)
    ensures ret.Success? ==> Seq.HasNoDuplicates(ss)
    decreases ss
  {
    var asSet: set<StringAttributeValue> := Seq.ToSet(ss);
    :- Need(|asSet| == |ss|, ""String Set had duplicate values""); Seq.LemmaNoDuplicatesCardinalityOfSet(ss); var sortedList: seq<seq<char>> := SortedSets.ComputeSetToOrderedSequence2(asSet, CharLess); var count: seq<uint8> :- U32ToBigEndian(|sortedList|); var body: seq<uint8> :- CollectString(sortedList); Success(count + body)
  }

  function method NumberSetAttrToBytes(ns: NumberSetAttributeValue): (ret: Result<seq<uint8>, string>)
    ensures ret.Success? ==> Seq.HasNoDuplicates(ns)
    decreases ns
  {
    var asSet: set<NumberAttributeValue> := Seq.ToSet(ns);
    :- Need(|asSet| == |ns|, ""Number Set had duplicate values""); Seq.LemmaNoDuplicatesCardinalityOfSet(ns); var normList: seq<string> :- Seq.MapWithResult((n: seq<char>) => Norm.NormalizeNumber(n), ns); var asSet: set<seq<char>> := Seq.ToSet(normList); :- Need(|asSet| == |normList|, ""Number Set had duplicate values after normalization.""); var sortedList: seq<seq<char>> := SortedSets.ComputeSetToOrderedSequence2(asSet, CharLess); var count: seq<uint8> :- U32ToBigEndian(|sortedList|); var body: seq<uint8> :- CollectString(sortedList); Success(count + body)
  }

  function method BinarySetAttrToBytes(bs: BinarySetAttributeValue): (ret: Result<seq<uint8>, string>)
    ensures ret.Success? ==> Seq.HasNoDuplicates(bs)
    decreases bs
  {
    var asSet: set<BinaryAttributeValue> := Seq.ToSet(bs);
    :- Need(|asSet| == |bs|, ""Binary Set had duplicate values""); Seq.LemmaNoDuplicatesCardinalityOfSet(bs); var sortedList: seq<seq<uint8>> := SortedSets.ComputeSetToOrderedSequence2(asSet, ByteLess); var count: seq<uint8> :- U32ToBigEndian(|sortedList|); var body: seq<uint8> :- CollectBinary(sortedList); Success(count + body)
  }

  function method MapAttrToBytes(ghost parent: AttributeValue, m: MapAttributeValue, depth: nat): (ret: Result<seq<uint8>, string>)
    requires forall kv: (AttributeName, AttributeValue) {:trigger kv.1} {:trigger kv in m.Items} | kv in m.Items :: kv.1 < parent
    decreases parent, m, depth
  {
    var bytesResults: map<AttributeName, Result<seq<uint8>, string>> := map kv: (AttributeName, AttributeValue) {:trigger kv.1} {:trigger kv.0} {:trigger kv in m.Items} | kv in m.Items :: kv.0 := AttrToBytes(kv.1, true, depth + 1);
    var count: seq<uint8> :- U32ToBigEndian(|m|); var bytes: map<AttributeName, seq<uint8>> :- SimplifyMapValue(bytesResults); var body: seq<uint8> :- CollectMap(bytes); Success(count + body)
  }

  function method ListAttrToBytes(l: ListAttributeValue, depth: nat): (ret: Result<seq<uint8>, string>)
    ensures ret.Success? ==> U32ToBigEndian(|l|).Success? && LENGTH_LEN <= |ret.value| && ret.value[..LENGTH_LEN] == U32ToBigEndian(|l|).value
    decreases l, depth
  {
    var count: seq<uint8> :- U32ToBigEndian(|l|); var body: seq<uint8> :- CollectList(l, depth); Success(count + body)
  }

  lemma BigEndianLemma()
    ensures U32ToBigEndian(3) == Success([0, 0, 0, 3])
    ensures BigEndianToU32([0, 0, 0, 3]) == Success(3)
  {
  }

  lemma U32ToBigEndianRoundTrip(x: nat)
    ensures U32ToBigEndian(x).Success? ==> BigEndianToU32(U32ToBigEndian(x).value).Success? && BigEndianToU32(U32ToBigEndian(x).value).value == x
    decreases x
  {
  }

  lemma BigEndianToU32RoundTrip(x: seq<uint8>)
    requires |x| == 4
    ensures BigEndianToU32(x).Success? ==> U32ToBigEndian(BigEndianToU32(x).value).Success? && U32ToBigEndian(BigEndianToU32(x).value).value == x
    decreases x
  {
  }

  function method U32ToBigEndian(x: nat): (ret: Result<seq<uint8>, string>)
    ensures ret.Success? ==> |ret.value| == LENGTH_LEN
    decreases x
  {
    if x > 4294967295 then
      Failure(""Length was too big"")
    else
      Success(UInt32ToSeq(x as uint32))
  }

  function method BigEndianToU32(x: seq<uint8>): (ret: Result<nat, string>)
    decreases x
  {
    if |x| < LENGTH_LEN then
      Failure(""Length of 4-byte integer was less than 4"")
    else
      Success(SeqToUInt32(x[..LENGTH_LEN]) as nat)
  }

  predicate IsSorted<T>(s: seq<T>, lessThanOrEq: (T, T) -> bool)
    decreases s
  {
    forall j: int, k: int {:trigger s[k], s[j]} :: 
      0 <= j < k < |s| ==>
        lessThanOrEq(s[j], s[k])
  }

  function method EncodeString(s: string): (ret: Result<seq<uint8>, string>)
    ensures ret.Success? ==> UTF8.Encode(s).Success? && U32ToBigEndian(|UTF8.Encode(s).value|).Success? && |ret.value| == LENGTH_LEN + |UTF8.Encode(s).value| && ret.value[0 .. LENGTH_LEN] == U32ToBigEndian(|UTF8.Encode(s).value|).value && ret.value[LENGTH_LEN..] == UTF8.Encode(s).value
    decreases s
  {
    var val: ValidUTF8Bytes :- UTF8.Encode(s); var len: seq<uint8> :- U32ToBigEndian(|val|); Success(len + val)
  }

  function method {:tailrecursion} {:opaque} CollectString(setToSerialize: StringSetAttributeValue, serialized: seq<uint8> := []): Result<seq<uint8>, string>
    decreases setToSerialize, serialized
  {
    if |setToSerialize| == 0 then
      Success(serialized)
    else
      var entry: seq<uint8> :- EncodeString(setToSerialize[0]); CollectString(setToSerialize[1..], serialized + entry)
  }

  function method SerializeBinaryValue(b: BinaryAttributeValue): (ret: Result<seq<uint8>, string>)
    ensures ret.Success? ==> U32ToBigEndian(|b|).Success? && |ret.value| == LENGTH_LEN + |b| && ret.value[0 .. LENGTH_LEN] == U32ToBigEndian(|b|).value && ret.value[LENGTH_LEN..] == b
    decreases b
  {
    var len: seq<uint8> :- U32ToBigEndian(|b|); Success(len + b)
  }

  function method {:tailrecursion} CollectBinary(setToSerialize: BinarySetAttributeValue, serialized: seq<uint8> := []): Result<seq<uint8>, string>
    decreases setToSerialize, serialized
  {
    if |setToSerialize| == 0 then
      Success(serialized)
    else
      var item: seq<uint8> :- SerializeBinaryValue(setToSerialize[0]); CollectBinary(setToSerialize[1..], serialized + item)
  }

  function method {:opaque} CollectList(listToSerialize: ListAttributeValue, depth: nat, serialized: seq<uint8> := []): (ret: Result<seq<uint8>, string>)
    ensures ret.Success? && |listToSerialize| == 0 ==> ret.value == serialized
    ensures ret.Success? && |listToSerialize| == 0 ==> |ret.value| == |serialized|
    decreases listToSerialize, depth, serialized
  {
    if |listToSerialize| == 0 then
      Success(serialized)
    else
      var val: seq<uint8> :- AttrToBytes(listToSerialize[0], true, depth + 1); CollectList(listToSerialize[1..], depth, serialized + val)
  }

  function method SerializeMapItem(key: string, value: seq<uint8>): (ret: Result<seq<uint8>, string>)
    ensures ret.Success? ==> |ret.value| >= TYPEID_LEN && ret.value[0 .. TYPEID_LEN] == SE.STRING && UTF8.Encode(key).Success? && |ret.value| == TYPEID_LEN + LENGTH_LEN + |UTF8.Encode(key).value| + |value| && UTF8.Decode(ret.value[TYPEID_LEN + LENGTH_LEN .. TYPEID_LEN + LENGTH_LEN + |UTF8.Encode(key).value|]).Success? && UTF8.Decode(ret.value[TYPEID_LEN + LENGTH_LEN .. TYPEID_LEN + LENGTH_LEN + |UTF8.Encode(key).value|]).value == key
    ensures ret.Success? ==> UTF8.Encode(key).Success? && U32ToBigEndian(|UTF8.Encode(key).value|).Success? && |ret.value| >= TYPEID_LEN + LENGTH_LEN && ret.value[TYPEID_LEN .. TYPEID_LEN + LENGTH_LEN] == U32ToBigEndian(|UTF8.Encode(key).value|).value
    decreases key, value
  {
    var name: ValidUTF8Bytes :- UTF8.Encode(key); assert UTF8.Decode(name).Success?; var len: seq<uint8> :- U32ToBigEndian(|name|); var serialized: seq<uint8> := SE.STRING + len + name + value; assert |serialized| == TYPEID_LEN + LENGTH_LEN + |name| + |value|; Success(serialized)
  }

  function method {:tailrecursion} {:opaque} CollectMap(mapToSerialize: map<AttributeName, seq<uint8>>, serialized: seq<uint8> := []): (ret: Result<seq<uint8>, string>)
    ensures ret.Success? && |mapToSerialize| == 0 ==> ret.value == serialized
    ensures ret.Success? && |mapToSerialize| == 0 ==> |ret.value| == |serialized|
    decreases mapToSerialize, serialized
  {
    var keys: seq<seq<char>> := SortedSets.ComputeSetToOrderedSequence2(mapToSerialize.Keys, CharLess);
    CollectOrderedMapSubset(keys, mapToSerialize, serialized)
  }

  function method {:tailrecursion} {:opaque} CollectOrderedMapSubset(keys: seq<AttributeName>, mapToSerialize: map<AttributeName, seq<uint8>>, serialized: seq<uint8> := []): (ret: Result<seq<uint8>, string>)
    requires forall k: AttributeName {:trigger k in mapToSerialize} {:trigger k in keys} | k in keys :: k in mapToSerialize
    ensures ret.Success? && |keys| == 0 ==> ret.value == serialized
    ensures ret.Success? && |keys| == 0 ==> |ret.value| == |serialized|
    decreases keys, mapToSerialize, serialized
  {
    if |keys| == 0 then
      Success(serialized)
    else
      var data: seq<uint8> :- SerializeMapItem(keys[0], mapToSerialize[keys[0]]); CollectOrderedMapSubset(keys[1..], mapToSerialize, serialized + data)
  }

  function method BoolToUint8(b: bool): uint8
    decreases b
  {
    if b then
      1
    else
      0
  }

  predicate method IsUnique<T(==)>(s: seq<T>)
    decreases s
  {
    |set x: T {:trigger x in s} | x in s :: x| == |s|
  }

  function method {:tailrecursion} {:vcs_split_on_every_assert} {:opaque} DeserializeBinarySet(serialized: seq<uint8>, remainingCount: nat, origSerializedSize: nat, resultSet: AttrValueAndLength): (ret: Result<AttrValueAndLength, string>)
    requires resultSet.val.BS?
    requires |serialized| + resultSet.len == origSerializedSize
    ensures ret.Success? ==> ret.value.val.BS?
    ensures ret.Success? ==> ret.value.len <= origSerializedSize
    ensures ret.Success? && remainingCount == 0 ==> IsUnique(resultSet.val.BS)
    decreases serialized, remainingCount, origSerializedSize, resultSet
  {
    if remainingCount == 0 then
      :- Need(IsUnique(resultSet.val.BS), ""Binary set values must not have duplicates""); Success(resultSet)
    else if |serialized| < LENGTH_LEN then
      Failure(""Out of bytes reading Binary Set"")
    else
      var len: nat :- BigEndianToU32(serialized); var serialized: seq<BoundedInts.uint8> := serialized[LENGTH_LEN..]; if |serialized| < len as int then Failure(""Binary Set Structured Data has too few bytes"") else var nattr: AttributeValue := AttributeValue.BS(resultSet.val.BS + [serialized[..len]]); DeserializeBinarySet(serialized[len..], remainingCount - 1, origSerializedSize, AttrValueAndLength(nattr, resultSet.len + len + LENGTH_LEN))
  }

  function method {:tailrecursion} {:vcs_split_on_every_assert} {:opaque} DeserializeStringSet(serialized: seq<uint8>, remainingCount: nat, origSerializedSize: nat, resultSet: AttrValueAndLength): (ret: Result<AttrValueAndLength, string>)
    requires resultSet.val.SS?
    requires |serialized| + resultSet.len == origSerializedSize
    ensures ret.Success? ==> ret.value.val.SS?
    ensures ret.Success? ==> ret.value.len <= origSerializedSize
    ensures ret.Success? && remainingCount == 0 ==> IsUnique(resultSet.val.SS)
    decreases serialized, remainingCount, origSerializedSize, resultSet
  {
    if remainingCount == 0 then
      :- Need(IsUnique(resultSet.val.SS), ""String set values must not have duplicates""); Success(resultSet)
    else if |serialized| < LENGTH_LEN then
      Failure(""Out of bytes reading String Set"")
    else
      var len: nat :- BigEndianToU32(serialized); var serialized: seq<BoundedInts.uint8> := serialized[LENGTH_LEN..]; if |serialized| < len as int then Failure(""String Set Structured Data has too few bytes"") else var nstring: string :- UTF8.Decode(serialized[..len]); var nattr: AttributeValue := AttributeValue.SS(resultSet.val.SS + [nstring]); DeserializeStringSet(serialized[len..], remainingCount - 1, origSerializedSize, AttrValueAndLength(nattr, resultSet.len + len + LENGTH_LEN))
  }

  function method {:tailrecursion} {:vcs_split_on_every_assert} {:opaque} DeserializeNumberSet(serialized: seq<uint8>, remainingCount: nat, origSerializedSize: nat, resultSet: AttrValueAndLength): (ret: Result<AttrValueAndLength, string>)
    requires resultSet.val.NS?
    requires |serialized| + resultSet.len == origSerializedSize
    ensures ret.Success? ==> ret.value.val.NS?
    ensures ret.Success? ==> ret.value.len <= origSerializedSize
    ensures ret.Success? && remainingCount == 0 ==> IsUnique(resultSet.val.NS)
    decreases serialized, remainingCount, origSerializedSize, resultSet
  {
    if remainingCount == 0 then
      :- Need(IsUnique(resultSet.val.NS), ""Number set values must not have duplicates""); Success(resultSet)
    else if |serialized| < LENGTH_LEN then
      Failure(""Out of bytes reading String Set"")
    else
      var len: nat :- BigEndianToU32(serialized); var serialized: seq<BoundedInts.uint8> := serialized[LENGTH_LEN..]; if |serialized| < len as int then Failure(""Number Set Structured Data has too few bytes"") else var nstring: string :- UTF8.Decode(serialized[..len]); var nattr: AttributeValue := AttributeValue.NS(resultSet.val.NS + [nstring]); DeserializeNumberSet(serialized[len..], remainingCount - 1, origSerializedSize, AttrValueAndLength(nattr, resultSet.len + len + LENGTH_LEN))
  }

  function method {:vcs_split_on_every_assert} {:opaque} DeserializeList(serialized: seq<uint8>, remainingCount: nat, ghost origSerializedSize: nat, depth: nat, resultList: AttrValueAndLength): (ret: Result<AttrValueAndLength, string>)
    requires resultList.val.L?
    requires |serialized| + resultList.len == origSerializedSize
    ensures ret.Success? ==> ret.value.val.L?
    ensures ret.Success? ==> ret.value.len <= origSerializedSize
    decreases |serialized|
  {
    if remainingCount == 0 then
      Success(resultList)
    else if |serialized| < 6 then
      Failure(""Out of bytes reading Type of List element"")
    else
      var TerminalTypeId: seq<BoundedInts.uint8> := serialized[0 .. 2]; var serialized: seq<BoundedInts.uint8> := serialized[2..]; var len: nat :- BigEndianToU32(serialized); var serialized: seq<BoundedInts.uint8> := serialized[LENGTH_LEN..]; if |serialized| < len then Failure(""Out of bytes reading Content of List element"") else var nval: AttrValueAndLength :- BytesToAttr(serialized[..len], TerminalTypeId, false, depth + 1); var nattr: AttributeValue := AttributeValue.L(resultList.val.L + [nval.val]); DeserializeList(serialized[len..], remainingCount - 1, origSerializedSize, depth, AttrValueAndLength(nattr, resultList.len + len + 6))
  }

  function method {:vcs_split_on_every_assert} {:opaque} DeserializeMap(serialized: seq<uint8>, remainingCount: nat, ghost origSerializedSize: nat, depth: nat, resultMap: AttrValueAndLength): (ret: Result<AttrValueAndLength, string>)
    requires resultMap.val.M?
    requires |serialized| + resultMap.len == origSerializedSize
    ensures ret.Success? ==> ret.value.val.M?
    ensures ret.Success? ==> ret.value.len <= origSerializedSize
    decreases |serialized|
  {
    ghost var serializedInitial: seq<uint8> := serialized;
    if remainingCount == 0 then
      Success(resultMap)
    else
      :- Need(6 <= |serialized|, ""Out of bytes reading Map Key""); var TerminalTypeId_key: seq<BoundedInts.uint8> := serialized[0 .. 2]; :- Need(TerminalTypeId_key == SE.STRING, ""Key of Map is not String""); var serialized: seq<BoundedInts.uint8> := serialized[2..]; var len: nat :- BigEndianToU32(serialized); var serialized: seq<BoundedInts.uint8> := serialized[LENGTH_LEN..]; :- Need(len as int <= |serialized|, ""Key of Map of Structured Data has too few bytes""); var key: string :- UTF8.Decode(serialized[..len]); var serialized: seq<BoundedInts.uint8> := serialized[len..]; assert |serialized| + 6 + len == |serializedInitial|; :- Need(2 <= |serialized|, ""Out of bytes reading Map Value""); :- Need(IsValid_AttributeName(key), ""Key is not valid AttributeName""); var TerminalTypeId_value: seq<BoundedInts.uint8> := serialized[0 .. 2]; var serialized: seq<BoundedInts.uint8> := serialized[2..]; var nval: AttrValueAndLength :- BytesToAttr(serialized, TerminalTypeId_value, true, depth + 1); var serialized: seq<BoundedInts.uint8> := serialized[nval.len..]; :- Need(key !in resultMap.val.M, ""Duplicate key in map.""); var nattr: AttributeValue := AttributeValue.M(resultMap.val.M[key := nval.val]); var newResultMap: AttrValueAndLength := AttrValueAndLength(nattr, resultMap.len + nval.len + 8 + len); assert |serialized| + newResultMap.len == origSerializedSize; DeserializeMap(serialized, remainingCount - 1, origSerializedSize, depth, newResultMap)
  }

  function method {:vcs_split_on_every_assert} {:opaque} BytesToAttr(value: seq<uint8>, typeId: TerminalTypeId, hasLen: bool, depth: nat := 1): (ret: Result<AttrValueAndLength, string>)
    ensures ret.Success? ==> ret.value.len <= |value|
    ensures MAX_STRUCTURE_DEPTH < depth ==> ret.Failure?
    decreases |value|
  {
    :- Need(depth <= MAX_STRUCTURE_DEPTH, ""Depth of attribute structure to deserialize exceeds limit of "" + MAX_STRUCTURE_DEPTH_STR); var len: int :- if hasLen then if |value| < LENGTH_LEN then Failure(""Out of bytes reading length"") else BigEndianToU32(value) else Success(|value|); var value: seq<BoundedInts.uint8> := if hasLen then value[LENGTH_LEN..] else value; var lengthBytes: int := if hasLen then LENGTH_LEN else 0; if |value| < len then Failure(""Structured Data has too few bytes"") else if typeId == SE.NULL then if len != 0 then Failure(""NULL type did not have length zero"") else Success(AttrValueAndLength(AttributeValue.NULL(true), lengthBytes)) else if typeId == SE.STRING then var str: string :- UTF8.Decode(value[..len]); Success(AttrValueAndLength(AttributeValue.S(str), len + lengthBytes)) else if typeId == SE.NUMBER then var str: string :- UTF8.Decode(value[..len]); Success(AttrValueAndLength(AttributeValue.N(str), len + lengthBytes)) else if typeId == SE.BINARY then Success(AttrValueAndLength(AttributeValue.B(value[..len]), len + lengthBytes)) else if typeId == SE.BOOLEAN then if len != BOOL_LEN then Failure(""Boolean Structured Data has more than one byte"") else if value[0] == 0 then Success(AttrValueAndLength(AttributeValue.BOOL(false), BOOL_LEN + lengthBytes)) else if value[0] == 1 then Success(AttrValueAndLength(AttributeValue.BOOL(true), BOOL_LEN + lengthBytes)) else Failure(""Boolean Structured Data had inappropriate value"") else if typeId == SE.STRING_SET then if |value| < LENGTH_LEN then Failure(""String Set Structured Data has less than LENGTH_LEN bytes"") else var len: nat :- BigEndianToU32(value); var value: seq<BoundedInts.uint8> := value[LENGTH_LEN..]; DeserializeStringSet(value, len, |value| + LENGTH_LEN + lengthBytes, AttrValueAndLength(AttributeValue.SS([]), LENGTH_LEN + lengthBytes)) else if typeId == SE.NUMBER_SET then if |value| < LENGTH_LEN then Failure(""Number Set Structured Data has less than 4 bytes"") else var len: nat :- BigEndianToU32(value); var value: seq<BoundedInts.uint8> := value[LENGTH_LEN..]; DeserializeNumberSet(value, len, |value| + LENGTH_LEN + lengthBytes, AttrValueAndLength(AttributeValue.NS([]), LENGTH_LEN + lengthBytes)) else if typeId == SE.BINARY_SET then if |value| < LENGTH_LEN then Failure(""Binary Set Structured Data has less than LENGTH_LEN bytes"") else var len: nat :- BigEndianToU32(value); var value: seq<BoundedInts.uint8> := value[LENGTH_LEN..]; DeserializeBinarySet(value, len, |value| + LENGTH_LEN + lengthBytes, AttrValueAndLength(AttributeValue.BS([]), LENGTH_LEN + lengthBytes)) else if typeId == SE.MAP then if |value| < LENGTH_LEN then Failure(""List Structured Data has less than 4 bytes"") else var len: nat :- BigEndianToU32(value); var value: seq<BoundedInts.uint8> := value[LENGTH_LEN..]; DeserializeMap(value, len, |value| + LENGTH_LEN + lengthBytes, depth, AttrValueAndLength(AttributeValue.M(map[]), LENGTH_LEN + lengthBytes)) else if typeId == SE.LIST then if |value| < LENGTH_LEN then Failure(""List Structured Data has less than 4 bytes"") else var len: nat :- BigEndianToU32(value); var value: seq<BoundedInts.uint8> := value[LENGTH_LEN..]; DeserializeList(value, len, |value| + LENGTH_LEN + lengthBytes, depth, AttrValueAndLength(AttributeValue.L([]), LENGTH_LEN + lengthBytes)) else Failure(""Unsupported TerminalTypeId"")
  }

  function method FlattenValueMap<X, Y>(m: map<X, Result<Y, string>>): map<X, Y>
    decreases m
  {
    map k: X {:trigger m[k]} {:trigger k in m} | k in m && m[k].Success? :: k := m[k].value
  }

  function method FlattenErrors<X, Y>(m: map<X, Result<Y, string>>): set<string>
    decreases m
  {
    set k: X {:trigger m[k]} {:trigger k in m} | k in m && m[k].Failure? :: m[k].error
  }

  lemma OneBadResult<X, Y>(m: map<X, Result<Y, string>>)
    requires !forall k: X {:trigger m[k]} {:trigger k in m} | k in m :: m[k].Success?
    ensures exists k: X {:trigger m[k]} {:trigger k in m} | k in m :: m[k].Failure?
    ensures |FlattenErrors(m)| > 0
    decreases m
  {
    assert exists k: X {:trigger m[k]} {:trigger k in m} | k in m :: m[k].Failure?;
    ghost var errors := FlattenErrors(m);
    assert exists k: X {:trigger m[k]} {:trigger k in m} :: k in m && m[k].Failure? && m[k].error in errors;
  }

  lemma MapKeysMatchItems<X, Y>(m: map<X, Y>)
    ensures forall k: X {:trigger m[k]} {:trigger k in m.Keys} :: k in m.Keys ==> (k, m[k]) in m.Items
    decreases m
  {
  }

  lemma OneBadKey<X, Y>(s: map<X, Y>, bad: set<X>, f: X -> bool)
    requires !forall k: X {:trigger f(k)} {:trigger k in s.Keys} | k in s.Keys :: f(k)
    requires bad == set k: X {:trigger f(k)} {:trigger k in s.Keys} | k in s.Keys && !f(k) :: k
    ensures exists k: X {:trigger f(k)} {:trigger k in s.Keys} | k in s.Keys :: !f(k)
    ensures |bad| > 0
    decreases s, bad
  {
    assert exists v: X {:trigger f(v)} {:trigger v in bad} :: v in bad && !f(v) && v in bad;
  }

  lemma SimplifyMapValueSuccess<X, Y>(m: map<X, Result<Y, string>>)
    ensures SimplifyMapValue(m).Success? <==> forall k: X {:trigger m[k]} {:trigger k in m} | k in m :: m[k].Success?
    ensures SimplifyMapValue(m).Success? ==> forall kv: (X, Result<Y, string>) {:trigger kv.1} {:trigger kv in m.Items} | kv in m.Items :: kv.1.Success?
    ensures SimplifyMapValue(m).Failure? <==> exists k: X {:trigger m[k]} {:trigger k in m.Keys} | k in m.Keys :: m[k].Failure?
    decreases m
  {
  }

  function method SimplifyMapValue<X, Y>(m: map<X, Result<Y, string>>): (ret: Result<map<X, Y>, string>)
    ensures ret.Success? ==> ret.value.Keys == m.Keys
    ensures ret.Success? ==> |ret.value.Keys| == |m.Keys|
    ensures ret.Success? ==> |ret.value| == |m|
    decreases m
  {
    if forall k: X {:trigger m[k]} {:trigger k in m} | k in m :: m[k].Success? then
      var result: map<X, Y> := FlattenValueMap(m);
      MapKeysMatchItems(m);
      Success(result)
    else
      OneBadResult(m); var badValues: set<string> := FlattenErrors(m); assert |badValues| > 0; var badValueSeq: seq<seq<char>> := SetToOrderedSequence(badValues, CharLess); Failure(Join(badValueSeq, ""\n""))
  }

  import opened ComAmazonawsDynamodbTypes

  import opened AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes

  import opened Wrappers

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import opened DynamoDbEncryptionUtil

  import AwsCryptographyDbEncryptionSdkDynamoDbTypes

  import UTF8

  import SortedSets

  import Seq

  import Norm = DynamoDbNormalizeNumber

  import SE = StructuredEncryptionUtil

  type Error = AwsCryptographyDbEncryptionSdkDynamoDbTypes.Error

  type TerminalDataMap = map<AttributeName, StructuredDataTerminal>

  datatype AttrValueAndLength = AttrValueAndLength(val: AttributeValue, len: nat)
}

module DynamoDbNormalizeNumber {
  function method {:tailrecursion} SkipLeadingZeros(val: string): (ret: string)
    decreases val
  {
    if 1 < |val| && val[0] == '0' && val[1] != '.' then
      SkipLeadingZeros(val[1..])
    else
      val
  }

  function method {:tailrecursion} SkipTrailingZeros(val: string): (ret: string)
    requires '.' in val
    decreases val
  {
    if 1 < |val| && val[|val| - 1] == '0' then
      if val[|val| - 2] == '.' then
        val[..|val| - 2]
      else
        SkipTrailingZeros(val[..|val| - 1])
    else
      val
  }

  function method {:tailrecursion} SkipAllTrailingZeros(val: string): (ret: string)
    ensures |ret| == 0 || ret[|ret| - 1] != '0'
    decreases val
  {
    if 0 < |val| && val[|val| - 1] == '0' then
      SkipAllTrailingZeros(val[..|val| - 1])
    else
      val
  }

  predicate method IsDecimalDigit(ch: char)
    decreases ch
  {
    '0' <= ch <= '9'
  }

  predicate AllDecimalDigits(s: string)
    decreases s
  {
    forall k: char {:trigger IsDecimalDigit(k)} {:trigger k in s} | k in s :: 
      IsDecimalDigit(k)
  }

  function method {:tailrecursion} StrToIntInner(s: string, acc: nat := 0): Result<nat, string>
    decreases s, acc
  {
    if |s| == 0 then
      Success(acc)
    else if IsDecimalDigit(s[0]) then
      StrToIntInner(s[1..], acc * 10 + s[0] as int - '0' as int)
    else
      Failure(""The character '"" + s[..1] + ""' is not a valid decimal digit."")
  }

  function method {:tailrecursion} StrToInt(s: string): Result<int, string>
    decreases s
  {
    if |s| == 0 then
      Failure(""An empty string is not a valid number."")
    else if s[0] == '-' then
      :- Need(1 < |s|, ""An empty string is not a valid number.""); var x: nat :- StrToIntInner(s[1..]); Success(-(x as int))
    else if s[0] == '+' then
      :- Need(1 < |s|, ""An empty string is not a valid number.""); StrToIntInner(s[1..])
    else
      StrToIntInner(s)
  }

  function method Zeros(n: nat): (ret: string)
    ensures AllDecimalDigits(ret)
    decreases n
  {
    seq(n, (i: int) => '0')
  }

  function method CountDigits(s: string): (ret: nat)
    ensures ret <= |s|
    ensures forall k: char {:trigger IsDecimalDigit(k)} {:trigger k in s[..ret]} | k in s[..ret] :: IsDecimalDigit(k)
    decreases s
  {
    if |s| == 0 then
      0
    else if IsDecimalDigit(s[0]) then
      1 + CountDigits(s[1..])
    else
      0
  }

  predicate method IsE(ch: char)
    decreases ch
  {
    ch == 'e' || ch == 'E'
  }

  function method ParseNumber(n: string): (ret: Result<(string, nat, int), string>)
    ensures ret.Success? ==> ret.value.1 <= |ret.value.0| && forall k: char {:trigger IsDecimalDigit(k)} {:trigger k in ret.value.0} | k in ret.value.0 :: IsDecimalDigit(k)
    decreases n
  {
    var preDot: nat := CountDigits(n);
    if |n| == preDot then
      Success((n, |n|, 0))
    else if n[preDot] == '.' then
      var postDot: nat := CountDigits(n[preDot + 1..]);
      :- Need(0 < preDot + postDot, ""Number needs digits either before or after the decimal point.""); var len: int := preDot + postDot + 1; if len == |n| then Success((n[0 .. preDot] + n[preDot + 1..], preDot, 0)) else if IsE(n[len]) then var exp: int :- StrToInt(n[len + 1..]); Success((n[0 .. preDot] + n[preDot + 1 .. len], preDot, exp)) else Failure(""Invalid Character in number at '"" + n[len..] + ""'."")
    else if preDot == 0 then
      Failure(""Number needs digits either before or after the decimal point."")
    else if IsE(n[preDot]) then
      var exp: int :- StrToInt(n[preDot + 1..]); Success((n[..preDot], preDot, exp))
    else
      Failure(""Invalid Character in number at '"" + n[preDot..] + ""'."")
  }

  function method CountZeros(value: string): (ret: nat)
    ensures ret <= |value|
    ensures Zeros(ret) <= value
    ensures ret == |value| || value[ret] != '0'
    decreases value
  {
    if |value| == 0 || value[0] != '0' then
      0
    else
      1 + CountZeros(value[1..])
  }

  function method NormalizeValue(value: string, pos: nat): (ret: (string, nat))
    requires pos <= |value|
    requires AllDecimalDigits(value)
    ensures ret.1 <= |ret.0|
    ensures AllDecimalDigits(ret.0)
    decreases value, pos
  {
    if |value| == 0 then
      (value, pos)
    else if value[0] == '0' && pos > 0 then
      NormalizeValue(value[1..], pos - 1)
    else if value[|value| - 1] == '0' && pos < |value| then
      NormalizeValue(value[..|value| - 1], pos)
    else
      (value, pos)
  }

  function method NormalizePositive(n: string): (ret: Result<string, string>)
    requires 0 < |n|
    ensures ret.Success? ==> 0 < |ret.value| && IsDecimalDigit(ret.value[0])
    decreases n
  {
    var (value: string, pos: nat, exp: int) :- ParseNumber(n); var (value: string, pos: nat) := NormalizeValue(value, pos); var digitsOfPrecision: string := SkipAllTrailingZeros(SkipLeadingZeros(value)); :- Need(|digitsOfPrecision| <= 38, ""Attempting to store more than 38 significant digits in a Number.""); var newPos: int := pos + exp; if |digitsOfPrecision| == 0 then Success(""0"") else if newPos <= 0 then :- Need(newPos - CountZeros(value) >= -129, ""Attempting to store a number with magnitude smaller than supported range.""); Success(""0."" + Zeros(-newPos) + value) else if newPos >= |value| then :- Need(newPos - CountZeros(value) <= 126, ""Attempting to store a number with magnitude larger than supported range.""); Success(value + Zeros(newPos - |value|)) else Success(value[..newPos] + ""."" + value[newPos..])
  }

  function method TrimZerosFromValidNumber(n: string): (ret: string)
    decreases n
  {
    var n: string := SkipLeadingZeros(n);
    if '.' in n then
      SkipTrailingZeros(n)
    else
      n
  }

  function method NormalizeNumber2(n: string): Result<string, string>
    decreases n
  {
    :- Need(0 < |n|, ""An empty string is not a valid number.""); var (neg: bool, n: seq<char>) := if n[0] == '-' then (true, n[1..]) else if n[0] == '+' then (false, n[1..]) else (false, n); :- Need(0 < |n|, ""An empty string is not a valid number.""); var n: string :- NormalizePositive(n); var n: string := TrimZerosFromValidNumber(n); if neg && n != ""0"" then Success(['-'] + n) else Success(n)
  }

  function method NormalizeNumber(n: string): Result<string, string>
    decreases n
  {
    var ret: Result<string, string> := NormalizeNumber2(n);
    if ret.Success? then
      ret
    else
      Failure(ret.error + "" when parsing '"" + n + ""'."")
  }

  import opened StandardLibrary

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened DynamoDbEncryptionUtil

  import Seq
}

module DynamoDbEncryptionUtil {
  const ReservedPrefix := ""aws_dbe_""
  const BeaconPrefix := ""aws_dbe_b_""
  const VersionPrefix := ""aws_dbe_v_""
  const MAX_STRUCTURE_DEPTH := 32
  const MAX_STRUCTURE_DEPTH_STR := ""32""

  function method MaybeFromOptionKeyId(x: Option<string>): MaybeKeyId
    decreases x
  {
    if x.Some? then
      KeyId(x.value)
    else
      DontUseKeyId
  }

  function method E(s: string): Error
    decreases s
  {
    DynamoDbEncryptionException(message := s)
  }

  predicate method CharLess(x: char, y: char)
    decreases x, y
  {
    x < y
  }

  predicate method ByteLess(x: uint8, y: uint8)
    decreases x, y
  {
    x < y
  }

  function method AttrTypeToStr(attr: DDB.AttributeValue): string
    decreases attr
  {
    match attr {
      case S(s) =>
        ""S""
      case N(n) =>
        ""N""
      case B(n) =>
        ""B""
      case SS(n) =>
        ""SS""
      case NS(n) =>
        ""NS""
      case BS(n) =>
        ""BS""
      case M(n) =>
        ""M""
      case L(n) =>
        ""L""
      case NULL(n) =>
        ""NULL""
      case BOOL(n) =>
        ""BOOL""
    }
  }

  function printFromFunction<T>(x: T): ()
  {
    ()
  } by method {
    print x, ""\n"";
    return ();
  }

  import opened AwsCryptographyDbEncryptionSdkDynamoDbTypes

  import opened Wrappers

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import DDB = ComAmazonawsDynamodbTypes

  type HmacKeyMap = map<string, Bytes>

  datatype MaybeKeyMap = DontUseKeys | ShouldHaveKeys | Keys(value: HmacKeyMap)

  datatype MaybeKeyId = DontUseKeyId | ShouldHaveKeyId | KeyId(value: string)

  type Bytes = seq<uint8>
}

module {:extern ""software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types""} AwsCryptographyDbEncryptionSdkDynamoDbTypes {
  predicate method IsValid_BeaconBitLength(x: int32)
    decreases x
  {
    1 <= x <= 63
  }

  predicate method IsValid_BeaconVersionList(x: seq<BeaconVersion>)
    decreases x
  {
    1 <= |x| <= 1
  }

  predicate method IsValid_Char(x: string)
    decreases x
  {
    1 <= |x| <= 1
  }

  predicate method IsValid_CompoundBeaconList(x: seq<CompoundBeacon>)
    decreases x
  {
    1 <= |x|
  }

  predicate method IsValid_ConstructorList(x: seq<Constructor>)
    decreases x
  {
    1 <= |x|
  }

  predicate method IsValid_ConstructorPartList(x: seq<ConstructorPart>)
    decreases x
  {
    1 <= |x|
  }

  predicate method IsValid_EncryptedPartsList(x: seq<EncryptedPart>)
    decreases x
  {
    1 <= |x|
  }

  predicate method IsValid_Prefix(x: string)
    decreases x
  {
    1 <= |x|
  }

  predicate method IsValid_SignedPartsList(x: seq<SignedPart>)
    decreases x
  {
    1 <= |x|
  }

  predicate method IsValid_StandardBeaconList(x: seq<StandardBeacon>)
    decreases x
  {
    1 <= |x|
  }

  predicate method IsValid_TerminalLocation(x: string)
    decreases x
  {
    1 <= |x|
  }

  predicate method IsValid_VersionNumber(x: int32)
    decreases x
  {
    1 <= x
  }

  predicate method IsValid_VirtualFieldList(x: seq<VirtualField>)
    decreases x
  {
    1 <= |x|
  }

  predicate method IsValid_VirtualPartList(x: seq<VirtualPart>)
    decreases x
  {
    1 <= |x|
  }

  predicate method IsValid_VirtualTransformList(x: seq<VirtualTransform>)
    decreases x
  {
    1 <= |x|
  }

  predicate method IsDummySubsetType(x: int)
    decreases x
  {
    0 < x
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes

  import AwsCryptographyMaterialProvidersTypes

  import AwsCryptographyKeyStoreTypes

  import AwsCryptographyPrimitivesTypes

  import ComAmazonawsDynamodbTypes

  datatype DafnyCallEvent<I, O> = DafnyCallEvent(input: I, output: O)

  datatype AsSet = AsSet

  type AttributeActions = map<ComAmazonawsDynamodbTypes.AttributeName, AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.CryptoAction>

  type BeaconBitLength = x: int32
    | IsValid_BeaconBitLength(x)
    witness *

  datatype BeaconKeySource = single(single: SingleKeyStore) | multi(multi: MultiKeyStore)

  datatype BeaconStyle = partOnly(partOnly: PartOnly) | shared(shared: Shared) | asSet(asSet: AsSet) | sharedSet(sharedSet: SharedSet)

  datatype BeaconVersion = BeaconVersion(nameonly version: VersionNumber, nameonly keyStore: AwsCryptographyKeyStoreTypes.IKeyStoreClient, nameonly keySource: BeaconKeySource, nameonly standardBeacons: StandardBeaconList, nameonly compoundBeacons: Option<CompoundBeaconList> := Option.None, nameonly virtualFields: Option<VirtualFieldList> := Option.None, nameonly encryptedParts: Option<EncryptedPartsList> := Option.None, nameonly signedParts: Option<SignedPartsList> := Option.None)

  type BeaconVersionList = x: seq<BeaconVersion>
    | IsValid_BeaconVersionList(x)
    witness *

  type Char = x: string
    | IsValid_Char(x)
    witness *

  datatype CompoundBeacon = CompoundBeacon(nameonly name: string, nameonly split: Char, nameonly encrypted: Option<EncryptedPartsList> := Option.None, nameonly signed: Option<SignedPartsList> := Option.None, nameonly constructors: Option<ConstructorList> := Option.None)

  type CompoundBeaconList = x: seq<CompoundBeacon>
    | IsValid_CompoundBeaconList(x)
    witness *

  datatype Constructor = Constructor(nameonly parts: ConstructorPartList)

  type ConstructorList = x: seq<Constructor>
    | IsValid_ConstructorList(x)
    witness *

  datatype ConstructorPart = ConstructorPart(nameonly name: string, nameonly required: bool)

  type ConstructorPartList = x: seq<ConstructorPart>
    | IsValid_ConstructorPartList(x)
    witness *

  datatype CreateDynamoDbEncryptionBranchKeyIdSupplierInput = CreateDynamoDbEncryptionBranchKeyIdSupplierInput(nameonly ddbKeyBranchKeyIdSupplier: IDynamoDbKeyBranchKeyIdSupplier)

  datatype CreateDynamoDbEncryptionBranchKeyIdSupplierOutput = CreateDynamoDbEncryptionBranchKeyIdSupplierOutput(nameonly branchKeyIdSupplier: AwsCryptographyMaterialProvidersTypes.IBranchKeyIdSupplier)

  class IDynamoDbEncryptionClientCallHistory {
    ghost constructor ()
    {
      CreateDynamoDbEncryptionBranchKeyIdSupplier := [];
      GetEncryptedDataKeyDescription := [];
    }

    ghost var CreateDynamoDbEncryptionBranchKeyIdSupplier: seq<DafnyCallEvent<CreateDynamoDbEncryptionBranchKeyIdSupplierInput, Result<CreateDynamoDbEncryptionBranchKeyIdSupplierOutput, Error>>>
    ghost var GetEncryptedDataKeyDescription: seq<DafnyCallEvent<GetEncryptedDataKeyDescriptionInput, Result<GetEncryptedDataKeyDescriptionOutput, Error>>>
  }

  trait {:termination false} IDynamoDbEncryptionClient {
    ghost const Modifies: set<object>

    predicate ValidState()
      ensures ValidState() ==> History in Modifies

    ghost const History: IDynamoDbEncryptionClientCallHistory

    predicate CreateDynamoDbEncryptionBranchKeyIdSupplierEnsuresPublicly(input: CreateDynamoDbEncryptionBranchKeyIdSupplierInput, output: Result<CreateDynamoDbEncryptionBranchKeyIdSupplierOutput, Error>)
      decreases input, output

    method CreateDynamoDbEncryptionBranchKeyIdSupplier(input: CreateDynamoDbEncryptionBranchKeyIdSupplierInput) returns (output: Result<CreateDynamoDbEncryptionBranchKeyIdSupplierOutput, Error>)
      requires ValidState() && input.ddbKeyBranchKeyIdSupplier.ValidState() && input.ddbKeyBranchKeyIdSupplier.Modifies !! {History}
      modifies Modifies - {History}, input.ddbKeyBranchKeyIdSupplier.Modifies, History`CreateDynamoDbEncryptionBranchKeyIdSupplier
      ensures ValidState() && (output.Success? ==> output.value.branchKeyIdSupplier.ValidState() && output.value.branchKeyIdSupplier.Modifies !! {History} && fresh(output.value.branchKeyIdSupplier) && fresh(output.value.branchKeyIdSupplier.Modifies - Modifies - {History} - input.ddbKeyBranchKeyIdSupplier.Modifies))
      ensures CreateDynamoDbEncryptionBranchKeyIdSupplierEnsuresPublicly(input, output)
      ensures History.CreateDynamoDbEncryptionBranchKeyIdSupplier == old(History.CreateDynamoDbEncryptionBranchKeyIdSupplier) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.ddbKeyBranchKeyIdSupplier.Modifies

    predicate GetEncryptedDataKeyDescriptionEnsuresPublicly(input: GetEncryptedDataKeyDescriptionInput, output: Result<GetEncryptedDataKeyDescriptionOutput, Error>)
      decreases input, output

    method GetEncryptedDataKeyDescription(input: GetEncryptedDataKeyDescriptionInput) returns (output: Result<GetEncryptedDataKeyDescriptionOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetEncryptedDataKeyDescription
      ensures true && ValidState()
      ensures GetEncryptedDataKeyDescriptionEnsuresPublicly(input, output)
      ensures History.GetEncryptedDataKeyDescription == old(History.GetEncryptedDataKeyDescription) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
  }

  datatype DynamoDbEncryptionConfig = DynamoDbEncryptionConfig

  class IDynamoDbKeyBranchKeyIdSupplierCallHistory {
    ghost constructor ()
    {
      GetBranchKeyIdFromDdbKey := [];
    }

    ghost var GetBranchKeyIdFromDdbKey: seq<DafnyCallEvent<GetBranchKeyIdFromDdbKeyInput, Result<GetBranchKeyIdFromDdbKeyOutput, Error>>>
  }

  trait {:termination false} IDynamoDbKeyBranchKeyIdSupplier {
    ghost const Modifies: set<object>

    predicate ValidState()
      ensures ValidState() ==> History in Modifies

    ghost const History: IDynamoDbKeyBranchKeyIdSupplierCallHistory

    predicate GetBranchKeyIdFromDdbKeyEnsuresPublicly(input: GetBranchKeyIdFromDdbKeyInput, output: Result<GetBranchKeyIdFromDdbKeyOutput, Error>)
      decreases input, output

    method GetBranchKeyIdFromDdbKey(input: GetBranchKeyIdFromDdbKeyInput) returns (output: Result<GetBranchKeyIdFromDdbKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetBranchKeyIdFromDdbKey
      ensures true && ValidState()
      ensures GetBranchKeyIdFromDdbKeyEnsuresPublicly(input, output)
      ensures History.GetBranchKeyIdFromDdbKey == old(History.GetBranchKeyIdFromDdbKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := GetBranchKeyIdFromDdbKey'(input);
      History.GetBranchKeyIdFromDdbKey := History.GetBranchKeyIdFromDdbKey + [DafnyCallEvent(input, output)];
    }

    method GetBranchKeyIdFromDdbKey'(input: GetBranchKeyIdFromDdbKeyInput) returns (output: Result<GetBranchKeyIdFromDdbKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}
      ensures true && ValidState()
      ensures GetBranchKeyIdFromDdbKeyEnsuresPublicly(input, output)
      ensures unchanged(History)
      decreases Modifies - {History}
  }

  datatype DynamoDbTableEncryptionConfig = DynamoDbTableEncryptionConfig(nameonly logicalTableName: string, nameonly partitionKeyName: ComAmazonawsDynamodbTypes.KeySchemaAttributeName, nameonly sortKeyName: Option<ComAmazonawsDynamodbTypes.KeySchemaAttributeName> := Option.None, nameonly search: Option<SearchConfig> := Option.None, nameonly attributeActionsOnEncrypt: AttributeActions, nameonly allowedUnsignedAttributes: Option<ComAmazonawsDynamodbTypes.AttributeNameList> := Option.None, nameonly allowedUnsignedAttributePrefix: Option<string> := Option.None, nameonly algorithmSuiteId: Option<AwsCryptographyMaterialProvidersTypes.DBEAlgorithmSuiteId> := Option.None, nameonly keyring: Option<AwsCryptographyMaterialProvidersTypes.IKeyring> := Option.None, nameonly cmm: Option<AwsCryptographyMaterialProvidersTypes.ICryptographicMaterialsManager> := Option.None, nameonly legacyOverride: Option<LegacyOverride> := Option.None, nameonly plaintextOverride: Option<PlaintextOverride> := Option.None)

  type DynamoDbTableEncryptionConfigList = map<ComAmazonawsDynamodbTypes.TableName, DynamoDbTableEncryptionConfig>

  datatype DynamoDbTablesEncryptionConfig = DynamoDbTablesEncryptionConfig(nameonly tableEncryptionConfigs: DynamoDbTableEncryptionConfigList)

  datatype EncryptedDataKeyDescription = EncryptedDataKeyDescription(nameonly keyProviderId: string, nameonly keyProviderInfo: Option<string> := Option.None, nameonly branchKeyId: Option<string> := Option.None, nameonly branchKeyVersion: Option<string> := Option.None)

  type EncryptedDataKeyDescriptionList = seq<EncryptedDataKeyDescription>

  datatype EncryptedPart = EncryptedPart(nameonly name: string, nameonly prefix: Prefix)

  type EncryptedPartsList = x: seq<EncryptedPart>
    | IsValid_EncryptedPartsList(x)
    witness *

  datatype GetBranchKeyIdFromDdbKeyInput = GetBranchKeyIdFromDdbKeyInput(nameonly ddbKey: ComAmazonawsDynamodbTypes.Key)

  datatype GetBranchKeyIdFromDdbKeyOutput = GetBranchKeyIdFromDdbKeyOutput(nameonly branchKeyId: string)

  datatype GetEncryptedDataKeyDescriptionInput = GetEncryptedDataKeyDescriptionInput(nameonly input: GetEncryptedDataKeyDescriptionUnion)

  datatype GetEncryptedDataKeyDescriptionOutput = GetEncryptedDataKeyDescriptionOutput(nameonly EncryptedDataKeyDescriptionOutput: EncryptedDataKeyDescriptionList)

  datatype GetEncryptedDataKeyDescriptionUnion = header(header: seq<uint8>) | item(item: ComAmazonawsDynamodbTypes.AttributeMap)

  datatype GetPrefix = GetPrefix(nameonly length: int32)

  datatype GetSegment = GetSegment(nameonly split: Char, nameonly index: int32)

  datatype GetSegments = GetSegments(nameonly split: Char, nameonly low: int32, nameonly high: int32)

  datatype GetSubstring = GetSubstring(nameonly low: int32, nameonly high: int32)

  datatype GetSuffix = GetSuffix(nameonly length: int32)

  datatype Insert = Insert(nameonly literal: string)

  class ILegacyDynamoDbEncryptorCallHistory {
    ghost constructor ()
    {
    }
  }

  trait {:termination false} ILegacyDynamoDbEncryptor {
    ghost const Modifies: set<object>

    predicate ValidState()
      ensures ValidState() ==> History in Modifies

    ghost const History: ILegacyDynamoDbEncryptorCallHistory
  }

  datatype LegacyOverride = LegacyOverride(nameonly policy: LegacyPolicy, nameonly encryptor: ILegacyDynamoDbEncryptor, nameonly attributeActionsOnEncrypt: AttributeActions, nameonly defaultAttributeFlag: Option<AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.CryptoAction> := Option.None)

  datatype LegacyPolicy = FORCE_LEGACY_ENCRYPT_ALLOW_LEGACY_DECRYPT | FORBID_LEGACY_ENCRYPT_ALLOW_LEGACY_DECRYPT | FORBID_LEGACY_ENCRYPT_FORBID_LEGACY_DECRYPT

  datatype Lower = Lower

  datatype MultiKeyStore = MultiKeyStore(nameonly keyFieldName: string, nameonly cacheTTL: int32, nameonly cache: Option<AwsCryptographyMaterialProvidersTypes.CacheType> := Option.None)

  datatype PartOnly = PartOnly

  datatype PlaintextOverride = FORCE_PLAINTEXT_WRITE_ALLOW_PLAINTEXT_READ | FORBID_PLAINTEXT_WRITE_ALLOW_PLAINTEXT_READ | FORBID_PLAINTEXT_WRITE_FORBID_PLAINTEXT_READ

  type Prefix = x: string
    | IsValid_Prefix(x)
    witness *

  datatype SearchConfig = SearchConfig(nameonly versions: BeaconVersionList, nameonly writeVersion: VersionNumber)

  datatype Shared = Shared(nameonly other: string)

  datatype SharedSet = SharedSet(nameonly other: string)

  datatype SignedPart = SignedPart(nameonly name: string, nameonly prefix: Prefix, nameonly loc: Option<TerminalLocation> := Option.None)

  type SignedPartsList = x: seq<SignedPart>
    | IsValid_SignedPartsList(x)
    witness *

  datatype SingleKeyStore = SingleKeyStore(nameonly keyId: string, nameonly cacheTTL: int32)

  datatype StandardBeacon = StandardBeacon(nameonly name: string, nameonly length: BeaconBitLength, nameonly loc: Option<TerminalLocation> := Option.None, nameonly style: Option<BeaconStyle> := Option.None)

  type StandardBeaconList = x: seq<StandardBeacon>
    | IsValid_StandardBeaconList(x)
    witness *

  type TerminalLocation = x: string
    | IsValid_TerminalLocation(x)
    witness *

  datatype Upper = Upper

  type VersionNumber = x: int32
    | IsValid_VersionNumber(x)
    witness *

  datatype VirtualField = VirtualField(nameonly name: string, nameonly parts: VirtualPartList)

  type VirtualFieldList = x: seq<VirtualField>
    | IsValid_VirtualFieldList(x)
    witness *

  datatype VirtualPart = VirtualPart(nameonly loc: TerminalLocation, nameonly trans: Option<VirtualTransformList> := Option.None)

  type VirtualPartList = x: seq<VirtualPart>
    | IsValid_VirtualPartList(x)
    witness *

  datatype VirtualTransform = upper(upper: Upper) | lower(lower: Lower) | insert(insert: Insert) | prefix(prefix: GetPrefix) | suffix(suffix: GetSuffix) | substring(substring: GetSubstring) | segment(segment: GetSegment) | segments(segments: GetSegments)

  type VirtualTransformList = x: seq<VirtualTransform>
    | IsValid_VirtualTransformList(x)
    witness *

  datatype Error = DynamoDbEncryptionException(nameonly message: string) | AwsCryptographyDbEncryptionSdkStructuredEncryption(AwsCryptographyDbEncryptionSdkStructuredEncryption: AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.Error) | AwsCryptographyMaterialProviders(AwsCryptographyMaterialProviders: AwsCryptographyMaterialProvidersTypes.Error) | AwsCryptographyKeyStore(AwsCryptographyKeyStore: AwsCryptographyKeyStoreTypes.Error) | AwsCryptographyPrimitives(AwsCryptographyPrimitives: AwsCryptographyPrimitivesTypes.Error) | ComAmazonawsDynamodb(ComAmazonawsDynamodb: ComAmazonawsDynamodbTypes.Error) | CollectionOfErrors(list: seq<Error>, nameonly message: string) | Opaque(obj: object) | OpaqueWithText(obj: object, objMessage: string)

  type OpaqueError = e: Error
    | e.Opaque? || e.OpaqueWithText?
    witness *

  type DummySubsetType = x: int
    | IsDummySubsetType(x)
    witness 1
}

abstract module AbstractAwsCryptographyDbEncryptionSdkDynamoDbService {
  function method DefaultDynamoDbEncryptionConfig(): DynamoDbEncryptionConfig

  method DynamoDbEncryption(config: DynamoDbEncryptionConfig := DefaultDynamoDbEncryptionConfig()) returns (res: Result<DynamoDbEncryptionClient, Error>)
    ensures res.Success? ==> fresh(res.value) && fresh(res.value.Modifies) && fresh(res.value.History) && res.value.ValidState()
    decreases config

  function method CreateSuccessOfClient(client: IDynamoDbEncryptionClient): Result<IDynamoDbEncryptionClient, Error>
    decreases client
  {
    Success(client)
  }

  function method CreateFailureOfError(error: Error): Result<IDynamoDbEncryptionClient, Error>
    decreases error
  {
    Failure(error)
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyDbEncryptionSdkDynamoDbTypes

  import Operations : AbstractAwsCryptographyDbEncryptionSdkDynamoDbOperations

  class DynamoDbEncryptionClient extends IDynamoDbEncryptionClient {
    constructor (config: Operations.InternalConfig)
      requires Operations.ValidInternalConfig?(config)
      ensures ValidState() && fresh(History) && this.config == config

    const config: Operations.InternalConfig

    predicate ValidState()
      ensures ValidState() ==> Operations.ValidInternalConfig?(config) && History !in Operations.ModifiesInternalConfig(config) && Modifies == Operations.ModifiesInternalConfig(config) + {History}

    predicate CreateDynamoDbEncryptionBranchKeyIdSupplierEnsuresPublicly(input: CreateDynamoDbEncryptionBranchKeyIdSupplierInput, output: Result<CreateDynamoDbEncryptionBranchKeyIdSupplierOutput, Error>)
      decreases input, output
    {
      Operations.CreateDynamoDbEncryptionBranchKeyIdSupplierEnsuresPublicly(input, output)
    }

    method CreateDynamoDbEncryptionBranchKeyIdSupplier(input: CreateDynamoDbEncryptionBranchKeyIdSupplierInput) returns (output: Result<CreateDynamoDbEncryptionBranchKeyIdSupplierOutput, Error>)
      requires ValidState() && input.ddbKeyBranchKeyIdSupplier.ValidState() && input.ddbKeyBranchKeyIdSupplier.Modifies !! {History}
      modifies Modifies - {History}, input.ddbKeyBranchKeyIdSupplier.Modifies, History`CreateDynamoDbEncryptionBranchKeyIdSupplier
      ensures ValidState() && (output.Success? ==> output.value.branchKeyIdSupplier.ValidState() && output.value.branchKeyIdSupplier.Modifies !! {History} && fresh(output.value.branchKeyIdSupplier) && fresh(output.value.branchKeyIdSupplier.Modifies - Modifies - {History} - input.ddbKeyBranchKeyIdSupplier.Modifies))
      ensures CreateDynamoDbEncryptionBranchKeyIdSupplierEnsuresPublicly(input, output)
      ensures History.CreateDynamoDbEncryptionBranchKeyIdSupplier == old(History.CreateDynamoDbEncryptionBranchKeyIdSupplier) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.ddbKeyBranchKeyIdSupplier.Modifies
    {
      output := Operations.CreateDynamoDbEncryptionBranchKeyIdSupplier(config, input);
      History.CreateDynamoDbEncryptionBranchKeyIdSupplier := History.CreateDynamoDbEncryptionBranchKeyIdSupplier + [DafnyCallEvent(input, output)];
    }

    predicate GetEncryptedDataKeyDescriptionEnsuresPublicly(input: GetEncryptedDataKeyDescriptionInput, output: Result<GetEncryptedDataKeyDescriptionOutput, Error>)
      decreases input, output
    {
      Operations.GetEncryptedDataKeyDescriptionEnsuresPublicly(input, output)
    }

    method GetEncryptedDataKeyDescription(input: GetEncryptedDataKeyDescriptionInput) returns (output: Result<GetEncryptedDataKeyDescriptionOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetEncryptedDataKeyDescription
      ensures true && ValidState()
      ensures GetEncryptedDataKeyDescriptionEnsuresPublicly(input, output)
      ensures History.GetEncryptedDataKeyDescription == old(History.GetEncryptedDataKeyDescription) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.GetEncryptedDataKeyDescription(config, input);
      History.GetEncryptedDataKeyDescription := History.GetEncryptedDataKeyDescription + [DafnyCallEvent(input, output)];
    }
  }
}

abstract module AbstractAwsCryptographyDbEncryptionSdkDynamoDbOperations {
  predicate ValidInternalConfig?(config: InternalConfig)

  function ModifiesInternalConfig(config: InternalConfig): set<object>

  predicate CreateDynamoDbEncryptionBranchKeyIdSupplierEnsuresPublicly(input: CreateDynamoDbEncryptionBranchKeyIdSupplierInput, output: Result<CreateDynamoDbEncryptionBranchKeyIdSupplierOutput, Error>)
    decreases input, output

  method CreateDynamoDbEncryptionBranchKeyIdSupplier(config: InternalConfig, input: CreateDynamoDbEncryptionBranchKeyIdSupplierInput) returns (output: Result<CreateDynamoDbEncryptionBranchKeyIdSupplierOutput, Error>)
    requires ValidInternalConfig?(config) && input.ddbKeyBranchKeyIdSupplier.ValidState()
    modifies ModifiesInternalConfig(config), input.ddbKeyBranchKeyIdSupplier.Modifies
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.branchKeyIdSupplier.ValidState() && fresh(output.value.branchKeyIdSupplier) && fresh(output.value.branchKeyIdSupplier.Modifies - ModifiesInternalConfig(config) - input.ddbKeyBranchKeyIdSupplier.Modifies))
    ensures CreateDynamoDbEncryptionBranchKeyIdSupplierEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), input.ddbKeyBranchKeyIdSupplier.Modifies

  predicate GetEncryptedDataKeyDescriptionEnsuresPublicly(input: GetEncryptedDataKeyDescriptionInput, output: Result<GetEncryptedDataKeyDescriptionOutput, Error>)
    decreases input, output

  method GetEncryptedDataKeyDescription(config: InternalConfig, input: GetEncryptedDataKeyDescriptionInput) returns (output: Result<GetEncryptedDataKeyDescriptionOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GetEncryptedDataKeyDescriptionEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyDbEncryptionSdkDynamoDbTypes

  type InternalConfig
}

module DynamoDbUpdateExpr {
  function method ExtractAttributes(s: string, ex: Option<ExpressionAttributeNameMap>): seq<string>
    decreases s, ex
  {
    var x: seq<string> := ExtractAttrs(s);
    if ex.None? then
      x
    else
      Resolve(x, ex.value)
  }

  predicate method IgnoreAttr(s: string)
    decreases s
  {
    s in [""SET"", ""REMOVE"", ""ADD"", ""DELETE"", ""list_append"", ""if_not_exists""]
  }

  function method {:tailrecursion} Resolve(names: seq<string>, ex: ExpressionAttributeNameMap): seq<string>
    decreases names, ex
  {
    if |names| == 0 then
      []
    else if names[0] in ex then
      [ex[names[0]]] + Resolve(names[1..], ex)
    else
      [names[0]] + Resolve(names[1..], ex)
  }

  function method ChopOne(s: string, ch: char): string
    decreases s, ch
  {
    if ch in s then
      SplitOnce(s, ch).0
    else
      s
  }

  function method Chop(s: string): string
    decreases s
  {
    var s: string := ChopOne(s, '.');
    ChopOne(s, '[')
  }

  function method {:tailrecursion} {:opaque} ExtractAttrs(s: string): seq<string>
    decreases s
  {
    if |s| == 0 then
      []
    else
      var ret: (nat, Option<string>) := FindToken(s); if ret.0 == 0 then [] else if ret.1.None? then ExtractAttrs(s[ret.0..]) else if IgnoreAttr(ret.1.value) then ExtractAttrs(s[ret.0..]) else [Chop(ret.1.value)] + ExtractAttrs(s[ret.0..])
  }

  predicate method BadStart(ch: char)
    decreases ch
  {
    ch == ':' || '0' <= ch <= '9'
  }

  predicate method AttrStart(ch: char)
    decreases ch
  {
    if 'a' <= ch <= 'z' then
      true
    else if 'A' <= ch <= 'Z' then
      true
    else if ch == '#' || ch == '_' then
      true
    else
      false
  }

  predicate method AttrChar(ch: char)
    decreases ch
  {
    if AttrStart(ch) then
      true
    else if '0' <= ch <= '9' then
      true
    else if ch in ['[', ']', '.'] then
      true
    else
      false
  }

  function method {:tailrecursion} AttrLen(s: string): (res: nat)
    ensures res <= |s|
    decreases s
  {
    if 0 == |s| then
      0
    else if AttrChar(s[0]) then
      AttrLen(s[1..]) + 1
    else
      0
  }

  function method FindToken(s: string): (res: (nat, Option<string>))
    ensures res.0 <= |s|
    decreases s
  {
    if 0 == |s| then
      (0, None)
    else
      var ch: char := s[0]; if ch == '#' then var x: int := AttrLen(s[1..]) + 1; (x, Some(s[0 .. x])) else if BadStart(ch) then var x: int := AttrLen(s[1..]) + 1; (x, None) else if AttrStart(ch) then var x: int := AttrLen(s[1..]) + 1; (x, Some(s[0 .. x])) else (1, None)
  }

  import opened Wrappers

  import opened StandardLibrary

  import opened ComAmazonawsDynamodbTypes
}

module SearchableEncryptionInfo {
  method GetAllKeys(client: Primitives.AtomicPrimitivesClient, stdNames: seq<string>, key: Bytes)
      returns (output: Result<HmacKeyMap, Error>)
    requires Seq.HasNoDuplicates(stdNames)
    requires client.ValidState()
    modifies client.Modifies
    ensures client.ValidState()
    decreases client, stdNames, key
  {
    var newKeys :- GetHmacKeys(client, stdNames, stdNames, key);
    return Success(newKeys);
  }

  method {:tailrecursion} GetHmacKeys(client: Primitives.AtomicPrimitivesClient, allKeys: seq<string>, keysLeft: seq<string>, key: Bytes, acc: HmacKeyMap := map[])
      returns (output: Result<HmacKeyMap, Error>)
    requires Seq.HasNoDuplicates(allKeys)
    requires Seq.HasNoDuplicates(keysLeft)
    requires forall k: seq<char> {:trigger k in acc} {:trigger k in keysLeft} {:trigger k in allKeys} | k in allKeys :: k in keysLeft || k in acc
    requires forall k: seq<char> {:trigger k in allKeys} {:trigger k in keysLeft} | k in keysLeft :: k in allKeys
    requires client.ValidState()
    modifies client.Modifies
    ensures output.Success? ==> forall k: seq<char> {:trigger k in output.value} {:trigger k in allKeys} | k in allKeys :: k in output.value
    ensures client.ValidState()
    decreases client, allKeys, keysLeft, key, acc
  {
    if |keysLeft| == 0 {
      return Success(acc);
    } else {
      var newKey :- GetBeaconKey(client, key, keysLeft[0]);
      reveal Seq.HasNoDuplicates();
      output := GetHmacKeys(client, allKeys, keysLeft[1..], key, acc[keysLeft[0] := newKey]);
    }
  }

  method GetBeaconKey(client: Primitives.AtomicPrimitivesClient, key: Bytes, name: string)
      returns (output: Result<Bytes, Error>)
    requires client.ValidState()
    modifies client.Modifies
    ensures client.ValidState()
    ensures output.Success? ==> true && var fullName: seq<char> := ""AWS_DBE_SCAN_BEACON"" + name; UTF8.Encode(fullName).Success? && var info: ValidUTF8Bytes := UTF8.Encode(fullName).value; true && var oldHistory: seq<DafnyCallEvent<HkdfInput, Result<seq<uint8>, Error>>> := old(client.History.Hkdf); true && var newHistory: seq<DafnyCallEvent<HkdfInput, Result<seq<uint8>, Error>>> := client.History.Hkdf; |newHistory| == |oldHistory| + 1 && Seq.Last(newHistory).output.Success? && var hkdfInput: HkdfInput := Seq.Last(newHistory).input; true && var hkdfOutput: Result<seq<uint8>, Error> := Seq.Last(newHistory).output; hkdfInput.digestAlgorithm == Prim.SHA_512 && hkdfInput.salt == None && hkdfInput.ikm == key && hkdfInput.info == info && hkdfInput.expectedLength == 64
    decreases client, key, name
  {
    var info :- UTF8.Encode(""AWS_DBE_SCAN_BEACON"" + name).MapFailure((e: string) => E(e));
    var keyR := client.Hkdf(Prim.HkdfInput(digestAlgorithm := Prim.SHA_512, salt := None, ikm := key, info := info, expectedLength := 64));
    var newKey :- keyR.MapFailure((e: Error) => AwsCryptographyPrimitives(e));
    return Success(newKey);
  }

  function method MakeSearchInfo(version: ValidBeaconVersion): (ret: ValidSearchInfo)
    decreases version
  {
    SearchInfo([version], 0)
  }

  predicate IsValidBeaconMap(m: map<string, Beacon>)
    decreases m
  {
    forall x: seq<char> {:trigger m[x]} {:trigger x in m} | x in m :: 
      x == m[x].getName()
  }

  predicate method IsPartOnly(b: Beacon)
    decreases b
  {
    b.Standard? &&
    b.std.partOnly
  }

  predicate method IsBeaconOfType(b: Beacon, t: BeaconType)
    decreases b, t
  {
    match t {
      case AnyBeacon() =>
        true
      case SignedBeacon() =>
        !b.isEncrypted()
      case EncryptedBeacon() =>
        b.isEncrypted()
    }
  }

  lemma /*{:_inductionTrigger _default.Filter(f, xs)}*/ /*{:_induction xs}*/ FilterDoesNotInventElements<T>(f: T ~> bool, xs: seq<T>)
    requires forall i: int {:trigger xs[i]} :: 0 <= i < |xs| ==> f.requires(xs[i])
    ensures ghost var result: seq<T> := Seq.Filter(f, xs); forall i: int {:trigger result[i]} :: 0 <= i < |result| ==> result[i] in xs
    decreases xs
  {
    reveal Seq.Filter();
  }

  lemma HasNoDuplicatesAppend(a: seq, b: seq)
    requires Seq.HasNoDuplicates(a)
    requires Seq.HasNoDuplicates(b)
    requires forall i: int, j: int {:trigger b[j], a[i]} :: 0 <= i < |a| && 0 <= j < |b| ==> a[i] != b[j]
    ensures Seq.HasNoDuplicates(a + b)
    decreases a, b
  {
    reveal Seq.HasNoDuplicates();
  }

  lemma /*{:_inductionTrigger _default.Filter(f, xs)}*/ /*{:_inductionTrigger |xs|}*/ /*{:_induction xs}*/ FilterPreservesHasNoDuplicates<T>(f: T ~> bool, xs: seq<T>)
    requires forall i: int {:trigger xs[i]} :: 0 <= i < |xs| ==> f.requires(xs[i])
    requires Seq.HasNoDuplicates(xs)
    ensures Seq.HasNoDuplicates(Seq.Filter(f, xs))
    decreases xs
  {
    reveal Seq.Filter(), Seq.HasNoDuplicates();
    if |xs| == 0 {
    } else {
      ghost var a := if f(xs[0]) then [xs[0]] else [];
      ghost var b := Seq.Filter(f, xs[1..]);
      calc {
        Seq.HasNoDuplicates(Seq.Filter(f, xs));
      ==
        {
          assert Seq.Filter(f, xs) == a + b;
        }
        Seq.HasNoDuplicates(a + b);
      <==
        {
          HasNoDuplicatesAppend(a, b);
        }
        Seq.HasNoDuplicates(a) &&
        Seq.HasNoDuplicates(b) &&
        forall i: int, j: int {:trigger b[j], a[i]} :: 
          0 <= i < |a| &&
          0 <= j < |b| ==>
            a[i] != b[j];
      ==
        {
          assert Seq.HasNoDuplicates(a);
        }
        Seq.HasNoDuplicates(b) &&
        forall i: int, j: int {:trigger b[j], a[i]} :: 
          0 <= i < |a| &&
          0 <= j < |b| ==>
            a[i] != b[j];
      ==
        {
          FilterPreservesHasNoDuplicates(f, xs[1..]);
        }
        forall i: int, j: int {:trigger b[j], a[i]} :: 
          0 <= i < |a| &&
          0 <= j < |b| ==>
            a[i] != b[j];
      }
      forall i: int, j: int | 0 <= i < |a| && 0 <= j < |b|
        ensures a[i] != b[j]
      {
        assert b[j] in Seq.Filter(f, xs[1..]);
        FilterDoesNotInventElements(f, xs[1..]);
      }
    }
  }

  function method MakeBeaconVersion(version: VersionNumber, keySource: KeySource, beacons: BeaconMap, virtualFields: VirtualFieldMap, actions: AttributeActions): (ret: Result<ValidBeaconVersion, Error>)
    requires version == 1
    requires keySource.ValidState()
    decreases version, keySource, beacons, virtualFields, actions
  {
    var beaconNames: seq<seq<char>> := SortedSets.ComputeSetToOrderedSequence2(beacons.Keys, CharLess);
    var stdKeys: seq<seq<char>> := Seq.Filter((k: string) => k in beacons && beacons[k].Standard?, beaconNames);
    FilterPreservesHasNoDuplicates((k: string) => k in beacons && beacons[k].Standard?, beaconNames);
    var encrypted: set<seq<char>> := set k: seq<char> {:trigger actions[k]} {:trigger k in actions} | k in actions && actions[k] == SE.ENCRYPT_AND_SIGN :: k;
    var bv: BeaconVersion := BeaconVersion.BeaconVersion(version, keySource, virtualFields, beacons, beaconNames, stdKeys, encrypted);
    assert bv.ValidState();
    Success(bv)
  }

  import opened AwsCryptographyDbEncryptionSdkDynamoDbTypes

  import BaseBeacon

  import CompoundBeacon

  import opened TermLoc

  import opened DynamoDbEncryptionUtil

  import opened DdbVirtualFields

  import opened StandardLibrary

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import SortedSets

  import Sets

  import UTF8

  import opened Time

  import KeyStore = AwsCryptographyKeyStoreTypes

  import Primitives = AtomicPrimitives

  import Prim = AwsCryptographyPrimitivesTypes

  import MP = AwsCryptographyMaterialProvidersTypes

  import KeyStoreTypes = AwsCryptographyKeyStoreTypes

  import SE = AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes

  newtype VersionNumber = x: int
    | x == 1
    witness 1

  type ValidSearchInfo = x: SearchInfo
    | x.ValidState()
    witness *

  type ValidStore = x: KeyStoreTypes.IKeyStoreClient
    | x.ValidState()
    witness *

  datatype KeyLocation = LiteralLoc(keys: HmacKeyMap) | SingleLoc(keyId: string) | MultiLoc(keyName: string, deleteKey: bool)

  datatype KeySource = KeySource(client: Primitives.AtomicPrimitivesClient, store: ValidStore, keyLoc: KeyLocation, cache: MP.ICryptographicMaterialsCache, cacheTTL: uint32) {
    function Modifies(): set<object>
      decreases this
    {
      client.Modifies + store.Modifies
    }

    predicate ValidState()
      decreases this
    {
      client.ValidState() &&
      store.ValidState()
    }

    method getKeyMap(stdNames: seq<string>, keyId: MaybeKeyId) returns (output: Result<MaybeKeyMap, Error>)
      requires Seq.HasNoDuplicates(stdNames)
      requires ValidState()
      modifies Modifies()
      ensures ValidState()
      decreases this, stdNames, keyId
    {
      if keyLoc.SingleLoc? {
        :- Need(keyId.DontUseKeyId?, E(""KeyID should not be supplied with a SingleKeyStore""));
        var theMap :- getKeysCache(stdNames, keyLoc.keyId);
        return Success(Keys(theMap));
      } else if keyLoc.LiteralLoc? {
        :- Need(keyId.DontUseKeyId?, E(""KeyID should not be supplied with a LiteralKeyStore""));
        var theMap :- getKeysLiteral();
        return Success(Keys(theMap));
      } else {
        match keyId {
          case {:split false} DontUseKeyId() =>
            return Failure(E(""KeyID must not be supplied with a MultiKeyStore""));
          case {:split false} ShouldHaveKeyId() =>
            return Success(ShouldHaveKeys);
          case {:split false} KeyId(id) =>
            var theMap :- getKeysCache(stdNames, id);
            return Success(Keys(theMap));
        }
      }
    }

    lemma {:axiom} verifyValidStateCache(cmc: MP.ICryptographicMaterialsCache)
      ensures cmc.ValidState()
      decreases this, cmc

    method getKeysLiteral() returns (output: Result<HmacKeyMap, Error>)
      requires keyLoc.LiteralLoc?
      decreases this
    {
      return Success(keyLoc.keys);
    }

    method getKeysCache(stdNames: seq<string>, keyId: string) returns (output: Result<HmacKeyMap, Error>)
      requires Seq.HasNoDuplicates(stdNames)
      requires ValidState()
      modifies Modifies()
      ensures ValidState()
      ensures output.Success? ==> true && var oldHistory: seq<DafnyCallEvent<GetCacheEntryInput, Result<GetCacheEntryOutput, Error>>> := old(cache.History.GetCacheEntry); true && var newHistory: seq<DafnyCallEvent<GetCacheEntryInput, Result<GetCacheEntryOutput, Error>>> := cache.History.GetCacheEntry; |newHistory| == |oldHistory| + 1 && Seq.Last(newHistory).output.Success? && var cacheInput: GetCacheEntryInput := Seq.Last(newHistory).input; true && var cacheOutput: Result<GetCacheEntryOutput, Error> := Seq.Last(newHistory).output; UTF8.Encode(keyId).Success? && cacheInput.identifier == UTF8.Encode(keyId).value && (cacheOutput.Success? ==> cacheOutput.value.materials.BeaconKey? && cacheOutput.value.materials.BeaconKey.hmacKeys.Some? && output.value == cacheOutput.value.materials.BeaconKey.hmacKeys.value) && (cacheOutput.Failure? ==> true && var oldGetHistory: seq<DafnyCallEvent<GetBeaconKeyInput, Result<GetBeaconKeyOutput, Error>>> := old(store.History.GetBeaconKey); true && var newGetHistory: seq<DafnyCallEvent<GetBeaconKeyInput, Result<GetBeaconKeyOutput, Error>>> := store.History.GetBeaconKey; |newGetHistory| == |oldGetHistory| + 1 && Seq.Last(newGetHistory).output.Success? && var storeInput: GetBeaconKeyInput := Seq.Last(newGetHistory).input; true && var storeOutput: Result<GetBeaconKeyOutput, Error> := Seq.Last(newGetHistory).output; storeInput.branchKeyIdentifier == keyId && var oldPutHistory: seq<DafnyCallEvent<PutCacheEntryInput, Result<(), Error>>> := old(cache.History.PutCacheEntry); true && var newPutHistory: seq<DafnyCallEvent<PutCacheEntryInput, Result<(), Error>>> := cache.History.PutCacheEntry; |newPutHistory| == |oldPutHistory| + 1 && Seq.Last(newPutHistory).output.Success? && var storeInput: PutCacheEntryInput := Seq.Last(newPutHistory).input; true && var storeOutput: Result<(), Error> := Seq.Last(newPutHistory).output; true && storeInput.materials.BeaconKey.hmacKeys == Some(output.value))
      decreases this, stdNames, keyId
    {
      var keyIdBytesR := UTF8.Encode(keyId);
      var keyIdBytes :- keyIdBytesR.MapFailure((e: seq<char>) => E(e));
      var getCacheInput := MP.GetCacheEntryInput(identifier := keyIdBytes, bytesUsed := None);
      verifyValidStateCache(cache);
      assume {:axiom} cache.Modifies == {};
      var getCacheOutput := cache.GetCacheEntry(getCacheInput);
      if getCacheOutput.Failure? && !getCacheOutput.error.EntryDoesNotExist? {
        return Failure(AwsCryptographyMaterialProviders(AwsCryptographyMaterialProviders := getCacheOutput.error));
      }
      if getCacheOutput.Failure? {
        var maybeRawBeaconKeyMaterials := store.GetBeaconKey(KeyStore.GetBeaconKeyInput(branchKeyIdentifier := keyId));
        var rawBeaconKeyMaterials :- maybeRawBeaconKeyMaterials.MapFailure((e: Error) => AwsCryptographyKeyStore(AwsCryptographyKeyStore := e));
        var key := rawBeaconKeyMaterials.beaconKeyMaterials.beaconKey;
        :- Need(key.Some?, E(""beacon key unexpectedly empty""));
        var keyMap :- getAllKeys(stdNames, key.value);
        var beaconKeyMaterials := rawBeaconKeyMaterials.beaconKeyMaterials.(beaconKey := None, hmacKeys := Some(keyMap));
        var now := Time.GetCurrent();
        var putCacheEntryInput := MP.PutCacheEntryInput(identifier := keyIdBytes, materials := MP.Materials.BeaconKey(beaconKeyMaterials), creationTime := now, expiryTime := now + cacheTTL as MP.PositiveLong, messagesUsed := None, bytesUsed := None);
        verifyValidStateCache(cache);
        assume {:axiom} cache.Modifies == {};
        var putResult := cache.PutCacheEntry(putCacheEntryInput);
        if putResult.Failure? && !putResult.error.EntryAlreadyExists? {
          return Failure(AwsCryptographyMaterialProviders(AwsCryptographyMaterialProviders := putResult.error));
        }
        return Success(keyMap);
      } else {
        :- Need(getCacheOutput.value.materials.BeaconKey? && getCacheOutput.value.materials.BeaconKey.hmacKeys.Some? && getCacheOutput.value.materials.BeaconKey.beaconKeyIdentifier == keyId && getCacheOutput.value.materials.BeaconKey.hmacKeys.Some?, E(""Invalid Material Type.""));
        return Success(getCacheOutput.value.materials.BeaconKey.hmacKeys.value);
      }
    }

    method getAllKeys(stdNames: seq<string>, key: Bytes) returns (output: Result<HmacKeyMap, Error>)
      requires Seq.HasNoDuplicates(stdNames)
      requires client.ValidState()
      modifies client.Modifies
      ensures client.ValidState()
      decreases this, stdNames, key
    {
      output := GetAllKeys(client, stdNames, key);
    }
  }

  datatype SearchInfo = SearchInfo(versions: seq<BeaconVersion>, currWrite: nat) {
    function Modifies(): set<object>
      decreases this
    {
      set y: BeaconVersion, x: object {:trigger x in y.Modifies()} | y in versions && x in y.Modifies() :: x
    }

    predicate ValidState()
      decreases this
    {
      |versions| == 1 &&
      currWrite == 0 &&
      versions[0].ValidState()
    }

    function method curr(): BeaconVersion
      requires ValidState()
      decreases this
    {
      versions[currWrite]
    }

    predicate method IsBeacon(field: string)
      requires ValidState()
      decreases this, field
    {
      versions[currWrite].IsBeacon(field)
    }

    predicate method IsVirtualField(field: string)
      requires ValidState()
      decreases this, field
    {
      versions[currWrite].IsVirtualField(field)
    }

    method GeneratePlainBeacons(item: DDB.AttributeMap) returns (output: Result<DDB.AttributeMap, Error>)
      requires ValidState()
      decreases this, item
    {
      output := versions[currWrite].GeneratePlainBeacons(item);
    }

    method GenerateSignedBeacons(item: DDB.AttributeMap) returns (output: Result<DDB.AttributeMap, Error>)
      requires ValidState()
      modifies Modifies()
      ensures ValidState()
      decreases this, item
    {
      output := versions[currWrite].GenerateSignedBeacons(item);
    }

    method GenerateEncryptedBeacons(item: DDB.AttributeMap, keyId: MaybeKeyId) returns (output: Result<DDB.AttributeMap, Error>)
      requires ValidState()
      modifies Modifies()
      ensures ValidState()
      decreases this, item, keyId
    {
      output := versions[currWrite].GenerateEncryptedBeacons(item, keyId);
    }
  }

  datatype Beacon = Standard(std: BaseBeacon.ValidStandardBeacon) | Compound(cmp: CompoundBeacon.ValidCompoundBeacon) {
    predicate method isEncrypted()
      decreases this
    {
      if Standard? then
        true
      else
        cmp.isEncrypted()
    }

    function method hash(item: DDB.AttributeMap, vf: VirtualFieldMap, keys: MaybeKeyMap): (ret: Result<Option<DDB.AttributeValue>, Error>)
      requires !keys.DontUseKeys?
      ensures Standard? && keys.ShouldHaveKeys? ==> ret.Failure?
      decreases this, item, vf, keys
    {
      if Standard? then
        :- Need(keys.Keys?, E(""Need key for beacon "" + std.keyName() + "" but no keyId found in query."")); if std.keyName() in keys.value then std.getHash(item, vf, keys.value[std.keyName()]) else Failure(E(""Internal error. Beacon "" + std.keyName() + "" has no key!""))
      else
        var strHash: Option<string> :- cmp.hash(item, vf, keys); if strHash.None? then Success(None) else Success(Some(DDB.AttributeValue.S(strHash.value)))
    }

    function method naked(item: DDB.AttributeMap, vf: VirtualFieldMap): Result<Option<DDB.AttributeValue>, Error>
      decreases this, item, vf
    {
      if Standard? then
        std.getNaked(item, vf)
      else
        var str: Option<string> :- cmp.getNaked(item, vf); if str.None? then Success(None) else Success(Some(DS(str.value)))
    }

    function method attrHash(item: DDB.AttributeMap, vf: VirtualFieldMap, keys: MaybeKeyMap): Result<Option<DDB.AttributeValue>, Error>
      decreases this, item, vf, keys
    {
      if keys.DontUseKeys? then
        naked(item, vf)
      else
        hash(item, vf, keys)
    }

    function method getName(): string
      decreases this
    {
      if Standard? then
        std.base.name
      else
        cmp.base.name
    }

    function method getBeaconName(): string
      decreases this
    {
      if Standard? then
        std.base.beaconName
      else
        cmp.base.beaconName
    }

    function method GetFields(virtualFields: VirtualFieldMap): seq<string>
      decreases this, virtualFields
    {
      if Standard? then
        std.GetFields(virtualFields)
      else
        cmp.GetFields(virtualFields)
    }

    function method GetBeaconValue(value: DDB.AttributeValue, keys: MaybeKeyMap, forEquality: bool, forContains: bool): Result<DDB.AttributeValue, Error>
      decreases this, value, keys, forEquality, forContains
    {
      if keys.DontUseKeys? then
        Success(value)
      else if Standard? then
        :- Need(!keys.ShouldHaveKeys?, E(""Need KeyId because of beacon "" + std.keyName() + "" but no KeyId found in query"")); var keys: HmacKeyMap := keys.value; if std.keyName() in keys then std.GetBeaconValue(value, keys[std.keyName()], forContains) else Failure(E(""Internal error. Beacon "" + std.keyName() + "" has no key.""))
      else
        cmp.GetBeaconValue(value, keys, forEquality)
    }

    predicate ValidState()
      decreases this
    {
      if Standard? then
        std.ValidState()
      else
        cmp.ValidState()
    }
  }

  type BeaconMap = x: map<string, Beacon>
    | IsValidBeaconMap(x)
    witness *

  datatype BeaconType = AnyBeacon | SignedBeacon | EncryptedBeacon

  type ValidBeaconVersion = x: BeaconVersion
    | x.ValidState()
    witness *

  datatype BeaconVersion = BeaconVersion(version: VersionNumber, keySource: KeySource, virtualFields: VirtualFieldMap, beacons: BeaconMap, beaconNames: seq<string>, stdNames: seq<string>, encryptedFields: set<string>) {
    function Modifies(): set<object>
      decreases this
    {
      keySource.Modifies()
    }

    predicate ValidState()
      decreases this
    {
      version == 1 &&
      keySource.ValidState() &&
      (forall k: seq<char> {:trigger k in beacons} {:trigger k in beaconNames} | k in beaconNames :: 
        k in beacons) &&
      Seq.HasNoDuplicates(beaconNames) &&
      |beaconNames| == |beacons| &&
      (forall k: seq<char> {:trigger k in beacons} {:trigger k in stdNames} | k in stdNames :: 
        k in beacons) &&
      Seq.HasNoDuplicates(stdNames)
    }

    predicate method IsBeacon(field: string)
      decreases this, field
    {
      field in beacons
    }

    predicate method IsVirtualField(field: string)
      decreases this, field
    {
      field in virtualFields
    }

    function method GetFields(field: string): seq<string>
      decreases this, field
    {
      if IsBeacon(field) then
        beacons[field].GetFields(virtualFields) + [""aws_dbe_b_"" + field]
      else
        [field]
    }

    method getKeyMap(keyId: MaybeKeyId) returns (output: Result<MaybeKeyMap, Error>)
      requires ValidState()
      modifies Modifies()
      ensures ValidState()
      decreases this, keyId
    {
      output := keySource.getKeyMap(stdNames, keyId);
    }

    function method ListSignedBeacons(): seq<string>
      requires ValidState()
      decreases this
    {
      Seq.Filter((s: string) requires s in beacons => IsBeaconOfType(beacons[s], SignedBeacon), beaconNames)
    }

    method GeneratePlainBeacons(item: DDB.AttributeMap) returns (output: Result<DDB.AttributeMap, Error>)
      requires ValidState()
      decreases this, item
    {
      output := GenerateBeacons2(beaconNames, item, DontUseKeys, AnyBeacon);
    }

    method GenerateSignedBeacons(item: DDB.AttributeMap) returns (output: Result<DDB.AttributeMap, Error>)
      requires ValidState()
      modifies Modifies()
      ensures ValidState()
      decreases this, item
    {
      output := GenerateBeacons2(beaconNames, item, DontUseKeys, SignedBeacon);
    }

    method GenerateEncryptedBeacons(item: DDB.AttributeMap, keyId: MaybeKeyId) returns (output: Result<DDB.AttributeMap, Error>)
      requires ValidState()
      modifies Modifies()
      ensures ValidState()
      decreases this, item, keyId
    {
      var hmacKeys :- getKeyMap(keyId);
      output := GenerateBeacons2(beaconNames, item, hmacKeys, EncryptedBeacon);
    }

    function method GenerateBeacon(name: string, item: DDB.AttributeMap, keys: MaybeKeyMap): Result<Option<DDB.AttributeValue>, Error>
      requires name in beacons
      decreases this, name, item, keys
    {
      beacons[name].attrHash(item, virtualFields, keys)
    }

    function method GenerateBeacons2(names: seq<string>, item: DDB.AttributeMap, keys: MaybeKeyMap, bType: BeaconType, acc: DDB.AttributeMap := map[]): Result<DDB.AttributeMap, Error>
      requires forall k: seq<char> {:trigger k in beacons} {:trigger k in names} | k in names :: k in beacons
      decreases this, names, item, keys, bType, acc
    {
      if |names| == 0 then
        Success(acc)
      else if IsBeaconOfType(beacons[names[0]], bType) && !IsPartOnly(beacons[names[0]]) then
        var value: Option<DDB.AttributeValue> :- GenerateBeacon(names[0], item, keys); if value.Some? then GenerateBeacons2(names[1..], item, keys, bType, acc[beacons[names[0]].getBeaconName() := value.value]) else GenerateBeacons2(names[1..], item, keys, bType, acc)
      else
        GenerateBeacons2(names[1..], item, keys, bType, acc)
    }
  }
}

module CompoundBeacon {
  function method MakeCompoundBeacon(base: BeaconBase, split: char, parts: seq<BeaconPart>, numSigned: nat, construct: ConstructorList): (ret: Result<ValidCompoundBeacon, Error>)
    requires numSigned <= |parts|
    requires OrderedParts(parts, numSigned)
    ensures ret.Success? ==> ret.value.ValidPrefixSet()
    decreases base, split, parts, numSigned, construct
  {
    var x: CompoundBeacon := CompoundBeacon.CompoundBeacon(base, split, parts, numSigned, construct);
    var _ /* _v0 */: bool :- x.ValidPrefixSetResult(); Success(x)
  }

  predicate OrderedParts(p: seq<BeaconPart>, n: nat)
    requires n <= |p|
    decreases p, n
  {
    (forall x: int {:trigger p[x]} | 0 <= x < n :: 
      p[x].Signed?) &&
    forall x: int {:trigger p[x]} | n <= x < |p| :: 
      p[x].Encrypted?
  }

  function method MakeDefaultConstructor(parts: seq<BeaconPart>): Constructor
    requires 0 < |parts|
    decreases parts
  {
    var cons: seq<ConstructorPart> := Seq.Map((x: BeaconPart) => ConstructorPart.ConstructorPart(x, true), parts);
    Constructor.Constructor(cons)
  }

  import opened Wrappers

  import opened BaseBeacon

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import opened String = StandardLibrary.String

  import opened TermLoc

  import opened AwsCryptographyDbEncryptionSdkDynamoDbTypes

  import opened DynamoDbEncryptionUtil

  import opened DdbVirtualFields

  import Prim = AwsCryptographyPrimitivesTypes

  import Primitives = AtomicPrimitives

  import UTF8

  import Seq

  import SortedSets

  type Prefix = x: string
    | 0 < |x|
    witness *

  datatype BeaconPart = Encrypted(prefix: Prefix, beacon: BaseBeacon.StandardBeacon) | Signed(prefix: Prefix, name: string, loc: TermLoc) {
    function method getPrefix(): string
      decreases this
    {
      match this {
        case Encrypted(p, b) =>
          p
        case Signed(p, n, l) =>
          p
      }
    }

    function method getName(): string
      decreases this
    {
      match this {
        case Encrypted(p, b) =>
          b.base.name
        case Signed(p, n, l) =>
          n
      }
    }

    function method getString(item: DDB.AttributeMap, vf: VirtualFieldMap): Result<Option<string>, Error>
      decreases this, item, vf
    {
      match this {
        case Encrypted(p, b) =>
          VirtToString(b.loc, item, vf)
        case Signed(p, n, l) =>
          VirtToString(l, item, vf)
      }
    }

    function method GetFields(virtualFields: VirtualFieldMap): seq<string>
      decreases this, virtualFields
    {
      match this {
        case Encrypted(p, b) =>
          b.GetFields(virtualFields)
        case Signed(p, n, l) =>
          if loc[0].key in virtualFields then
            virtualFields[loc[0].key].GetFields()
          else
            [loc[0].key]
      }
    }
  }

  datatype ConstructorPart = ConstructorPart(part: BeaconPart, required: bool)

  type ConstructorPartList = x: seq<ConstructorPart>
    | 0 < |x|
    witness *

  datatype Constructor = Constructor(parts: ConstructorPartList) {
    function method getReqParts(): set<BeaconPart>
      decreases this
    {
      set k: ConstructorPart {:trigger k.part} {:trigger k.required} {:trigger k in parts} | k in parts && k.required :: k.part
    }
  }

  type ConstructorList = x: seq<Constructor>
    | 0 < |x|
    witness *

  type ValidCompoundBeacon = x: CompoundBeacon
    | x.ValidState()
    witness *

  datatype CompoundBeacon = CompoundBeacon(base: BeaconBase, split: char, parts: seq<BeaconPart>, numSigned: nat, construct: ConstructorList) {
    predicate ValidState()
      decreases this
    {
      ValidPrefixSet() &&
      numSigned <= |parts| &&
      OrderedParts(parts, numSigned)
    }

    predicate ValidPrefixSet()
      decreases this
    {
      forall x: nat, y: nat {:trigger OkPrefixPair(x, y)} | 0 <= x < |parts| && x < y < |parts| :: 
        OkPrefixPair(x, y)
    }

    predicate method {:tailrecursion} HasBeacon2(parts: seq<BeaconPart>, name: string)
      decreases this, parts, name
    {
      if |parts| == 0 then
        false
      else if parts[0].getName() == name then
        true
      else
        HasBeacon2(parts[1..], name)
    }

    predicate method HasBeacon(name: string)
      decreases this, name
    {
      HasBeacon2(parts, name)
    }

    predicate method isEncrypted()
      decreases this
    {
      numSigned < |parts|
    }

    function method getPartFromPrefix(value: string): (ret: Result<BeaconPart, Error>)
      ensures ret.Success? ==> ret.value.prefix <= value
      decreases this, value
    {
      partFromPrefix(parts, value)
    }

    function method PartsToString(p: seq<BeaconPart>): string
      decreases this, p
    {
      var beaconParts: seq<string> := Seq.Map((s: BeaconPart) => s.getPrefix(), p);
      if |beaconParts| == 0 then
        """"
      else
        Join(beaconParts, """")
    }

    function method CPartToString(s: ConstructorPart): string
      decreases this, s
    {
      if s.required then
        s.part.getPrefix()
      else
        ""["" + s.part.getPrefix() + ""]""
    }

    function method CPartsToString(p: seq<ConstructorPart>): string
      decreases this, p
    {
      var beaconParts: seq<string> := Seq.Map((s: ConstructorPart) => CPartToString(s), p);
      if |beaconParts| == 0 then
        """"
      else
        Join(beaconParts, """")
    }

    function method CListToString(p: ConstructorList): string
      decreases this, p
    {
      var beaconParts: seq<string> := Seq.Map((s: Constructor) => CPartsToString(s.parts), p);
      Join(beaconParts, "", "")
    }

    predicate method CanConstruct(con: seq<ConstructorPart>, inParts: seq<BeaconPart>, matched: bool := false)
      decreases this, con, inParts, matched
    {
      if |inParts| == 0 then
        true
      else if |con| == 0 then
        false
      else if con[0].part == inParts[0] then
        CanConstruct(con[1..], inParts[1..], true)
      else if !con[0].required || !matched then
        CanConstruct(con[1..], inParts, matched)
      else
        false
    }

    predicate method {:tailrecursion} IsValidPartOrder(candidates: seq<Constructor>, inParts: seq<BeaconPart>)
      decreases this, candidates, inParts
    {
      if |candidates| == 0 then
        false
      else if CanConstruct(candidates[0].parts, inParts) then
        true
      else
        IsValidPartOrder(candidates[1..], inParts)
    }

    function method ValidatePartOrder(inParts: seq<BeaconPart>, orig: string): Result<bool, Error>
      decreases this, inParts, orig
    {
      if IsValidPartOrder(construct, inParts) then
        Success(true)
      else
        var msg: seq<char> := ""Compound Beacon value '"" + orig + ""' cannot be constructed from any available constructor for "" + base.name + "" value parsed as "" + PartsToString(inParts) + "" available constructors are "" + CListToString(construct) + "".""; Failure(E(msg))
    }

    function method {:tailrecursion} partFromPrefix(p: seq<BeaconPart>, value: string): (ret: Result<BeaconPart, Error>)
      ensures ret.Success? ==> ret.value.prefix <= value
      decreases this, p, value
    {
      if |p| == 0 then
        Failure(E(""Value "" + value + "" for beacon "" + base.name + "" does not match the prefix of any configured part.""))
      else if p[0].prefix <= value then
        Success(p[0])
      else
        partFromPrefix(p[1..], value)
    }

    function method SkipSignedPieces(pieces: seq<string>): Result<seq<string>, Error>
      decreases this, pieces
    {
      if |pieces| == 0 then
        Success(pieces)
      else
        var p: BeaconPart :- partFromPrefix(parts, pieces[0]); if p.Encrypted? then Success(pieces) else SkipSignedPieces(pieces[1..])
    }

    function method IsLessThanComparable(pieces: seq<string>): Result<bool, Error>
      decreases this, pieces
    {
      var rest: seq<string> :- SkipSignedPieces(pieces); if |rest| == 0 then Success(true) else if |rest| != 1 then Success(false) else var p: BeaconPart :- partFromPrefix(parts, rest[0]); Success(p.prefix == rest[0])
    }

    function method GetFields(virtualFields: VirtualFieldMap): seq<string>
      decreases this, virtualFields
    {
      Seq.Flatten(Seq.Map((p: BeaconPart) => p.GetFields(virtualFields), parts))
    }

    function method FindAndCalcPart(value: string, keys: MaybeKeyMap): Result<string, Error>
      requires !keys.DontUseKeys?
      decreases this, value, keys
    {
      var part: BeaconPart :- partFromPrefix(parts, value); PartValueCalc(value[|part.prefix|..], keys, part)
    }

    function method justPrefix(value: string): Result<bool, Error>
      decreases this, value
    {
      var part: BeaconPart :- partFromPrefix(parts, value); Success(value == part.prefix)
    }

    function method GetBeaconValue(value: DDB.AttributeValue, keys: MaybeKeyMap, forEquality: bool): Result<DDB.AttributeValue, Error>
      requires !keys.DontUseKeys?
      decreases this, value, keys, forEquality
    {
      if !value.S? then
        Failure(E(""CompoundBeacon "" + base.name + "" can only be queried as a string, not as "" + AttrTypeToStr(value)))
      else
        var parts: seq<seq<char>> := Split(value.S, split); var partsUsed: seq<BeaconPart> :- Seq.MapWithResult((s: seq<char>) => getPartFromPrefix(s), parts); var _ /* _v1 */: bool :- ValidatePartOrder(partsUsed, value.S); var beaconParts: seq<string> :- Seq.MapWithResult((s: seq<char>) => FindAndCalcPart(s, keys), parts); var lastIsPrefix: bool :- justPrefix(Seq.Last(parts)); if !forEquality && lastIsPrefix then var result: seq<char> := Join(beaconParts[..|parts| - 1] + [Seq.Last(parts)], [split]); Success(DDB.AttributeValue.S(result)) else var result: seq<char> := Join(beaconParts, [split]); Success(DDB.AttributeValue.S(result))
    }

    function method {:opaque} {:tailrecursion} TryConstructor(consFields: seq<ConstructorPart>, item: DDB.AttributeMap, vf: VirtualFieldMap, keys: MaybeKeyMap, acc: string := """"): (ret: Result<Option<string>, Error>)
      ensures ret.Success? && ret.value.Some? ==> |ret.value.value| > 0
      decreases this, consFields, item, vf, keys, acc
    {
      if |consFields| == 0 then
        if |acc| == 0 then
          Failure(E(""Internal Error : Empty beacon created.""))
        else
          Success(Some(acc))
      else
        var part: BeaconPart := consFields[0].part; var strValue: Option<string> :- part.getString(item, vf); if strValue.Some? then :- Need(split !in strValue.value, E(""Part "" + part.getName() + "" for beacon "" + base.name + "" has value '"" + strValue.value + ""' which contains the split character "" + [split] + ""'."")); var val: seq<char> :- if keys.DontUseKeys? then Success(part.prefix + strValue.value) else PartValueCalc(strValue.value, keys, part); if |acc| == 0 then TryConstructor(consFields[1..], item, vf, keys, val) else TryConstructor(consFields[1..], item, vf, keys, acc + [split] + val) else if consFields[0].required then Success(None) else TryConstructor(consFields[1..], item, vf, keys, acc)
    }

    function method {:opaque} {:tailrecursion} TryConstructors(construct: seq<Constructor>, item: DDB.AttributeMap, vf: VirtualFieldMap, keys: MaybeKeyMap): (ret: Result<Option<string>, Error>)
      ensures ret.Success? && ret.value.Some? ==> |ret.value.value| > 0
      decreases this, construct, item, vf, keys
    {
      if |construct| == 0 then
        Success(None)
      else
        var x: Option<string> :- TryConstructor(construct[0].parts, item, vf, keys); if x.Some? then Success(x) else TryConstructors(construct[1..], item, vf, keys)
    }

    function method {:opaque} hash(item: DDB.AttributeMap, vf: VirtualFieldMap, keys: MaybeKeyMap): (res: Result<Option<string>, Error>)
      ensures res.Success? && res.value.Some? ==> |res.value.value| > 0 && TryConstructors(construct, item, vf, keys).Success?
      decreases this, item, vf, keys
    {
      TryConstructors(construct, item, vf, keys)
    }

    function method {:opaque} getNaked(item: DDB.AttributeMap, vf: VirtualFieldMap): (res: Result<Option<string>, Error>)
      ensures res.Success? && res.value.Some? ==> true && |res.value.value| > 0
      decreases this, item, vf
    {
      TryConstructors(construct, item, vf, DontUseKeys)
    }

    function method {:opaque} findPart(val: string): (ret: Result<BeaconPart, Error>)
      ensures |Seq.Filter((x: BeaconPart) => x.prefix <= val, parts)| == 0 ==> ret.Failure?
      ensures ret.Success? ==> ret.value.prefix <= val
      ensures |Seq.Filter((x: BeaconPart) => x.prefix <= val, parts)| == 0 ==> ret.Failure?
      decreases this, val
    {
      var thePart: seq<BeaconPart> := Seq.Filter((x: BeaconPart) => x.prefix <= val, parts);
      if |thePart| == 0 then
        Failure(E(""No part found in beacon "" + base.name + "" match prefix "" + val))
      else if |thePart| > 1 then
        Failure(E(""Internal error. Multiple parts for beacon "" + base.name + "" matched prefix of "" + val))
      else
        assert |thePart| == 1; Success(thePart[0])
    }

    function method {:opaque} getPart(val: string, keys: HmacKeyMap): (ret: Result<string, Error>)
      requires 0 < |val|
      ensures ret.Success? ==> |ret.value| > 0 && var pieces: seq<seq<char>> := Split(val, split); calcParts(pieces, keys).Success? && ret.value == calcParts(pieces, keys).value
      decreases this, val, keys
    {
      var pieces: seq<seq<char>> := Split(val, split);
      calcParts(pieces, keys)
    }

    function method calcPart(piece: string, keys: HmacKeyMap): (ret: Result<string, Error>)
      ensures ret.Success? ==> findPart(piece).Success? && |ret.value| > 0 && var thePart: BeaconPart := findPart(piece).value; PartValueCalc(piece, Keys(keys), thePart).Success? && ret.value == PartValueCalc(piece, Keys(keys), thePart).value
      ensures findPart(piece).Failure? ==> ret.Failure?
      decreases this, piece, keys
    {
      var thePart: BeaconPart :- findPart(piece); PartValueCalc(piece, Keys(keys), thePart)
    }

    function method calcParts(pieces: seq<string>, keys: HmacKeyMap, acc: string := []): (ret: Result<string, Error>)
      requires |pieces| > 0 || |acc| > 0
      ensures ret.Success? ==> |ret.value| > 0
      decreases this, pieces, keys, acc
    {
      if |pieces| == 0 then
        Success(acc)
      else
        var theBeacon: string :- calcPart(pieces[0], keys); if |acc| == 0 then calcParts(pieces[1..], keys, theBeacon) else calcParts(pieces[1..], keys, acc + [split] + theBeacon)
    }

    static predicate method OkPrefixStringPair(x: string, y: string)
      decreases x, y
    {
      !(x <= y) &&
      !(y <= x)
    }

    predicate method OkPrefixPair(pos1: nat, pos2: nat)
      requires pos1 < |parts|
      requires pos2 < |parts|
      decreases this, pos1, pos2
    {
      pos1 == pos2 || OkPrefixStringPair(parts[pos1].prefix, parts[pos2].prefix)
    }

    function method CheckOnePrefixPart(pos1: nat, pos2: nat): (ret: Result<bool, Error>)
      requires pos1 < |parts|
      requires pos2 < |parts|
      ensures ret.Success? ==> OkPrefixPair(pos1, pos2)
      decreases this, pos1, pos2
    {
      if !OkPrefixPair(pos1, pos2) then
        Failure(E(""Compound beacon "" + base.name + "" defines part "" + parts[pos1].getName() + "" with prefix "" + parts[pos1].prefix + "" which is incompatible with part "" + parts[pos2].getName() + "" which has a prefix of "" + parts[pos2].prefix + "".""))
      else
        Success(true)
    }

    function method CheckOnePrefix(pos: nat): (ret: Result<bool, Error>)
      requires pos < |parts|
      decreases this, pos
    {
      var partNumbers: seq<nat> := seq(|parts|, (i: nat) => i as nat);
      var _ /* _v2 */: seq<bool> :- Seq.MapWithResult((p: int) requires 0 <= p < |parts| => CheckOnePrefixPart(pos, p), seq(|parts|, (i: int) => i)); Success(true)
    }

    function method {:tailrecursion} ValidPrefixSetResultPos(index: nat): (ret: Result<bool, Error>)
      decreases |parts| - index
    {
      if |parts| <= index then
        Success(true)
      else
        var _ /* _v3 */: bool :- CheckOnePrefix(index); ValidPrefixSetResultPos(index + 1)
    }

    function method ValidPrefixSetResult(): (ret: Result<bool, Error>)
      ensures ret.Success? ==> ValidPrefixSet() && ret.value
      decreases this
    {
      var _ /* _v4 */: bool :- ValidPrefixSetResultPos(0); if forall x: nat, y: nat {:trigger OkPrefixPair(x, y)} | 0 <= x < |parts| && x < y < |parts| :: OkPrefixPair(x, y) then Success(true) else Failure(E(""Internal Error""))
    }

    function method {:opaque} PartValueCalc(data: string, keys: MaybeKeyMap, part: BeaconPart): (ret: Result<string, Error>)
      requires !keys.DontUseKeys?
      ensures part.Signed? && ret.Success? ==> ret.value == part.prefix + data && 0 < |ret.value| && split !in data
      ensures part.Encrypted? && ret.Success? ==> 0 < |ret.value| && keys.Keys? && part.beacon.hashStr(data, keys.value).Success? && ret.value == part.prefix + part.beacon.hashStr(data, keys.value).value && split !in data
      decreases this, data, keys, part
    {
      :- Need(split !in data, E(""Value '"" + data + ""' for beacon part "" + part.getName() + "" contains the split character '"" + [split] + ""'."")); match part { case Encrypted(p, b) => (:- Need(keys.Keys?, E(""Need KeyId for beacon "" + b.base.name + "" but no KeyId found in query."")); var hash: string :- b.hashStr(data, keys.value); Success(part.prefix + hash)) case Signed => Success(part.prefix + data) }
    }
  }
}

module BaseBeacon {
  function method MakeStandardBeacon(client: Primitives.AtomicPrimitivesClient, name: string, length: BeaconLength, loc: string, partOnly: bool, asSet: bool, share: Option<string>): (ret: Result<ValidStandardBeacon, Error>)
    ensures ret.Success? ==> TermLoc.MakeTermLoc(loc).Success? && ret.value.loc == TermLoc.MakeTermLoc(loc).value
    decreases client, name, length, loc, partOnly, asSet, share
  {
    var termLoc: TermLoc :- TermLoc.MakeTermLoc(loc); var beaconName: seq<char> := BeaconPrefix + name; :- Need(DDB.IsValid_AttributeName(beaconName), E(beaconName + "" is not a valid attribute name."")); Success(StandardBeacon.StandardBeacon(BeaconBase(client := client, name := name, beaconName := beaconName), length, termLoc, partOnly, asSet, share))
  }

  function method CharsFromBeaconLength(bits: BeaconLength): (ret: nat)
    ensures 0 < ret <= 16
    decreases bits
  {
    ((bits as uint8 + 3) / 4) as nat
  }

  function method TopBits(bits: BeaconLength): (ret: uint8)
    ensures 1 <= ret <= 4
    decreases bits
  {
    var x: BoundedInts.uint8 := bits as uint8 % 4;
    if x == 0 then
      4
    else
      x
  }

  function method BytesFromBeaconLength(bits: BeaconLength): (ret: nat)
    ensures 0 < ret <= 8
    decreases bits
  {
    ((bits as uint8 + 7) / 8) as nat
  }

  function method TruncateNibble(nibble: Nibble, length: uint8): Nibble
    requires 1 <= length <= 4
    decreases nibble, length
  {
    if length == 4 then
      nibble
    else if length == 3 then
      nibble % 8
    else if length == 2 then
      nibble % 4
    else
      nibble % 2
  }

  function method BytesToHex(bytes: Bytes, bits: BeaconLength): (ret: string)
    requires |bytes| == 8
    ensures |ret| == ((bits as uint8 + 3) / 4) as nat
    decreases bytes, bits
  {
    var numBytes: nat := BytesFromBeaconLength(bits);
    var numChars: nat := CharsFromBeaconLength(bits);
    var topBits: uint8 := TopBits(bits);
    var bytes: seq<BoundedInts.uint8> := bytes[8 - numBytes..];
    if numChars == 2 * numBytes then
      var topNibble: BoundedInts.uint8 := bytes[0] / 16;
      var bottomNibble: BoundedInts.uint8 := bytes[0] % 16;
      [HexChar(TruncateNibble(topNibble, topBits)), HexChar(bottomNibble)] + ToHexString(bytes[1..])
    else
      [HexChar(TruncateNibble(bytes[0] % 16, topBits))] + ToHexString(bytes[1..])
  }

  import opened Wrappers

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import opened String = StandardLibrary.String

  import opened AwsCryptographyDbEncryptionSdkDynamoDbTypes

  import opened HexStrings

  import opened DynamoDbEncryptionUtil

  import opened DdbVirtualFields

  import opened Seq

  import DynamoToStruct

  import DDB = ComAmazonawsDynamodbTypes

  import Prim = AwsCryptographyPrimitivesTypes

  import Primitives = AtomicPrimitives

  import UTF8

  import SortedSets

  import TermLoc

  newtype BeaconLength = x: int
    | 1 <= x <= 63
    witness 1

  type Nibble = x: uint8
    | 0 <= x < 16

  datatype BeaconBase = BeaconBase(nameonly client: Primitives.AtomicPrimitivesClient, nameonly name: string, nameonly beaconName: DDB.AttributeName) {
    function method {:opaque} hash(val: Bytes, key: Bytes, length: BeaconLength): (ret: Result<string, Error>)
      ensures ret.Success? ==> |ret.value| > 0 && getHmac(val, key).Success? && var hash: Bytes := getHmac(val, key).value; ret.value == BytesToHex(hash, length) && |ret.value| == ((length as uint8 + 3) / 4) as nat
      decreases this, val, key, length
    {
      var hash: Bytes :- getHmac(val, key); Success(BytesToHex(hash, length))
    }

    function method {:opaque} hashStr(val: string, key: Bytes, length: BeaconLength): (res: Result<string, Error>)
      ensures res.Success? ==> |res.value| > 0
      decreases this, val, key, length
    {
      var str: Result<ValidUTF8Bytes, string> := UTF8.Encode(val);
      if str.Failure? then
        Failure(E(str.error))
      else
        hash(str.value, key, length)
    }

    function method {:opaque} getHmac(data: Bytes, key: Bytes): (res: Result<Bytes, Error>)
      ensures res.Success? ==> |res.value| == 8
      ensures res.Success? ==> true && var input: HMacInput := Prim.HMacInput(digestAlgorithm := Prim.SHA_384, key := key, message := data); client.HMac(input).Success? && res.value == client.HMac(input).value[..8]
      decreases this, data, key
    {
      var input: HMacInput := Prim.HMacInput(digestAlgorithm := Prim.SHA_384, key := key, message := data);
      var output: seq<uint8> :- client.HMac(input).MapFailure((e: Error) => AwsCryptographyPrimitives(e)); Success(output[..8])
    }
  }

  type ValidStandardBeacon = x: StandardBeacon
    | x.ValidState()
    witness *

  datatype StandardBeacon = StandardBeacon(base: BeaconBase, length: BeaconLength, loc: TermLoc.TermLoc, partOnly: bool, asSet: bool, share: Option<string>) {
    function method {:opaque} hash(val: Bytes, key: Bytes): (ret: Result<string, Error>)
      ensures ret.Success? ==> |ret.value| > 0 && base.hash(val, key, length).Success? && ret.value == base.hash(val, key, length).value && |ret.value| == ((length as uint8 + 3) / 4) as nat
      decreases this, val, key
    {
      base.hash(val, key, length)
    }

    function method keyName(): string
      decreases this
    {
      if share.Some? then
        share.value
      else
        base.name
    }

    function method {:opaque} hashStr(val: string, keys: HmacKeyMap): (res: Result<string, Error>)
      ensures res.Success? ==> |res.value| > 0
      ensures res.Success? ==> keyName() in keys && UTF8.Encode(val).Success? && var str: ValidUTF8Bytes := UTF8.Encode(val).value; hash(str, keys[keyName()]).Success? && res.value == hash(str, keys[keyName()]).value
      decreases this, val, keys
    {
      :- Need(keyName() in keys, E(""Internal Error, no key for "" + keyName())); var str: Result<ValidUTF8Bytes, string> := UTF8.Encode(val); if str.Failure? then Failure(E(str.error)) else hash(str.value, keys[keyName()])
    }

    function method {:opaque} ValueToSet(value: DDB.AttributeValue, key: Bytes): (ret: Result<DDB.AttributeValue, Error>)
      ensures ret.Success? ==> ret.value.SS?
      ensures !value.SS? && !value.NS? && !value.BS? ==> ret.Failure?
      ensures ret.Success? ==> HasNoDuplicates(ret.value.SS)
      decreases this, value, key
    {
      reveal HasNoDuplicates();
      assert HasNoDuplicates<string>([]);
      var beaconSeq: seq<string> :- match value { case SS(n) => BeaconizeStringSet(n, key) case NS(n) => BeaconizeNumberSet(n, key) case BS(n) => BeaconizeBinarySet(n, key) case _ /* _v0 */ => Failure(E(""Beacon "" + base.name + "" has style AsSet, but attribute has type "" + AttrTypeToStr(value) + ""."")) }; Success(DDB.AttributeValue.SS(beaconSeq))
    }

    function method {:opaque} getHash(item: DDB.AttributeMap, vf: VirtualFieldMap, key: Bytes): (ret: Result<Option<DDB.AttributeValue>, Error>)
      ensures asSet ==> ret == getHashSet(item, key)
      ensures !asSet ==> ret == getHashNonSet(item, vf, key)
      decreases this, item, vf, key
    {
      if asSet then
        getHashSet(item, key)
      else
        getHashNonSet(item, vf, key)
    }

    function method {:opaque} getHashSet(item: DDB.AttributeMap, key: Bytes): (ret: Result<Option<DDB.AttributeValue>, Error>)
      requires asSet
      ensures ret.Success? ==> (ret.value.Some? ==> ret.value.value.SS?) && (ret.value.Some? ==> HasNoDuplicates(ret.value.value.SS)) && var value: Option<DDB.AttributeValue> := TermLoc.TermToAttr(loc, item, None); true && (value.Some? && !(value.value.SS? || value.value.NS? || value.value.BS?) ==> ret.Failure?)
      decreases this, item, key
    {
      var value: Option<DDB.AttributeValue> := TermLoc.TermToAttr(loc, item, None);
      if value.None? then
        Success(None)
      else
        var setValue: DDB.AttributeValue :- ValueToSet(value.value, key); Success(Some(setValue))
    }

    function method {:opaque} getHashNonSet(item: DDB.AttributeMap, vf: VirtualFieldMap, key: Bytes): (ret: Result<Option<DDB.AttributeValue>, Error>)
      requires !asSet
      ensures ret.Success? ==> (ret.value.Some? ==> ret.value.value.S?) && VirtToBytes(loc, item, vf).Success? && var bytes: Option<Bytes> := VirtToBytes(loc, item, vf).value; (bytes.None? ==> ret.value.None?) && (bytes.Some? ==> ret.value.Some? && hash(bytes.value, key).Success? && ret.value.value == DDB.AttributeValue.S(hash(bytes.value, key).value)) && (bytes.Some? ==> ret.value.Some? && base.hash(bytes.value, key, length).Success? && ret.value.value == DDB.AttributeValue.S(base.hash(bytes.value, key, length).value))
      decreases this, item, vf, key
    {
      var bytes: Option<Bytes> :- VirtToBytes(loc, item, vf); if bytes.None? then Success(None) else var res: string :- hash(bytes.value, key); Success(Some(DDB.AttributeValue.S(res)))
    }

    function method {:opaque} getNaked(item: DDB.AttributeMap, vf: VirtualFieldMap): Result<Option<DDB.AttributeValue>, Error>
      decreases this, item, vf
    {
      VirtToAttr(loc, item, vf)
    }

    function method GetFields(virtualFields: VirtualFieldMap): seq<string>
      decreases this, virtualFields
    {
      if loc[0].key in virtualFields then
        virtualFields[loc[0].key].GetFields()
      else
        [loc[0].key]
    }

    function method {:tailrecursion} BeaconizeStringSet(value: DDB.StringSetAttributeValue, key: Bytes, converted: seq<string> := []): (ret: Result<seq<string>, Error>)
      requires HasNoDuplicates(converted)
      ensures ret.Success? ==> HasNoDuplicates(ret.value)
      decreases this, value, key, converted
    {
      if |value| == 0 then
        Success(converted)
      else
        var bytes: seq<uint8> :- DynamoToStruct.TopLevelAttributeToBytes(DDB.AttributeValue.S(value[0])).MapFailure((e: seq<char>) => E(e)); var h: string :- hash(bytes, key); if h in converted then BeaconizeStringSet(value[1..], key, converted) else reveal HasNoDuplicates(); BeaconizeStringSet(value[1..], key, converted + [h])
    }

    function method {:tailrecursion} BeaconizeNumberSet(value: DDB.NumberSetAttributeValue, key: Bytes, converted: seq<string> := []): (ret: Result<seq<string>, Error>)
      requires HasNoDuplicates(converted)
      ensures ret.Success? ==> HasNoDuplicates(ret.value)
      decreases this, value, key, converted
    {
      if |value| == 0 then
        Success(converted)
      else
        var bytes: seq<uint8> :- DynamoToStruct.TopLevelAttributeToBytes(DDB.AttributeValue.N(value[0])).MapFailure((e: seq<char>) => E(e)); var h: string :- hash(bytes, key); if h in converted then BeaconizeNumberSet(value[1..], key, converted) else reveal HasNoDuplicates(); BeaconizeNumberSet(value[1..], key, converted + [h])
    }

    function method {:tailrecursion} BeaconizeBinarySet(value: DDB.BinarySetAttributeValue, key: Bytes, converted: seq<string> := []): (ret: Result<seq<string>, Error>)
      requires HasNoDuplicates(converted)
      ensures ret.Success? ==> HasNoDuplicates(ret.value)
      decreases this, value, key, converted
    {
      if |value| == 0 then
        Success(converted)
      else
        var bytes: seq<uint8> :- DynamoToStruct.TopLevelAttributeToBytes(DDB.AttributeValue.B(value[0])).MapFailure((e: seq<char>) => E(e)); var h: string :- hash(bytes, key); if h in converted then BeaconizeBinarySet(value[1..], key, converted) else reveal HasNoDuplicates(); BeaconizeBinarySet(value[1..], key, converted + [h])
    }

    function method GetBeaconValue(value: DDB.AttributeValue, key: Bytes, forContains: bool): (ret: Result<DDB.AttributeValue, Error>)
      decreases this, value, key, forContains
    {
      if asSet && !value.S? && !value.N? && !value.B? then
        ValueToSet(value, key)
      else if forContains && (value.SS? || value.NS? || value.BS?) then
        ValueToSet(value, key)
      else
        var bytes: seq<uint8> :- DynamoToStruct.TopLevelAttributeToBytes(value).MapFailure((e: seq<char>) => E(e)); var h: string :- hash(bytes, key); Success(DDB.AttributeValue.S(h))
    }

    function method {:opaque} getPart(val: Bytes, key: Bytes): (ret: Result<string, Error>)
      requires 0 < |val|
      ensures ret.Success? ==> true && |ret.value| > 0
      ensures ret.Success? ==> base.hash(val, key, length).Success? && ret.value == base.hash(val, key, length).value
      decreases this, val, key
    {
      base.hash(val, key, length)
    }

    predicate ValidState()
      decreases this
    {
      true
    }
  }
}

module DynamoDBFilterExpr {
  function method ExtractAttributes(s: string, ex: Option<DDB.ExpressionAttributeNameMap>): seq<string>
    decreases s, ex
  {
    var tokens: seq<Token> := ParseExpr(s);
    ExtractAttributes2(tokens, ex, -1)
  }

  predicate method IsSpecial(t: Token)
    decreases t
  {
    t.AttributeExists? || t.AttributeNotExists? || t.Size?
  }

  function method {:tailrecursion} ExtractAttributes2(tokens: seq<Token>, names: Option<DDB.ExpressionAttributeNameMap>, tokensUntilSkip: int): seq<string>
    decreases tokens, names, tokensUntilSkip
  {
    if |tokens| == 0 then
      []
    else if IsSpecial(tokens[0]) then
      ExtractAttributes2(tokens[1..], names, 1)
    else if tokens[0].Attr? && tokensUntilSkip == 0 then
      ExtractAttributes2(tokens[1..], names, -1)
    else if tokens[0].Attr? then
      [GetAttrName(tokens[0], names)] + ExtractAttributes2(tokens[1..], names, -1)
    else
      ExtractAttributes2(tokens[1..], names, tokensUntilSkip - 1)
  }

  predicate method IsEquality(t: Token)
    decreases t
  {
    t.Eq? || t.Ne? || t.In?
  }

  predicate method IsInequality(t: Token)
    decreases t
  {
    t.Lt? || t.Le? || t.Gt? || t.Ge?
  }

  function method TokenToString(t: Token): string
    decreases t
  {
    match t {
      case Attr(s, l) =>
        s
      case Value(s) =>
        s
      case Eq() =>
        ""=""
      case Ne() =>
        ""<>""
      case Lt() =>
        ""<""
      case Gt() =>
        "">""
      case Le() =>
        ""<=""
      case Ge() =>
        "">=""
      case Between() =>
        ""BETWEEN""
      case In() =>
        ""IN""
      case Open() =>
        ""(""
      case Close() =>
        "")""
      case Comma() =>
        "",""
      case Not() =>
        ""NOT""
      case And() =>
        ""AND""
      case Or() =>
        ""OR""
      case AttributeExists() =>
        ""attribute_exists""
      case AttributeNotExists() =>
        ""attribute_not_exists""
      case AttributeType() =>
        ""attribute_type""
      case BeginsWith() =>
        ""begins_with""
      case Contains() =>
        ""contains""
      case Size() =>
        ""size""
    }
  }

  function method {:tailrecursion} GetInPos(expr: seq<Token>, pos: nat): (ret: Option<nat>)
    requires pos < |expr|
    requires expr[pos].Value?
    ensures ret.Some? ==> ret.value >= 1 && ret.value < |expr|
    decreases expr, pos
  {
    if pos < 3 then
      None
    else if expr[pos - 1].Open? && expr[pos - 2].In? then
      Some(pos - 2)
    else if expr[pos - 1].Comma? && expr[pos - 2].Value? then
      GetInPos(expr, pos - 2)
    else
      None
  }

  function method RealName(s: string): string
    decreases s
  {
    if BeaconPrefix < s then
      s[|BeaconPrefix|..]
    else
      s
  }

  predicate method HasBeacon(b: SI.BeaconVersion, t: Token, names: Option<DDB.ExpressionAttributeNameMap>)
    decreases b, t, names
  {
    if t.Attr? then
      var name: string := RealName(t.s);
      name in b.beacons || (names.Some? && name in names.value && RealName(names.value[name]) in b.beacons) || name in b.encryptedFields || (names.Some? && name in names.value && RealName(names.value[name]) in b.encryptedFields)
    else
      false
  }

  function method GetBeacon2(b: SI.BeaconVersion, t: Token, names: Option<DDB.ExpressionAttributeNameMap>): (ret: Result<SI.Beacon, Error>)
    requires HasBeacon(b, t, names)
    ensures var name: string := RealName(t.s); name in b.beacons && SI.IsPartOnly(b.beacons[name]) ==> ret.Failure?
    decreases b, t, names
  {
    var name: string := RealName(t.s);
    if name in b.beacons then
      if SI.IsPartOnly(b.beacons[name]) then
        Failure(E(""Field "" + name + "" is encrypted, and has a PartOnly beacon, and so can only be used as part of a compound beacon.""))
      else
        Success(b.beacons[name])
    else if names.Some? && name in names.value && RealName(names.value[name]) in b.beacons then
      var name2: string := RealName(names.value[name]);
      Success(b.beacons[name2])
    else if name in b.encryptedFields then
      Failure(E(""Field "" + name + "" is encrypted, and cannot be searched without a beacon.""))
    else
      var name2: string := RealName(names.value[name]); Failure(E(""Field "" + name2 + "" is encrypted, and cannot be searched without a beacon.""))
  }

  function method GetBeacon(bv: SI.BeaconVersion, t: Token, op: Token, value: Token, names: Option<DDB.ExpressionAttributeNameMap>, values: DDB.ExpressionAttributeValueMap): Result<EqualityBeacon, Error>
    requires HasBeacon(bv, t, names)
    requires value.Value?
    decreases bv, t, op, value, names, values
  {
    var b: SI.Beacon :- GetBeacon2(bv, t, names); var _ /* _v0 */: bool :- CanBeacon(b, op, value.s, values); Success(EqualityBeacon(Some(b), IsEquality(op), op == Contains))
  }

  function method GetBetweenBeacon(bv: SI.BeaconVersion, t: Token, op: Token, leftValue: Token, rightValue: Token, names: Option<DDB.ExpressionAttributeNameMap>, values: DDB.ExpressionAttributeValueMap): (ret: Result<EqualityBeacon, Error>)
    requires HasBeacon(bv, t, names)
    requires leftValue.Value?
    requires rightValue.Value?
    ensures GetBeacon2(bv, t, names).Success? && (var b: SI.Beacon := GetBeacon2(bv, t, names).value; true && CanBetween(b, op, leftValue.s, rightValue.s, values).Failure?) ==> ret.Failure?
    decreases bv, t, op, leftValue, rightValue, names, values
  {
    var b: SI.Beacon :- GetBeacon2(bv, t, names); var _ /* _v1 */: bool :- CanBetween(b, op, leftValue.s, rightValue.s, values); Success(EqualityBeacon(Some(b), false, false))
  }

  function method CanStandardBeacon(op: Token): (ret: Result<bool, Error>)
    ensures ret.Success? ==> ret.value
    decreases op
  {
    match op {
      case Ne() | Lt() | Gt() | Le() | Ge() | Between() | BeginsWith() =>
        Failure(E(""The operation '"" + TokenToString(op) + ""' cannot be used with a standard beacon.""))
      case _ /* _v2 */ =>
        Success(true)
    }
  }

  function method CanCompoundBeacon(b: SI.Beacon, op: Token, value: string): (ret: Result<bool, Error>)
    requires b.Compound?
    ensures ret.Success? ==> ret.value
    ensures IsInequality(op) && (var pieces: seq<seq<char>> := Split(value, b.cmp.split); b.cmp.IsLessThanComparable(pieces).Success? && !b.cmp.IsLessThanComparable(pieces).value) ==> ret.Failure?
    decreases b, op, value
  {
    match op {
      case Lt() | Gt() | Le() | Ge() =>
        var pieces: seq<seq<char>> := Split(value, b.cmp.split);
        var canLess: bool :- b.cmp.IsLessThanComparable(pieces); if canLess then Success(true) else Failure(E(""The operation '"" + TokenToString(op) + ""' cannot be used with a compound beacon, unless the value is LessThanComparable : "" + value))
      case _ /* _v3 */ =>
        Success(true)
    }
  }

  function method GetStringFromValue(value: string, values: DDB.ExpressionAttributeValueMap, b: SI.Beacon): (ret: Result<string, Error>)
    requires b.Compound?
    decreases value, values, b
  {
    if value in values then
      var val: AttributeValue := values[value];
      if val.S? then
        Success(val.S)
      else
        Failure(E(""Value "" + value + "" supplied for compound beacon "" + b.cmp.base.name + "" is of type "" + AttrTypeToStr(val) + "" but must be of type S (string).""))
    else
      Failure(E(""Value "" + value + "" used in query string, but not supplied in value map.""))
  }

  function method CanBeacon(b: SI.Beacon, op: Token, value: string, values: DDB.ExpressionAttributeValueMap): (ret: Result<bool, Error>)
    ensures ret.Success? ==> ret.value
    decreases b, op, value, values
  {
    if b.Standard? then
      CanStandardBeacon(op)
    else
      var val: string :- GetStringFromValue(value, values, b); CanCompoundBeacon(b, op, val)
  }

  function method {:tailrecursion} RemoveCommonPrefix(x: seq<string>, y: seq<string>): (seq<string>, seq<string>)
    decreases x, y
  {
    if |x| == 0 || |y| == 0 || x[0] != y[0] then
      (x, y)
    else
      RemoveCommonPrefix(x[1..], y[1..])
  }

  function method CanBetween(b: SI.Beacon, op: Token, leftValue: string, rightValue: string, values: DDB.ExpressionAttributeValueMap): (ret: Result<bool, Error>)
    ensures ret.Success? ==> ret.value
    ensures b.Compound? && GetStringFromValue(leftValue, values, b).Success? && (var leftVal: string := GetStringFromValue(leftValue, values, b).value; GetStringFromValue(rightValue, values, b).Success? && var rightVal: string := GetStringFromValue(rightValue, values, b).value; true && var leftParts: seq<seq<char>> := Split(leftVal, b.cmp.split); true && var rightParts: seq<seq<char>> := Split(rightVal, b.cmp.split); true && var (newLeft: seq<string>, newRight: seq<string>) := RemoveCommonPrefix(leftParts, rightParts); b.cmp.IsLessThanComparable(newLeft).Success? && var leftCanLess: bool := b.cmp.IsLessThanComparable(newLeft).value; b.cmp.IsLessThanComparable(newRight).Success? && var rightCanLess: bool := b.cmp.IsLessThanComparable(newRight).value; true && !(leftCanLess && rightCanLess)) ==> ret.Failure?
    decreases b, op, leftValue, rightValue, values
  {
    if b.Standard? then
      Failure(E(""The operation BETWEEN cannot be used with a standard beacon.""))
    else
      var leftVal: string :- GetStringFromValue(leftValue, values, b); var rightVal: string :- GetStringFromValue(rightValue, values, b); var leftParts: seq<seq<char>> := Split(leftVal, b.cmp.split); var rightParts: seq<seq<char>> := Split(rightVal, b.cmp.split); var (newLeft: seq<string>, newRight: seq<string>) := RemoveCommonPrefix(leftParts, rightParts); var leftCanLess: bool :- b.cmp.IsLessThanComparable(newLeft); var rightCanLess: bool :- b.cmp.IsLessThanComparable(newRight); :- Need(leftCanLess && rightCanLess, E(""To use BETWEEN with a compound beacon, the part after any common prefix must be LessThanComparable : "" + ""BETWEEN "" + leftVal + "" AND "" + rightVal)); Success(true)
  }

  function method BeaconForValue(b: SI.BeaconVersion, expr: seq<Token>, pos: nat, names: Option<DDB.ExpressionAttributeNameMap>, values: DDB.ExpressionAttributeValueMap): Result<EqualityBeacon, Error>
    requires pos < |expr|
    requires expr[pos].Value?
    decreases b, expr, pos, names, values
  {
    if pos + 2 < |expr| && IsComp(expr[pos + 1]) && HasBeacon(b, expr[pos + 2], names) then
      GetBeacon(b, expr[pos + 2], expr[pos + 1], expr[pos], names, values)
    else if 2 <= pos && IsComp(expr[pos - 1]) && HasBeacon(b, expr[pos - 2], names) then
      GetBeacon(b, expr[pos - 2], expr[pos - 1], expr[pos], names, values)
    else if 4 <= pos && (expr[pos - 4].Contains? || expr[pos - 4].BeginsWith?) && expr[pos - 3].Open? && HasBeacon(b, expr[pos - 2], names) && expr[pos - 1].Comma? then
      GetBeacon(b, expr[pos - 2], expr[pos - 4], expr[pos], names, values)
    else if 2 <= pos < |expr| - 2 && (expr[pos - 2].Contains? || expr[pos - 2].BeginsWith?) && expr[pos - 1].Open? && HasBeacon(b, expr[pos + 2], names) && expr[pos + 1].Comma? then
      GetBeacon(b, expr[pos + 2], expr[pos - 2], expr[pos], names, values)
    else if 2 <= pos < |expr| - 2 && expr[pos - 1].Between? && HasBeacon(b, expr[pos - 2], names) && expr[pos + 2].Value? then
      GetBetweenBeacon(b, expr[pos - 2], expr[pos - 1], expr[pos], expr[pos + 2], names, values)
    else if 4 <= pos && expr[pos - 1].And? && expr[pos - 3].Between? && HasBeacon(b, expr[pos - 4], names) && expr[pos - 2].Value? then
      GetBetweenBeacon(b, expr[pos - 4], expr[pos - 3], expr[pos - 2], expr[pos], names, values)
    else if expr[pos].Value? then
      var in_pos: Option<nat> := GetInPos(expr, pos);
      if in_pos.None? then
        Success(EqualityBeacon(None, true, false))
      else if HasBeacon(b, expr[in_pos.value - 1], names) then
        GetBeacon(b, expr[in_pos.value - 1], expr[in_pos.value], expr[pos], names, values)
      else
        Success(EqualityBeacon(None, true, false))
    else
      Success(EqualityBeacon(None, true, false))
  }

  function method AttrForValue(expr: seq<Token>, pos: nat): (ret: Option<Token>)
    requires pos < |expr|
    requires expr[pos].Value?
    ensures ret.Some? ==> ret.value.Attr?
    decreases expr, pos
  {
    if pos + 2 < |expr| && IsComp(expr[pos + 1]) && expr[pos + 2].Attr? then
      Some(expr[pos + 2])
    else if 2 <= pos && IsComp(expr[pos - 1]) && expr[pos - 2].Attr? then
      Some(expr[pos - 2])
    else if 4 <= pos && (expr[pos - 4].Contains? || expr[pos - 4].BeginsWith?) && expr[pos - 3].Open? && expr[pos - 2].Attr? && expr[pos - 1].Comma? then
      Some(expr[pos - 2])
    else if 2 <= pos && expr[pos - 1].Between? && expr[pos - 2].Attr? then
      Some(expr[pos - 2])
    else if 4 <= pos && expr[pos - 1].And? && expr[pos - 3].Between? && expr[pos - 4].Attr? then
      Some(expr[pos - 4])
    else
      var in_pos: Option<nat> := GetInPos(expr, pos); if in_pos.None? then None else if expr[in_pos.value - 1].Attr? then Some(expr[in_pos.value - 1]) else None
  }

  predicate method OpNeedsBeacon(expr: seq<Token>, pos: nat)
    requires pos < |expr|
    requires expr[pos].Attr?
    decreases expr, pos
  {
    if pos < 2 then
      true
    else if !expr[pos - 1].Open? then
      true
    else
      TokenNeedsBeacon(expr[pos - 2])
  }

  predicate method IsAllowedOnBeaconPred(expr: seq<Token>, pos: nat)
    requires pos < |expr|
    requires expr[pos].Attr?
    decreases expr, pos
  {
    if pos < 2 then
      true
    else if !expr[pos - 1].Open? then
      true
    else if TokenAllowsBeacon(expr[pos - 2]) then
      true
    else
      false
  }

  function method IsAllowedOnBeacon(expr: seq<Token>, pos: nat, name: string): Result<bool, Error>
    requires pos < |expr|
    requires expr[pos].Attr?
    decreases expr, pos, name
  {
    if IsAllowedOnBeaconPred(expr, pos) then
      Success(true)
    else
      Failure(E(""Function "" + TokenToString(expr[pos - 2]) + "" cannot be used on encrypted fields, but it is being used with "" + name))
  }

  predicate method TokenNeedsBeacon(t: Token)
    decreases t
  {
    !(t.AttributeExists? || t.AttributeNotExists?)
  }

  predicate method TokenAllowsBeacon(t: Token)
    decreases t
  {
    !(t.AttributeType? || t.Size?)
  }

  function method {:tailrecursion} BeaconizeParsedExpr(b: SI.BeaconVersion, expr: seq<Token>, pos: nat, oldValues: DDB.ExpressionAttributeValueMap, names: Option<DDB.ExpressionAttributeNameMap>, keys: MaybeKeyMap, newValues: DDB.ExpressionAttributeValueMap, acc: seq<Token> := []): Result<ParsedContext, Error>
    requires pos <= |expr|
    decreases |expr| - pos
  {
    if pos == |expr| then
      Success(ParsedContext(acc, newValues, names))
    else if expr[pos].Attr? then
      var isIndirectName: bool := ""#"" <= expr[pos].s;
      :- Need(!isIndirectName || (names.Some? && expr[pos].s in names.value), E(""Name "" + expr[pos].s + "" not in ExpressionAttributeNameMap."")); var oldName: seq<char> := if isIndirectName then names.value[expr[pos].s] else expr[pos].s; var exclude: bool := keys.DontUseKeys? && !IsAllowedOnBeaconPred(expr, pos); if b.IsBeacon(oldName) && !exclude then var _ /* _v4 */: bool :- IsAllowedOnBeacon(expr, pos, oldName); if OpNeedsBeacon(expr, pos) then var newName: string := b.beacons[oldName].getBeaconName(); if isIndirectName then BeaconizeParsedExpr(b, expr, pos + 1, oldValues, Some(names.value[expr[pos].s := newName]), keys, newValues, acc + [expr[pos]]) else BeaconizeParsedExpr(b, expr, pos + 1, oldValues, names, keys, newValues, acc + [Attr(newName, TermLocMap(newName))]) else BeaconizeParsedExpr(b, expr, pos + 1, oldValues, names, keys, newValues, acc + [expr[pos]]) else BeaconizeParsedExpr(b, expr, pos + 1, oldValues, names, keys, newValues, acc + [expr[pos]])
    else if expr[pos].Value? then
      var name: string := expr[pos].s;
      :- Need(name in oldValues, E(name + "" not found in ExpressionAttributeValueMap"")); var oldValue: AttributeValue := oldValues[name]; var eb: EqualityBeacon :- BeaconForValue(b, expr, pos, names, oldValues); var newValue: DDB.AttributeValue :- if eb.beacon.None? then Success(oldValue) else eb.beacon.value.GetBeaconValue(oldValue, keys, eb.forEquality, eb.forContains); :- Need(name !in newValues || newValues[name] == newValue, E(name + "" used in two different contexts, which is not allowed."")); BeaconizeParsedExpr(b, expr, pos + 1, oldValues, names, keys, newValues[name := newValue], acc + [expr[pos]])
    else
      BeaconizeParsedExpr(b, expr, pos + 1, oldValues, names, keys, newValues, acc + [expr[pos]])
  }

  function method ParsedExprToString(t: seq<Token>): string
    decreases t
  {
    var x: seq<string> := Seq.Map((x: Token) => TokenToString(x), t);
    if |x| == 0 then
      """"
    else
      Join(x, "" "")
  }

  predicate method IsUnary(t: Token)
    decreases t
  {
    match t
    case Not() =>
      true
    case _ /* _v5 */ =>
      false
  }

  predicate method IsComp(t: Token)
    decreases t
  {
    match t
    case Eq() | Ne() | Lt() | Gt() | Le() | Ge() =>
      true
    case _ /* _v6 */ =>
      false
  }

  predicate method IsBinaryBool(t: Token)
    decreases t
  {
    match t
    case And() | Or() =>
      true
    case _ /* _v7 */ =>
      false
  }

  predicate method IsBinary(t: Token)
    decreases t
  {
    IsComp(t) || IsBinaryBool(t)
  }

  predicate method IsVar(t: Token)
    decreases t
  {
    match t
    case Value(s) =>
      true
    case Attr(s, loc) =>
      true
    case _ /* _v8 */ =>
      false
  }

  predicate method IsFunction(t: Token)
    decreases t
  {
    match t
    case Between() | In() | AttributeExists() | AttributeNotExists() | AttributeType() | BeginsWith() | Contains() | Size() =>
      true
    case _ /* _v9 */ =>
      false
  }

  function method Precedence(t: Token): nat
    decreases t
  {
    match t
    case Open() =>
      11
    case Close() =>
      11
    case Comma() =>
      11
    case Attr(s, loc) =>
      10
    case Value(s) =>
      10
    case Eq() =>
      9
    case Ne() =>
      9
    case Lt() =>
      9
    case Gt() =>
      9
    case Le() =>
      9
    case Ge() =>
      9
    case In() =>
      8
    case Between() =>
      7
    case AttributeExists() =>
      6
    case AttributeNotExists() =>
      6
    case AttributeType() =>
      6
    case BeginsWith() =>
      6
    case Contains() =>
      6
    case Size() =>
      6
    case Not() =>
      5
    case And() =>
      4
    case Or() =>
      3
  }

  function method {:tailrecursion} ParseExpr(s: string): (res: seq<Token>)
    ensures s == [] ==> res == []
    decreases |s|
  {
    var tup: (nat, Token) := FindIndexToken(s);
    if 0 < tup.0 then
      [tup.1] + ParseExpr(s[tup.0..])
    else
      []
  }

  function method ByteLower(ch: uint8): uint8
    decreases ch
  {
    if 'A' as uint8 <= ch <= 'Z' as uint8 then
      ch - 'A' as uint8 + 'a' as uint8
    else
      ch
  }

  function method CharLower(ch: char): char
    decreases ch
  {
    if 'A' <= ch <= 'Z' then
      ch - 'A' + 'a'
    else
      ch
  }

  function method strLower(s: string): (res: string)
    ensures |s| == |res|
    decreases s
  {
    if 0 == |s| then
      s
    else
      [CharLower(s[0])] + strLower(s[1..])
  }

  function method PrefixLower(pre: string, s: string): (res: bool)
    decreases pre, s
  {
    strLower(pre) <= strLower(s)
  }

  predicate method ValueChar(ch: char)
    decreases ch
  {
    if 'a' <= ch <= 'z' then
      true
    else if 'A' <= ch <= 'Z' then
      true
    else if '0' <= ch <= '9' then
      true
    else if ch == '_' then
      true
    else
      false
  }

  predicate method AttributeChar(ch: char)
    decreases ch
  {
    if ValueChar(ch) then
      true
    else if ch in [':', '[', ']', '.', '#'] then
      true
    else
      false
  }

  function method ValueLen(s: string): (res: nat)
    ensures res <= |s|
    decreases s
  {
    if 0 == |s| then
      0
    else if ValueChar(s[0]) then
      ValueLen(s[1..]) + 1
    else
      0
  }

  function method AttributeLen(s: string): (res: nat)
    ensures res <= |s|
    decreases s
  {
    if 0 == |s| then
      0
    else if AttributeChar(s[0]) then
      AttributeLen(s[1..]) + 1
    else
      0
  }

  function method MakeAttr(s: string): Token
    decreases s
  {
    var loc: Result<TermLoc, Error> := MakeTermLoc(s);
    if loc.Success? then
      Attr(s, loc.value)
    else
      Attr(s, TermLocMap(s))
  }

  function method {:vcs_split_on_every_assert} FindIndexToken(s: string): (res: (nat, Token))
    ensures res.0 <= |s|
    decreases s
  {
    if 0 == |s| then
      (0, Close)
    else
      var ch: char := s[0]; if ch == ' ' then var foo: (nat, Token) := FindIndexToken(s[1..]); if foo.0 == 0 then (foo.0, foo.1) else (foo.0 + 1, foo.1) else if ch == '(' then (1, Open) else if ch == ')' then (1, Close) else if ch == ',' then (1, Comma) else if ch == '=' then (1, Eq) else if ch == '<' then if ""<="" <= s then (2, Le) else if ""<>"" <= s then (2, Ne) else (1, Lt) else if ch == '>' then if "">="" <= s then (2, Ge) else (1, Gt) else if PrefixLower(""in"", s) then (2, In) else if PrefixLower(""between"", s) then (7, Between) else if PrefixLower(""and"", s) then (3, And) else if PrefixLower(""or"", s) then (2, Or) else if PrefixLower(""not"", s) then (3, Not) else if PrefixLower(""attribute_not_exists"", s) then (20, AttributeNotExists) else if PrefixLower(""attribute_type"", s) then (14, AttributeType) else if PrefixLower(""begins_with"", s) then (11, BeginsWith) else if PrefixLower(""attribute_exists"", s) then (16, AttributeExists) else if PrefixLower(""contains"", s) then (8, Contains) else if PrefixLower(""size"", s) then (4, Size) else if ch == ':' then var x: int := ValueLen(s[1..]) + 1; (x, Value(s[0 .. x])) else if ch == '#' then var x: int := ValueLen(s[1..]) + 1; (x, MakeAttr(s[0 .. x])) else var x: nat := AttributeLen(s); (x, MakeAttr(s[0 .. x]))
  }

  function method {:opaque} VarOrSize(input: seq<Token>): (ret: nat)
    ensures ret <= |input|
    decreases input
  {
    if |input| == 0 then
      0
    else if input[0].Value? || input[0].Attr? then
      1
    else if 3 < |input| && input[0].Size? && input[1].Open? && IsVar(input[2]) && input[3].Close? then
      4
    else
      0
  }

  function method IsBetween(input: seq<Token>): (ret: Option<(int, int, int)>)
    ensures ret.Some? ==> ret.value.0 + ret.value.1 + ret.value.2 + 2 <= |input|
    decreases input
  {
    if |input| < 5 then
      None
    else
      var p1: nat := VarOrSize(input); if 0 < p1 && p1 + 1 < |input| && input[p1].Between? then var p2: nat := VarOrSize(input[p1 + 1..]); if 0 < p2 && p1 + p2 + 2 < |input| && input[p1 + p2 + 1].And? then var p3: nat := VarOrSize(input[p1 + p2 + 2..]); if 0 < p3 then Some((p1, p2, p3)) else None else None else None
  }

  predicate method IsIN(input: seq<Token>)
    decreases input
  {
    if |input| < 3 then
      false
    else if !IsVar(input[0]) then
      false
    else if input[1] != In then
      false
    else if input[2] != Open then
      false
    else
      true
  }

  function method ConvertToPrefix(input: seq<Token>): (res: seq<Token>)
    decreases input
  {
    var between: Option<(int, int, int)> := IsBetween(input);
    if |input| < 5 then
      input
    else if IsIN(input) then
      [input[1], input[2], input[0], Comma] + ConvertToPrefix(input[3..])
    else if between.Some? then
      var b: (int, int, int) := between.value;
      [Between, Open] + input[0 .. b.0] + [Comma] + input[b.0 + 1 .. b.0 + b.1 + 1] + [Comma] + input[b.0 + b.1 + 2 .. b.0 + b.1 + b.2 + 2] + [Close] + ConvertToPrefix(input[b.0 + b.1 + b.2 + 2..])
    else
      [input[0]] + ConvertToPrefix(input[1..])
  }

  lemma /*{:_inductionTrigger ConvertToPrefix(input)}*/ /*{:_inductionTrigger IsIN(input)}*/ /*{:_induction input}*/ TestConvertToPrefix3(input: seq<Token>)
    requires input == [MakeAttr(""A""), In, Open, MakeAttr(""B""), Comma, MakeAttr(""C""), Close]
    ensures IsIN(input)
    ensures ConvertToPrefix(input) == [In, Open, MakeAttr(""A""), Comma, MakeAttr(""B""), Comma, MakeAttr(""C""), Close]
    decreases input
  {
  }

  function method ConvertToRpn(input: seq<Token>): seq<Token>
    decreases input
  {
    var stack: seq<Token> := [];
    ConvertToRpn_inner(input, stack)
  }

  function method ConvertToRpn_inner(input: seq<Token>, stack: seq<Token>): seq<Token>
    decreases input, stack
  {
    if 0 == |input| then
      if 0 == |stack| then
        []
      else
        [stack[|stack| - 1]] + ConvertToRpn_inner(input, stack[..|stack| - 1])
    else
      match input[0] case Attr(s, loc) => [input[0]] + ConvertToRpn_inner(input[1..], stack) case Value(s) => [input[0]] + ConvertToRpn_inner(input[1..], stack) case Between() | In() | Not() | AttributeExists() | AttributeNotExists() | AttributeType() | BeginsWith() | Contains() | Size() => ConvertToRpn_inner(input[1..], stack + [input[0]]) case Comma() => (if 0 < |stack| then if IsFunction(stack[|stack| - 1]) then ConvertToRpn_inner(input[1..], stack) else [stack[|stack| - 1]] + ConvertToRpn_inner(input[1..], stack[..|stack| - 1]) else ConvertToRpn_inner(input[1..], stack)) case Close() => (if 0 == |stack| then ConvertToRpn_inner(input[1..], stack) else if stack[|stack| - 1] == Open then ConvertToRpn_inner(input[1..], stack[..|stack| - 1]) else [stack[|stack| - 1]] + ConvertToRpn_inner(input[1..], stack[..|stack| - 1])) case Eq() | Ne() | Lt() | Gt() | Le() | Ge() | And() | Or() => (if 0 == |stack| then ConvertToRpn_inner(input[1..], stack + [input[0]]) else if Precedence(stack[|stack| - 1]) >= Precedence(input[0]) then [stack[|stack| - 1]] + ConvertToRpn_inner(input, stack[..|stack| - 1]) else ConvertToRpn_inner(input[1..], stack + [input[0]])) case Open() => ConvertToRpn_inner(input[1..], stack)
  }

  function method GetSize(value: DDB.AttributeValue): nat
    decreases value
  {
    match value {
      case S(s) =>
        |s|
      case N(n) =>
        |n|
      case B(n) =>
        |n|
      case SS(n) =>
        |n|
      case NS(n) =>
        |n|
      case BS(n) =>
        |n|
      case M(n) =>
        |n|
      case L(n) =>
        |n|
      case NULL(n) =>
        1
      case BOOL(n) =>
        1
    }
  }

  function method GetStr(s: StackValue): DDB.AttributeValue
    decreases s
  {
    match s
    case Bool(b) =>
      DDB.AttributeValue.NULL(true)
    case Str(s) =>
      s
    case DoesNotExist() =>
      DDB.AttributeValue.NULL(true)
  }

  function method AsStr(s: string): StackValue
    decreases s
  {
    Str(DDB.AttributeValue.S(s))
  }

  function method StackValueFromValue(s: string, values: DDB.ExpressionAttributeValueMap): StackValue
    decreases s, values
  {
    if s in values then
      Str(values[s])
    else
      DoesNotExist
  }

  function method StackValueFromItem(s: string, item: DDB.AttributeMap): StackValue
    decreases s, item
  {
    if s in item then
      Str(item[s])
    else
      DoesNotExist
  }

  function method StackValueFromAttr(t: Token, item: DDB.AttributeMap, names: Option<DDB.ExpressionAttributeNameMap>): StackValue
    requires t.Attr?
    decreases t, item, names
  {
    if names.Some? && t.s in names.value then
      StackValueFromItem(names.value[t.s], item)
    else
      var attr: Option<DDB.AttributeValue> := TermToAttr(t.loc, item, names); if attr.Some? then Str(attr.value) else DoesNotExist
  }

  function method GetParsedExpr(input: string): Result<seq<Token>, Error>
    decreases input
  {
    var seq1: seq<Token> := ParseExpr(input);
    var seq2: seq<Token> := ConvertToPrefix(seq1);
    Success(ConvertToRpn(seq2))
  }

  function method EvalExpr(input: seq<Token>, item: DDB.AttributeMap, names: Option<DDB.ExpressionAttributeNameMap>, values: DDB.ExpressionAttributeValueMap): Result<bool, Error>
    decreases input, item, names, values
  {
    InnerEvalExpr(input, [], item, names, values)
  }

  function method StringsFollowing(input: seq<StackValue>): nat
    decreases input
  {
    if |input| == 0 then
      0
    else if !input[|input| - 1].Str? then
      0
    else
      1 + StringsFollowing(input[..|input| - 1])
  }

  predicate method {:tailrecursion} seq_contains<T(==)>(haystack: seq<T>, needle: seq<T>)
    decreases haystack, needle
  {
    if |needle| == 0 then
      true
    else if |haystack| == 0 then
      false
    else if |haystack| < |needle| then
      false
    else if needle[0] == haystack[0] && needle[1..] <= haystack[1..] then
      true
    else
      seq_contains(haystack[1..], needle)
  }

  predicate method does_contain(haystack: DDB.AttributeValue, needle: DDB.AttributeValue)
    decreases haystack, needle
  {
    match haystack {
      case S(s) =>
        if needle.S? then
          seq_contains(haystack.S, needle.S)
        else
          false
      case N(n) =>
        if needle.N? then
          seq_contains(haystack.N, needle.N)
        else
          false
      case B(n) =>
        if needle.B? then
          seq_contains(haystack.B, needle.B)
        else
          false
      case SS(s) =>
        if needle.S? then
          needle.S in haystack.SS
        else
          false
      case NS(s) =>
        if needle.N? then
          needle.N in haystack.NS
        else
          false
      case BS(s) =>
        if needle.B? then
          needle.B in haystack.BS
        else
          false
      case L(list) =>
        needle in list
      case _ /* _v10 */ =>
        false
    }
  }

  predicate method begins_with(haystack: DDB.AttributeValue, needle: DDB.AttributeValue)
    decreases haystack, needle
  {
    match haystack {
      case S(s) =>
        if needle.S? then
          needle.S <= haystack.S
        else
          false
      case N(n) =>
        if needle.N? then
          needle.N <= haystack.N
        else
          false
      case B(n) =>
        if needle.B? then
          needle.B <= haystack.B
        else
          false
      case L(list) =>
        if |list| == 0 then
          false
        else if list[0] == needle then
          true
        else if needle.L? then
          needle.L <= list
        else
          false
      case _ /* _v11 */ =>
        false
    }
  }

  function method is_between(middle: DDB.AttributeValue, left: DDB.AttributeValue, right: DDB.AttributeValue): Result<bool, Error>
    decreases middle, left, right
  {
    var leftRet: bool :- AttributeLE(left, middle); var rightRet: bool :- AttributeLE(middle, right); Success(leftRet && rightRet)
  }

  predicate method is_in(target: DDB.AttributeValue, list: seq<StackValue>)
    decreases target, list
  {
    if |list| == 0 then
      false
    else if GetStr(list[0]) == target then
      true
    else
      is_in(target, list[1..])
  }

  function method AttrToStr(attr: DDB.AttributeValue): string
    decreases attr
  {
    match attr {
      case S(s) =>
        s
      case N(n) =>
        n
      case _ /* _v12 */ =>
        """"
    }
  }

  function method IsAttrType(attr: StackValue, typeStr: StackValue): bool
    decreases attr, typeStr
  {
    AttrTypeToStr(GetStr(attr)) == AttrToStr(GetStr(typeStr))
  }

  function method apply_function(input: Token, stack: seq<StackValue>, num_args: nat): Result<StackValue, Error>
    decreases input, stack, num_args
  {
    match input {
      case Between() =>
        if |stack| < 3 then
          Failure(E(""No Stack for Between""))
        else if stack[|stack| - 1].Str? && stack[|stack| - 2].Str? && stack[|stack| - 3].Str? then
          var ret: bool :- is_between(stack[|stack| - 3].s, stack[|stack| - 2].s, stack[|stack| - 1].s); Success(Bool(ret))
        else
          Failure(E(""Wrong Types for contains""))
      case In() =>
        var num: nat := StringsFollowing(stack);
        if |stack| < num then
          Failure(E(""Tautology False""))
        else if num == 0 then
          Failure(E(""In has no args""))
        else
          Success(Bool(is_in(GetStr(stack[|stack| - num]), stack[|stack| - num + 1..])))
      case AttributeExists() =>
        if |stack| < 1 then
          Failure(E(""No Stack for AttributeExists""))
        else
          Success(Bool(!stack[|stack| - 1].DoesNotExist?))
      case AttributeNotExists() =>
        if |stack| < 1 then
          Failure(E(""No Stack for AttributeExists""))
        else
          Success(Bool(stack[|stack| - 1].DoesNotExist?))
      case AttributeType() =>
        if |stack| < 2 then
          Failure(E(""No Stack for AttributeType""))
        else
          Success(Bool(IsAttrType(stack[|stack| - 2], stack[|stack| - 1])))
      case BeginsWith() =>
        if |stack| < 2 then
          Failure(E(""No Stack for BeginsWith""))
        else if stack[|stack| - 1].Str? && stack[|stack| - 2].Str? then
          Success(Bool(begins_with(stack[|stack| - 2].s, stack[|stack| - 1].s)))
        else
          Failure(E(""Wrong Types for BeginsWith""))
      case Contains() =>
        if |stack| < 2 then
          Failure(E(""No Stack for contains""))
        else if stack[|stack| - 1].Str? && stack[|stack| - 2].Str? then
          Success(Bool(does_contain(stack[|stack| - 2].s, stack[|stack| - 1].s)))
        else
          Failure(E(""Wrong Types for contains""))
      case Size() =>
        if |stack| < 1 then
          Failure(E(""No Stack for Size""))
        else if !stack[|stack| - 1].Str? then
          Failure(E(""Wrong Types for Size""))
        else
          (var n: nat := GetSize(stack[|stack| - 1].s); Success(Str(DDB.AttributeValue.N(String.Base10Int2String(n)))))
      case _ /* _v13 */ =>
        Success(Bool(true))
    }
  }

  function method apply_unary(input: Token, stack: StackValue): Result<StackValue, Error>
    decreases input, stack
  {
    if stack.Bool? then
      Success(Bool(!stack.b))
    else
      Failure(E(""wrong type for Not""))
  }

  function method apply_binary_bool(input: Token, x: bool, y: bool): Result<bool, Error>
    decreases input, x, y
  {
    match input
    case And() =>
      Success(x && y)
    case Or() =>
      Success(x || y)
    case _ /* _v14 */ =>
      Failure(E(""invalid op in apply_binary_bool""))
  }

  predicate method IsHighSurrogate(ch: char)
    decreases ch
  {
    55296 as char <= ch <= 56319 as char
  }

  predicate method {:tailrecursion} UnicodeLess(a: string, b: string)
    decreases a, b
  {
    if |a| == 0 && |b| == 0 then
      false
    else if |a| == 0 then
      true
    else if |b| == 0 then
      false
    else if a[0] == b[0] then
      UnicodeLess(a[1..], b[1..])
    else
      var aIsHighSurrogate: bool := IsHighSurrogate(a[0]); var bIsHighSurrogate: bool := IsHighSurrogate(b[0]); if aIsHighSurrogate == bIsHighSurrogate then a[0] < b[0] else bIsHighSurrogate
  }

  predicate method UnicodeLessOrEqual(a: string, b: string)
    decreases a, b
  {
    !UnicodeLess(b, a)
  }

  function method CompareFloat(x: string, y: string): Result<FloatCompare.CompareType, Error>
    decreases x, y
  {
    var newX: string :- Norm.NormalizeNumber(x).MapFailure((e: string) => E(e)); var newY: string :- Norm.NormalizeNumber(y).MapFailure((e: string) => E(e)); Success(FloatCompare.CompareFloat(newX, newY))
  }

  function method AttributeEQ(a: DDB.AttributeValue, b: DDB.AttributeValue): Result<bool, Error>
    decreases a, b
  {
    if a.N? && b.N? then
      var ret: FloatCompare.CompareType :- CompareFloat(a.N, b.N); Success(ret == 0)
    else
      Success(a == b)
  }

  function method AttributeNE(a: DDB.AttributeValue, b: DDB.AttributeValue): Result<bool, Error>
    decreases a, b
  {
    var ret: bool :- AttributeEQ(a, b); Success(!ret)
  }

  function method AttributeLE(a: DDB.AttributeValue, b: DDB.AttributeValue): Result<bool, Error>
    decreases a, b
  {
    if a.N? && b.N? then
      var ret: FloatCompare.CompareType :- CompareFloat(a.N, b.N); Success(ret <= 0)
    else if a.S? && b.S? then
      Success(UnicodeLessOrEqual(a.S, b.S))
    else if a.B? && b.B? then
      Success(LexicographicLessOrEqual(a.B, b.B, ByteLess))
    else
      Success(false)
  }

  function method AttributeLT(a: DDB.AttributeValue, b: DDB.AttributeValue): Result<bool, Error>
    decreases a, b
  {
    var ret: bool :- AttributeLE(b, a); Success(!ret)
  }

  function method AttributeGT(a: DDB.AttributeValue, b: DDB.AttributeValue): Result<bool, Error>
    decreases a, b
  {
    var ret: bool :- AttributeLE(a, b); Success(!ret)
  }

  function method AttributeGE(a: DDB.AttributeValue, b: DDB.AttributeValue): Result<bool, Error>
    decreases a, b
  {
    var ret: bool :- AttributeLE(b, a); Success(ret)
  }

  function method apply_binary_comp(input: Token, x: DDB.AttributeValue, y: DDB.AttributeValue): Result<bool, Error>
    decreases input, x, y
  {
    match input
    case Eq() =>
      AttributeEQ(x, y)
    case Ne() =>
      AttributeNE(x, y)
    case Le() =>
      AttributeLE(x, y)
    case Lt() =>
      AttributeLT(x, y)
    case Ge() =>
      AttributeGE(x, y)
    case Gt() =>
      AttributeGT(x, y)
    case _ /* _v15 */ =>
      Failure(E(""invalid op in apply_binary_bool""))
  }

  function method apply_binary(input: Token, x: StackValue, y: StackValue): Result<StackValue, Error>
    decreases input, x, y
  {
    if IsComp(input) then
      if x.Str? && y.Str? then
        var val: bool :- apply_binary_comp(input, x.s, y.s); Success(Bool(val))
      else
        Failure(E(""wrong types for comparison""))
    else if x.Bool? && y.Bool? then
      var val: bool :- apply_binary_bool(input, x.b, y.b); Success(Bool(val))
    else
      Failure(E(""wrong types for boolean binary""))
  }

  function method NumArgs(t: Token, stack: seq<StackValue>): nat
    decreases t, stack
  {
    match t
    case Between() =>
      3
    case In() =>
      StringsFollowing(stack)
    case AttributeExists() =>
      1
    case AttributeNotExists() =>
      1
    case AttributeType() =>
      2
    case BeginsWith() =>
      2
    case Contains() =>
      2
    case Size() =>
      1
    case _ /* _v16 */ =>
      0
  }

  function method InnerEvalExpr(input: seq<Token>, stack: seq<StackValue>, item: DDB.AttributeMap, names: Option<DDB.ExpressionAttributeNameMap>, values: DDB.ExpressionAttributeValueMap): Result<bool, Error>
    decreases input, stack, item, names, values
  {
    if 0 == |input| then
      if 1 == |stack| && stack[0].Bool? then
        Success(stack[0].b)
      else
        Failure(E(""ended with bad stack""))
    else
      var t: Token := input[0]; if t.Value? then InnerEvalExpr(input[1..], stack + [StackValueFromValue(t.s, values)], item, names, values) else if t.Attr? then InnerEvalExpr(input[1..], stack + [StackValueFromAttr(t, item, names)], item, names, values) else if IsUnary(t) then if 0 == |stack| then Failure(E(""Empty stack for unary op"")) else var val: StackValue :- apply_unary(t, stack[|stack| - 1]); InnerEvalExpr(input[1..], stack[..|stack| - 1] + [val], item, names, values) else if IsBinary(t) then if |stack| < 2 then Failure(E(""Empty stack for binary op"")) else var val: StackValue :- apply_binary(t, stack[|stack| - 2], stack[|stack| - 1]); InnerEvalExpr(input[1..], stack[..|stack| - 2] + [val], item, names, values) else if IsFunction(t) then var num_args: nat := NumArgs(t, stack); if |stack| < num_args then Failure(E(""Empty stack for function call"")) else var val: StackValue :- apply_function(t, stack, num_args); InnerEvalExpr(input[1..], stack[..|stack| - num_args] + [val], item, names, values) else Success(true)
  }

  method FilterItems(b: SI.BeaconVersion, parsed: seq<Token>, ItemList: DDB.ItemList, names: Option<DDB.ExpressionAttributeNameMap>, values: DDB.ExpressionAttributeValueMap)
      returns (output: Result<DDB.ItemList, Error>)
    requires b.ValidState()
    modifies b.Modifies()
    ensures b.ValidState()
    decreases b, parsed, ItemList, names, values
  {
    var acc: DDB.ItemList := [];
    for i: int := 0 to |ItemList| {
      var newAttrs :- b.GeneratePlainBeacons(ItemList[i]);
      var doesMatch :- EvalExpr(parsed, ItemList[i] + newAttrs, names, values);
      if doesMatch {
        acc := acc + [ItemList[i]];
      }
    }
    return Success(acc);
  }

  method FilterResults(b: SI.BeaconVersion, ItemList: DDB.ItemList, KeyExpression: Option<DDB.KeyExpression>, FilterExpression: Option<DDB.ConditionExpression>, names: Option<DDB.ExpressionAttributeNameMap>, values: Option<DDB.ExpressionAttributeValueMap>)
      returns (output: Result<DDB.ItemList, Error>)
    requires b.ValidState()
    modifies b.Modifies()
    ensures b.ValidState()
    decreases b, ItemList, KeyExpression, FilterExpression, names, values
  {
    if |ItemList| == 0 || (KeyExpression.None? && FilterExpression.None?) {
      return Success(ItemList);
    } else {
      var afterKeys;
      if KeyExpression.Some? {
        var parsed := ParseExpr(KeyExpression.value);
        var expr :- BeaconizeParsedExpr(b, parsed, 0, values.UnwrapOr(map[]), names, DontUseKeys, map[]);
        var expr1 := ConvertToPrefix(expr.expr);
        var expr2 := ConvertToRpn(expr1);
        afterKeys :- FilterItems(b, expr2, ItemList, expr.names, expr.values);
      } else {
        afterKeys := ItemList;
      }
      if FilterExpression.Some? {
        var parsed := ParseExpr(FilterExpression.value);
        var expr :- BeaconizeParsedExpr(b, parsed, 0, values.UnwrapOr(map[]), names, DontUseKeys, map[]);
        var expr1 := ConvertToPrefix(expr.expr);
        var expr2 := ConvertToRpn(expr1);
        output := FilterItems(b, expr2, afterKeys, expr.names, expr.values);
      } else {
        return Success(afterKeys);
      }
    }
  }

  function method KeyIdFromPart(bv: SI.BeaconVersion, keyIdField: string, attr: string, value: string): Option<string>
    decreases bv, keyIdField, attr, value
  {
    if attr !in bv.beacons || bv.beacons[attr].Standard? then
      None
    else
      var parts: seq<BeaconPart> := bv.beacons[attr].cmp.parts; var theParts: seq<BeaconPart> := Seq.Filter((p: CompoundBeacon.BeaconPart) => p.Signed? && p.loc[0].key == keyIdField, parts); if |theParts| != 1 then None else var pieces: seq<seq<char>> := Split(value, bv.beacons[attr].cmp.split); var piece: seq<seq<char>> := Seq.Filter((s: string) => theParts[0].prefix <= s, pieces); if |piece| != 1 then None else var p: seq<char> := piece[0]; assert theParts[0].prefix <= p; Some(p[|theParts[0].prefix|..])
  }

  function method KeyIdFromAttr(bv: SI.BeaconVersion, attr: Option<Token>, value: string, names: Option<DDB.ExpressionAttributeNameMap>): Option<string>
    requires bv.keySource.keyLoc.MultiLoc?
    requires attr.None? || attr.value.Attr?
    decreases bv, attr, value, names
  {
    if attr.None? then
      None
    else
      var name: seq<char> := if names.Some? && attr.value.s in names.value then names.value[attr.value.s] else attr.value.s; var keyIdField: string := bv.keySource.keyLoc.keyName; if keyIdField == name then Some(value) else KeyIdFromPart(bv, keyIdField, attr.value.s, value)
  }

  function method {:tailrecursion} GetBeaconKeyIds2(pos: nat, bv: SI.BeaconVersion, expr: seq<Token>, values: DDB.ExpressionAttributeValueMap, names: Option<DDB.ExpressionAttributeNameMap>, soFar: seq<string>): Result<seq<string>, Error>
    requires bv.keySource.keyLoc.MultiLoc?
    requires pos <= |expr|
    decreases |expr| - pos
  {
    if pos == |expr| then
      Success(soFar)
    else if expr[pos].Value? then
      :- Need(expr[pos].s in values, E(expr[pos].s + "" not found in ExpressionAttributeValueMap"")); var oldValue: AttributeValue := values[expr[pos].s]; if oldValue.S? then var attr: Option<Token> := AttrForValue(expr, pos); var keyId: Option<string> := KeyIdFromAttr(bv, attr, oldValue.S, names); if keyId.None? || keyId.value in soFar then GetBeaconKeyIds2(pos + 1, bv, expr, values, names, soFar) else GetBeaconKeyIds2(pos + 1, bv, expr, values, names, soFar + [keyId.value]) else GetBeaconKeyIds2(pos + 1, bv, expr, values, names, soFar)
    else
      GetBeaconKeyIds2(pos + 1, bv, expr, values, names, soFar)
  }

  function method GetBeaconKeyIds(bv: SI.BeaconVersion, expr: Option<DDB.ConditionExpression>, values: DDB.ExpressionAttributeValueMap, names: Option<DDB.ExpressionAttributeNameMap>, soFar: seq<string>): Result<seq<string>, Error>
    requires bv.keySource.keyLoc.MultiLoc?
    decreases bv, expr, values, names, soFar
  {
    if expr.None? then
      Success(soFar)
    else
      var parsed: seq<Token> := ParseExpr(expr.value); GetBeaconKeyIds2(0, bv, parsed, values, names, soFar)
  }

  function method GetBeaconKeyId(bv: SI.BeaconVersion, keyExpr: Option<DDB.ConditionExpression>, filterExpr: Option<DDB.ConditionExpression>, values: Option<DDB.ExpressionAttributeValueMap>, names: Option<DDB.ExpressionAttributeNameMap>): (ret: Result<MaybeKeyId, Error>)
    ensures !bv.keySource.keyLoc.MultiLoc? ==> ret == Success(DontUseKeyId)
    ensures ret.Success? && bv.keySource.keyLoc.MultiLoc? && values.Some? ==> GetBeaconKeyIds(bv, keyExpr, values.value, names, []).Success? && var soFar: seq<string> := GetBeaconKeyIds(bv, keyExpr, values.value, names, []).value; GetBeaconKeyIds(bv, filterExpr, values.value, names, soFar).Success? && var final: seq<string> := GetBeaconKeyIds(bv, filterExpr, values.value, names, soFar).value; (|final| == 0 ==> ret == Success(ShouldHaveKeyId)) && (|final| == 1 ==> ret == Success(KeyId(final[0]))) && (|final| > 1 ==> ret.Failure?)
    decreases bv, keyExpr, filterExpr, values, names
  {
    if !bv.keySource.keyLoc.MultiLoc? then
      Success(DontUseKeyId)
    else if values.None? then
      Success(ShouldHaveKeyId)
    else
      var soFar: seq<string> :- GetBeaconKeyIds(bv, keyExpr, values.value, names, []); var final: seq<string> :- GetBeaconKeyIds(bv, filterExpr, values.value, names, soFar); if |final| == 1 then Success(KeyId(final[0])) else if |final| == 0 then Success(ShouldHaveKeyId) else Failure(E(""Multiple values found for "" + bv.keySource.keyLoc.keyName + "" in query : "" + Join(final, "", "")))
  }

  method Beaconize(b: SI.BeaconVersion, context: ExprContext, keyId: MaybeKeyId, naked: bool := false)
      returns (output: Result<ExprContext, Error>)
    requires b.ValidState()
    modifies b.Modifies()
    ensures b.ValidState()
    decreases b, context, keyId, naked
  {
    if context.keyExpr.None? && context.filterExpr.None? {
      return Success(context);
    } else {
      var keys := DontUseKeys;
      if !naked {
        keys :- b.getKeyMap(keyId);
      }
      var values := if context.values.Some? then context.values.value else map[];
      var newValues: DDB.ExpressionAttributeValueMap := map[];
      var newKeyExpr := context.keyExpr;
      var newFilterExpr := context.filterExpr;
      var newNames := context.names;
      if context.keyExpr.Some? {
        var parsed := ParseExpr(context.keyExpr.value);
        var newContext :- BeaconizeParsedExpr(b, parsed, 0, values, newNames, keys, newValues);
        newKeyExpr := Some(ParsedExprToString(newContext.expr));
        newValues := newContext.values;
        newNames := newContext.names;
      }
      if context.filterExpr.Some? {
        var parsed := ParseExpr(context.filterExpr.value);
        var newContext :- BeaconizeParsedExpr(b, parsed, 0, values, newNames, keys, newValues);
        newFilterExpr := Some(ParsedExprToString(newContext.expr));
        newValues := newContext.values;
        newNames := newContext.names;
      }
      return Success(ExprContext(newKeyExpr, newFilterExpr, if |newValues| == 0 then None else Some(newValues), newNames));
    }
  }

  function method GetAttrName(t: Token, names: Option<DDB.ExpressionAttributeNameMap>): string
    requires t.Attr?
    decreases t, names
  {
    if names.Some? && t.s in names.value then
      names.value[t.s]
    else
      t.s
  }

  method TestParsedExpr(expr: seq<Token>, encrypted: set<string>, names: Option<DDB.ExpressionAttributeNameMap>)
      returns (output: Outcome<Error>)
    decreases expr, encrypted, names
  {
    for i: int := 0 to |expr| {
      if expr[i].Attr? {
        var name := GetAttrName(expr[i], names);
        if name in encrypted {
          return Fail(E(""Query is using encrypted field : "" + name + "".""));
        }
      }
    }
    return Pass;
  }

  method TestBeaconize(actions: AttributeActions, keyExpr: Option<DDB.KeyExpression>, filterExpr: Option<DDB.ConditionExpression>, names: Option<DDB.ExpressionAttributeNameMap>)
      returns (output: Result<bool, Error>)
    decreases actions, keyExpr, filterExpr, names
  {
    var encrypted := set k: seq<char> {:trigger actions[k]} {:trigger k in actions} | k in actions && actions[k] == SE.ENCRYPT_AND_SIGN :: k;
    if keyExpr.Some? {
      :- TestParsedExpr(ParseExpr(keyExpr.value), encrypted, names);
    }
    if filterExpr.Some? {
      :- TestParsedExpr(ParseExpr(filterExpr.value), encrypted, names);
    }
    return Success(true);
  }

  import opened AwsCryptographyDbEncryptionSdkDynamoDbTypes

  import opened Wrappers

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import DDB = ComAmazonawsDynamodbTypes

  import SI = SearchableEncryptionInfo

  import opened DynamoDbEncryptionUtil

  import FloatCompare

  import opened TermLoc

  import Seq

  import String = StandardLibrary.String

  import CompoundBeacon

  import SE = AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes

  import Norm = DynamoDbNormalizeNumber

  datatype Token = Attr(s: string, loc: TermLoc) | Value(s: string) | Eq | Ne | Lt | Gt | Le | Ge | Between | In | Open | Close | Comma | Not | And | Or | AttributeExists | AttributeNotExists | AttributeType | BeginsWith | Contains | Size

  datatype EqualityBeacon = EqualityBeacon(beacon: Option<SI.Beacon>, forEquality: bool, forContains: bool)

  datatype StackValue = Bool(b: bool) | Str(s: DDB.AttributeValue) | DoesNotExist

  datatype ExprContext = ExprContext(keyExpr: Option<DDB.KeyExpression>, filterExpr: Option<DDB.ConditionExpression>, values: Option<DDB.ExpressionAttributeValueMap>, names: Option<DDB.ExpressionAttributeNameMap>)

  datatype ParsedContext = ParsedContext(expr: seq<Token>, values: DDB.ExpressionAttributeValueMap, names: Option<DDB.ExpressionAttributeNameMap>)
}

module DynamoDbEncryptionBranchKeyIdSupplier {
  function method ConvertToMplError(err: Error): (ret: MPL.Error)
    decreases err
  {
    if err.Opaque? then
      MPL.Opaque(obj := err.obj)
    else
      MPL.AwsCryptographicMaterialProvidersException(message := ""Unexpected error while getting Branch Key ID."")
  }

  import opened AwsCryptographyDbEncryptionSdkDynamoDbTypes

  import opened Wrappers

  import MPL = AwsCryptographyMaterialProvidersTypes

  import DynamoDbItemEncryptorUtil

  class DynamoDbEncryptionBranchKeyIdSupplier extends MPL.IBranchKeyIdSupplier {
    const ddbKeyBranchKeyIdSupplier: IDynamoDbKeyBranchKeyIdSupplier

    predicate ValidState()
      ensures ValidState() ==> History in Modifies
    {
      History in Modifies &&
      ddbKeyBranchKeyIdSupplier.ValidState() &&
      ddbKeyBranchKeyIdSupplier.Modifies <= Modifies &&
      History !in ddbKeyBranchKeyIdSupplier.Modifies
    }

    constructor (ddbKeyBranchKeyIdSupplier: IDynamoDbKeyBranchKeyIdSupplier)
      requires ddbKeyBranchKeyIdSupplier.ValidState()
      ensures this.ddbKeyBranchKeyIdSupplier == ddbKeyBranchKeyIdSupplier
      ensures ValidState() && fresh(this) && fresh(History) && fresh(Modifies - ddbKeyBranchKeyIdSupplier.Modifies)
      decreases ddbKeyBranchKeyIdSupplier
    {
      this.ddbKeyBranchKeyIdSupplier := ddbKeyBranchKeyIdSupplier;
      History := new MPL.IBranchKeyIdSupplierCallHistory();
      Modifies := {History} + ddbKeyBranchKeyIdSupplier.Modifies;
    }

    predicate GetBranchKeyIdEnsuresPublicly(input: MPL.GetBranchKeyIdInput, output: Result<MPL.GetBranchKeyIdOutput, MPL.Error>)
      decreases input, output
    {
      true
    }

    method GetBranchKeyId'(input: MPL.GetBranchKeyIdInput) returns (output: Result<MPL.GetBranchKeyIdOutput, MPL.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures GetBranchKeyIdEnsuresPublicly(input, output)
      ensures unchanged(History)
      decreases Modifies - {History}
    {
      var attrMapR := DynamoDbItemEncryptorUtil.ConvertContextForSelector(input.encryptionContext);
      var attrMap :- attrMapR.MapFailure((e: seq<char>) => MPL.AwsCryptographicMaterialProvidersException(message := e));
      var branchKeyIdR := ddbKeyBranchKeyIdSupplier.GetBranchKeyIdFromDdbKey(GetBranchKeyIdFromDdbKeyInput(ddbKey := attrMap));
      var branchKeyIdOut :- branchKeyIdR.MapFailure(ConvertToMplError);
      return Success(MPL.GetBranchKeyIdOutput(branchKeyId := branchKeyIdOut.branchKeyId));
    }
  }
}

module DynamoDBSupport {
  function method IsWriteable(item: DDB.AttributeMap): (ret: Result<bool, string>)
    ensures ret.Success? ==> forall k: seq<char> {:trigger k in item} | k in item :: !(ReservedPrefix <= k)
    decreases item
  {
    if forall k: seq<char> {:trigger k in item} | k in item :: !(ReservedPrefix <= k) then
      Success(true)
    else
      var bad: set<seq<char>> := set k: seq<char> {:trigger k in item} | k in item && ReservedPrefix <= k; var badSeq: seq<seq<char>> := SortedSets.ComputeSetToOrderedSequence2(bad, CharLess); if |badSeq| == 0 then Failure("""") else Failure(""Writing reserved attributes not allowed : "" + Join(badSeq, ""\n""))
  }

  function method GetEncryptedAttributes(actions: AttributeActions, expr: Option<string>, attrNames: Option<DDB.ExpressionAttributeNameMap>): seq<string>
    decreases actions, expr, attrNames
  {
    if expr.None? then
      []
    else
      var attrs: seq<string> := Filter.ExtractAttributes(expr.value, attrNames); Seq.Filter((attr: string) => IsEncrypted(actions, attr), attrs)
  }

  function method TestConditionExpression(actions: AttributeActions, expr: Option<DDB.ConditionExpression>, attrNames: Option<DDB.ExpressionAttributeNameMap>, attrValues: Option<DDB.ExpressionAttributeValueMap>): (ret: Result<bool, string>)
    ensures ret.Success? ==> |GetEncryptedAttributes(actions, expr, attrNames)| == 0
    decreases actions, expr, attrNames, attrValues
  {
    if expr.Some? then
      var attrs: seq<string> := GetEncryptedAttributes(actions, expr, attrNames);
      if |attrs| == 0 then
        Success(true)
      else
        Failure(""Condition Expressions forbidden on encrypted attributes : "" + Join(attrs, "",""))
    else
      Success(true)
  }

  predicate method IsSigned(actions: AttributeActions, attr: string)
    decreases actions, attr
  {
    attr in actions &&
    actions[attr] != SET.DO_NOTHING
  }

  predicate method IsEncrypted(actions: AttributeActions, attr: string)
    decreases actions, attr
  {
    attr in actions &&
    actions[attr] == SET.ENCRYPT_AND_SIGN
  }

  function method TestUpdateExpression(actions: AttributeActions, expr: Option<DDB.UpdateExpression>, attrNames: Option<DDB.ExpressionAttributeNameMap>, attrValues: Option<DDB.ExpressionAttributeValueMap>): (ret: Result<bool, string>)
    ensures ret.Success? ==> expr.None? || |Seq.Filter((s: seq<char>) => IsSigned(actions, s), Update.ExtractAttributes(expr.value, attrNames))| == 0
    decreases actions, expr, attrNames, attrValues
  {
    if expr.Some? then
      var attrs: seq<string> := Update.ExtractAttributes(expr.value, attrNames);
      var encryptedAttrs: seq<string> := Seq.Filter((s: seq<char>) => IsSigned(actions, s), attrs);
      if |encryptedAttrs| == 0 then
        Success(true)
      else
        Failure(""Update Expressions forbidden on signed attributes : "" + Join(encryptedAttrs, "",""))
    else
      Success(true)
  }

  method GetEncryptedBeacons(search: Option<ValidSearchInfo>, item: DDB.AttributeMap, keyId: MaybeKeyId)
      returns (output: Result<DDB.AttributeMap, Error>)
    modifies if search.Some? then search.value.Modifies() else {}
    decreases search, item, keyId
  {
    if search.None? {
      return Success(map[]);
    } else {
      output := search.value.GenerateEncryptedBeacons(item, keyId);
    }
  }

  const VersionTag: DDB.AttributeName := VersionPrefix + ""1""

  method AddSignedBeacons(search: Option<ValidSearchInfo>, item: DDB.AttributeMap) returns (output: Result<DDB.AttributeMap, Error>)
    modifies if search.Some? then search.value.Modifies() else {}
    ensures output.Success? && search.Some? ==> VersionTag in output.value
    decreases search, item
  {
    if search.None? {
      return Success(item);
    } else {
      var newAttrs :- search.value.GenerateSignedBeacons(item);
      var badAttrs := set k: AttributeName {:trigger newAttrs[k]} {:trigger item[k]} {:trigger k in item} {:trigger k in newAttrs} | k in newAttrs && k in item && item[k] != newAttrs[k] :: k;
      :- Need(|badAttrs| == 0, E(""Signed beacons have generated values different from supplied values.""));
      var version: DDB.AttributeMap := map[VersionTag := DS("" "")];
      var both := newAttrs.Keys * item.Keys;
      var bad := set k: AttributeName {:trigger item[k]} {:trigger newAttrs[k]} {:trigger k in both} | k in both && newAttrs[k] != item[k];
      if 0 < |bad| {
        var badSeq := SortedSets.ComputeSetToOrderedSequence2(bad, CharLess);
        return Failure(E(""Supplied Beacons do not match calculated beacons : "" + Join(badSeq, "", "")));
      }
      if search.value.curr().keySource.keyLoc.MultiLoc? && search.value.curr().keySource.keyLoc.deleteKey {
        var newItem := map k: AttributeName {:trigger item[k]} {:trigger k in item} | k in item && k != search.value.curr().keySource.keyLoc.keyName :: k := item[k];
        return Success(newItem + newAttrs + version);
      } else {
        return Success(item + newAttrs + version);
      }
    }
  }

  function method DoRemoveBeacons(item: DDB.AttributeMap): DDB.AttributeMap
    decreases item
  {
    map k: AttributeName {:trigger item[k]} {:trigger k in item} | k in item && !(ReservedPrefix <= k) :: k := item[k]
  }

  function method RemoveBeacons(search: Option<ValidSearchInfo>, item: DDB.AttributeMap): (ret: Result<DDB.AttributeMap, string>)
    ensures ret.Success? && search.Some? ==> (forall k: seq<char> {:trigger k in ret.value} | k in ret.value :: !(ReservedPrefix <= k)) && forall k: seq<char> {:trigger item[k]} {:trigger ret.value[k]} {:trigger k in ret.value} {:trigger k in item} | k in item :: (ReservedPrefix <= k || k in ret.value) && (ReservedPrefix <= k || ret.value[k] == item[k])
    decreases search, item
  {
    Success(DoRemoveBeacons(item))
  }

  method QueryInputForBeacons(search: Option<ValidSearchInfo>, actions: AttributeActions, req: DDB.QueryInput)
      returns (output: Result<DDB.QueryInput, Error>)
    modifies if search.Some? then search.value.Modifies() else {}
    decreases search, actions, req
  {
    if search.None? {
      var _ /* _v0 */ :- Filter.TestBeaconize(actions, req.KeyConditionExpression, req.FilterExpression, req.ExpressionAttributeNames);
      return Success(req);
    } else {
      var keyId :- Filter.GetBeaconKeyId(search.value.curr(), req.KeyConditionExpression, req.FilterExpression, req.ExpressionAttributeValues, req.ExpressionAttributeNames);
      var oldContext := Filter.ExprContext(req.KeyConditionExpression, req.FilterExpression, req.ExpressionAttributeValues, req.ExpressionAttributeNames);
      var newContext :- Filter.Beaconize(search.value.curr(), oldContext, keyId);
      return Success(req.(KeyConditionExpression := newContext.keyExpr, FilterExpression := newContext.filterExpr, ExpressionAttributeNames := newContext.names, ExpressionAttributeValues := newContext.values));
    }
  }

  method QueryOutputForBeacons(search: Option<ValidSearchInfo>, req: DDB.QueryInput, resp: DDB.QueryOutput)
      returns (output: Result<DDB.QueryOutput, Error>)
    requires resp.Items.Some?
    modifies if search.Some? then search.value.Modifies() else {}
    ensures output.Success? ==> output.value.Items.Some?
    decreases search, req, resp
  {
    if search.None? {
      var trimmedItems := Seq.Map((i: map<AttributeName, AttributeValue>) => DoRemoveBeacons(i), resp.Items.value);
      return Success(resp.(Items := Some(trimmedItems)));
    } else {
      var newItems :- Filter.FilterResults(search.value.curr(), resp.Items.value, req.KeyConditionExpression, req.FilterExpression, req.ExpressionAttributeNames, req.ExpressionAttributeValues);
      :- Need(|newItems| < INT32_MAX_LIMIT, DynamoDbEncryptionUtil.E(""This is impossible.""));
      var trimmedItems := Seq.Map((i: map<AttributeName, AttributeValue>) => DoRemoveBeacons(i), newItems);
      var count := if resp.Count.Some? then Some(|trimmedItems| as DDB.Integer) else None;
      return Success(resp.(Items := Some(trimmedItems), Count := count));
    }
  }

  function method GetBeaconKeyId(search: Option<ValidSearchInfo>, keyExpr: Option<DDB.ConditionExpression>, filterExpr: Option<DDB.ConditionExpression>, values: Option<DDB.ExpressionAttributeValueMap>, names: Option<DDB.ExpressionAttributeNameMap>): Result<MaybeKeyId, Error>
    decreases search, keyExpr, filterExpr, values, names
  {
    if search.None? then
      Success(DontUseKeyId)
    else
      Filter.GetBeaconKeyId(search.value.curr(), keyExpr, filterExpr, values, names)
  }

  method ScanInputForBeacons(search: Option<ValidSearchInfo>, actions: AttributeActions, req: DDB.ScanInput)
      returns (output: Result<DDB.ScanInput, Error>)
    modifies if search.Some? then search.value.Modifies() else {}
    decreases search, actions, req
  {
    if search.None? {
      var _ /* _v1 */ :- Filter.TestBeaconize(actions, None, req.FilterExpression, req.ExpressionAttributeNames);
      return Success(req);
    } else {
      var keyId :- Filter.GetBeaconKeyId(search.value.curr(), None, req.FilterExpression, req.ExpressionAttributeValues, req.ExpressionAttributeNames);
      var context := Filter.ExprContext(None, req.FilterExpression, req.ExpressionAttributeValues, req.ExpressionAttributeNames);
      var newContext :- Filter.Beaconize(search.value.curr(), context, keyId);
      return Success(req.(FilterExpression := newContext.filterExpr, ExpressionAttributeNames := newContext.names, ExpressionAttributeValues := newContext.values));
    }
  }

  method ScanOutputForBeacons(search: Option<ValidSearchInfo>, req: DDB.ScanInput, resp: DDB.ScanOutput)
      returns (ret: Result<DDB.ScanOutput, Error>)
    requires resp.Items.Some?
    modifies if search.Some? then search.value.Modifies() else {}
    ensures ret.Success? ==> ret.value.Items.Some?
    decreases search, req, resp
  {
    if search.None? {
      var trimmedItems := Seq.Map((i: map<AttributeName, AttributeValue>) => DoRemoveBeacons(i), resp.Items.value);
      return Success(resp.(Items := Some(trimmedItems)));
    } else {
      var newItems :- Filter.FilterResults(search.value.curr(), resp.Items.value, None, req.FilterExpression, req.ExpressionAttributeNames, req.ExpressionAttributeValues);
      :- Need(|newItems| < INT32_MAX_LIMIT, DynamoDbEncryptionUtil.E(""This is impossible.""));
      var trimmedItems := Seq.Map((i: map<AttributeName, AttributeValue>) => DoRemoveBeacons(i), newItems);
      var count := if resp.Count.Some? then Some(|trimmedItems| as DDB.Integer) else None;
      return Success(resp.(Items := Some(trimmedItems), Count := count));
    }
  }

  function method {:tailrecursion} GetVirtualFieldsLoop(fields: seq<string>, bv: SearchableEncryptionInfo.BeaconVersion, item: DDB.AttributeMap, results: map<string, string> := map[]): (output: Result<map<string, string>, Error>)
    requires forall x: seq<char> {:trigger x in bv.virtualFields} {:trigger x in fields} | x in fields :: x in bv.virtualFields
    requires forall x: seq<char> {:trigger x in bv.virtualFields} {:trigger x in results} | x in results :: x in bv.virtualFields
    ensures output.Success? ==> forall x: seq<char> {:trigger x in bv.virtualFields} {:trigger x in output.value} | x in output.value :: x in bv.virtualFields
    decreases fields, bv, item, results
  {
    if |fields| == 0 then
      Success(results)
    else
      var optValue: Option<string> :- GetVirtField(bv.virtualFields[fields[0]], item); if optValue.Some? then GetVirtualFieldsLoop(fields[1..], bv, item, results[fields[0] := optValue.value]) else GetVirtualFieldsLoop(fields[1..], bv, item, results)
  }

  method GetVirtualFields(beaconVersion: SearchableEncryptionInfo.BeaconVersion, item: DDB.AttributeMap) returns (output: Result<map<string, string>, Error>)
    decreases beaconVersion, item
  {
    var fieldNames := SortedSets.ComputeSetToOrderedSequence2(beaconVersion.virtualFields.Keys, CharLess);
    output := GetVirtualFieldsLoop(fieldNames, beaconVersion, item);
  }

  function method {:tailrecursion} GetCompoundBeaconsLoop(fields: seq<string>, bv: SearchableEncryptionInfo.BeaconVersion, item: DDB.AttributeMap, results: map<string, string> := map[]): (output: Result<map<string, string>, Error>)
    requires forall x: seq<char> {:trigger x in bv.beacons} {:trigger x in fields} | x in fields :: x in bv.beacons
    requires forall x: seq<char> {:trigger x in bv.beacons} {:trigger x in results} | x in results :: x in bv.beacons
    ensures output.Success? ==> forall x: seq<char> {:trigger x in bv.beacons} {:trigger x in output.value} | x in output.value :: x in bv.beacons
    decreases fields, bv, item, results
  {
    if |fields| == 0 then
      Success(results)
    else
      var beacon: Beacon := bv.beacons[fields[0]]; if beacon.Compound? then var optValue: Option<string> :- beacon.cmp.getNaked(item, bv.virtualFields); if optValue.Some? then GetCompoundBeaconsLoop(fields[1..], bv, item, results[fields[0] := optValue.value]) else GetCompoundBeaconsLoop(fields[1..], bv, item, results) else GetCompoundBeaconsLoop(fields[1..], bv, item, results)
  }

  method GetCompoundBeacons(beaconVersion: SearchableEncryptionInfo.BeaconVersion, item: DDB.AttributeMap) returns (output: Result<map<string, string>, Error>)
    decreases beaconVersion, item
  {
    var beaconNames := SortedSets.ComputeSetToOrderedSequence2(beaconVersion.beacons.Keys, CharLess);
    output := GetCompoundBeaconsLoop(beaconNames, beaconVersion, item);
  }

  import DDB = ComAmazonawsDynamodbTypes

  import opened AwsCryptographyDbEncryptionSdkDynamoDbTypes

  import opened Wrappers

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import opened DynamoDbEncryptionUtil

  import opened DdbVirtualFields

  import opened SearchableEncryptionInfo

  import UTF8

  import SortedSets

  import Seq

  import Update = DynamoDbUpdateExpr

  import Filter = DynamoDBFilterExpr

  import SET = AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes
}

module SearchConfigToInfo {
  method Convert(outer: DynamoDbTableEncryptionConfig) returns (output: Result<Option<I.ValidSearchInfo>, Error>)
    requires ValidSearchConfig(outer.search)
    ensures output.Success? && output.value.Some? ==> output.value.value.ValidState() && fresh(output.value.value.versions[0].keySource.client)
    ensures outer.search.Some? && outer.search.value.writeVersion != 1 ==> output.Failure?
    ensures outer.search.Some? && |outer.search.value.versions| != 1 ==> output.Failure?
    decreases outer
  {
    if outer.search.None? {
      return Success(None);
    } else {
      :- Need(outer.search.value.writeVersion == 1, E(""writeVersion must be '1'.""));
      :- Need(|outer.search.value.versions| == 1, E(""search config must be have exactly one version.""));
      var version :- ConvertVersion(outer, outer.search.value.versions[0]);
      var info := I.MakeSearchInfo(version);
      return Success(Some(info));
    }
  }

  predicate ValidBeaconVersion(config: BeaconVersion)
    decreases config
  {
    config.keyStore.ValidState()
  }

  predicate ValidSearchConfig(config: Option<SearchConfig>)
    decreases config
  {
    if config.None? then
      true
    else
      forall b: BeaconVersion {:trigger ValidBeaconVersion(b)} {:trigger b in config.value.versions} | b in config.value.versions :: ValidBeaconVersion(b)
  }

  function method ShouldDeleteKeyField(outer: DynamoDbTableEncryptionConfig, keyFieldName: string): (ret: Result<bool, Error>)
    ensures keyFieldName in outer.attributeActionsOnEncrypt && outer.attributeActionsOnEncrypt[keyFieldName] == SE.ENCRYPT_AND_SIGN ==> ret.Failure?
    decreases outer, keyFieldName
  {
    if keyFieldName !in outer.attributeActionsOnEncrypt then
      Success(true)
    else
      match outer.attributeActionsOnEncrypt[keyFieldName] { case DO_NOTHING() => Success(true) case SIGN_ONLY() => Success(false) case SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT() => Success(false) case ENCRYPT_AND_SIGN() => Failure(E(""Beacon key field name "" + keyFieldName + "" is configured as ENCRYPT_AND_SIGN which is not allowed."")) }
  }

  method MakeKeySource(outer: DynamoDbTableEncryptionConfig, keyStore: I.ValidStore, config: BeaconKeySource, client: Primitives.AtomicPrimitivesClient)
      returns (output: Result<I.KeySource, Error>)
    requires client.ValidState()
    modifies client.Modifies
    ensures client.ValidState()
    ensures output.Success? ==> output.value.ValidState() && output.value.client == client && output.value.store == keyStore
    ensures config.multi? && config.multi.keyFieldName in outer.attributeActionsOnEncrypt && outer.attributeActionsOnEncrypt[config.multi.keyFieldName] == SE.ENCRYPT_AND_SIGN ==> output.Failure?
    ensures config.multi? && config.multi.cache.Some? && config.multi.cache.value.Shared? ==> output.Failure? && !output.error.AwsCryptographyMaterialProviders? ==> output.error.DynamoDbEncryptionException? && output.error.message == ""Searchable Encryption does not support the Shared Cache type at this time.""
    decreases outer, keyStore, config, client
  {
    var mplR := MaterialProviders.MaterialProviders();
    var mpl :- mplR.MapFailure((e: Error) => AwsCryptographyMaterialProviders(e));
    var cacheType: MPT.CacheType := if config.multi? then if config.multi.cache.Some? then config.multi.cache.value else MPT.Default(Default := MPT.DefaultCache(entryCapacity := 1000)) else MPT.Default(Default := MPT.DefaultCache(entryCapacity := 1));
    var cache;
    if cacheType.Shared? {
      return Failure(DynamoDbEncryptionException(message := ""Searchable Encryption does not support the Shared Cache type at this time.""));
    } else {
      var input := MPT.CreateCryptographicMaterialsCacheInput(cache := cacheType);
      var maybeCache := mpl.CreateCryptographicMaterialsCache(input);
      cache :- maybeCache.MapFailure((e: Error) => AwsCryptographyMaterialProviders(e));
    }
    if config.multi? {
      :- Need(0 < config.multi.cacheTTL, E(""Beacon Cache TTL must be at least 1.""));
      var deleteKey :- ShouldDeleteKeyField(outer, config.multi.keyFieldName);
      output := Success(I.KeySource(client, keyStore, I.MultiLoc(config.multi.keyFieldName, deleteKey), cache, config.multi.cacheTTL as uint32));
    } else {
      :- Need(0 < config.single.cacheTTL, E(""Beacon Cache TTL must be at least 1.""));
      output := Success(I.KeySource(client, keyStore, I.SingleLoc(config.single.keyId), cache, config.single.cacheTTL as uint32));
    }
  }

  method ConvertVersion(outer: DynamoDbTableEncryptionConfig, config: BeaconVersion) returns (output: Result<I.ValidBeaconVersion, Error>)
    requires ValidBeaconVersion(config)
    ensures output.Success? ==> output.value.ValidState() && fresh(output.value.keySource.client)
    ensures config.version != 1 ==> output.Failure?
    ensures |config.standardBeacons| == 0 ==> output.Failure?
    decreases outer, config
  {
    :- Need(config.version == 1, E(""Version number in BeaconVersion must be '1'.""));
    :- Need(0 < |config.standardBeacons|, E(""At least one standard beacon must be configured.""));
    var maybePrimitives := Primitives.AtomicPrimitives();
    var primitives :- maybePrimitives.MapFailure((e: Error) => AwsCryptographyPrimitives(e));
    var source :- MakeKeySource(outer, config.keyStore, config.keySource, primitives);
    output := ConvertVersionWithSource(outer, config, source);
  }

  method ConvertVersionWithSource(outer: DynamoDbTableEncryptionConfig, config: BeaconVersion, source: I.KeySource)
      returns (output: Result<I.ValidBeaconVersion, Error>)
    requires config.version == 1
    requires source.ValidState()
    modifies source.client.Modifies
    ensures output.Success? ==> output.value.ValidState() && output.value.keySource == source
    decreases outer, config, source
  {
    var virtualFields :- ConvertVirtualFields(outer, config.virtualFields);
    var std :- AddStandardBeacons(config.standardBeacons, outer, source.client, virtualFields);
    var signed := if config.signedParts.Some? then config.signedParts.value else [];
    var globalSignedParts :- GetSignedParts(signed, outer, ""Global Parts List"");
    var globalEncryptedParts: PartSet := PartSet([], {}, {});
    if config.encryptedParts.Some? {
      globalEncryptedParts :- GetEncryptedParts(config.encryptedParts.value, std, ""Global Parts List"");
    }
    var beacons: I.BeaconMap;
    if config.compoundBeacons.Some? {
      beacons :- AddCompoundBeacons(config.compoundBeacons.value, outer, source.client, virtualFields, std, globalSignedParts, globalEncryptedParts);
    } else {
      beacons := std;
    }
    var _ /* _v0 */ :- CheckBeacons(beacons);
    if source.keyLoc.MultiLoc? {
      var name := source.keyLoc.keyName;
      if name in beacons {
        return Failure(E(""A beacon key field name of "" + name + "" was configured, but there's also a beacon of that name.""));
      }
      if name in virtualFields {
        return Failure(E(""A beacon key field name of "" + name + "" was configured, but there's also a virtual field of that name.""));
      }
    }
    return I.MakeBeaconVersion(config.version as I.VersionNumber, source, beacons, virtualFields, outer.attributeActionsOnEncrypt);
  }

  function method ConvertVirtualFields(outer: DynamoDbTableEncryptionConfig, vf: Option<VirtualFieldList>): Result<V.VirtualFieldMap, Error>
    decreases outer, vf
  {
    if vf.None? then
      Success(map[])
    else
      AddVirtualFields(vf.value, outer)
  }

  predicate method IsSigned(outer: DynamoDbTableEncryptionConfig, loc: TermLoc)
    decreases outer, loc
  {
    true &&
    var name: string := loc[0].key; name in outer.attributeActionsOnEncrypt && outer.attributeActionsOnEncrypt[name] != SE.DO_NOTHING
  }

  predicate method IsSignOnly(outer: DynamoDbTableEncryptionConfig, loc: TermLoc)
    decreases outer, loc
  {
    true &&
    var name: string := loc[0].key; name in outer.attributeActionsOnEncrypt && (outer.attributeActionsOnEncrypt[name] == SE.SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT || outer.attributeActionsOnEncrypt[name] == SE.SIGN_ONLY)
  }

  predicate method IsEncrypted(outer: DynamoDbTableEncryptionConfig, loc: TermLoc)
    decreases outer, loc
  {
    true &&
    var name: string := loc[0].key; name in outer.attributeActionsOnEncrypt && outer.attributeActionsOnEncrypt[name] == SE.ENCRYPT_AND_SIGN
  }

  predicate method IsEncryptedV(outer: DynamoDbTableEncryptionConfig, virtualFields: V.VirtualFieldMap, loc: TermLoc)
    decreases outer, virtualFields, loc
  {
    IsEncrypted(outer, loc) || (loc[0].key in virtualFields && virtualFields[loc[0].key].examine((t: TermLoc) => IsEncrypted(outer, t)))
  }

  function method {:opaque} BeaconNameAllowed(outer: DynamoDbTableEncryptionConfig, virtualFields: V.VirtualFieldMap, name: string, context: string, isSignedBeacon: bool := false): (ret: Result<bool, Error>)
    ensures name in outer.attributeActionsOnEncrypt && outer.attributeActionsOnEncrypt[name] != SE.ENCRYPT_AND_SIGN ==> ret.Failure?
    decreases outer, virtualFields, name, context, isSignedBeacon
  {
    if name in outer.attributeActionsOnEncrypt && outer.attributeActionsOnEncrypt[name] != SE.ENCRYPT_AND_SIGN then
      Failure(E(name + "" not allowed as a "" + context + "" because it is already an unencrypted attribute.""))
    else if isSignedBeacon && name in outer.attributeActionsOnEncrypt then
      Failure(E(name + "" not allowed as a "" + context + "" because a fully signed beacon cannot have the same name as an existing attribute.""))
    else if outer.allowedUnsignedAttributes.Some? && name in outer.allowedUnsignedAttributes.value then
      Failure(E(name + "" not allowed as a "" + context + "" because it is already an allowed unauthenticated attribute.""))
    else if outer.allowedUnsignedAttributePrefix.Some? && outer.allowedUnsignedAttributePrefix.value <= name then
      Failure(E(name + "" not allowed as a "" + context + "" because it begins with the allowed unauthenticated prefix.""))
    else if ReservedPrefix <= name then
      Failure(E(name + "" not allowed as a "" + context + "" because it begins with the reserved prefix.""))
    else
      Success(true)
  }

  function method VirtualFieldNameAllowed(outer: DynamoDbTableEncryptionConfig, name: string): Result<bool, Error>
    decreases outer, name
  {
    if name in outer.attributeActionsOnEncrypt then
      Failure(E(name + "" not allowed as a Virtual Field because it is already a configured attribute.""))
    else if outer.allowedUnsignedAttributes.Some? && name in outer.allowedUnsignedAttributes.value then
      Failure(E(name + "" not allowed as a Virtual Field because it is already an allowed unauthenticated attribute.""))
    else if outer.allowedUnsignedAttributePrefix.Some? && outer.allowedUnsignedAttributePrefix.value <= name then
      Failure(E(name + "" not allowed as a Virtual Field because it begins with the allowed unauthenticated prefix.""))
    else if ReservedPrefix <= name then
      Failure(E(name + "" not allowed as a Virtual Field because it begins with the reserved prefix.""))
    else
      Success(true)
  }

  function method FindVirtualFieldWithThisLocation(fields: V.VirtualFieldMap, locs: set<TermLoc>): Option<string>
    decreases fields, locs
  {
    var badNames: set<seq<char>> := set b: seq<char> {:trigger fields[b]} {:trigger b in fields} | b in fields && fields[b].GetLocs() == locs :: b;
    if |badNames| == 0 then
      None
    else
      var badSeq: seq<seq<char>> := SortedSets.ComputeSetToOrderedSequence2(badNames, CharLess); Some(badSeq[0])
  }

  predicate method ExistsConstructorWithTheseRequired(cons: seq<CB.Constructor>, locs: set<CB.BeaconPart>)
    decreases cons, locs
  {
    0 < SeqCount((c: CB.Constructor) => c.getReqParts() == locs, cons)
  }

  function method getPartsString(c: CB.Constructor): string
    decreases c
  {
    var req: seq<ConstructorPart> := Seq.Filter((p: CB.ConstructorPart) => p.required, c.parts);
    var names: seq<string> := Seq.Map((p: CB.ConstructorPart) => p.part.getName(), req);
    if |names| == 0 then
      """"
    else
      Join(names, "", "")
  }

  function method {:tailrecursion} AddVirtualFields(vf: seq<AwsCryptographyDbEncryptionSdkDynamoDbTypes.VirtualField>, outer: DynamoDbTableEncryptionConfig, converted: V.VirtualFieldMap := map[]): (ret: Result<V.VirtualFieldMap, Error>)
    ensures 0 < |vf| && VirtualFieldNameAllowed(outer, vf[0].name).Failure? ==> ret.Failure?
    ensures 0 < |vf| && (V.ParseVirtualFieldConfig(vf[0]).Failure? || V.ParseVirtualFieldConfig(vf[0]).value.examine((t: TermLoc) => !IsSigned(outer, t))) ==> ret.Failure?
    ensures ret.Success? && 0 < |vf| ==> vf[0].name !in converted && V.ParseVirtualFieldConfig(vf[0]).Success? && var newField: VirtField := V.ParseVirtualFieldConfig(vf[0]).value; !newField.examine((t: TermLoc) => !IsSigned(outer, t)) && FindVirtualFieldWithThisLocation(converted, newField.GetLocs()).None?
    decreases vf, outer, converted
  {
    if |vf| == 0 then
      Success(converted)
    else
      :- Need(vf[0].name !in converted, E(""Duplicate VirtualField name : "" + vf[0].name)); var _ /* _v1 */: bool :- VirtualFieldNameAllowed(outer, vf[0].name); var newField: VirtField :- V.ParseVirtualFieldConfig(vf[0]); :- Need(!newField.examine((t: TermLoc) => !IsSigned(outer, t)), E(""VirtualField "" + vf[0].name + "" must be defined on signed fields."")); var badField: Option<string> := FindVirtualFieldWithThisLocation(converted, newField.GetLocs()); if badField.Some? then Failure(E(""Virtual field "" + vf[0].name + "" is defined on the same locations as "" + badField.value + ""."")) else AddVirtualFields(vf[1..], outer, converted[vf[0].name := newField])
  }

  function method FindBeaconWithThisLocation(beacons: I.BeaconMap, loc: TermLoc): Option<string>
    decreases beacons, loc
  {
    var badNames: set<seq<char>> := set b: seq<char> {:trigger beacons[b]} {:trigger b in beacons} | b in beacons && beacons[b].Standard? && beacons[b].std.loc == loc :: b;
    if |badNames| == 0 then
      None
    else
      var badSeq: seq<seq<char>> := SortedSets.ComputeSetToOrderedSequence2(badNames, CharLess); Some(badSeq[0])
  }

  function method IsValidShare(converted: I.BeaconMap, name: string, length: B.BeaconLength, share: string): (ret: Result<bool, Error>)
    ensures ret.Success? ==> share in converted && converted[share].Standard? && converted[share].std.length == length
    decreases converted, name, length, share
  {
    if share in converted then
      var tb: Beacon := converted[share];
      if tb.Standard? then
        if tb.std.share.Some? then
          if name == share then
            Failure(E(""Beacon "" + name + "" is shared to itself.""))
          else
            Failure(E(""Beacon "" + name + "" is shared to "" + share + "" which is in turn shared to "" + tb.std.share.value + "". Share chains are not allowed.""))
        else if tb.std.length == length then
          Success(true)
        else
          Failure(E(""Beacon "" + name + "" is shared to "" + share + "" but "" + name + "" has length "" + Base10Int2String(length as int) + "" and "" + share + "" has length "" + Base10Int2String(tb.std.length as int) + "".""))
      else
        Failure(E(""Beacon "" + name + "" is shared to "" + share + "" but "" + share + "" is a compound beacon.""))
    else
      Failure(E(""Beacon "" + name + "" is shared to "" + share + "" which is not defined.""))
  }

  method {:tailrecursion} AddStandardBeacons(beacons: seq<StandardBeacon>, outer: DynamoDbTableEncryptionConfig, client: Primitives.AtomicPrimitivesClient, virtualFields: V.VirtualFieldMap, converted: I.BeaconMap := map[])
      returns (output: Result<I.BeaconMap, Error>)
    requires client.ValidState()
    modifies client.Modifies
    ensures client.ValidState()
    ensures 0 < |beacons| && beacons[0].name in converted ==> output.Failure?
    ensures 0 < |beacons| && beacons[0].name in outer.attributeActionsOnEncrypt && outer.attributeActionsOnEncrypt[beacons[0].name] != SE.ENCRYPT_AND_SIGN ==> output.Failure?
    ensures output.Success? && 0 < |beacons| ==> beacons[0].name !in converted && var locString: string := GetLocStr(beacons[0].name, beacons[0].loc); locString == (if beacons[0].loc.Some? then beacons[0].loc.value else beacons[0].name) && MakeTermLoc(locString).Success? && var loc: TermLoc := MakeTermLoc(locString).value; FindBeaconWithThisLocation(converted, loc).None? && FindVirtualFieldWithThisLocation(virtualFields, {loc}).None?
    decreases beacons, outer, client, virtualFields, converted
  {
    if |beacons| == 0 {
      return Success(converted);
    }
    :- Need(beacons[0].name !in converted, E(""Duplicate StandardBeacon name : "" + beacons[0].name));
    var _ /* _v2 */ :- BeaconNameAllowed(outer, virtualFields, beacons[0].name, ""StandardBeacon"");
    var locString := GetLocStr(beacons[0].name, beacons[0].loc);
    var isPartOnly := false;
    var isAsSet := false;
    var share: Option<string> := None;
    if beacons[0].style.Some? {
      match beacons[0].style.value {
        case {:split false} partOnly(t) =>
          isPartOnly := true;
        case {:split false} shared(t) =>
          share := Some(t.other);
        case {:split false} asSet(t) =>
          isAsSet := true;
        case {:split false} sharedSet(t) =>
          share := Some(t.other);
          isAsSet := true;
      }
    }
    var newBeacon :- B.MakeStandardBeacon(client, beacons[0].name, beacons[0].length as B.BeaconLength, locString, isPartOnly, isAsSet, share);
    :- Need(IsEncryptedV(outer, virtualFields, newBeacon.loc), E(""StandardBeacon "" + beacons[0].name + "" not defined on an encrypted field.""));
    var badBeacon := FindBeaconWithThisLocation(converted, newBeacon.loc);
    if badBeacon.Some? {
      return Failure(E(""Beacon "" + beacons[0].name + "" is defined on location "" + TermLocToString(newBeacon.loc) + "", but beacon "" + badBeacon.value + "" is already defined on that location.""));
    }
    var badField := FindVirtualFieldWithThisLocation(virtualFields, {newBeacon.loc});
    if badField.Some? {
      return Failure(E(""Beacon "" + beacons[0].name + "" is defined on location "" + TermLocToString(newBeacon.loc) + "", but virtual field "" + badField.value + "" is already defined on that single location.""));
    }
    output := AddStandardBeacons(beacons[1..], outer, client, virtualFields, converted[beacons[0].name := I.Standard(newBeacon)]);
  }

  function method GetLoc(name: string, loc: Option<string>): Result<TermLoc, Error>
    decreases name, loc
  {
    if loc.None? then
      Success(TermLocMap(name))
    else
      MakeTermLoc(loc.value)
  }

  function method GetLocStr(name: string, loc: Option<string>): string
    decreases name, loc
  {
    if loc.None? then
      name
    else
      loc.value
  }

  function method {:tailrecursion} GetSignedParts(parts: seq<SignedPart>, outer: DynamoDbTableEncryptionConfig, name: string, ghost origSize: nat := |parts|, converted: PartSet := PartSet([], {}, {})): (ret: Result<PartSet, Error>)
    requires origSize == |parts| + |converted.parts|
    requires forall p: CB.BeaconPart {:trigger p.Signed?} {:trigger p in converted.parts} | p in converted.parts :: p.Signed?
    ensures ret.Success? ==> |ret.value.parts| == origSize
    ensures ret.Success? ==> forall p: CB.BeaconPart {:trigger p.Signed?} {:trigger p in ret.value.parts} | p in ret.value.parts :: p.Signed?
    ensures 0 < |parts| && GetLoc(parts[0].name, parts[0].loc).Success? && (var loc: TermLoc := GetLoc(parts[0].name, parts[0].loc).value; true && !IsSignOnly(outer, CB.Signed(parts[0].prefix, parts[0].name, loc).loc)) ==> ret.Failure?
    ensures ret.Success? && 0 < |parts| ==> GetLoc(parts[0].name, parts[0].loc).Success? && var loc: TermLoc := GetLoc(parts[0].name, parts[0].loc).value; true && IsSignOnly(outer, loc)
    decreases parts, outer, name, origSize, converted
  {
    if |parts| == 0 then
      Success(converted)
    else
      var loc: TermLoc :- GetLoc(parts[0].name, parts[0].loc); var newPart: BeaconPart := CB.Signed(parts[0].prefix, parts[0].name, loc); :- Need(IsSignOnly(outer, newPart.loc), E(""Signed Part "" + newPart.name + "" is built from "" + GetLocStr(parts[0].name, parts[0].loc) + "" which is not SIGN_ONLY."")); var newParts: PartSet :- converted.add(newPart, name); GetSignedParts(parts[1..], outer, name, origSize, newParts)
  }

  function method GetEncryptedParts(parts: seq<EncryptedPart>, std: I.BeaconMap, name: string, ghost origSize: nat := |parts|, converted: PartSet := PartSet([], {}, {})): (ret: Result<PartSet, Error>)
    requires origSize == |parts| + |converted.parts|
    requires forall x: CB.BeaconPart {:trigger x.Encrypted?} {:trigger x in converted.parts} | x in converted.parts :: x.Encrypted?
    ensures ret.Success? ==> |ret.value.parts| == origSize
    ensures ret.Success? && 0 < |parts| ==> parts[0].name in std && std[parts[0].name].Standard?
    ensures ret.Success? ==> forall x: CB.BeaconPart {:trigger x.Encrypted?} {:trigger x in ret.value.parts} | x in ret.value.parts :: x.Encrypted?
    ensures |parts| != 0 && parts[0].name in std && std[parts[0].name].Standard? && std[parts[0].name].std.asSet ==> ret.Failure?
    decreases parts, std, name, origSize, converted
  {
    if |parts| == 0 then
      Success(converted)
    else if parts[0].name in std && std[parts[0].name].Standard? && std[parts[0].name].std.asSet then
      Failure(E(name + "" uses "" + parts[0].name + "" which is an AsSet beacon, and therefore cannot be used in a Compound Beacon.""))
    else if parts[0].name in std && std[parts[0].name].Standard? then
      var newPart: BeaconPart := CB.Encrypted(parts[0].prefix, std[parts[0].name].std);
      var newParts: PartSet :- converted.add(newPart, name); GetEncryptedParts(parts[1..], std, name, origSize, newParts)
    else
      Failure(E(name + "" refers to standard beacon "" + parts[0].name + "" which is not configured.""))
  }

  function method MakeDefaultConstructor(parts: seq<CB.BeaconPart>, ghost allParts: seq<CB.BeaconPart>, ghost numNon: nat, converted: seq<CB.ConstructorPart> := []): (ret: Result<seq<CB.Constructor>, Error>)
    requires 0 < |parts| + |converted|
    requires |allParts| == |parts| + |converted|
    requires parts == allParts[|converted|..]
    requires numNon <= |allParts|
    requires CB.OrderedParts(allParts, numNon)
    requires forall i: int {:trigger allParts[i]} {:trigger converted[i]} | 0 <= i < |converted| :: converted[i].part == allParts[i] && converted[i].required
    ensures ret.Success? ==> |ret.value| == 1 && |ret.value[0].parts| == |parts| + |converted| && CB.OrderedParts(allParts, numNon) && forall i: int {:trigger allParts[i]} {:trigger ret.value[0].parts[i]} | 0 <= i < |ret.value[0].parts| :: ret.value[0].parts[i].part == allParts[i] && ret.value[0].parts[i].required
    decreases parts, allParts, numNon, converted
  {
    if |parts| == 0 then
      Success([CB.Constructor(converted)])
    else
      MakeDefaultConstructor(parts[1..], allParts, numNon, converted + [CB.ConstructorPart(parts[0], true)])
  }

  function method MyFilter<T>(f: T ~> bool, xs: seq<T>): (result: seq<T>)
    requires forall i: int {:trigger xs[i]} :: 0 <= i < |xs| ==> f.requires(xs[i])
    reads set i: int, o: object? {:trigger o in f.reads(xs[i])} | 0 <= i < |xs| && o in f.reads(xs[i]) :: o
    ensures |result| <= |xs|
    ensures forall i: nat {:trigger result[i]} :: i < |result| && f.requires(result[i]) ==> f(result[i])
    ensures forall x: T {:trigger x in xs} {:trigger x in result} | x in result :: x in xs
    decreases set i: int, o: object? {:trigger o in f.reads(xs[i])} | 0 <= i < |xs| && o in f.reads(xs[i]) :: o, xs
  {
    if |xs| == 0 then
      []
    else
      (if f(xs[0]) then [xs[0]] else []) + MyFilter(f, xs[1..])
  }

  function method SeqCount<T>(f: T ~> bool, xs: seq<T>): (result: nat)
    requires forall i: int {:trigger xs[i]} :: 0 <= i < |xs| ==> f.requires(xs[i])
    reads set i: int, o: object? {:trigger o in f.reads(xs[i])} | 0 <= i < |xs| && o in f.reads(xs[i]) :: o
    ensures result <= |xs|
    decreases set i: int, o: object? {:trigger o in f.reads(xs[i])} | 0 <= i < |xs| && o in f.reads(xs[i]) :: o, xs
  {
    if |xs| == 0 then
      0
    else
      (if f(xs[0]) then 1 else 0) + SeqCount(f, xs[1..])
  }

  function method MakeConstructor2(c: seq<ConstructorPart>, parts: seq<CB.BeaconPart>, origSize: nat, converted: seq<CB.ConstructorPart> := []): (ret: Result<seq<CB.ConstructorPart>, Error>)
    requires origSize == |c| + |converted|
    ensures ret.Success? ==> |ret.value| == origSize
    ensures ret.Success? && 0 < |c| ==> exists p: CB.BeaconPart {:trigger p.getName()} {:trigger p in parts} | p in parts :: p.getName() == c[0].name
    decreases c, parts, origSize, converted
  {
    if |c| == 0 then
      Success(converted)
    else
      var thePart: seq<CB.BeaconPart> := MyFilter((p: CB.BeaconPart) => p.getName() == c[0].name, parts); :- Need(0 < |thePart|, E(""Constructor refers to part name "" + c[0].name + "" but there is no part by that name."")); assert thePart[0] in parts; assert thePart[0].getName() == c[0].name; var newPart: ConstructorPart := CB.ConstructorPart(thePart[0], c[0].required); MakeConstructor2(c[1..], parts, origSize, converted + [newPart])
  }

  function method MakeConstructor(c: Constructor, parts: seq<CB.BeaconPart>): (ret: Result<CB.Constructor, Error>)
    requires 0 < |c.parts|
    ensures ret.Success? ==> |ret.value.parts| == |c.parts|
    decreases c, parts
  {
    var newParts: seq<CB.ConstructorPart> :- MakeConstructor2(c.parts, parts, |c.parts|); Success(CB.Constructor(newParts))
  }

  function method AddConstructors2(constructors: seq<Constructor>, name: string, parts: seq<CB.BeaconPart>, origSize: nat, converted: seq<CB.Constructor> := []): (ret: Result<seq<CB.Constructor>, Error>)
    requires 0 < origSize
    requires origSize == |constructors| + |converted|
    ensures ret.Success? ==> |ret.value| == origSize
    ensures ret.Success? && 0 < |constructors| ==> 0 < SeqCount((p: ConstructorPart) => p.required, constructors[0].parts)
    ensures ret.Success? && 0 < |constructors| ==> MakeConstructor(constructors[0], parts).Success? && var c: CB.Constructor := MakeConstructor(constructors[0], parts).value; true && !ExistsConstructorWithTheseRequired(converted, c.getReqParts())
    decreases constructors, name, parts, origSize, converted
  {
    if |constructors| == 0 then
      Success(converted)
    else
      :- Need(0 < |constructors[0].parts|, E(""Every constructor must have at least one part."")); :- Need(0 < SeqCount((p: ConstructorPart) => p.required, constructors[0].parts), E(""A Constructor for beacon "" + name + "" lacks any required parts"")); var c: CB.Constructor :- MakeConstructor(constructors[0], parts); if ExistsConstructorWithTheseRequired(converted, c.getReqParts()) then var p: string := getPartsString(c); Failure(E(""Multiple constructors for "" + name + "" have the same set of required parts : "" + p)) else AddConstructors2(constructors[1..], name, parts, origSize, converted + [c])
  }

  function method AddConstructors(constructors: Option<ConstructorList>, name: string, parts: seq<CB.BeaconPart>, ghost numSigned: nat): (ret: Result<seq<CB.Constructor>, Error>)
    requires 0 < |parts|
    requires constructors.Some? ==> 0 < |constructors.value|
    requires numSigned <= |parts|
    requires CB.OrderedParts(parts, numSigned)
    ensures ret.Success? ==> (constructors.None? ==> |ret.value| == 1) && (constructors.Some? ==> |ret.value| == |constructors.value|)
    ensures ret.Success? && constructors.None? ==> ret == MakeDefaultConstructor(parts, parts, numSigned)
    decreases constructors, name, parts, numSigned
  {
    if constructors.None? then
      MakeDefaultConstructor(parts, parts, numSigned)
    else
      AddConstructors2(constructors.value, name, parts, |constructors.value|)
  }

  function method {:tailrecursion} GetGlobalPartsFrom(cons: seq<ConstructorPart>, globalParts: PartSet, signed: bool, parts: PartSet): (ret: Result<PartSet, Error>)
    requires forall x: CB.BeaconPart {:trigger IsSignedPart(x, signed)} {:trigger x in parts.parts} | x in parts.parts :: IsSignedPart(x, signed)
    ensures ret.Success? ==> forall x: CB.BeaconPart {:trigger IsSignedPart(x, signed)} {:trigger x in ret.value.parts} | x in ret.value.parts :: IsSignedPart(x, signed)
    decreases cons, globalParts, signed, parts
  {
    if |cons| == 0 then
      Success(parts)
    else
      var newPart: Option<CB.BeaconPart> := FindGlobalPart(globalParts.parts, cons[0], signed); if newPart.Some? then var newParts: PartSet :- parts.add(newPart.value, ""Global Parts List""); GetGlobalPartsFrom(cons[1..], globalParts, signed, newParts) else GetGlobalPartsFrom(cons[1..], globalParts, signed, parts)
  }

  function method {:tailrecursion} GetGlobalParts(cons: seq<Constructor>, globalParts: PartSet, signed: bool, parts: PartSet := PartSet([], {}, {})): (ret: Result<PartSet, Error>)
    requires forall x: CB.BeaconPart {:trigger IsSignedPart(x, signed)} {:trigger x in parts.parts} | x in parts.parts :: IsSignedPart(x, signed)
    ensures ret.Success? ==> forall x: CB.BeaconPart {:trigger IsSignedPart(x, signed)} {:trigger x in ret.value.parts} | x in ret.value.parts :: IsSignedPart(x, signed)
    decreases cons, globalParts, signed, parts
  {
    if |cons| == 0 then
      Success(parts)
    else
      var newParts: PartSet :- GetGlobalPartsFrom(cons[0].parts, globalParts, signed, parts); GetGlobalParts(cons[1..], globalParts, signed, newParts)
  }

  function method {:opaque} GetAllEncryptedParts(parts: seq<EncryptedPart>, cons: seq<Constructor>, globalEncryptedParts: PartSet, name: string, std: I.BeaconMap): (ret: Result<seq<CB.BeaconPart>, Error>)
    ensures ret.Success? ==> forall x: CB.BeaconPart {:trigger x.Encrypted?} {:trigger x in ret.value} | x in ret.value :: x.Encrypted?
    decreases parts, cons, globalEncryptedParts, name, std
  {
    var p1: PartSet :- GetEncryptedParts(parts, std, ""Compound beacon "" + name); var p2: PartSet :- GetGlobalParts(cons, globalEncryptedParts, false); var both: PartSet :- p1.combine(p2, name, ""Global Parts List""); Success(both.parts)
  }

  predicate method IsSignedPart(part: CB.BeaconPart, signed: bool)
    decreases part, signed
  {
    if signed then
      part.Signed?
    else
      part.Encrypted?
  }

  function method {:tailrecursion} FindGlobalPart(globalParts: seq<CB.BeaconPart>, cons: ConstructorPart, signed: bool): (ret: Option<CB.BeaconPart>)
    ensures ret.Some? && signed ==> ret.value.Signed?
    ensures ret.Some? && !signed ==> ret.value.Encrypted?
    decreases globalParts, cons, signed
  {
    if |globalParts| == 0 then
      None
    else if IsSignedPart(globalParts[0], signed) && globalParts[0].getName() == cons.name then
      Some(globalParts[0])
    else
      FindGlobalPart(globalParts[1..], cons, signed)
  }

  function method {:opaque} GetAllSignedParts(parts: seq<SignedPart>, cons: seq<Constructor>, globalSignedParts: PartSet, name: string, outer: DynamoDbTableEncryptionConfig): (ret: Result<seq<CB.BeaconPart>, Error>)
    ensures ret.Success? ==> forall x: CB.BeaconPart {:trigger x.Signed?} {:trigger x in ret.value} | x in ret.value :: x.Signed?
    decreases parts, cons, globalSignedParts, name, outer
  {
    var p1: PartSet :- GetSignedParts(parts, outer, name); var p2: PartSet :- GetGlobalParts(cons, globalSignedParts, true); var both: PartSet :- p1.combine(p2, name, ""Global Parts List""); Success(both.parts)
  }

  function method {:opaque} {:tailrecursion} CheckSignedParts(parts: seq<SignedPart>, globals: PartSet, name: string): Result<bool, Error>
    decreases parts, globals, name
  {
    if |parts| == 0 then
      Success(true)
    else if parts[0].name in globals.names then
      Failure(E(""Compound beacon "" + name + "" defines signed part "" + parts[0].name + "" which is already defined as a global part.""))
    else if parts[0].prefix in globals.prefixes then
      Failure(E(""Compound beacon "" + name + "" defines signed part "" + parts[0].name + "" with prefix "" + parts[0].prefix + "" which is already defined as the prefix of a global part.""))
    else
      CheckSignedParts(parts[1..], globals, name)
  }

  function method {:opaque} {:tailrecursion} CheckEncryptedParts(parts: seq<EncryptedPart>, globals: PartSet, name: string): Result<bool, Error>
    decreases parts, globals, name
  {
    if |parts| == 0 then
      Success(true)
    else if parts[0].name in globals.names then
      Failure(E(""Compound beacon "" + name + "" defines encrypted part "" + parts[0].name + "" which is already defined as a global part.""))
    else if parts[0].prefix in globals.prefixes then
      Failure(E(""Compound beacon "" + name + "" defines encrypted part "" + parts[0].name + "" with prefix "" + parts[0].prefix + "" which is already defined as the prefix of a global part.""))
    else
      CheckEncryptedParts(parts[1..], globals, name)
  }

  function method {:opaque} CreateCompoundBeacon(beacon: CompoundBeacon, outer: DynamoDbTableEncryptionConfig, client: Primitives.AtomicPrimitivesClient, virtualFields: V.VirtualFieldMap, converted: I.BeaconMap, globalSignedParts: PartSet, globalEncryptedParts: PartSet): (ret: Result<CB.ValidCompoundBeacon, Error>)
    ensures beacon.name in converted ==> ret.Failure?
    ensures beacon.name in outer.attributeActionsOnEncrypt && outer.attributeActionsOnEncrypt[beacon.name] != SE.ENCRYPT_AND_SIGN ==> ret.Failure?
    ensures ret.Success? ==> true && var encryptedParts: seq<EncryptedPart> := if beacon.encrypted.Some? then beacon.encrypted.value else []; true && var constructors: seq<Constructor> := if beacon.constructors.Some? then beacon.constructors.value else []; true && var encrypted: Result<seq<CB.BeaconPart>, Error> := GetAllEncryptedParts(encryptedParts, constructors, globalEncryptedParts, beacon.name, converted); encrypted.Success? && ret.value.base.name == beacon.name && (|encrypted.value| == 0 ==> ret.value.base.beaconName == beacon.name) && (|encrypted.value| != 0 ==> ret.value.base.beaconName == BeaconPrefix + beacon.name)
    ensures true && var encryptedParts: seq<EncryptedPart> := if beacon.encrypted.Some? then beacon.encrypted.value else []; true && var signedParts: seq<SignedPart> := if beacon.signed.Some? then beacon.signed.value else []; true && (!(beacon.constructors.Some? || |signedParts| != 0 || |encryptedParts| != 0) ==> ret.Failure?)
    decreases beacon, outer, client, virtualFields, converted, globalSignedParts, globalEncryptedParts
  {
    var signedParts: seq<SignedPart> := if beacon.signed.Some? then beacon.signed.value else [];
    var encryptedParts: seq<EncryptedPart> := if beacon.encrypted.Some? then beacon.encrypted.value else [];
    var constructors: seq<Constructor> := if beacon.constructors.Some? then beacon.constructors.value else [];
    var globalParts: PartSet :- globalSignedParts.combine(globalEncryptedParts, ""Global Signed Parts List"", ""Global Encrypted Parts List""); var _ /* _v3 */: bool :- CheckSignedParts(signedParts, globalParts, beacon.name); var _ /* _v4 */: bool :- CheckEncryptedParts(encryptedParts, globalParts, beacon.name); var signed: seq<CB.BeaconPart> :- GetAllSignedParts(signedParts, constructors, globalSignedParts, beacon.name, outer); var encrypted: seq<CB.BeaconPart> :- GetAllEncryptedParts(encryptedParts, constructors, globalEncryptedParts, beacon.name, converted); :- Need(beacon.name !in converted, E(""Duplicate CompoundBeacon name : "" + beacon.name)); :- Need(beacon.constructors.None? || 0 < |beacon.constructors.value|, E(""For beacon "" + beacon.name + "" an empty constructor list was supplied."")); :- Need(beacon.constructors.Some? || |signedParts| != 0 || |encryptedParts| != 0, E(""Compound beacon "" + beacon.name + "" defines no constructors, and also no local parts. Cannot make a default constructor from global parts."")); var numNon: int := |signed|; assert CB.OrderedParts(signed, numNon); var allParts: seq<CB.BeaconPart> := signed + encrypted; assert CB.OrderedParts(allParts, numNon); var isSignedBeacon: bool := |encrypted| == 0; var _ /* _v5 */: bool :- BeaconNameAllowed(outer, virtualFields, beacon.name, ""CompoundBeacon"", isSignedBeacon); :- Need(0 < |allParts|, E(""For beacon "" + beacon.name + "" no parts were supplied."")); var constructors: seq<CB.Constructor> :- AddConstructors(beacon.constructors, beacon.name, allParts, numNon); var beaconName: seq<char> := if isSignedBeacon then beacon.name else BeaconPrefix + beacon.name; :- Need(DDB.IsValid_AttributeName(beaconName), E(beaconName + "" is not a valid attribute name."")); CB.MakeCompoundBeacon(B.BeaconBase(client := client, name := beacon.name, beaconName := beaconName), beacon.split[0], allParts, numNon, constructors)
  }

  method {:tailrecursion} AddCompoundBeacons(beacons: seq<CompoundBeacon>, outer: DynamoDbTableEncryptionConfig, client: Primitives.AtomicPrimitivesClient, virtualFields: V.VirtualFieldMap, converted: I.BeaconMap, globalSignedParts: PartSet, globalEncryptedParts: PartSet)
      returns (output: Result<I.BeaconMap, Error>)
    requires client.ValidState()
    modifies client.Modifies
    ensures client.ValidState()
    ensures 0 < |beacons| && beacons[0].name in converted ==> output.Failure?
    ensures 0 < |beacons| && beacons[0].name in outer.attributeActionsOnEncrypt && outer.attributeActionsOnEncrypt[beacons[0].name] != SE.ENCRYPT_AND_SIGN ==> output.Failure?
    decreases beacons, outer, client, virtualFields, converted, globalSignedParts, globalEncryptedParts
  {
    if |beacons| == 0 {
      return Success(converted);
    }
    var newBeacon :- CreateCompoundBeacon(beacons[0], outer, client, virtualFields, converted, globalSignedParts, globalEncryptedParts);
    output := AddCompoundBeacons(beacons[1..], outer, client, virtualFields, converted[beacons[0].name := I.Compound(newBeacon)], globalSignedParts, globalEncryptedParts);
  }

  predicate method ExistsInCompound(names: seq<string>, name: string, data: I.BeaconMap)
    requires forall x: seq<char> {:trigger x in data} {:trigger x in names} | x in names :: x in data
    decreases names, name, data
  {
    if |names| == 0 then
      false
    else
      var b: Beacon := data[names[0]]; if b.Compound? && b.cmp.HasBeacon(name) then true else ExistsInCompound(names[1..], name, data)
  }

  function method CheckAllBeacons(names: seq<string>, allNames: seq<string>, data: I.BeaconMap): (ret: Result<bool, Error>)
    requires forall x: seq<char> {:trigger x in data} {:trigger x in names} | x in names :: x in data
    requires forall x: seq<char> {:trigger x in data} {:trigger x in allNames} | x in allNames :: x in data
    ensures |names| != 0 && I.IsPartOnly(data[names[0]]) && !ExistsInCompound(allNames, names[0], data) ==> ret.Failure?
    ensures ret.Success? && 0 < |names| && data[names[0]].Standard? && data[names[0]].std.share.Some? ==> true && var share: string := data[names[0]].std.share.value; IsValidShare(data, names[0], data[names[0]].std.length, share).Success? && share in data && data[share].Standard? && data[share].std.length == data[names[0]].std.length
    decreases names, allNames, data
  {
    if |names| == 0 then
      Success(true)
    else
      var b: Beacon := data[names[0]]; if I.IsPartOnly(b) && !ExistsInCompound(allNames, names[0], data) then Failure(E(""PartOnly beacon "" + names[0] + "" MUST be used in a compound beacon."")) else if b.Standard? && b.std.share.Some? then var _ /* _v6 */: bool :- IsValidShare(data, names[0], b.std.length, b.std.share.value); CheckAllBeacons(names[1..], allNames, data) else CheckAllBeacons(names[1..], allNames, data)
  }

  function method CheckBeacons(data: I.BeaconMap): Result<bool, Error>
    decreases data
  {
    var beaconNames: seq<seq<char>> := SortedSets.ComputeSetToOrderedSequence2(data.Keys, CharLess);
    CheckAllBeacons(beaconNames, beaconNames, data)
  }

  import opened AwsCryptographyDbEncryptionSdkDynamoDbTypes

  import opened StandardLibrary

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened DynamoDbEncryptionUtil

  import opened TermLoc

  import opened String = StandardLibrary.String

  import MaterialProviders

  import SortedSets

  import I = SearchableEncryptionInfo

  import V = DdbVirtualFields

  import B = BaseBeacon

  import CB = CompoundBeacon

  import SE = AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes

  import MPT = AwsCryptographyMaterialProvidersTypes

  import Primitives = AtomicPrimitives

  datatype PartSet = PartSet(parts: seq<CB.BeaconPart>, names: set<string>, prefixes: set<string>) {
    function method add(part: CB.BeaconPart, name: string): Result<PartSet, Error>
      decreases this, part, name
    {
      if part.getName() in names then
        Failure(E(""Duplicate part name "" + part.getName() + "" in "" + name + "".""))
      else if part.getPrefix() in prefixes then
        Failure(E(""Duplicate prefix "" + part.getPrefix() + "" in "" + name + "".""))
      else
        Success(PartSet(parts := parts + [part], names := names + {part.getName()}, prefixes := prefixes + {part.getPrefix()}))
    }

    function method GetSetAsString(strings: set<string>): string
      requires |strings| != 0
      decreases this, strings
    {
      var names: seq<seq<char>> := SortedSets.ComputeSetToOrderedSequence2(strings, CharLess);
      Join(names, "", "")
    }

    function method combine(other: PartSet, name: string, otherName: string): Result<PartSet, Error>
      decreases this, other, name, otherName
    {
      if |names * other.names| != 0 then
        var tags: string := GetSetAsString(names * other.names);
        Failure(E(""Duplicate part name(s) "" + tags + "" between "" + name + "" and "" + otherName + "".""))
      else if |prefixes * other.prefixes| != 0 then
        var tags: string := GetSetAsString(prefixes * other.prefixes);
        Failure(E(""Duplicate prefix(es) "" + tags + "" between "" + name + "" and "" + otherName + "".""))
      else
        Success(PartSet(parts := parts + other.parts, names := names + other.names, prefixes := prefixes + other.prefixes))
    }
  }
}

module AwsCryptographyDbEncryptionSdkDynamoDbOperations refines AbstractAwsCryptographyDbEncryptionSdkDynamoDbOperations {
  const SALT_LENGTH := 16
  const IV_LENGTH := 12
  const VERSION_LENGTH := 16

  predicate ValidInternalConfig?(config: InternalConfig)
    decreases config
  {
    true
  }

  function ModifiesInternalConfig(config: InternalConfig): set<object>
    decreases config
  {
    {}
  }

  predicate CreateDynamoDbEncryptionBranchKeyIdSupplierEnsuresPublicly(input: CreateDynamoDbEncryptionBranchKeyIdSupplierInput, output: Result<CreateDynamoDbEncryptionBranchKeyIdSupplierOutput, Error>)
    decreases input, output
  {
    true
  }

  method CreateDynamoDbEncryptionBranchKeyIdSupplier(config: InternalConfig, input: CreateDynamoDbEncryptionBranchKeyIdSupplierInput) returns (output: Result<CreateDynamoDbEncryptionBranchKeyIdSupplierOutput, Error>)
    requires ValidInternalConfig?(config) && input.ddbKeyBranchKeyIdSupplier.ValidState()
    modifies ModifiesInternalConfig(config), input.ddbKeyBranchKeyIdSupplier.Modifies
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.branchKeyIdSupplier.ValidState() && fresh(output.value.branchKeyIdSupplier) && fresh(output.value.branchKeyIdSupplier.Modifies - ModifiesInternalConfig(config) - input.ddbKeyBranchKeyIdSupplier.Modifies))
    ensures CreateDynamoDbEncryptionBranchKeyIdSupplierEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), input.ddbKeyBranchKeyIdSupplier.Modifies
  {
    var supplier := new DynamoDbEncryptionBranchKeyIdSupplier.DynamoDbEncryptionBranchKeyIdSupplier(input.ddbKeyBranchKeyIdSupplier);
    return Success(CreateDynamoDbEncryptionBranchKeyIdSupplierOutput(branchKeyIdSupplier := supplier));
  }

  predicate GetEncryptedDataKeyDescriptionEnsuresPublicly(input: GetEncryptedDataKeyDescriptionInput, output: Result<GetEncryptedDataKeyDescriptionOutput, Error>)
    decreases input, output
  {
    true
  }

  method GetEncryptedDataKeyDescription(config: InternalConfig, input: GetEncryptedDataKeyDescriptionInput) returns (output: Result<GetEncryptedDataKeyDescriptionOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GetEncryptedDataKeyDescriptionEnsuresPublicly(input, output)
    ensures GetEncryptedDataKeyDescriptionEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    var header;
    match input.input {
      case {:split false} item(item) =>
        {
          :- Need(""aws_dbe_head"" in item && item[""aws_dbe_head""].B?, E(""Header not found in the DynamoDB item.""));
          header := item[""aws_dbe_head""].B;
        }
      case {:split false} header(headerItem) =>
        header := headerItem;
    }
    var deserializedHeader :- Header.PartialDeserialize(header).MapFailure((e: Error) => AwsCryptographyDbEncryptionSdkStructuredEncryption(e));
    var datakeys := deserializedHeader.dataKeys;
    var list: EncryptedDataKeyDescriptionList := [];
    for i: int := 0 to |datakeys| {
      var extractedKeyProviderId :- UTF8.Decode(datakeys[i].keyProviderId).MapFailure((e: string) => E(e));
      var extractedKeyProviderIdInfo := Option.None;
      var expectedBranchKeyVersion := Option.None;
      if ""aws-kms"" <= extractedKeyProviderId {
        :- Need(deserializedHeader.flavor == 0 || deserializedHeader.flavor == 1, E(""Invalid format flavor.""));
        var algorithmSuite;
        if deserializedHeader.flavor == 0 {
          algorithmSuite := AlgorithmSuites.DBE_ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_SYMSIG_HMAC_SHA384;
        } else {
          algorithmSuite := AlgorithmSuites.DBE_ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384_SYMSIG_HMAC_SHA384;
        }
        var maybeKeyProviderIdInfo :- UTF8.Decode(datakeys[i].keyProviderInfo).MapFailure((e: string) => E(e));
        extractedKeyProviderIdInfo := Some(maybeKeyProviderIdInfo);
        if extractedKeyProviderId == ""aws-kms-hierarchy"" {
          var providerWrappedMaterial :- EdkWrapping.GetProviderWrappedMaterial(datakeys[i].ciphertext, algorithmSuite).MapFailure((e: Types.Error) => AwsCryptographyMaterialProviders(e));
          var EDK_CIPHERTEXT_BRANCH_KEY_VERSION_INDEX := SALT_LENGTH + IV_LENGTH;
          var EDK_CIPHERTEXT_VERSION_INDEX := EDK_CIPHERTEXT_BRANCH_KEY_VERSION_INDEX + VERSION_LENGTH;
          :- Need(EDK_CIPHERTEXT_BRANCH_KEY_VERSION_INDEX < EDK_CIPHERTEXT_VERSION_INDEX, E(""Wrong branch key version index.""));
          :- Need(|providerWrappedMaterial| >= EDK_CIPHERTEXT_VERSION_INDEX, E(""Incorrect ciphertext structure length.""));
          var branchKeyVersionUuid := providerWrappedMaterial[EDK_CIPHERTEXT_BRANCH_KEY_VERSION_INDEX .. EDK_CIPHERTEXT_VERSION_INDEX];
          var maybeBranchKeyVersion :- UUID.FromByteArray(branchKeyVersionUuid).MapFailure((e: string) => E(e));
          expectedBranchKeyVersion := Some(maybeBranchKeyVersion);
        }
      }
      var singleDataKeyOutput := EncryptedDataKeyDescription(keyProviderId := extractedKeyProviderId, keyProviderInfo := extractedKeyProviderIdInfo, branchKeyId := extractedKeyProviderIdInfo, branchKeyVersion := expectedBranchKeyVersion);
      list := list + [singleDataKeyOutput];
    }
    output := Success(GetEncryptedDataKeyDescriptionOutput(EncryptedDataKeyDescriptionOutput := list));
  }

  import DynamoDbEncryptionBranchKeyIdSupplier

  import EdkWrapping

  import UUID

  import AlgorithmSuites

  import Header = StructuredEncryptionHeader

  import opened DynamoDbEncryptionUtil

  datatype Config = Config

  type InternalConfig = Config

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyDbEncryptionSdkDynamoDbTypes
}

module AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations refines AbstractAwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations {
  predicate method AllowedUnsigned(unauthenticatedAttributes: Option<ComAmazonawsDynamodbTypes.AttributeNameList>, unauthenticatedPrefix: Option<string>, attr: string)
    decreases unauthenticatedAttributes, unauthenticatedPrefix, attr
  {
    (unauthenticatedAttributes.Some? && attr in unauthenticatedAttributes.value) || (unauthenticatedPrefix.Some? && unauthenticatedPrefix.value <= attr) || ReservedPrefix <= attr
  }

  predicate method ForwardCompatibleAttributeAction(attribute: string, action: CSE.CryptoAction, unauthenticatedAttributes: Option<ComAmazonawsDynamodbTypes.AttributeNameList>, unauthenticatedPrefix: Option<string>)
    decreases attribute, action, unauthenticatedAttributes, unauthenticatedPrefix
  {
    if action == CSE.DO_NOTHING then
      AllowedUnsigned(unauthenticatedAttributes, unauthenticatedPrefix, attribute)
    else
      !AllowedUnsigned(unauthenticatedAttributes, unauthenticatedPrefix, attribute)
  }

  function method CryptoActionString(action: CSE.CryptoAction): string
    decreases action
  {
    if action == CSE.DO_NOTHING then
      ""DO_NOTHING""
    else if action == CSE.SIGN_ONLY then
      ""SIGN_ONLY""
    else if action == CSE.SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT then
      ""SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT""
    else if action == CSE.ENCRYPT_AND_SIGN then
      ""ENCRYPT_AND_SIGN""
    else
      assert false by {
    assert action != CSE.DO_NOTHING;
    assert action != CSE.SIGN_ONLY;
    assert action != CSE.SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT;
    assert action != CSE.ENCRYPT_AND_SIGN;
  } ""internal error""
  }

  function method ExplainNotForwardCompatible(attr: string, action: CSE.CryptoAction, unauthenticatedAttributes: Option<ComAmazonawsDynamodbTypes.AttributeNameList>, unauthenticatedPrefix: Option<string>): string
    requires !ForwardCompatibleAttributeAction(attr, action, unauthenticatedAttributes, unauthenticatedPrefix)
    decreases attr, action, unauthenticatedAttributes, unauthenticatedPrefix
  {
    ""Attribute "" + attr + "" is configured as "" + CryptoActionString(action) + "" but "" + if action == CSE.DO_NOTHING then ""it must also be in unauthenticatedAttributes or begin with the unauthenticatedPrefix."" else if unauthenticatedAttributes.Some? && attr in unauthenticatedAttributes.value then ""it is also in unauthenticatedAttributes."" else if unauthenticatedPrefix.Some? && unauthenticatedPrefix.value <= attr then ""it also begins with the unauthenticatedPrefix."" else assert ReservedPrefix <= attr; ""it also begins with the reserved prefix.""
  }

  predicate method UnknownAttribute(config: InternalConfig, attr: ComAmazonawsDynamodbTypes.AttributeName)
    decreases config, attr
  {
    InSignatureScope(config, attr) &&
    attr !in config.attributeActionsOnEncrypt
  }

  predicate method InSignatureScope(config: InternalConfig, attr: ComAmazonawsDynamodbTypes.AttributeName)
    decreases config, attr
  {
    !AllowedUnsigned(config.allowedUnsignedAttributes, config.allowedUnsignedAttributePrefix, attr)
  }

  function method EncodeName(k: string): (ret: Result<UTF8.ValidUTF8Bytes, Error>)
    ensures ret == DDBEncode(SE.ATTR_PREFIX + k)
    decreases k
  {
    DDBEncode(SE.ATTR_PREFIX + k)
  }

  function method MakeEncryptionContextForEncrypt(config: InternalConfig, item: DynamoToStruct.TerminalDataMap): (ret: Result<CMP.EncryptionContext, Error>)
    ensures config.version == 2 ==> ret == MakeEncryptionContextV2(config, item)
    ensures config.version == 1 ==> ret == MakeEncryptionContextV1(config, item)
    ensures config.version == 1 || config.version == 2
    decreases config, item
  {
    if config.version == 2 then
      MakeEncryptionContextV2(config, item)
    else
      MakeEncryptionContextV1(config, item)
  }

  function method MakeEncryptionContextForDecrypt(config: InternalConfig, header: seq<uint8>, item: DynamoToStruct.TerminalDataMap): (ret: Result<CMP.EncryptionContext, Error>)
    requires 0 < |header|
    ensures ret.Success? ==> (header[0] == 2 ==> ret == MakeEncryptionContextV2(config, item)) && (header[0] == 1 ==> ret == MakeEncryptionContextV1(config, item)) && (header[0] == 1 || header[0] == 2)
    ensures header[0] != 1 && header[0] != 2 ==> ret.Failure?
    decreases config, header, item
  {
    if header[0] == 2 then
      MakeEncryptionContextV2(config, item)
    else if header[0] == 1 then
      MakeEncryptionContextV1(config, item)
    else
      Failure(E(""Header attribute has unexpected version number""))
  }

  function method {:opaque} {:vcs_split_on_every_assert} MakeEncryptionContextV1(config: InternalConfig, item: DynamoToStruct.TerminalDataMap): (ret: Result<CMP.EncryptionContext, Error>)
    ensures ret.Success? ==> config.partitionKeyName in item && TABLE_NAME in ret.value && DDBEncode(config.logicalTableName).Success? && var logicalTableName: ValidUTF8Bytes := DDBEncode(config.logicalTableName).value; ret.value[TABLE_NAME] == logicalTableName && PARTITION_NAME in ret.value && DDBEncode(config.partitionKeyName).Success? && var partitionName: ValidUTF8Bytes := DDBEncode(config.partitionKeyName).value; ret.value[PARTITION_NAME] == partitionName && EncodeName(config.partitionKeyName).Success? && var partitionKeyName: ValidUTF8Bytes := EncodeName(config.partitionKeyName).value; true && var partitionKeyValue: ValidUTF8Bytes := SE.EncodeTerminal(item[config.partitionKeyName]); partitionKeyName in ret.value && ret.value[partitionKeyName] == partitionKeyValue
    ensures ret.Success? && config.sortKeyName.Some? ==> config.sortKeyName.value in item && SORT_NAME in ret.value && DDBEncode(config.sortKeyName.value).Success? && var sortName: UTF8.ValidUTF8Bytes := DDBEncode(config.sortKeyName.value).value; ret.value[SORT_NAME] == sortName && EncodeName(config.sortKeyName.value).Success? && var sortKeyName: ValidUTF8Bytes := EncodeName(config.sortKeyName.value).value; sortKeyName in ret.value && var sortKeyValue: ValidUTF8Bytes := SE.EncodeTerminal(item[config.sortKeyName.value]); true && ret.value[sortKeyName] == sortKeyValue
    ensures ret.Success? && config.sortKeyName.None? ==> SORT_NAME !in ret.value
    decreases config, item
  {
    UTF8.EncodeAsciiUnique();
    :- Need(config.partitionKeyName in item, DDBError(""Partition key "" + config.partitionKeyName + "" not found in Item to be encrypted or decrypted"")); var logicalTableName: ValidUTF8Bytes :- DDBEncode(config.logicalTableName); var partitionName: ValidUTF8Bytes :- DDBEncode(config.partitionKeyName); var partitionKeyName: ValidUTF8Bytes :- EncodeName(config.partitionKeyName); var partitionKeyValue: ValidUTF8Bytes := SE.EncodeTerminal(item[config.partitionKeyName]); if config.sortKeyName.None? then :- Need(|{TABLE_NAME, PARTITION_NAME, SORT_NAME, partitionKeyName}| == 4, E(""Internal Error"")); var ec: CMP.EncryptionContext := map[TABLE_NAME := logicalTableName, PARTITION_NAME := partitionName, partitionKeyName := partitionKeyValue]; assert TABLE_NAME in ec; assert PARTITION_NAME in ec; assert partitionKeyName in ec; assert SORT_NAME !in ec; assert ec[TABLE_NAME] == logicalTableName; assert ec[PARTITION_NAME] == partitionName; assert ec[partitionKeyName] == partitionKeyValue; Success(ec) else :- Need(config.sortKeyName.value in item, DDBError(""Sort key "" + config.sortKeyName.value + "" not found in Item to be encrypted or decrypted"")); var sortName: UTF8.ValidUTF8Bytes :- DDBEncode(config.sortKeyName.value); var sortKeyName: ValidUTF8Bytes :- EncodeName(config.sortKeyName.value); var sortKeyValue: ValidUTF8Bytes := SE.EncodeTerminal(item[config.sortKeyName.value]); :- Need(|{TABLE_NAME, PARTITION_NAME, partitionKeyName, SORT_NAME, sortKeyName}| == 5, E(""Internal Error"")); var ec: CMP.EncryptionContext := map[TABLE_NAME := logicalTableName, PARTITION_NAME := partitionName, partitionKeyName := partitionKeyValue, SORT_NAME := sortName, sortKeyName := sortKeyValue]; assert TABLE_NAME in ec; assert PARTITION_NAME in ec; assert partitionKeyName in ec; assert SORT_NAME in ec; assert sortKeyName in ec; assert ec[TABLE_NAME] == logicalTableName; assert ec[PARTITION_NAME] == partitionName; assert ec[partitionKeyName] == partitionKeyValue; assert ec[SORT_NAME] == sortName; assert ec[sortKeyName] == sortKeyValue; Success(ec)
  }

  function method {:opaque} {:vcs_split_on_every_assert} MakeEncryptionContextV2(config: InternalConfig, item: DynamoToStruct.TerminalDataMap): (ret: Result<CMP.EncryptionContext, Error>)
    ensures ret.Success? ==> config.partitionKeyName in item && TABLE_NAME in ret.value && DDBEncode(config.logicalTableName).Success? && var logicalTableName: ValidUTF8Bytes := DDBEncode(config.logicalTableName).value; ret.value[TABLE_NAME] == logicalTableName && PARTITION_NAME in ret.value && DDBEncode(config.partitionKeyName).Success? && var partitionName: ValidUTF8Bytes := DDBEncode(config.partitionKeyName).value; true && ret.value[PARTITION_NAME] == partitionName
    ensures ret.Success? && config.sortKeyName.Some? ==> config.sortKeyName.value in item && SORT_NAME in ret.value && DDBEncode(config.sortKeyName.value).Success? && var sortName: UTF8.ValidUTF8Bytes := DDBEncode(config.sortKeyName.value).value; true && ret.value[SORT_NAME] == sortName
    ensures ret.Success? && config.sortKeyName.None? ==> SORT_NAME !in ret.value
    decreases config, item
  {
    UTF8.EncodeAsciiUnique();
    :- Need(config.partitionKeyName in item, DDBError(""Partition key "" + config.partitionKeyName + "" not found in Item to be encrypted or decrypted"")); var logicalTableName: ValidUTF8Bytes :- DDBEncode(config.logicalTableName); var partitionName: ValidUTF8Bytes :- DDBEncode(config.partitionKeyName); var partitionKeyName: ValidUTF8Bytes :- EncodeName(config.partitionKeyName); if config.sortKeyName.None? then assert |{TABLE_NAME, PARTITION_NAME, SORT_NAME}| == 3; var ec: CMP.EncryptionContext := map[TABLE_NAME := logicalTableName, PARTITION_NAME := partitionName]; assert TABLE_NAME in ec; assert PARTITION_NAME in ec; assert SORT_NAME !in ec; assert ec[TABLE_NAME] == logicalTableName; assert ec[PARTITION_NAME] == partitionName; Success(ec) else :- Need(config.sortKeyName.value in item, DDBError(""Sort key "" + config.sortKeyName.value + "" not found in Item to be encrypted or decrypted"")); var sortName: UTF8.ValidUTF8Bytes :- DDBEncode(config.sortKeyName.value); var sortKeyName: ValidUTF8Bytes :- EncodeName(config.sortKeyName.value); assert |{TABLE_NAME, PARTITION_NAME, SORT_NAME}| == 3; var ec: CMP.EncryptionContext := map[TABLE_NAME := logicalTableName, PARTITION_NAME := partitionName, SORT_NAME := sortName]; assert TABLE_NAME in ec; assert PARTITION_NAME in ec; assert SORT_NAME in ec; assert ec[TABLE_NAME] == logicalTableName; assert ec[PARTITION_NAME] == partitionName; assert ec[SORT_NAME] == sortName; Success(ec)
  }

  function method DDBError(s: string): Error
    decreases s
  {
    Error.DynamoDbItemEncryptorException(message := s)
  }

  function method DDBEncode(s: string): Result<UTF8.ValidUTF8Bytes, Error>
    decreases s
  {
    UTF8.Encode(s).MapFailure((e: string) => DDBError(e))
  }

  predicate method IsVersion2Schema(actions: DDBE.AttributeActions)
    decreases actions
  {
    exists x: seq<char> {:trigger actions[x]} {:trigger x in actions} | x in actions :: 
      actions[x] == CSE.SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT
  }

  function method VersionFromActions(actions: DDBE.AttributeActions): (ret: StructuredEncryptionHeader.Version)
    ensures (exists x: seq<char> {:trigger actions[x]} {:trigger x in actions} | x in actions :: actions[x] == CSE.SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT) <==> ret == 2
    ensures !(exists x: seq<char> {:trigger actions[x]} {:trigger x in actions} | x in actions :: actions[x] == CSE.SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT) <==> ret == 1
    decreases actions
  {
    if IsVersion2Schema(actions) then
      2
    else
      1
  }

  function method KeyActionFromVersion(version: StructuredEncryptionHeader.Version): (ret: CSE.CryptoAction)
    ensures version == 1 <==> ret == CSE.SIGN_ONLY
    ensures version == 2 <==> ret == CSE.SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT
    decreases version
  {
    if version == 2 then
      CSE.SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT
    else
      CSE.SIGN_ONLY
  }

  function method KeyActionStringFromVersion(version: StructuredEncryptionHeader.Version): string
    decreases version
  {
    if version == 2 then
      ""SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT""
    else
      ""SIGN_ONLY""
  }

  predicate ValidInternalConfig?(config: InternalConfig)
    decreases config
  {
    config.cmm.ValidState() &&
    config.cmpClient.ValidState() &&
    config.cmm.Modifies !! {config.cmpClient.History} &&
    config.structuredEncryption.ValidState() &&
    config.cmm.Modifies !! config.structuredEncryption.Modifies &&
    config.partitionKeyName in config.attributeActionsOnEncrypt &&
    config.attributeActionsOnEncrypt[config.partitionKeyName] == KeyActionFromVersion(config.version) &&
    (config.sortKeyName.Some? ==>
      config.sortKeyName.value in config.attributeActionsOnEncrypt &&
      config.attributeActionsOnEncrypt[config.sortKeyName.value] == KeyActionFromVersion(config.version)) &&
    (forall attribute: seq<char> {:trigger config.attributeActionsOnEncrypt[attribute]} {:trigger attribute in config.attributeActionsOnEncrypt.Keys} | attribute in config.attributeActionsOnEncrypt.Keys :: 
      ForwardCompatibleAttributeAction(attribute, config.attributeActionsOnEncrypt[attribute], config.allowedUnsignedAttributes, config.allowedUnsignedAttributePrefix)) &&
    (forall attribute: seq<char> {:trigger attribute in config.attributeActionsOnEncrypt.Keys} | attribute in config.attributeActionsOnEncrypt.Keys :: 
      !(ReservedPrefix <= attribute)) &&
    (config.internalLegacyOverride.Some? ==>
      config.plaintextOverride.FORBID_PLAINTEXT_WRITE_FORBID_PLAINTEXT_READ?) &&
    (config.plaintextOverride.FORBID_PLAINTEXT_WRITE_ALLOW_PLAINTEXT_READ? || config.plaintextOverride.FORCE_PLAINTEXT_WRITE_ALLOW_PLAINTEXT_READ? ==>
      config.internalLegacyOverride.None?)
  }

  function ModifiesInternalConfig(config: InternalConfig): set<object>
    decreases config
  {
    config.cmm.Modifies + config.structuredEncryption.Modifies + config.cmpClient.Modifies
  }

  function method GetCryptoSchemaActionInner(config: InternalConfig, attr: ComAmazonawsDynamodbTypes.AttributeName): (ret: Result<CSE.CryptoAction, string>)
    ensures attr !in config.attributeActionsOnEncrypt && InSignatureScope(config, attr) ==> ret.Failure?
    decreases config, attr
  {
    if attr in config.attributeActionsOnEncrypt then
      Success(config.attributeActionsOnEncrypt[attr])
    else if !InSignatureScope(config, attr) then
      Success(CSE.CryptoAction.DO_NOTHING)
    else
      Failure(""No Crypto Action configured for attribute "" + attr)
  }

  function method GetCryptoSchemaAction(config: InternalConfig, attr: ComAmazonawsDynamodbTypes.AttributeName): (ret: Result<CSE.CryptoAction, string>)
    ensures attr !in config.attributeActionsOnEncrypt && InSignatureScope(config, attr) ==> ret.Failure?
    decreases config, attr
  {
    GetCryptoSchemaActionInner(config, attr)
  }

  function method GetAuthenticateSchemaAction(config: InternalConfig, attr: ComAmazonawsDynamodbTypes.AttributeName): (ret: CSE.AuthenticateAction)
    requires ValidInternalConfig?(config)
    ensures ret == CSE.DO_NOT_SIGN <==> !InSignatureScope(config, attr)
    decreases config, attr
  {
    if InSignatureScope(config, attr) then
      CSE.SIGN
    else
      CSE.DO_NOT_SIGN
  }

  function method ConfigToCryptoSchema(config: InternalConfig, item: ComAmazonawsDynamodbTypes.AttributeMap): (ret: Result<CSE.CryptoSchemaMap, DDBE.Error>)
    ensures forall k: ComAmazonawsDynamodbTypes.AttributeName {:trigger InSignatureScope(config, k)} {:trigger k in config.attributeActionsOnEncrypt} {:trigger k in item.Keys} | k in item.Keys :: k !in config.attributeActionsOnEncrypt && InSignatureScope(config, k) ==> ret.Failure?
    ensures ret.Success? ==> item.Keys == ret.value.Keys
    ensures ret.Success? ==> forall k: ComAmazonawsDynamodbTypes.AttributeName {:trigger config.attributeActionsOnEncrypt[k]} {:trigger k in config.attributeActionsOnEncrypt} {:trigger ret.value[k]} {:trigger GetCryptoSchemaAction(config, k)} {:trigger k in item.Keys} | k in item.Keys :: GetCryptoSchemaAction(config, k).Success? && ret.value[k] == GetCryptoSchemaAction(config, k).value && (k in config.attributeActionsOnEncrypt ==> ret.value[k] == config.attributeActionsOnEncrypt[k])
    decreases config, item
  {
    var schema: map<seq<char>, Result<CSE.CryptoAction, string>> := map k: seq<char> {:trigger GetCryptoSchemaAction(config, k)} {:trigger k in item} | k in item :: k := GetCryptoSchemaAction(config, k);
    DynamoToStruct.MapKeysMatchItems(item);
    DynamoToStruct.SimplifyMapValueSuccess(schema);
    var actionMapRes: Result<map<seq<char>, CSE.CryptoAction>, string> := DynamoToStruct.SimplifyMapValue(schema);
    assert actionMapRes.Failure? ==> exists kv: (AttributeName, AttributeValue) {:trigger kv.0} {:trigger kv in item.Items} | kv in item.Items :: GetCryptoSchemaAction(config, kv.0).Failure?;
    assert actionMapRes.Failure? <==> exists k: seq<char> {:trigger schema[k]} {:trigger k in item.Keys} | k in item.Keys :: schema[k].Failure?;
    assert actionMapRes.Failure? <==> exists k: ComAmazonawsDynamodbTypes.AttributeName {:trigger GetCryptoSchemaAction(config, k)} {:trigger k in item.Keys} | k in item.Keys :: GetCryptoSchemaAction(config, k).Failure?;
    DynamoToStruct.MapError(actionMapRes)
  }

  function method ConfigToAuthenticateSchema(config: InternalConfig, item: ComAmazonawsDynamodbTypes.AttributeMap): (ret: CSE.AuthenticateSchemaMap)
    requires ValidInternalConfig?(config)
    ensures item.Keys == ret.Keys
    ensures forall k: ComAmazonawsDynamodbTypes.AttributeName {:trigger ret[k]} {:trigger InSignatureScope(config, k)} {:trigger k in item.Keys} | k in item.Keys :: !InSignatureScope(config, k) ==> ret[k] == CSE.DO_NOT_SIGN
    ensures forall k: ComAmazonawsDynamodbTypes.AttributeName {:trigger ret[k]} {:trigger InSignatureScope(config, k)} {:trigger k in item.Keys} | k in item.Keys :: InSignatureScope(config, k) ==> ret[k] == CSE.SIGN
    decreases config, item
  {
    map k: ComAmazonawsDynamodbTypes.AttributeName {:trigger GetAuthenticateSchemaAction(config, k)} {:trigger k in item} | k in item && true :: k := GetAuthenticateSchemaAction(config, k)
  }

  predicate method IsPlaintextItem(ddbItem: ComAmazonawsDynamodbTypes.AttributeMap)
    decreases ddbItem
  {
    SE.HeaderField !in ddbItem &&
    SE.FooterField !in ddbItem
  }

  function method ConvertCryptoSchemaToAttributeActions(config: ValidConfig, schema: CSE.CryptoSchemaMap): (ret: Result<map<ComAmazonawsDynamodbTypes.AttributeName, CSE.CryptoAction>, Error>)
    requires forall k: seq<char> {:trigger schema[k]} {:trigger k in schema} | k in schema :: _default.IsAuthAttr(schema[k])
    ensures ret.Success? ==> forall k: ComAmazonawsDynamodbTypes.AttributeName {:trigger InSignatureScope(config, k)} {:trigger k in ret.value.Keys} | k in ret.value.Keys :: InSignatureScope(config, k)
    ensures ret.Success? ==> forall k: seq<char> {:trigger ret.value[k]} {:trigger k in ret.value.Keys} | k in ret.value.Keys :: !ret.value[k].DO_NOTHING?
    decreases config, schema
  {
    :- Need(forall k: ComAmazonawsDynamodbTypes.AttributeName {:trigger InSignatureScope(config, k)} {:trigger k in schema} | k in schema :: InSignatureScope(config, k), DynamoDbItemEncryptorException(message := ""Received unexpected Crypto Schema: mismatch with signature scope"")); :- Need(forall k: string {:trigger _default.IsValid_AttributeName(k)} {:trigger k in schema} | k in schema :: _default.IsValid_AttributeName(k), DynamoDbItemEncryptorException(message := ""Received unexpected Crypto Schema: Invalid attribute names"")); Success(schema)
  }

  predicate EncryptItemEnsuresPublicly(input: EncryptItemInput, output: Result<EncryptItemOutput, Error>)
    decreases input, output
  {
    true
  }

  function method GetItemNames(item: ComAmazonawsDynamodbTypes.AttributeMap): string
    decreases item
  {
    var keys: seq<seq<char>> := SortedSets.ComputeSetToOrderedSequence2(item.Keys, CharLess);
    if |keys| == 0 then
      ""item is empty""
    else
      Join(keys, "" "")
  }

  function method KeyMissingMsg(config: InternalConfig, item: ComAmazonawsDynamodbTypes.AttributeMap, tag: string): string
    decreases config, item, tag
  {
    ""On "" + tag + "" : "" + (if config.partitionKeyName !in item then ""Partition key '"" + config.partitionKeyName + ""' does not exist in item. "" else """") + (if config.sortKeyName.Some? && config.sortKeyName.value !in item then ""Sort key '"" + config.sortKeyName.value + ""' does not exist in item. "" else """") + ""Item contains these attributes : "" + GetItemNames(item) + "".""
  }

  predicate method ContextAttrsExist(actions: DDBE.AttributeActions, item: DDB.AttributeMap)
    decreases actions, item
  {
    forall k: seq<char> {:trigger k in item} {:trigger actions[k]} {:trigger k in actions} | k in actions :: 
      actions[k] == CSE.SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT ==>
        k in item
  }

  function method ContextMissingMsg(actions: DDBE.AttributeActions, item: DDB.AttributeMap): string
    decreases actions, item
  {
    var s: set<seq<char>> := set k: seq<char> {:trigger k in item} {:trigger actions[k]} {:trigger k in actions} | k in actions && actions[k] == CSE.SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT && k !in item;
    var missing: seq<seq<char>> := SortedSets.ComputeSetToOrderedSequence2(s, CharLess);
    if |missing| == 0 then
      ""No missing SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT attributes.""
    else if |missing| == 1 then
      ""Attribute "" + missing[0] + "" was configured with SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT but was not present in item to be encrypted.""
    else
      ""These attributes were configured with SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT but were not present in item to be encrypted."" + Join(missing, "","")
  }

  method {:vcs_split_on_every_assert} EncryptItem(config: InternalConfig, input: EncryptItemInput) returns (output: Result<EncryptItemOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures EncryptItemEnsuresPublicly(input, output)
    ensures output.Success? ==> config.partitionKeyName in input.plaintextItem
    ensures config.partitionKeyName !in input.plaintextItem ==> output.Failure?
    ensures output.Success? ==> config.sortKeyName.None? || config.sortKeyName.value in input.plaintextItem
    ensures config.sortKeyName.Some? && config.sortKeyName.value !in input.plaintextItem ==> output.Failure?
    ensures output.Success? ==> forall k: seq<char> {:trigger k in input.plaintextItem} {:trigger config.attributeActionsOnEncrypt[k]} {:trigger k in config.attributeActionsOnEncrypt} | k in config.attributeActionsOnEncrypt :: config.attributeActionsOnEncrypt[k] == CSE.SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT ==> k in input.plaintextItem
    ensures output.Success? && !(config.internalLegacyOverride.Some? && config.internalLegacyOverride.value.policy.FORCE_LEGACY_ENCRYPT_ALLOW_LEGACY_DECRYPT?) && !config.plaintextOverride.FORCE_PLAINTEXT_WRITE_ALLOW_PLAINTEXT_READ? ==> |config.structuredEncryption.History.EncryptStructure| == |old(config.structuredEncryption.History.EncryptStructure)| + 1 && Seq.Last(config.structuredEncryption.History.EncryptStructure).output.Success? && ConfigToCryptoSchema(config, input.plaintextItem).Success? && Seq.Last(config.structuredEncryption.History.EncryptStructure).input.cryptoSchema == ConfigToCryptoSchema(config, input.plaintextItem).value && DynamoToStruct.ItemToStructured(input.plaintextItem).Success? && var plaintextStructure: TerminalDataMap := DynamoToStruct.ItemToStructured(input.plaintextItem).value; Seq.Last(config.structuredEncryption.History.EncryptStructure).input.plaintextStructure == plaintextStructure && MakeEncryptionContextForEncrypt(config, plaintextStructure).Success? && Seq.Last(config.structuredEncryption.History.EncryptStructure).input.encryptionContext == Some(MakeEncryptionContextForEncrypt(config, plaintextStructure).value) && output.value.parsedHeader.Some? && var structuredEncOut: EncryptStructureOutput := Seq.Last(config.structuredEncryption.History.EncryptStructure).output.value; true && var parsedHeaderMap: CryptoSchemaMap := structuredEncOut.cryptoSchema; (forall k: seq<char> {:trigger parsedHeaderMap[k]} {:trigger k in parsedHeaderMap} | k in parsedHeaderMap :: _default.IsAuthAttr(parsedHeaderMap[k])) && var maybeCryptoSchema: Result<map<ComAmazonawsDynamodbTypes.AttributeName, CSE.CryptoAction>, Error> := ConvertCryptoSchemaToAttributeActions(config, structuredEncOut.cryptoSchema); maybeCryptoSchema.Success? && ConvertContextForSelector(structuredEncOut.parsedHeader.encryptionContext).Success? && var selectorContext: DDB.Key := ConvertContextForSelector(structuredEncOut.parsedHeader.encryptionContext).value; true && output.value.parsedHeader.value == ParsedHeader(attributeActionsOnEncrypt := maybeCryptoSchema.value, algorithmSuiteId := structuredEncOut.parsedHeader.algorithmSuiteId, storedEncryptionContext := structuredEncOut.parsedHeader.storedEncryptionContext, encryptedDataKeys := structuredEncOut.parsedHeader.encryptedDataKeys, encryptionContext := structuredEncOut.parsedHeader.encryptionContext, selectorContext := selectorContext)
    ensures config.plaintextOverride.FORCE_PLAINTEXT_WRITE_ALLOW_PLAINTEXT_READ? && output.Success? ==> output.value.encryptedItem == input.plaintextItem && output.value.parsedHeader == None
    ensures output.Success? ==> |input.plaintextItem| <= MAX_ATTRIBUTE_COUNT
    decreases ModifiesInternalConfig(config)
  {
    :- Need(config.partitionKeyName in input.plaintextItem && (config.sortKeyName.None? || config.sortKeyName.value in input.plaintextItem), E(KeyMissingMsg(config, input.plaintextItem, ""Encrypt"")));
    :- Need(ContextAttrsExist(config.attributeActionsOnEncrypt, input.plaintextItem), E(ContextMissingMsg(config.attributeActionsOnEncrypt, input.plaintextItem)));
    if |input.plaintextItem| > MAX_ATTRIBUTE_COUNT {
      var actCount := String.Base10Int2String(|input.plaintextItem|);
      var maxCount := String.Base10Int2String(MAX_ATTRIBUTE_COUNT);
      return Failure(E(""Item to encrypt had "" + actCount + "" attributes, but maximum allowed is "" + maxCount));
    }
    if config.internalLegacyOverride.Some? && config.internalLegacyOverride.value.policy.FORCE_LEGACY_ENCRYPT_ALLOW_LEGACY_DECRYPT? {
      var encryptItemOutput :- config.internalLegacyOverride.value.EncryptItem(input);
      return Success(encryptItemOutput);
    }
    if config.plaintextOverride.FORCE_PLAINTEXT_WRITE_ALLOW_PLAINTEXT_READ? {
      var passthroughOutput := EncryptItemOutput(encryptedItem := input.plaintextItem, parsedHeader := None);
      return Success(passthroughOutput);
    }
    var plaintextStructure :- DynamoToStruct.ItemToStructured(input.plaintextItem).MapFailure((e: Error) => Error.AwsCryptographyDbEncryptionSdkDynamoDb(e));
    var context :- MakeEncryptionContextForEncrypt(config, plaintextStructure);
    var cryptoSchema :- ConfigToCryptoSchema(config, input.plaintextItem).MapFailure((e: DDBE.Error) => Error.AwsCryptographyDbEncryptionSdkDynamoDb(e));
    var contextKeysX: seq<seq<uint8>> := SortedSets.ComputeSetToOrderedSequence2(context.Keys, ByteLess);
    assert forall k: seq<uint8> {:trigger ValidUTF8Seq(k)} {:trigger k in contextKeysX} | k in contextKeysX :: ValidUTF8Seq(k) by {
      assert forall k: seq<uint8> {:trigger k in context.Keys} {:trigger k in contextKeysX} | k in contextKeysX :: k in context.Keys;
      assert forall k: seq<uint8> {:trigger ValidUTF8Seq(k)} {:trigger k in context.Keys} | k in context.Keys :: ValidUTF8Seq(k);
    }
    var contextKeys: seq<CMP.Utf8Bytes> := contextKeysX;
    var reqCMMR := config.cmpClient.CreateRequiredEncryptionContextCMM(CMP.CreateRequiredEncryptionContextCMMInput(underlyingCMM := Some(config.cmm), keyring := None, requiredEncryptionContextKeys := contextKeys));
    var reqCMM :- reqCMMR.MapFailure((e: Error) => AwsCryptographyMaterialProviders(e));
    var encryptRes := config.structuredEncryption.EncryptStructure(CSE.EncryptStructureInput(tableName := config.logicalTableName, plaintextStructure := plaintextStructure, cryptoSchema := cryptoSchema, cmm := reqCMM, algorithmSuiteId := config.algorithmSuiteId, encryptionContext := Some(context)));
    assert {:split_here} true;
    var encryptVal :- encryptRes.MapFailure((e: Error) => Error.AwsCryptographyDbEncryptionSdkDynamoDb(DDBE.AwsCryptographyDbEncryptionSdkStructuredEncryption(e)));
    var encryptedData := encryptVal.encryptedStructure;
    :- Need(forall k: string {:trigger _default.IsValid_AttributeName(k)} {:trigger k in encryptedData} | k in encryptedData :: _default.IsValid_AttributeName(k), E(""""));
    var ddbKey :- DynamoToStruct.StructuredToItem(encryptedData).MapFailure((e: Error) => Error.AwsCryptographyDbEncryptionSdkDynamoDb(e));
    var parsedActions :- ConvertCryptoSchemaToAttributeActions(config, encryptVal.cryptoSchema);
    var selectorContextR := ConvertContextForSelector(encryptVal.parsedHeader.encryptionContext);
    var selectorContext :- selectorContextR.MapFailure((e: seq<char>) => E(e));
    var parsedHeader := ParsedHeader(attributeActionsOnEncrypt := parsedActions, algorithmSuiteId := encryptVal.parsedHeader.algorithmSuiteId, storedEncryptionContext := encryptVal.parsedHeader.storedEncryptionContext, encryptedDataKeys := encryptVal.parsedHeader.encryptedDataKeys, encryptionContext := encryptVal.parsedHeader.encryptionContext, selectorContext := selectorContext);
    output := Success(EncryptItemOutput(encryptedItem := ddbKey, parsedHeader := Some(parsedHeader)));
  }

  predicate DecryptItemEnsuresPublicly(input: DecryptItemInput, output: Result<DecryptItemOutput, Error>)
    decreases input, output
  {
    true
  }

  method {:vcs_split_on_every_assert} DecryptItem(config: InternalConfig, input: DecryptItemInput) returns (output: Result<DecryptItemOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DecryptItemEnsuresPublicly(input, output)
    ensures output.Success? ==> config.partitionKeyName in input.encryptedItem
    ensures config.partitionKeyName !in input.encryptedItem ==> output.Failure?
    ensures output.Success? ==> config.sortKeyName.None? || config.sortKeyName.value in input.encryptedItem
    ensures config.sortKeyName.Some? && config.sortKeyName.value !in input.encryptedItem ==> output.Failure?
    ensures output.Success? && !(config.internalLegacyOverride.Some? && config.internalLegacyOverride.value.IsLegacyInput(input)) && (config.plaintextOverride.FORBID_PLAINTEXT_WRITE_FORBID_PLAINTEXT_READ? || !IsPlaintextItem(input.encryptedItem)) ==> |config.structuredEncryption.History.DecryptStructure| == |old(config.structuredEncryption.History.DecryptStructure)| + 1 && Seq.Last(config.structuredEncryption.History.DecryptStructure).output.Success? && Seq.Last(config.structuredEncryption.History.DecryptStructure).input.authenticateSchema == ConfigToAuthenticateSchema(config, input.encryptedItem) && DynamoToStruct.ItemToStructured(input.encryptedItem).Success? && var plaintextStructure: TerminalDataMap := DynamoToStruct.ItemToStructured(input.encryptedItem).value; Seq.Last(config.structuredEncryption.History.DecryptStructure).input.encryptedStructure == plaintextStructure && SE.HeaderField in input.encryptedItem && var header: AttributeValue := input.encryptedItem[SE.HeaderField]; header.B? && 0 < |header.B| && MakeEncryptionContextForDecrypt(config, header.B, plaintextStructure).Success? && Seq.Last(config.structuredEncryption.History.DecryptStructure).input.encryptionContext == Some(MakeEncryptionContextForDecrypt(config, header.B, plaintextStructure).value) && output.value.parsedHeader.Some? && var structuredEncOut: DecryptStructureOutput := Seq.Last(config.structuredEncryption.History.DecryptStructure).output.value; (forall k: seq<char> {:trigger structuredEncOut.cryptoSchema[k]} {:trigger k in structuredEncOut.cryptoSchema} | k in structuredEncOut.cryptoSchema :: _default.IsAuthAttr(structuredEncOut.cryptoSchema[k])) && var maybeCryptoSchema: Result<map<ComAmazonawsDynamodbTypes.AttributeName, CSE.CryptoAction>, Error> := ConvertCryptoSchemaToAttributeActions(config, structuredEncOut.cryptoSchema); maybeCryptoSchema.Success? && ConvertContextForSelector(structuredEncOut.parsedHeader.encryptionContext).Success? && var selectorContext: DDB.Key := ConvertContextForSelector(structuredEncOut.parsedHeader.encryptionContext).value; true && output.value.parsedHeader.value == ParsedHeader(attributeActionsOnEncrypt := maybeCryptoSchema.value, algorithmSuiteId := structuredEncOut.parsedHeader.algorithmSuiteId, storedEncryptionContext := structuredEncOut.parsedHeader.storedEncryptionContext, encryptedDataKeys := structuredEncOut.parsedHeader.encryptedDataKeys, encryptionContext := structuredEncOut.parsedHeader.encryptionContext, selectorContext := selectorContext)
    ensures (config.plaintextOverride.FORCE_PLAINTEXT_WRITE_ALLOW_PLAINTEXT_READ? || config.plaintextOverride.FORBID_PLAINTEXT_WRITE_ALLOW_PLAINTEXT_READ?) && IsPlaintextItem(input.encryptedItem) && output.Success? ==> output.value.plaintextItem == input.encryptedItem && output.value.parsedHeader == None
    decreases ModifiesInternalConfig(config)
  {
    var realCount := |set k: seq<char> {:trigger k in input.encryptedItem} | k in input.encryptedItem && !(ReservedPrefix <= k)|;
    if realCount > MAX_ATTRIBUTE_COUNT {
      var actCount := String.Base10Int2String(realCount);
      var maxCount := String.Base10Int2String(MAX_ATTRIBUTE_COUNT);
      return Failure(E(""Item to decrypt had "" + actCount + "" attributes, but maximum allowed is "" + maxCount));
    }
    :- Need(config.partitionKeyName in input.encryptedItem && (config.sortKeyName.None? || config.sortKeyName.value in input.encryptedItem), DynamoDbItemEncryptorException(message := KeyMissingMsg(config, input.encryptedItem, ""Decrypt"")));
    if config.internalLegacyOverride.Some? && config.internalLegacyOverride.value.IsLegacyInput(input) {
      var decryptItemOutput :- config.internalLegacyOverride.value.DecryptItem(input);
      return Success(decryptItemOutput);
    }
    if (config.plaintextOverride.FORCE_PLAINTEXT_WRITE_ALLOW_PLAINTEXT_READ? || config.plaintextOverride.FORBID_PLAINTEXT_WRITE_ALLOW_PLAINTEXT_READ?) && IsPlaintextItem(input.encryptedItem) {
      var passthroughOutput := DecryptItemOutput(plaintextItem := input.encryptedItem, parsedHeader := None);
      return Success(passthroughOutput);
    }
    :- Need(!IsPlaintextItem(input.encryptedItem), DynamoDbItemEncryptorException(message := ""Encrypted item missing expected header and footer attributes""));
    var encryptedStructure :- DynamoToStruct.ItemToStructured(input.encryptedItem).MapFailure((e: Error) => Error.AwsCryptographyDbEncryptionSdkDynamoDb(e));
    :- Need(SE.HeaderField in input.encryptedItem, E(""Header field, \""aws_dbe_head\"", not in item.""));
    var header := input.encryptedItem[SE.HeaderField];
    :- Need(header.B?, E(""Header field, \""aws_dbe_head\"", not binary""));
    assert header.B?;
    :- Need(0 < |header.B|, E(""Unexpected empty header field.""));
    var context :- MakeEncryptionContextForDecrypt(config, header.B, encryptedStructure);
    var authenticateSchema := ConfigToAuthenticateSchema(config, input.encryptedItem);
    var reqCMMR := config.cmpClient.CreateRequiredEncryptionContextCMM(CMP.CreateRequiredEncryptionContextCMMInput(underlyingCMM := Some(config.cmm), keyring := None, requiredEncryptionContextKeys := SortedSets.ComputeSetToOrderedSequence2(context.Keys, ByteLess)));
    var reqCMM :- reqCMMR.MapFailure((e: Error) => AwsCryptographyMaterialProviders(e));
    var decryptRes := config.structuredEncryption.DecryptStructure(CSE.DecryptStructureInput(tableName := config.logicalTableName, encryptedStructure := encryptedStructure, authenticateSchema := authenticateSchema, cmm := reqCMM, encryptionContext := Some(context)));
    var decryptVal :- decryptRes.MapFailure((e: Error) => Error.AwsCryptographyDbEncryptionSdkDynamoDb(DDBE.AwsCryptographyDbEncryptionSdkStructuredEncryption(e)));
    var decryptedData := decryptVal.plaintextStructure;
    :- Need(forall k: string {:trigger _default.IsValid_AttributeName(k)} {:trigger k in decryptedData} | k in decryptedData :: _default.IsValid_AttributeName(k), E(""""));
    var ddbItem :- DynamoToStruct.StructuredToItem(decryptedData).MapFailure((e: Error) => Error.AwsCryptographyDbEncryptionSdkDynamoDb(e));
    var schemaToConvert := decryptVal.cryptoSchema;
    var parsedAuthActions :- ConvertCryptoSchemaToAttributeActions(config, schemaToConvert);
    var selectorContextR := ConvertContextForSelector(decryptVal.parsedHeader.encryptionContext);
    var selectorContext :- selectorContextR.MapFailure((e: seq<char>) => E(e));
    var parsedHeader := ParsedHeader(attributeActionsOnEncrypt := parsedAuthActions, algorithmSuiteId := decryptVal.parsedHeader.algorithmSuiteId, storedEncryptionContext := decryptVal.parsedHeader.storedEncryptionContext, encryptedDataKeys := decryptVal.parsedHeader.encryptedDataKeys, encryptionContext := decryptVal.parsedHeader.encryptionContext, selectorContext := selectorContext);
    output := Success(DecryptItemOutput(plaintextItem := ddbItem, parsedHeader := Some(parsedHeader)));
  }

  import ComAmazonawsDynamodbTypes

  import opened DynamoDbItemEncryptorUtil

  import CMP = AwsCryptographyMaterialProvidersTypes

  import StructuredEncryption

  import DynamoToStruct

  import SortedSets

  import Base64

  import opened StandardLibrary

  import Seq

  import CSE = AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes

  import SE = StructuredEncryptionUtil

  import InternalLegacyOverride

  import MaterialProviders

  import RequiredEncryptionContextCMM

  import SET = AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes

  import DDBE = AwsCryptographyDbEncryptionSdkDynamoDbTypes

  import String = StandardLibrary.String

  import StructuredEncryptionHeader

  datatype Config = Config(nameonly version: StructuredEncryptionHeader.Version, nameonly cmpClient: MaterialProviders.MaterialProvidersClient, nameonly logicalTableName: string, nameonly partitionKeyName: ComAmazonawsDynamodbTypes.KeySchemaAttributeName, nameonly sortKeyName: Option<ComAmazonawsDynamodbTypes.KeySchemaAttributeName>, nameonly cmm: CMP.ICryptographicMaterialsManager, nameonly attributeActionsOnEncrypt: DDBE.AttributeActions, nameonly allowedUnsignedAttributes: Option<ComAmazonawsDynamodbTypes.AttributeNameList>, nameonly allowedUnsignedAttributePrefix: Option<string>, nameonly algorithmSuiteId: Option<CMP.DBEAlgorithmSuiteId>, nameonly structuredEncryption: StructuredEncryption.StructuredEncryptionClient, nameonly plaintextOverride: DDBE.PlaintextOverride, nameonly internalLegacyOverride: Option<InternalLegacyOverride.InternalLegacyOverride> := None)

  type InternalConfig = Config

  type ValidConfig = x: Config
    | ValidInternalConfig?(x)
    witness *

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes
}

module {:extern ""software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.legacy""} InternalLegacyOverride {

  import opened Wrappers

  import Types = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes

  import DDBE = AwsCryptographyDbEncryptionSdkDynamoDbTypes
  class {:extern} InternalLegacyOverride {
    static method {:extern} Build(encryptorConfig: Types.DynamoDbItemEncryptorConfig) returns (output: Result<Option<InternalLegacyOverride>, Types.Error>)
      decreases encryptorConfig

    const {:extern} policy: DDBE.LegacyPolicy

    method {:extern} EncryptItem(input: Types.EncryptItemInput) returns (output: Result<Types.EncryptItemOutput, Types.Error>)
      decreases input

    method {:extern} DecryptItem(input: Types.DecryptItemInput) returns (output: Result<Types.DecryptItemOutput, Types.Error>)
      decreases input

    predicate method {:extern} IsLegacyInput(input: Types.DecryptItemInput)
      decreases input

    static function method CreateBuildSuccess(value: Option<InternalLegacyOverride>): Result<Option<InternalLegacyOverride>, Types.Error>
      decreases value
    {
      Success(value)
    }

    static function method CreateBuildFailure(error: Types.Error): Result<Option<InternalLegacyOverride>, Types.Error>
      decreases error
    {
      Failure(error)
    }

    static function method CreateInternalLegacyOverrideSome(value: InternalLegacyOverride): Option<InternalLegacyOverride>
      decreases value
    {
      Some(value)
    }

    static function method CreateInternalLegacyOverrideNone(): Option<InternalLegacyOverride>
    {
      None
    }

    function method CreateEncryptItemSuccess(value: Types.EncryptItemOutput): Result<Types.EncryptItemOutput, Types.Error>
      decreases value
    {
      Success(value)
    }

    function method CreateEncryptItemFailure(error: Types.Error): Result<Types.EncryptItemOutput, Types.Error>
      decreases error
    {
      Failure(error)
    }

    function method CreateDecryptItemSuccess(value: Types.DecryptItemOutput): Result<Types.DecryptItemOutput, Types.Error>
      decreases value
    {
      Success(value)
    }

    function method CreateDecryptItemFailure(error: Types.Error): Result<Types.DecryptItemOutput, Types.Error>
      decreases error
    {
      Failure(error)
    }
  }
}

module {:extern ""software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny""} DynamoDbEncryptionTransforms refines AbstractAwsCryptographyDbEncryptionSdkDynamoDbTransformsService {
  function method DefaultDynamoDbTablesEncryptionConfig(): AwsCryptographyDbEncryptionSdkDynamoDbTypes.DynamoDbTablesEncryptionConfig
  {
    ET.DynamoDbTablesEncryptionConfig(tableEncryptionConfigs := map[])
  }

  predicate ValidWholeSearchConfig(config: ET.DynamoDbTablesEncryptionConfig)
    decreases config
  {
    forall t: seq<char> {:trigger config.tableEncryptionConfigs[t]} {:trigger t in config.tableEncryptionConfigs} | t in config.tableEncryptionConfigs :: 
      _default.ValidSearchConfig(config.tableEncryptionConfigs[t].search)
  }

  function TheModifies(config: AwsCryptographyDbEncryptionSdkDynamoDbTypes.DynamoDbTablesEncryptionConfig): set<object>
    decreases config
  {
    ghost var tmps11: set<set<AwsCryptographyKeyStoreTypes.IKeyStoreClient>> := set t11: DynamoDbTableEncryptionConfig {:trigger t11.search} {:trigger t11 in config.tableEncryptionConfigs.Values} | t11 in config.tableEncryptionConfigs.Values && t11.search.Some? :: set t12: BeaconVersion {:trigger t12.keyStore} {:trigger t12 in t11.search.value.versions} | t12 in t11.search.value.versions :: t12.keyStore;
    ghost var tmps11FlattenedModifiesSet: set<set<object>> := set t0: set<AwsCryptographyKeyStoreTypes.IKeyStoreClient>, t1: AwsCryptographyKeyStoreTypes.IKeyStoreClient {:trigger t1.Modifies, t0 in tmps11} {:trigger t1 in t0} | t0 in tmps11 && t1 in t0 :: t1.Modifies;
    set tmp13Modifies: set<object>, tmp13ModifyEntry: object {:trigger tmp13ModifyEntry in tmp13Modifies} | tmp13Modifies in tmps11FlattenedModifiesSet && tmp13ModifyEntry in tmp13Modifies :: tmp13ModifyEntry
  }

  function SearchModifies(config: AwsCryptographyDbEncryptionSdkDynamoDbTypes.DynamoDbTablesEncryptionConfig, tableName: string): set<object>
    requires tableName in config.tableEncryptionConfigs
    decreases config, tableName
  {
    ghost var inputConfig: DynamoDbTableEncryptionConfig := config.tableEncryptionConfigs[tableName];
    if inputConfig.search.Some? then
      inputConfig.search.value.versions[0].keyStore.Modifies
    else
      {}
  }

  lemma {:axiom} SearchInModifies(config: AwsCryptographyDbEncryptionSdkDynamoDbTypes.DynamoDbTablesEncryptionConfig, tableName: string)
    requires tableName in config.tableEncryptionConfigs
    ensures SearchModifies(config, tableName) <= TheModifies(config)
    decreases config, tableName

  function method {:tailrecursion} AddSignedBeaconActions(names: seq<string>, actions: ET.AttributeActions): ET.AttributeActions
    requires forall k: string {:trigger _default.IsValid_AttributeName(k)} {:trigger k in names} | k in names :: _default.IsValid_AttributeName(k)
    decreases names, actions
  {
    if |names| == 0 then
      actions
    else
      AddSignedBeaconActions(names[1..], actions[names[0] := SET.SIGN_ONLY])
  }

  predicate method IsConfigured(config: AwsCryptographyDbEncryptionSdkDynamoDbTypes.DynamoDbTableEncryptionConfig, name: string)
    decreases config, name
  {
    name in config.attributeActionsOnEncrypt || (config.allowedUnsignedAttributes.Some? && name in config.allowedUnsignedAttributes.value) || (config.allowedUnsignedAttributePrefix.Some? && config.allowedUnsignedAttributePrefix.value <= name)
  }

  predicate {:opaque} AllTableConfigsValid?(configs: map<string, TableConfig>)
    ensures 0 == |configs| ==> AllTableConfigsValid?(configs)
    decreases configs
  {
    forall tableName: seq<char> {:trigger configs[tableName]} {:trigger tableName in configs} | tableName in configs :: 
      ValidTableConfig?(configs[tableName])
  }

  predicate {:opaque} CorrectlyTransferedStructure?(internalConfigs: map<string, DdbMiddlewareConfig.ValidTableConfig>, config: AwsCryptographyDbEncryptionSdkDynamoDbTypes.DynamoDbTablesEncryptionConfig)
    ensures 0 == |internalConfigs| ==> CorrectlyTransferedStructure?(internalConfigs, config)
    decreases internalConfigs, config
  {
    forall tableName: seq<char> {:trigger config.tableEncryptionConfigs[tableName]} {:trigger internalConfigs[tableName]} {:trigger tableName in config.tableEncryptionConfigs} {:trigger tableName in internalConfigs} | tableName in internalConfigs :: 
      tableName in config.tableEncryptionConfigs &&
      ConfigsMatch(tableName, internalConfigs[tableName], config.tableEncryptionConfigs[tableName])
  }

  predicate {:opaque} ConfigsMatch(tableName: string, internalConfig: DdbMiddlewareConfig.ValidTableConfig, inputConfig: AwsCryptographyDbEncryptionSdkDynamoDbTypes.DynamoDbTableEncryptionConfig)
    decreases tableName, internalConfig, inputConfig
  {
    tableName == internalConfig.physicalTableName &&
    inputConfig.logicalTableName == internalConfig.logicalTableName &&
    inputConfig.partitionKeyName == internalConfig.partitionKeyName &&
    inputConfig.sortKeyName == internalConfig.sortKeyName
  }

  method {:vcs_split_on_every_assert} DynamoDbEncryptionTransforms(config: AwsCryptographyDbEncryptionSdkDynamoDbTypes.DynamoDbTablesEncryptionConfig := DefaultDynamoDbTablesEncryptionConfig()) returns (res: Result<DynamoDbEncryptionTransformsClient, Error>)
    requires var tmps0: set<DynamoDbTableEncryptionConfig> := set t0: DynamoDbTableEncryptionConfig {:trigger t0 in config.tableEncryptionConfigs.Values} | t0 in config.tableEncryptionConfigs.Values; forall tmp0: DynamoDbTableEncryptionConfig {:trigger tmp0.keyring} {:trigger tmp0 in tmps0} :: tmp0 in tmps0 ==> tmp0.keyring.Some? ==> tmp0.keyring.value.ValidState()
    requires var tmps1: set<DynamoDbTableEncryptionConfig> := set t1: DynamoDbTableEncryptionConfig {:trigger t1 in config.tableEncryptionConfigs.Values} | t1 in config.tableEncryptionConfigs.Values; forall tmp1: DynamoDbTableEncryptionConfig {:trigger tmp1.cmm} {:trigger tmp1 in tmps1} :: tmp1 in tmps1 ==> tmp1.cmm.Some? ==> tmp1.cmm.value.ValidState()
    requires var tmps2: set<DynamoDbTableEncryptionConfig> := set t2: DynamoDbTableEncryptionConfig {:trigger t2 in config.tableEncryptionConfigs.Values} | t2 in config.tableEncryptionConfigs.Values; forall tmp2: DynamoDbTableEncryptionConfig {:trigger tmp2.legacyOverride} {:trigger tmp2 in tmps2} :: tmp2 in tmps2 ==> tmp2.legacyOverride.Some? ==> tmp2.legacyOverride.value.encryptor.ValidState()
    requires var tmps3: set<DynamoDbTableEncryptionConfig> := set t3: DynamoDbTableEncryptionConfig {:trigger t3 in config.tableEncryptionConfigs.Values} | t3 in config.tableEncryptionConfigs.Values; forall tmp3: DynamoDbTableEncryptionConfig {:trigger tmp3.search} {:trigger tmp3 in tmps3} :: tmp3 in tmps3 ==> tmp3.search.Some? ==> var tmps4: set<BeaconVersion> := set t4: BeaconVersion {:trigger t4 in tmp3.search.value.versions} | t4 in tmp3.search.value.versions; forall tmp4: BeaconVersion {:trigger tmp4.keyStore} {:trigger tmp4 in tmps4} :: tmp4 in tmps4 ==> tmp4.keyStore.ValidState()
    requires var tmps5: set<DynamoDbTableEncryptionConfig> := set t5: DynamoDbTableEncryptionConfig {:trigger t5 in config.tableEncryptionConfigs.Values} | t5 in config.tableEncryptionConfigs.Values; forall tmp5: DynamoDbTableEncryptionConfig {:trigger tmp5.search} {:trigger tmp5 in tmps5} :: tmp5 in tmps5 ==> tmp5.search.Some? ==> var tmps6: set<BeaconVersion> := set t6: BeaconVersion {:trigger t6 in tmp5.search.value.versions} | t6 in tmp5.search.value.versions; forall tmp6: BeaconVersion {:trigger tmp6.keySource} {:trigger tmp6 in tmps6} :: tmp6 in tmps6 ==> tmp6.keySource.multi? ==> tmp6.keySource.multi.cache.Some? ==> tmp6.keySource.multi.cache.value.Shared? ==> tmp6.keySource.multi.cache.value.Shared.ValidState()
    modifies set tmps7: AwsCryptographyMaterialProvidersTypes.IKeyring, obj: object {:trigger obj in tmps7.Modifies} | tmps7 in (set t7: DynamoDbTableEncryptionConfig {:trigger t7.keyring} {:trigger t7 in config.tableEncryptionConfigs.Values} | t7 in config.tableEncryptionConfigs.Values && true && t7.keyring.Some? :: t7.keyring.value) && obj in tmps7.Modifies && obj in tmps7.Modifies :: obj, set tmps8: AwsCryptographyMaterialProvidersTypes.ICryptographicMaterialsManager, obj: object {:trigger obj in tmps8.Modifies} | tmps8 in (set t8: DynamoDbTableEncryptionConfig {:trigger t8.cmm} {:trigger t8 in config.tableEncryptionConfigs.Values} | t8 in config.tableEncryptionConfigs.Values && true && t8.cmm.Some? :: t8.cmm.value) && obj in tmps8.Modifies && obj in tmps8.Modifies :: obj, set tmps9: ILegacyDynamoDbEncryptor, obj: object {:trigger obj in tmps9.Modifies} | tmps9 in (set t9: DynamoDbTableEncryptionConfig {:trigger t9.legacyOverride} {:trigger t9 in config.tableEncryptionConfigs.Values} | t9 in config.tableEncryptionConfigs.Values && true && t9.legacyOverride.Some? :: t9.legacyOverride.value.encryptor) && obj in tmps9.Modifies && obj in tmps9.Modifies :: obj, set tmps10: AwsCryptographyKeyStoreTypes.IKeyStoreClient, obj: object {:trigger obj in tmps10.Modifies} | tmps10 in (set t10: DynamoDbTableEncryptionConfig, t11: BeaconVersion {:trigger t11.keyStore, t10.search} {:trigger t11.keyStore, t10 in config.tableEncryptionConfigs.Values} | t10 in config.tableEncryptionConfigs.Values && true && t10.search.Some? && t11 in t10.search.value.versions && true :: t11.keyStore) && obj in tmps10.Modifies && obj in tmps10.Modifies :: obj, set tmps12: ICryptographicMaterialsCache, obj: object {:trigger obj in tmps12.Modifies} | tmps12 in (set t12: DynamoDbTableEncryptionConfig, t13: BeaconVersion {:trigger t13.keySource, t12.search} {:trigger t13.keySource, t12 in config.tableEncryptionConfigs.Values} | t12 in config.tableEncryptionConfigs.Values && true && t12.search.Some? && t13 in t12.search.value.versions && true && t13.keySource.multi? && t13.keySource.multi.cache.Some? && t13.keySource.multi.cache.value.Shared? :: t13.keySource.multi.cache.value.Shared) && obj in tmps12.Modifies && obj in tmps12.Modifies :: obj
    ensures res.Success? ==> fresh(res.value) && fresh(res.value.Modifies - (set tmps14: AwsCryptographyMaterialProvidersTypes.IKeyring, obj: object {:trigger obj in tmps14.Modifies} | tmps14 in (set t14: DynamoDbTableEncryptionConfig {:trigger t14.keyring} {:trigger t14 in config.tableEncryptionConfigs.Values} | t14 in config.tableEncryptionConfigs.Values && true && t14.keyring.Some? :: t14.keyring.value) && obj in tmps14.Modifies && obj in tmps14.Modifies :: obj) - (set tmps15: AwsCryptographyMaterialProvidersTypes.ICryptographicMaterialsManager, obj: object {:trigger obj in tmps15.Modifies} | tmps15 in (set t15: DynamoDbTableEncryptionConfig {:trigger t15.cmm} {:trigger t15 in config.tableEncryptionConfigs.Values} | t15 in config.tableEncryptionConfigs.Values && true && t15.cmm.Some? :: t15.cmm.value) && obj in tmps15.Modifies && obj in tmps15.Modifies :: obj) - (set tmps16: ILegacyDynamoDbEncryptor, obj: object {:trigger obj in tmps16.Modifies} | tmps16 in (set t16: DynamoDbTableEncryptionConfig {:trigger t16.legacyOverride} {:trigger t16 in config.tableEncryptionConfigs.Values} | t16 in config.tableEncryptionConfigs.Values && true && t16.legacyOverride.Some? :: t16.legacyOverride.value.encryptor) && obj in tmps16.Modifies && obj in tmps16.Modifies :: obj) - (set tmps17: AwsCryptographyKeyStoreTypes.IKeyStoreClient, obj: object {:trigger obj in tmps17.Modifies} | tmps17 in (set t17: DynamoDbTableEncryptionConfig, t18: BeaconVersion {:trigger t18.keyStore, t17.search} {:trigger t18.keyStore, t17 in config.tableEncryptionConfigs.Values} | t17 in config.tableEncryptionConfigs.Values && true && t17.search.Some? && t18 in t17.search.value.versions && true :: t18.keyStore) && obj in tmps17.Modifies && obj in tmps17.Modifies :: obj) - set tmps19: ICryptographicMaterialsCache, obj: object {:trigger obj in tmps19.Modifies} | tmps19 in (set t19: DynamoDbTableEncryptionConfig, t20: BeaconVersion {:trigger t20.keySource, t19.search} {:trigger t20.keySource, t19 in config.tableEncryptionConfigs.Values} | t19 in config.tableEncryptionConfigs.Values && true && t19.search.Some? && t20 in t19.search.value.versions && true && t20.keySource.multi? && t20.keySource.multi.cache.Some? && t20.keySource.multi.cache.value.Shared? :: t20.keySource.multi.cache.value.Shared) && obj in tmps19.Modifies && obj in tmps19.Modifies :: obj) && fresh(res.value.History) && res.value.ValidState()
    ensures var tmps21: set<DynamoDbTableEncryptionConfig> := set t21: DynamoDbTableEncryptionConfig {:trigger t21 in config.tableEncryptionConfigs.Values} | t21 in config.tableEncryptionConfigs.Values; forall tmp21: DynamoDbTableEncryptionConfig {:trigger tmp21.keyring} {:trigger tmp21 in tmps21} :: tmp21 in tmps21 ==> tmp21.keyring.Some? ==> tmp21.keyring.value.ValidState()
    ensures var tmps22: set<DynamoDbTableEncryptionConfig> := set t22: DynamoDbTableEncryptionConfig {:trigger t22 in config.tableEncryptionConfigs.Values} | t22 in config.tableEncryptionConfigs.Values; forall tmp22: DynamoDbTableEncryptionConfig {:trigger tmp22.cmm} {:trigger tmp22 in tmps22} :: tmp22 in tmps22 ==> tmp22.cmm.Some? ==> tmp22.cmm.value.ValidState()
    ensures var tmps23: set<DynamoDbTableEncryptionConfig> := set t23: DynamoDbTableEncryptionConfig {:trigger t23 in config.tableEncryptionConfigs.Values} | t23 in config.tableEncryptionConfigs.Values; forall tmp23: DynamoDbTableEncryptionConfig {:trigger tmp23.legacyOverride} {:trigger tmp23 in tmps23} :: tmp23 in tmps23 ==> tmp23.legacyOverride.Some? ==> tmp23.legacyOverride.value.encryptor.ValidState()
    ensures var tmps24: set<DynamoDbTableEncryptionConfig> := set t24: DynamoDbTableEncryptionConfig {:trigger t24 in config.tableEncryptionConfigs.Values} | t24 in config.tableEncryptionConfigs.Values; forall tmp24: DynamoDbTableEncryptionConfig {:trigger tmp24.search} {:trigger tmp24 in tmps24} :: tmp24 in tmps24 ==> tmp24.search.Some? ==> var tmps25: set<BeaconVersion> := set t25: BeaconVersion {:trigger t25 in tmp24.search.value.versions} | t25 in tmp24.search.value.versions; forall tmp25: BeaconVersion {:trigger tmp25.keyStore} {:trigger tmp25 in tmps25} :: tmp25 in tmps25 ==> tmp25.keyStore.ValidState()
    ensures var tmps26: set<DynamoDbTableEncryptionConfig> := set t26: DynamoDbTableEncryptionConfig {:trigger t26 in config.tableEncryptionConfigs.Values} | t26 in config.tableEncryptionConfigs.Values; forall tmp26: DynamoDbTableEncryptionConfig {:trigger tmp26.search} {:trigger tmp26 in tmps26} :: tmp26 in tmps26 ==> tmp26.search.Some? ==> var tmps27: set<BeaconVersion> := set t27: BeaconVersion {:trigger t27 in tmp26.search.value.versions} | t27 in tmp26.search.value.versions; forall tmp27: BeaconVersion {:trigger tmp27.keySource} {:trigger tmp27 in tmps27} :: tmp27 in tmps27 ==> tmp27.keySource.multi? ==> tmp27.keySource.multi.cache.Some? ==> tmp27.keySource.multi.cache.value.Shared? ==> tmp27.keySource.multi.cache.value.Shared.ValidState()
    ensures res.Success? ==> res.value is DynamoDbEncryptionTransformsClient && var config: Operations.InternalConfig := (res.value as DynamoDbEncryptionTransformsClient).config; true && DdbMiddlewareConfig.ValidConfig?(config)
    decreases config
  {
    var internalConfigs: map<string, DdbMiddlewareConfig.ValidTableConfig> := map[];
    assert ValidWholeSearchConfig(config);
    var m' := config.tableEncryptionConfigs;
    var mKeys := m'.Keys;
    var tableNamesSeq := SortedSets.ComputeSetToSequence(mKeys);
    ghost var mKeysSet := mKeys;
    ghost var inputConfigsModifies: set<object> := set tableConfig: DynamoDbTableEncryptionConfig, o: object | tableConfig in config.tableEncryptionConfigs.Values && o in (if tableConfig.keyring.Some? then tableConfig.keyring.value.Modifies else {}) + (if tableConfig.cmm.Some? then tableConfig.cmm.value.Modifies else {}) + if tableConfig.legacyOverride.Some? then tableConfig.legacyOverride.value.encryptor.Modifies else {} :: o;
    var allLogicalTableNames := {};
    var i := 0;
    while i < |tableNamesSeq|
      invariant m'.Keys <= config.tableEncryptionConfigs.Keys
      invariant forall k: seq<char> {:trigger config.tableEncryptionConfigs[k]} {:trigger m'[k]} {:trigger k in m'} | k in m' :: m'[k] == config.tableEncryptionConfigs[k]
      invariant forall internalConfig: DdbMiddlewareConfig.ValidTableConfig {:trigger internalConfig.logicalTableName} {:trigger internalConfig in internalConfigs.Values} | internalConfig in internalConfigs.Values :: internalConfig.logicalTableName in allLogicalTableNames
      invariant CorrectlyTransferedStructure?(internalConfigs, config)
      invariant AllTableConfigsValid?(internalConfigs)
      invariant ValidConfig?(Config(internalConfigs))
      decreases |tableNamesSeq| - i
      modifies inputConfigsModifies
    {
      var tableName: string := tableNamesSeq[i];
      var inputConfig := config.tableEncryptionConfigs[tableName];
      :- Need(inputConfig.logicalTableName !in allLogicalTableNames, E(""Duplicate logical table maped to multipule physical tables: "" + inputConfig.logicalTableName));
      assert SearchConfigToInfo.ValidSearchConfig(inputConfig.search);
      SearchInModifies(config, tableName);
      var searchR := SearchConfigToInfo.Convert(inputConfig);
      var search :- searchR.MapFailure((e: Error) => AwsCryptographyDbEncryptionSdkDynamoDb(e));
      assert search.None? || search.value.ValidState();
      var signedBeacons := if search.None? then [] else search.value.curr().ListSignedBeacons();
      var badBeacons := Seq.Filter((s: seq<char>) => IsConfigured(inputConfig, s), signedBeacons);
      if 0 < |badBeacons| {
        return Failure(E(""Signed beacons cannot be configured with CryptoActions or as unauthenticated : "" + Join(badBeacons, "", "")));
      }
      :- Need(forall k: string {:trigger _default.IsValid_AttributeName(k)} {:trigger k in signedBeacons} | k in signedBeacons :: _default.IsValid_AttributeName(k), E(""Beacon configured with bad name""));
      var newActions := AddSignedBeaconActions(signedBeacons, inputConfig.attributeActionsOnEncrypt);
      var encryptorConfig := IE_Types.DynamoDbItemEncryptorConfig(logicalTableName := inputConfig.logicalTableName, partitionKeyName := inputConfig.partitionKeyName, sortKeyName := inputConfig.sortKeyName, attributeActionsOnEncrypt := newActions, allowedUnsignedAttributes := inputConfig.allowedUnsignedAttributes, allowedUnsignedAttributePrefix := inputConfig.allowedUnsignedAttributePrefix, algorithmSuiteId := inputConfig.algorithmSuiteId, keyring := inputConfig.keyring, cmm := inputConfig.cmm, legacyOverride := inputConfig.legacyOverride, plaintextOverride := inputConfig.plaintextOverride);
      var itemEncryptorRes := DynamoDbItemEncryptor.DynamoDbItemEncryptor(encryptorConfig);
      var itemEncryptorX: IE_Types.IDynamoDbItemEncryptorClient :- itemEncryptorRes.MapFailure((e: Error) => AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptor(e));
      assert itemEncryptorX is DynamoDbItemEncryptor.DynamoDbItemEncryptorClient;
      var itemEncryptor := itemEncryptorX as DynamoDbItemEncryptor.DynamoDbItemEncryptorClient;
      assert itemEncryptor.ValidState();
      var encConfig := itemEncryptor.config;
      assert inputConfig.logicalTableName == encConfig.logicalTableName;
      assert inputConfig.partitionKeyName == encConfig.partitionKeyName;
      assert inputConfig.sortKeyName == encConfig.sortKeyName;
      var internalConfig: DdbMiddlewareConfig.ValidTableConfig := DdbMiddlewareConfig.TableConfig(physicalTableName := tableName, logicalTableName := inputConfig.logicalTableName, partitionKeyName := inputConfig.partitionKeyName, sortKeyName := inputConfig.sortKeyName, itemEncryptor := itemEncryptor, search := search, plaintextOverride := inputConfig.plaintextOverride.UnwrapOr(AwsCryptographyDbEncryptionSdkDynamoDbTypes.PlaintextOverride.FORBID_PLAINTEXT_WRITE_FORBID_PLAINTEXT_READ));
      internalConfigs := internalConfigs[tableName := internalConfig];
      allLogicalTableNames := allLogicalTableNames + {internalConfig.logicalTableName};
      assert AllTableConfigsValid?(internalConfigs) by {
        reveal AllTableConfigsValid?();
        assert AllTableConfigsValid?(internalConfigs - {tableName});
        assert ValidTableConfig?(internalConfig);
      }
      assert ValidConfig?(Config(internalConfigs)) by {
        assert ValidConfig?(Config(internalConfigs - {tableName}));
        assert internalConfig.physicalTableName == tableName;
      }
      assert CorrectlyTransferedStructure?(internalConfigs, config) by {
        reveal CorrectlyTransferedStructure?();
        reveal ConfigsMatch();
        assert CorrectlyTransferedStructure?(internalConfigs - {tableName}, config);
        assert ConfigsMatch(tableName, internalConfig, inputConfig);
      }
      i := i + 1;
    }
    assert SearchValidState(DdbMiddlewareConfig.Config(tableEncryptionConfigs := internalConfigs));
    var newConfig := DdbMiddlewareConfig.Config(tableEncryptionConfigs := internalConfigs);
    assert Operations.ValidInternalConfig?(newConfig);
    var client := new DynamoDbEncryptionTransformsClient(newConfig);
    assume {:axiom} fresh(client.Modifies - (var tmps14: set<AwsCryptographyMaterialProvidersTypes.IKeyring> := set t14: DynamoDbTableEncryptionConfig {:trigger t14.keyring} {:trigger t14 in config.tableEncryptionConfigs.Values} | t14 in config.tableEncryptionConfigs.Values && t14.keyring.Some? :: t14.keyring.value; var tmps14FlattenedModifiesSet: set<set<object>> := set t0: AwsCryptographyMaterialProvidersTypes.IKeyring {:trigger t0.Modifies} {:trigger t0 in tmps14} | t0 in tmps14 :: t0.Modifies; set tmp15Modifies: set<object>, tmp15ModifyEntry: object {:trigger tmp15ModifyEntry in tmp15Modifies} | tmp15Modifies in tmps14FlattenedModifiesSet && tmp15ModifyEntry in tmp15Modifies :: tmp15ModifyEntry) - (var tmps16: set<AwsCryptographyMaterialProvidersTypes.ICryptographicMaterialsManager> := set t16: DynamoDbTableEncryptionConfig {:trigger t16.cmm} {:trigger t16 in config.tableEncryptionConfigs.Values} | t16 in config.tableEncryptionConfigs.Values && t16.cmm.Some? :: t16.cmm.value; var tmps16FlattenedModifiesSet: set<set<object>> := set t0: AwsCryptographyMaterialProvidersTypes.ICryptographicMaterialsManager {:trigger t0.Modifies} {:trigger t0 in tmps16} | t0 in tmps16 :: t0.Modifies; set tmp17Modifies: set<object>, tmp17ModifyEntry: object {:trigger tmp17ModifyEntry in tmp17Modifies} | tmp17Modifies in tmps16FlattenedModifiesSet && tmp17ModifyEntry in tmp17Modifies :: tmp17ModifyEntry) - (var tmps18: set<ILegacyDynamoDbEncryptor> := set t18: DynamoDbTableEncryptionConfig {:trigger t18.legacyOverride} {:trigger t18 in config.tableEncryptionConfigs.Values} | t18 in config.tableEncryptionConfigs.Values && t18.legacyOverride.Some? :: t18.legacyOverride.value.encryptor; var tmps18FlattenedModifiesSet: set<set<object>> := set t0: ILegacyDynamoDbEncryptor {:trigger t0.Modifies} {:trigger t0 in tmps18} | t0 in tmps18 :: t0.Modifies; set tmp19Modifies: set<object>, tmp19ModifyEntry: object {:trigger tmp19ModifyEntry in tmp19Modifies} | tmp19Modifies in tmps18FlattenedModifiesSet && tmp19ModifyEntry in tmp19Modifies :: tmp19ModifyEntry) - var tmps20: set<set<AwsCryptographyKeyStoreTypes.IKeyStoreClient>> := set t20: DynamoDbTableEncryptionConfig {:trigger t20.search} {:trigger t20 in config.tableEncryptionConfigs.Values} | t20 in config.tableEncryptionConfigs.Values && t20.search.Some? :: set t21: BeaconVersion {:trigger t21.keyStore} {:trigger t21 in t20.search.value.versions} | t21 in t20.search.value.versions :: t21.keyStore; var tmps20FlattenedModifiesSet: set<set<object>> := set t0: set<AwsCryptographyKeyStoreTypes.IKeyStoreClient>, t1: AwsCryptographyKeyStoreTypes.IKeyStoreClient {:trigger t1.Modifies, t0 in tmps20} {:trigger t1 in t0} | t0 in tmps20 && t1 in t0 :: t1.Modifies; set tmp22Modifies: set<object>, tmp22ModifyEntry: object {:trigger tmp22ModifyEntry in tmp22Modifies} | tmp22Modifies in tmps20FlattenedModifiesSet && tmp22ModifyEntry in tmp22Modifies :: tmp22ModifyEntry);
    return Success(client);
  }

  function method CreateSuccessOfClient(client: IDynamoDbEncryptionTransformsClient): Result<IDynamoDbEncryptionTransformsClient, Error>
    decreases client
  {
    Success(client)
  }

  function method CreateFailureOfError(error: Error): Result<IDynamoDbEncryptionTransformsClient, Error>
    decreases error
  {
    Failure(error)
  }

  import opened DdbMiddlewareConfig

  import opened StandardLibrary

  import IE_Types = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes

  import Operations = AwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations

  import DynamoDbItemEncryptor

  import SearchConfigToInfo

  import Seq

  import SortedSets

  import ET = AwsCryptographyDbEncryptionSdkDynamoDbTypes

  import SET = AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes

  import DDB = ComAmazonawsDynamodbTypes

  class DynamoDbEncryptionTransformsClient ... {
    predicate ValidState()
      ensures ValidState() ==> Operations.ValidInternalConfig?(config) && History !in Operations.ModifiesInternalConfig(config) && Modifies == Operations.ModifiesInternalConfig(config) + {History}
    {
      Operations.ValidInternalConfig?(config) &&
      History !in Operations.ModifiesInternalConfig(config) &&
      Modifies == Operations.ModifiesInternalConfig(config) + {History}
    }

    constructor {:vcs_split_on_every_assert} (config: Operations.InternalConfig)
      requires Operations.ValidInternalConfig?(config)
      ensures ValidState() && fresh(History) && this.config == config
      decreases config
    {
      this.config := config;
      History := new IDynamoDbEncryptionTransformsClientCallHistory();
      Modifies := Operations.ModifiesInternalConfig(config) + {History};
    }

    const config: Operations.InternalConfig

    predicate PutItemInputTransformEnsuresPublicly(input: PutItemInputTransformInput, output: Result<PutItemInputTransformOutput, Error>)
      decreases input, output
    {
      Operations.PutItemInputTransformEnsuresPublicly(input, output)
    }

    method PutItemInputTransform(input: PutItemInputTransformInput) returns (output: Result<PutItemInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`PutItemInputTransform
      ensures true && ValidState()
      ensures PutItemInputTransformEnsuresPublicly(input, output)
      ensures History.PutItemInputTransform == old(History.PutItemInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.PutItemInputTransform(config, input);
      History.PutItemInputTransform := History.PutItemInputTransform + [DafnyCallEvent(input, output)];
    }

    predicate PutItemOutputTransformEnsuresPublicly(input: PutItemOutputTransformInput, output: Result<PutItemOutputTransformOutput, Error>)
      decreases input, output
    {
      Operations.PutItemOutputTransformEnsuresPublicly(input, output)
    }

    method PutItemOutputTransform(input: PutItemOutputTransformInput) returns (output: Result<PutItemOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`PutItemOutputTransform
      ensures true && ValidState()
      ensures PutItemOutputTransformEnsuresPublicly(input, output)
      ensures History.PutItemOutputTransform == old(History.PutItemOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.PutItemOutputTransform(config, input);
      History.PutItemOutputTransform := History.PutItemOutputTransform + [DafnyCallEvent(input, output)];
    }

    predicate GetItemInputTransformEnsuresPublicly(input: GetItemInputTransformInput, output: Result<GetItemInputTransformOutput, Error>)
      decreases input, output
    {
      Operations.GetItemInputTransformEnsuresPublicly(input, output)
    }

    method GetItemInputTransform(input: GetItemInputTransformInput) returns (output: Result<GetItemInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetItemInputTransform
      ensures true && ValidState()
      ensures GetItemInputTransformEnsuresPublicly(input, output)
      ensures History.GetItemInputTransform == old(History.GetItemInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.GetItemInputTransform(config, input);
      History.GetItemInputTransform := History.GetItemInputTransform + [DafnyCallEvent(input, output)];
    }

    predicate GetItemOutputTransformEnsuresPublicly(input: GetItemOutputTransformInput, output: Result<GetItemOutputTransformOutput, Error>)
      decreases input, output
    {
      Operations.GetItemOutputTransformEnsuresPublicly(input, output)
    }

    method GetItemOutputTransform(input: GetItemOutputTransformInput) returns (output: Result<GetItemOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetItemOutputTransform
      ensures true && ValidState()
      ensures GetItemOutputTransformEnsuresPublicly(input, output)
      ensures History.GetItemOutputTransform == old(History.GetItemOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.GetItemOutputTransform(config, input);
      History.GetItemOutputTransform := History.GetItemOutputTransform + [DafnyCallEvent(input, output)];
    }

    predicate BatchWriteItemInputTransformEnsuresPublicly(input: BatchWriteItemInputTransformInput, output: Result<BatchWriteItemInputTransformOutput, Error>)
      decreases input, output
    {
      Operations.BatchWriteItemInputTransformEnsuresPublicly(input, output)
    }

    method BatchWriteItemInputTransform(input: BatchWriteItemInputTransformInput) returns (output: Result<BatchWriteItemInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`BatchWriteItemInputTransform
      ensures true && ValidState()
      ensures BatchWriteItemInputTransformEnsuresPublicly(input, output)
      ensures History.BatchWriteItemInputTransform == old(History.BatchWriteItemInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.BatchWriteItemInputTransform(config, input);
      History.BatchWriteItemInputTransform := History.BatchWriteItemInputTransform + [DafnyCallEvent(input, output)];
    }

    predicate BatchWriteItemOutputTransformEnsuresPublicly(input: BatchWriteItemOutputTransformInput, output: Result<BatchWriteItemOutputTransformOutput, Error>)
      decreases input, output
    {
      Operations.BatchWriteItemOutputTransformEnsuresPublicly(input, output)
    }

    method BatchWriteItemOutputTransform(input: BatchWriteItemOutputTransformInput) returns (output: Result<BatchWriteItemOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`BatchWriteItemOutputTransform
      ensures true && ValidState()
      ensures BatchWriteItemOutputTransformEnsuresPublicly(input, output)
      ensures History.BatchWriteItemOutputTransform == old(History.BatchWriteItemOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.BatchWriteItemOutputTransform(config, input);
      History.BatchWriteItemOutputTransform := History.BatchWriteItemOutputTransform + [DafnyCallEvent(input, output)];
    }

    predicate BatchGetItemInputTransformEnsuresPublicly(input: BatchGetItemInputTransformInput, output: Result<BatchGetItemInputTransformOutput, Error>)
      decreases input, output
    {
      Operations.BatchGetItemInputTransformEnsuresPublicly(input, output)
    }

    method BatchGetItemInputTransform(input: BatchGetItemInputTransformInput) returns (output: Result<BatchGetItemInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`BatchGetItemInputTransform
      ensures true && ValidState()
      ensures BatchGetItemInputTransformEnsuresPublicly(input, output)
      ensures History.BatchGetItemInputTransform == old(History.BatchGetItemInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.BatchGetItemInputTransform(config, input);
      History.BatchGetItemInputTransform := History.BatchGetItemInputTransform + [DafnyCallEvent(input, output)];
    }

    predicate BatchGetItemOutputTransformEnsuresPublicly(input: BatchGetItemOutputTransformInput, output: Result<BatchGetItemOutputTransformOutput, Error>)
      decreases input, output
    {
      Operations.BatchGetItemOutputTransformEnsuresPublicly(input, output)
    }

    method BatchGetItemOutputTransform(input: BatchGetItemOutputTransformInput) returns (output: Result<BatchGetItemOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`BatchGetItemOutputTransform
      ensures true && ValidState()
      ensures BatchGetItemOutputTransformEnsuresPublicly(input, output)
      ensures History.BatchGetItemOutputTransform == old(History.BatchGetItemOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.BatchGetItemOutputTransform(config, input);
      History.BatchGetItemOutputTransform := History.BatchGetItemOutputTransform + [DafnyCallEvent(input, output)];
    }

    predicate ScanInputTransformEnsuresPublicly(input: ScanInputTransformInput, output: Result<ScanInputTransformOutput, Error>)
      decreases input, output
    {
      Operations.ScanInputTransformEnsuresPublicly(input, output)
    }

    method ScanInputTransform(input: ScanInputTransformInput) returns (output: Result<ScanInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ScanInputTransform
      ensures true && ValidState()
      ensures ScanInputTransformEnsuresPublicly(input, output)
      ensures History.ScanInputTransform == old(History.ScanInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.ScanInputTransform(config, input);
      History.ScanInputTransform := History.ScanInputTransform + [DafnyCallEvent(input, output)];
    }

    predicate ScanOutputTransformEnsuresPublicly(input: ScanOutputTransformInput, output: Result<ScanOutputTransformOutput, Error>)
      decreases input, output
    {
      Operations.ScanOutputTransformEnsuresPublicly(input, output)
    }

    method ScanOutputTransform(input: ScanOutputTransformInput) returns (output: Result<ScanOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ScanOutputTransform
      ensures true && ValidState()
      ensures ScanOutputTransformEnsuresPublicly(input, output)
      ensures History.ScanOutputTransform == old(History.ScanOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.ScanOutputTransform(config, input);
      History.ScanOutputTransform := History.ScanOutputTransform + [DafnyCallEvent(input, output)];
    }

    predicate QueryInputTransformEnsuresPublicly(input: QueryInputTransformInput, output: Result<QueryInputTransformOutput, Error>)
      decreases input, output
    {
      Operations.QueryInputTransformEnsuresPublicly(input, output)
    }

    method QueryInputTransform(input: QueryInputTransformInput) returns (output: Result<QueryInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`QueryInputTransform
      ensures true && ValidState()
      ensures QueryInputTransformEnsuresPublicly(input, output)
      ensures History.QueryInputTransform == old(History.QueryInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.QueryInputTransform(config, input);
      History.QueryInputTransform := History.QueryInputTransform + [DafnyCallEvent(input, output)];
    }

    predicate QueryOutputTransformEnsuresPublicly(input: QueryOutputTransformInput, output: Result<QueryOutputTransformOutput, Error>)
      decreases input, output
    {
      Operations.QueryOutputTransformEnsuresPublicly(input, output)
    }

    method QueryOutputTransform(input: QueryOutputTransformInput) returns (output: Result<QueryOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`QueryOutputTransform
      ensures true && ValidState()
      ensures QueryOutputTransformEnsuresPublicly(input, output)
      ensures History.QueryOutputTransform == old(History.QueryOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.QueryOutputTransform(config, input);
      History.QueryOutputTransform := History.QueryOutputTransform + [DafnyCallEvent(input, output)];
    }

    predicate TransactWriteItemsInputTransformEnsuresPublicly(input: TransactWriteItemsInputTransformInput, output: Result<TransactWriteItemsInputTransformOutput, Error>)
      decreases input, output
    {
      Operations.TransactWriteItemsInputTransformEnsuresPublicly(input, output)
    }

    method TransactWriteItemsInputTransform(input: TransactWriteItemsInputTransformInput) returns (output: Result<TransactWriteItemsInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`TransactWriteItemsInputTransform
      ensures true && ValidState()
      ensures TransactWriteItemsInputTransformEnsuresPublicly(input, output)
      ensures History.TransactWriteItemsInputTransform == old(History.TransactWriteItemsInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.TransactWriteItemsInputTransform(config, input);
      History.TransactWriteItemsInputTransform := History.TransactWriteItemsInputTransform + [DafnyCallEvent(input, output)];
    }

    predicate TransactWriteItemsOutputTransformEnsuresPublicly(input: TransactWriteItemsOutputTransformInput, output: Result<TransactWriteItemsOutputTransformOutput, Error>)
      decreases input, output
    {
      Operations.TransactWriteItemsOutputTransformEnsuresPublicly(input, output)
    }

    method TransactWriteItemsOutputTransform(input: TransactWriteItemsOutputTransformInput) returns (output: Result<TransactWriteItemsOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`TransactWriteItemsOutputTransform
      ensures true && ValidState()
      ensures TransactWriteItemsOutputTransformEnsuresPublicly(input, output)
      ensures History.TransactWriteItemsOutputTransform == old(History.TransactWriteItemsOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.TransactWriteItemsOutputTransform(config, input);
      History.TransactWriteItemsOutputTransform := History.TransactWriteItemsOutputTransform + [DafnyCallEvent(input, output)];
    }

    predicate UpdateItemInputTransformEnsuresPublicly(input: UpdateItemInputTransformInput, output: Result<UpdateItemInputTransformOutput, Error>)
      decreases input, output
    {
      Operations.UpdateItemInputTransformEnsuresPublicly(input, output)
    }

    method UpdateItemInputTransform(input: UpdateItemInputTransformInput) returns (output: Result<UpdateItemInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`UpdateItemInputTransform
      ensures true && ValidState()
      ensures UpdateItemInputTransformEnsuresPublicly(input, output)
      ensures History.UpdateItemInputTransform == old(History.UpdateItemInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.UpdateItemInputTransform(config, input);
      History.UpdateItemInputTransform := History.UpdateItemInputTransform + [DafnyCallEvent(input, output)];
    }

    predicate UpdateItemOutputTransformEnsuresPublicly(input: UpdateItemOutputTransformInput, output: Result<UpdateItemOutputTransformOutput, Error>)
      decreases input, output
    {
      Operations.UpdateItemOutputTransformEnsuresPublicly(input, output)
    }

    method UpdateItemOutputTransform(input: UpdateItemOutputTransformInput) returns (output: Result<UpdateItemOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`UpdateItemOutputTransform
      ensures true && ValidState()
      ensures UpdateItemOutputTransformEnsuresPublicly(input, output)
      ensures History.UpdateItemOutputTransform == old(History.UpdateItemOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.UpdateItemOutputTransform(config, input);
      History.UpdateItemOutputTransform := History.UpdateItemOutputTransform + [DafnyCallEvent(input, output)];
    }

    predicate DeleteItemInputTransformEnsuresPublicly(input: DeleteItemInputTransformInput, output: Result<DeleteItemInputTransformOutput, Error>)
      decreases input, output
    {
      Operations.DeleteItemInputTransformEnsuresPublicly(input, output)
    }

    method DeleteItemInputTransform(input: DeleteItemInputTransformInput) returns (output: Result<DeleteItemInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DeleteItemInputTransform
      ensures true && ValidState()
      ensures DeleteItemInputTransformEnsuresPublicly(input, output)
      ensures History.DeleteItemInputTransform == old(History.DeleteItemInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.DeleteItemInputTransform(config, input);
      History.DeleteItemInputTransform := History.DeleteItemInputTransform + [DafnyCallEvent(input, output)];
    }

    predicate DeleteItemOutputTransformEnsuresPublicly(input: DeleteItemOutputTransformInput, output: Result<DeleteItemOutputTransformOutput, Error>)
      decreases input, output
    {
      Operations.DeleteItemOutputTransformEnsuresPublicly(input, output)
    }

    method DeleteItemOutputTransform(input: DeleteItemOutputTransformInput) returns (output: Result<DeleteItemOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DeleteItemOutputTransform
      ensures true && ValidState()
      ensures DeleteItemOutputTransformEnsuresPublicly(input, output)
      ensures History.DeleteItemOutputTransform == old(History.DeleteItemOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.DeleteItemOutputTransform(config, input);
      History.DeleteItemOutputTransform := History.DeleteItemOutputTransform + [DafnyCallEvent(input, output)];
    }

    predicate TransactGetItemsInputTransformEnsuresPublicly(input: TransactGetItemsInputTransformInput, output: Result<TransactGetItemsInputTransformOutput, Error>)
      decreases input, output
    {
      Operations.TransactGetItemsInputTransformEnsuresPublicly(input, output)
    }

    method TransactGetItemsInputTransform(input: TransactGetItemsInputTransformInput) returns (output: Result<TransactGetItemsInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`TransactGetItemsInputTransform
      ensures true && ValidState()
      ensures TransactGetItemsInputTransformEnsuresPublicly(input, output)
      ensures History.TransactGetItemsInputTransform == old(History.TransactGetItemsInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.TransactGetItemsInputTransform(config, input);
      History.TransactGetItemsInputTransform := History.TransactGetItemsInputTransform + [DafnyCallEvent(input, output)];
    }

    predicate TransactGetItemsOutputTransformEnsuresPublicly(input: TransactGetItemsOutputTransformInput, output: Result<TransactGetItemsOutputTransformOutput, Error>)
      decreases input, output
    {
      Operations.TransactGetItemsOutputTransformEnsuresPublicly(input, output)
    }

    method TransactGetItemsOutputTransform(input: TransactGetItemsOutputTransformInput) returns (output: Result<TransactGetItemsOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`TransactGetItemsOutputTransform
      ensures true && ValidState()
      ensures TransactGetItemsOutputTransformEnsuresPublicly(input, output)
      ensures History.TransactGetItemsOutputTransform == old(History.TransactGetItemsOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.TransactGetItemsOutputTransform(config, input);
      History.TransactGetItemsOutputTransform := History.TransactGetItemsOutputTransform + [DafnyCallEvent(input, output)];
    }

    predicate ExecuteStatementInputTransformEnsuresPublicly(input: ExecuteStatementInputTransformInput, output: Result<ExecuteStatementInputTransformOutput, Error>)
      decreases input, output
    {
      Operations.ExecuteStatementInputTransformEnsuresPublicly(input, output)
    }

    method ExecuteStatementInputTransform(input: ExecuteStatementInputTransformInput) returns (output: Result<ExecuteStatementInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ExecuteStatementInputTransform
      ensures true && ValidState()
      ensures ExecuteStatementInputTransformEnsuresPublicly(input, output)
      ensures History.ExecuteStatementInputTransform == old(History.ExecuteStatementInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.ExecuteStatementInputTransform(config, input);
      History.ExecuteStatementInputTransform := History.ExecuteStatementInputTransform + [DafnyCallEvent(input, output)];
    }

    predicate ExecuteStatementOutputTransformEnsuresPublicly(input: ExecuteStatementOutputTransformInput, output: Result<ExecuteStatementOutputTransformOutput, Error>)
      decreases input, output
    {
      Operations.ExecuteStatementOutputTransformEnsuresPublicly(input, output)
    }

    method ExecuteStatementOutputTransform(input: ExecuteStatementOutputTransformInput) returns (output: Result<ExecuteStatementOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ExecuteStatementOutputTransform
      ensures true && ValidState()
      ensures ExecuteStatementOutputTransformEnsuresPublicly(input, output)
      ensures History.ExecuteStatementOutputTransform == old(History.ExecuteStatementOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.ExecuteStatementOutputTransform(config, input);
      History.ExecuteStatementOutputTransform := History.ExecuteStatementOutputTransform + [DafnyCallEvent(input, output)];
    }

    predicate BatchExecuteStatementInputTransformEnsuresPublicly(input: BatchExecuteStatementInputTransformInput, output: Result<BatchExecuteStatementInputTransformOutput, Error>)
      decreases input, output
    {
      Operations.BatchExecuteStatementInputTransformEnsuresPublicly(input, output)
    }

    method BatchExecuteStatementInputTransform(input: BatchExecuteStatementInputTransformInput) returns (output: Result<BatchExecuteStatementInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`BatchExecuteStatementInputTransform
      ensures true && ValidState()
      ensures BatchExecuteStatementInputTransformEnsuresPublicly(input, output)
      ensures History.BatchExecuteStatementInputTransform == old(History.BatchExecuteStatementInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.BatchExecuteStatementInputTransform(config, input);
      History.BatchExecuteStatementInputTransform := History.BatchExecuteStatementInputTransform + [DafnyCallEvent(input, output)];
    }

    predicate BatchExecuteStatementOutputTransformEnsuresPublicly(input: BatchExecuteStatementOutputTransformInput, output: Result<BatchExecuteStatementOutputTransformOutput, Error>)
      decreases input, output
    {
      Operations.BatchExecuteStatementOutputTransformEnsuresPublicly(input, output)
    }

    method BatchExecuteStatementOutputTransform(input: BatchExecuteStatementOutputTransformInput) returns (output: Result<BatchExecuteStatementOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`BatchExecuteStatementOutputTransform
      ensures true && ValidState()
      ensures BatchExecuteStatementOutputTransformEnsuresPublicly(input, output)
      ensures History.BatchExecuteStatementOutputTransform == old(History.BatchExecuteStatementOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.BatchExecuteStatementOutputTransform(config, input);
      History.BatchExecuteStatementOutputTransform := History.BatchExecuteStatementOutputTransform + [DafnyCallEvent(input, output)];
    }

    predicate ExecuteTransactionInputTransformEnsuresPublicly(input: ExecuteTransactionInputTransformInput, output: Result<ExecuteTransactionInputTransformOutput, Error>)
      decreases input, output
    {
      Operations.ExecuteTransactionInputTransformEnsuresPublicly(input, output)
    }

    method ExecuteTransactionInputTransform(input: ExecuteTransactionInputTransformInput) returns (output: Result<ExecuteTransactionInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ExecuteTransactionInputTransform
      ensures true && ValidState()
      ensures ExecuteTransactionInputTransformEnsuresPublicly(input, output)
      ensures History.ExecuteTransactionInputTransform == old(History.ExecuteTransactionInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.ExecuteTransactionInputTransform(config, input);
      History.ExecuteTransactionInputTransform := History.ExecuteTransactionInputTransform + [DafnyCallEvent(input, output)];
    }

    predicate ExecuteTransactionOutputTransformEnsuresPublicly(input: ExecuteTransactionOutputTransformInput, output: Result<ExecuteTransactionOutputTransformOutput, Error>)
      decreases input, output
    {
      Operations.ExecuteTransactionOutputTransformEnsuresPublicly(input, output)
    }

    method ExecuteTransactionOutputTransform(input: ExecuteTransactionOutputTransformInput) returns (output: Result<ExecuteTransactionOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ExecuteTransactionOutputTransform
      ensures true && ValidState()
      ensures ExecuteTransactionOutputTransformEnsuresPublicly(input, output)
      ensures History.ExecuteTransactionOutputTransform == old(History.ExecuteTransactionOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.ExecuteTransactionOutputTransform(config, input);
      History.ExecuteTransactionOutputTransform := History.ExecuteTransactionOutputTransform + [DafnyCallEvent(input, output)];
    }

    predicate ResolveAttributesEnsuresPublicly(input: ResolveAttributesInput, output: Result<ResolveAttributesOutput, Error>)
      decreases input, output
    {
      Operations.ResolveAttributesEnsuresPublicly(input, output)
    }

    method ResolveAttributes(input: ResolveAttributesInput) returns (output: Result<ResolveAttributesOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ResolveAttributes
      ensures true && ValidState()
      ensures ResolveAttributesEnsuresPublicly(input, output)
      ensures History.ResolveAttributes == old(History.ResolveAttributes) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.ResolveAttributes(config, input);
      History.ResolveAttributes := History.ResolveAttributes + [DafnyCallEvent(input, output)];
    }
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes
}

module AwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations refines AbstractAwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations {
  predicate ValidInternalConfig?(config: InternalConfig)
    decreases config
  {
    ValidConfig?(config)
  }

  function ModifiesInternalConfig(config: InternalConfig): set<object>
    decreases config
  {
    ModifiesConfig(config)
  }

  predicate PutItemInputTransformEnsuresPublicly(input: PutItemInputTransformInput, output: Result<PutItemInputTransformOutput, Error>)
    decreases input, output
  {
    true
  }

  method PutItemInputTransform(config: InternalConfig, input: PutItemInputTransformInput) returns (output: Result<PutItemInputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures PutItemInputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := PutItemTransform.Input(config, input);
  }

  predicate PutItemOutputTransformEnsuresPublicly(input: PutItemOutputTransformInput, output: Result<PutItemOutputTransformOutput, Error>)
    decreases input, output
  {
    true
  }

  method PutItemOutputTransform(config: InternalConfig, input: PutItemOutputTransformInput) returns (output: Result<PutItemOutputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures PutItemOutputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := PutItemTransform.Output(config, input);
  }

  predicate GetItemInputTransformEnsuresPublicly(input: GetItemInputTransformInput, output: Result<GetItemInputTransformOutput, Error>)
    decreases input, output
  {
    true
  }

  method GetItemInputTransform(config: InternalConfig, input: GetItemInputTransformInput) returns (output: Result<GetItemInputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GetItemInputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := GetItemTransform.Input(config, input);
  }

  predicate GetItemOutputTransformEnsuresPublicly(input: GetItemOutputTransformInput, output: Result<GetItemOutputTransformOutput, Error>)
    decreases input, output
  {
    true
  }

  method GetItemOutputTransform(config: InternalConfig, input: GetItemOutputTransformInput) returns (output: Result<GetItemOutputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GetItemOutputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := GetItemTransform.Output(config, input);
  }

  predicate UpdateItemInputTransformEnsuresPublicly(input: UpdateItemInputTransformInput, output: Result<UpdateItemInputTransformOutput, Error>)
    decreases input, output
  {
    true
  }

  method UpdateItemInputTransform(config: InternalConfig, input: UpdateItemInputTransformInput) returns (output: Result<UpdateItemInputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures UpdateItemInputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := UpdateItemTransform.Input(config, input);
  }

  predicate UpdateItemOutputTransformEnsuresPublicly(input: UpdateItemOutputTransformInput, output: Result<UpdateItemOutputTransformOutput, Error>)
    decreases input, output
  {
    true
  }

  method UpdateItemOutputTransform(config: InternalConfig, input: UpdateItemOutputTransformInput) returns (output: Result<UpdateItemOutputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures UpdateItemOutputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := UpdateItemTransform.Output(config, input);
  }

  predicate BatchWriteItemInputTransformEnsuresPublicly(input: BatchWriteItemInputTransformInput, output: Result<BatchWriteItemInputTransformOutput, Error>)
    decreases input, output
  {
    true
  }

  method BatchWriteItemInputTransform(config: InternalConfig, input: BatchWriteItemInputTransformInput) returns (output: Result<BatchWriteItemInputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures BatchWriteItemInputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := BatchWriteItemTransform.Input(config, input);
  }

  predicate BatchWriteItemOutputTransformEnsuresPublicly(input: BatchWriteItemOutputTransformInput, output: Result<BatchWriteItemOutputTransformOutput, Error>)
    decreases input, output
  {
    true
  }

  method BatchWriteItemOutputTransform(config: InternalConfig, input: BatchWriteItemOutputTransformInput) returns (output: Result<BatchWriteItemOutputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures BatchWriteItemOutputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := BatchWriteItemTransform.Output(config, input);
  }

  predicate TransactWriteItemsInputTransformEnsuresPublicly(input: TransactWriteItemsInputTransformInput, output: Result<TransactWriteItemsInputTransformOutput, Error>)
    decreases input, output
  {
    true
  }

  method TransactWriteItemsInputTransform(config: InternalConfig, input: TransactWriteItemsInputTransformInput) returns (output: Result<TransactWriteItemsInputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures TransactWriteItemsInputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := TransactWriteItemsTransform.Input(config, input);
  }

  predicate TransactWriteItemsOutputTransformEnsuresPublicly(input: TransactWriteItemsOutputTransformInput, output: Result<TransactWriteItemsOutputTransformOutput, Error>)
    decreases input, output
  {
    true
  }

  method TransactWriteItemsOutputTransform(config: InternalConfig, input: TransactWriteItemsOutputTransformInput) returns (output: Result<TransactWriteItemsOutputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures TransactWriteItemsOutputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := TransactWriteItemsTransform.Output(config, input);
  }

  predicate BatchGetItemInputTransformEnsuresPublicly(input: BatchGetItemInputTransformInput, output: Result<BatchGetItemInputTransformOutput, Error>)
    decreases input, output
  {
    true
  }

  method BatchGetItemInputTransform(config: InternalConfig, input: BatchGetItemInputTransformInput) returns (output: Result<BatchGetItemInputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures BatchGetItemInputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := BatchGetItemTransform.Input(config, input);
  }

  predicate BatchGetItemOutputTransformEnsuresPublicly(input: BatchGetItemOutputTransformInput, output: Result<BatchGetItemOutputTransformOutput, Error>)
    decreases input, output
  {
    true
  }

  method BatchGetItemOutputTransform(config: InternalConfig, input: BatchGetItemOutputTransformInput) returns (output: Result<BatchGetItemOutputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures BatchGetItemOutputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := BatchGetItemTransform.Output(config, input);
  }

  predicate ScanInputTransformEnsuresPublicly(input: ScanInputTransformInput, output: Result<ScanInputTransformOutput, Error>)
    decreases input, output
  {
    true
  }

  method ScanInputTransform(config: InternalConfig, input: ScanInputTransformInput) returns (output: Result<ScanInputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ScanInputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := ScanTransform.Input(config, input);
  }

  predicate ScanOutputTransformEnsuresPublicly(input: ScanOutputTransformInput, output: Result<ScanOutputTransformOutput, Error>)
    decreases input, output
  {
    true
  }

  method ScanOutputTransform(config: InternalConfig, input: ScanOutputTransformInput) returns (output: Result<ScanOutputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ScanOutputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := ScanTransform.Output(config, input);
  }

  predicate QueryInputTransformEnsuresPublicly(input: QueryInputTransformInput, output: Result<QueryInputTransformOutput, Error>)
    decreases input, output
  {
    true
  }

  method QueryInputTransform(config: InternalConfig, input: QueryInputTransformInput) returns (output: Result<QueryInputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures QueryInputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := QueryTransform.Input(config, input);
  }

  predicate QueryOutputTransformEnsuresPublicly(input: QueryOutputTransformInput, output: Result<QueryOutputTransformOutput, Error>)
    decreases input, output
  {
    true
  }

  method QueryOutputTransform(config: InternalConfig, input: QueryOutputTransformInput) returns (output: Result<QueryOutputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures QueryOutputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := QueryTransform.Output(config, input);
  }

  predicate TransactGetItemsInputTransformEnsuresPublicly(input: TransactGetItemsInputTransformInput, output: Result<TransactGetItemsInputTransformOutput, Error>)
    decreases input, output
  {
    true
  }

  method TransactGetItemsInputTransform(config: InternalConfig, input: TransactGetItemsInputTransformInput) returns (output: Result<TransactGetItemsInputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures TransactGetItemsInputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := TransactGetItemsTransform.Input(config, input);
  }

  predicate TransactGetItemsOutputTransformEnsuresPublicly(input: TransactGetItemsOutputTransformInput, output: Result<TransactGetItemsOutputTransformOutput, Error>)
    decreases input, output
  {
    true
  }

  method TransactGetItemsOutputTransform(config: InternalConfig, input: TransactGetItemsOutputTransformInput) returns (output: Result<TransactGetItemsOutputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures TransactGetItemsOutputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := TransactGetItemsTransform.Output(config, input);
  }

  predicate DeleteItemInputTransformEnsuresPublicly(input: DeleteItemInputTransformInput, output: Result<DeleteItemInputTransformOutput, Error>)
    decreases input, output
  {
    true
  }

  method DeleteItemInputTransform(config: InternalConfig, input: DeleteItemInputTransformInput) returns (output: Result<DeleteItemInputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DeleteItemInputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := DeleteItemTransform.Input(config, input);
  }

  predicate DeleteItemOutputTransformEnsuresPublicly(input: DeleteItemOutputTransformInput, output: Result<DeleteItemOutputTransformOutput, Error>)
    decreases input, output
  {
    true
  }

  method DeleteItemOutputTransform(config: InternalConfig, input: DeleteItemOutputTransformInput) returns (output: Result<DeleteItemOutputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DeleteItemOutputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := DeleteItemTransform.Output(config, input);
  }

  predicate ExecuteStatementInputTransformEnsuresPublicly(input: ExecuteStatementInputTransformInput, output: Result<ExecuteStatementInputTransformOutput, Error>)
    decreases input, output
  {
    true
  }

  method ExecuteStatementInputTransform(config: InternalConfig, input: ExecuteStatementInputTransformInput) returns (output: Result<ExecuteStatementInputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ExecuteStatementInputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := ExecuteStatementTransform.Input(config, input);
  }

  predicate ExecuteStatementOutputTransformEnsuresPublicly(input: ExecuteStatementOutputTransformInput, output: Result<ExecuteStatementOutputTransformOutput, Error>)
    decreases input, output
  {
    true
  }

  method ExecuteStatementOutputTransform(config: InternalConfig, input: ExecuteStatementOutputTransformInput) returns (output: Result<ExecuteStatementOutputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ExecuteStatementOutputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := ExecuteStatementTransform.Output(config, input);
  }

  predicate BatchExecuteStatementInputTransformEnsuresPublicly(input: BatchExecuteStatementInputTransformInput, output: Result<BatchExecuteStatementInputTransformOutput, Error>)
    decreases input, output
  {
    true
  }

  method BatchExecuteStatementInputTransform(config: InternalConfig, input: BatchExecuteStatementInputTransformInput) returns (output: Result<BatchExecuteStatementInputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures BatchExecuteStatementInputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := BatchExecuteStatementTransform.Input(config, input);
  }

  predicate BatchExecuteStatementOutputTransformEnsuresPublicly(input: BatchExecuteStatementOutputTransformInput, output: Result<BatchExecuteStatementOutputTransformOutput, Error>)
    decreases input, output
  {
    true
  }

  method BatchExecuteStatementOutputTransform(config: InternalConfig, input: BatchExecuteStatementOutputTransformInput) returns (output: Result<BatchExecuteStatementOutputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures BatchExecuteStatementOutputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := BatchExecuteStatementTransform.Output(config, input);
  }

  predicate ExecuteTransactionInputTransformEnsuresPublicly(input: ExecuteTransactionInputTransformInput, output: Result<ExecuteTransactionInputTransformOutput, Error>)
    decreases input, output
  {
    true
  }

  method ExecuteTransactionInputTransform(config: InternalConfig, input: ExecuteTransactionInputTransformInput) returns (output: Result<ExecuteTransactionInputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ExecuteTransactionInputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := ExecuteTransactionTransform.Input(config, input);
  }

  predicate ExecuteTransactionOutputTransformEnsuresPublicly(input: ExecuteTransactionOutputTransformInput, output: Result<ExecuteTransactionOutputTransformOutput, Error>)
    decreases input, output
  {
    true
  }

  method ExecuteTransactionOutputTransform(config: InternalConfig, input: ExecuteTransactionOutputTransformInput) returns (output: Result<ExecuteTransactionOutputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ExecuteTransactionOutputTransformEnsuresPublicly(input, output)
    ensures output.Success? && output.value.transformedOutput == input.sdkOutput
    decreases ModifiesInternalConfig(config)
  {
    output := ExecuteTransactionTransform.Output(config, input);
  }

  predicate ResolveAttributesEnsuresPublicly(input: ResolveAttributesInput, output: Result<ResolveAttributesOutput, Error>)
    decreases input, output
  {
    true
  }

  method ResolveAttributes(config: InternalConfig, input: ResolveAttributesInput) returns (output: Result<ResolveAttributesOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ResolveAttributesEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := AttributeResolver.Resolve(config, input);
  }

  import opened DdbMiddlewareConfig

  import DDB = ComAmazonawsDynamodbTypes

  import AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes

  import DynamoDbItemEncryptor

  import DynamoToStruct

  import ENC = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations

  import EncTypes = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes

  import AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes

  import Seq

  import DdbStatement

  import PutItemTransform

  import GetItemTransform

  import UpdateItemTransform

  import BatchWriteItemTransform

  import TransactWriteItemsTransform

  import BatchGetItemTransform

  import ScanTransform

  import QueryTransform

  import TransactGetItemsTransform

  import DeleteItemTransform

  import ExecuteStatementTransform

  import BatchExecuteStatementTransform

  import ExecuteTransactionTransform

  import AttributeResolver

  type InternalConfig = Config

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes
}

module AttributeResolver {
  method Resolve(config: Config, input: ResolveAttributesInput) returns (output: Result<ResolveAttributesOutput, Error>)
    requires ValidConfig?(config)
    modifies ModifiesConfig(config)
    ensures ValidConfig?(config)
    decreases config, input
  {
    if input.TableName !in config.tableEncryptionConfigs || config.tableEncryptionConfigs[input.TableName].search.None? {
      return Success(ResolveAttributesOutput(VirtualFields := map[], CompoundBeacons := map[]));
    } else {
      var tableConfig := config.tableEncryptionConfigs[input.TableName];
      var vf :- GetVirtualFields(tableConfig.search.value, input.Item, input.Version);
      var cb :- GetCompoundBeacons(tableConfig.search.value, input.Item, input.Version);
      return Success(ResolveAttributesOutput(VirtualFields := vf, CompoundBeacons := cb));
    }
  }

  import opened DdbMiddlewareConfig

  import opened DynamoDbMiddlewareSupport

  import opened Wrappers

  import DDB = ComAmazonawsDynamodbTypes

  import opened AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes

  import EncTypes = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes

  import Seq

  import DynamoDBSupport
}

module DynamoDbMiddlewareSupport {
  predicate method NoMap<X, Y>(m: Option<map<X, Y>>)
    decreases m
  {
    m.None? || |m.value| == 0
  }

  predicate method NoList<X>(m: Option<seq<X>>)
    decreases m
  {
    m.None? || |m.value| == 0
  }

  function method {:opaque} IsWriteable(config: ValidTableConfig, item: DDB.AttributeMap): Result<bool, Error>
    decreases config, item
  {
    BS.IsWriteable(item).MapFailure((e: string) => E(e))
  }

  predicate method {:opaque} IsSigned(config: ValidTableConfig, attr: string)
    decreases config, attr
  {
    BS.IsSigned(config.itemEncryptor.config.attributeActionsOnEncrypt, attr)
  }

  function method {:opaque} TestConditionExpression(config: ValidTableConfig, expr: Option<DDB.ConditionExpression>, attrNames: Option<DDB.ExpressionAttributeNameMap>, attrValues: Option<DDB.ExpressionAttributeValueMap>): Result<bool, Error>
    decreases config, expr, attrNames, attrValues
  {
    BS.TestConditionExpression(config.itemEncryptor.config.attributeActionsOnEncrypt, expr, attrNames, attrValues).MapFailure((e: string) => E(e))
  }

  function method {:opaque} TestUpdateExpression(config: ValidTableConfig, expr: Option<DDB.UpdateExpression>, attrNames: Option<DDB.ExpressionAttributeNameMap>, attrValues: Option<DDB.ExpressionAttributeValueMap>): Result<bool, Error>
    decreases config, expr, attrNames, attrValues
  {
    BS.TestUpdateExpression(config.itemEncryptor.config.attributeActionsOnEncrypt, expr, attrNames, attrValues).MapFailure((e: string) => E(e))
  }

  method AddSignedBeacons(config: ValidTableConfig, item: DDB.AttributeMap) returns (output: Result<DDB.AttributeMap, Error>)
    requires AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations.ValidInternalConfig?(config.itemEncryptor.config)
    requires OneSearchValidState(config)
    modifies OneSearchModifies(config)
    ensures OneSearchValidState(config)
    decreases config, item
  {
    var ret := BS.AddSignedBeacons(config.search, item);
    return ret.MapFailure((e: Error) => AwsCryptographyDbEncryptionSdkDynamoDb(e));
  }

  method GetEncryptedBeacons(config: ValidTableConfig, item: DDB.AttributeMap, keyId: Util.MaybeKeyId)
      returns (output: Result<DDB.AttributeMap, Error>)
    requires AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations.ValidInternalConfig?(config.itemEncryptor.config)
    requires OneSearchValidState(config)
    modifies OneSearchModifies(config)
    ensures OneSearchValidState(config)
    decreases config, item, keyId
  {
    var ret := BS.GetEncryptedBeacons(config.search, item, keyId);
    return ret.MapFailure((e: Error) => AwsCryptographyDbEncryptionSdkDynamoDb(e));
  }

  function method GetBeaconKeyId(config: ValidTableConfig, keyExpr: Option<DDB.ConditionExpression>, filterExpr: Option<DDB.ConditionExpression>, values: Option<DDB.ExpressionAttributeValueMap>, names: Option<DDB.ExpressionAttributeNameMap>): Result<Util.MaybeKeyId, Error>
    decreases config, keyExpr, filterExpr, values, names
  {
    BS.GetBeaconKeyId(config.search, keyExpr, filterExpr, values, names).MapFailure((e: Error) => AwsCryptographyDbEncryptionSdkDynamoDb(e))
  }

  const HierarchicalKeyringId := UTF8.EncodeAscii(""aws-kms-hierarchy"")

  function method GetKeyIdFromHeader(config: ValidTableConfig, output: AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes.EncryptItemOutput): (ret: Result<Option<string>, Error>)
    ensures ret.Success? && config.search.Some? && config.search.value.curr().keySource.keyLoc.MultiLoc? ==> output.parsedHeader.Some? && var keys: AwsCryptographyMaterialProvidersTypes.EncryptedDataKeyList := output.parsedHeader.value.encryptedDataKeys; |keys| == 1 && keys[0].keyProviderId == HierarchicalKeyringId && UTF8.Decode(keys[0].keyProviderInfo).Success? && ret.value == Some(UTF8.Decode(keys[0].keyProviderInfo).value)
    decreases config, output
  {
    if config.search.Some? && config.search.value.curr().keySource.keyLoc.MultiLoc? then
      :- Need(output.parsedHeader.Some?, E(""In multi-tenant mode, the parsed header is required."")); var keys: AwsCryptographyMaterialProvidersTypes.EncryptedDataKeyList := output.parsedHeader.value.encryptedDataKeys; :- Need(|keys| == 1, E(""Encrypt header has more than one Encrypted Data Key"")); :- Need(keys[0].keyProviderId == HierarchicalKeyringId, E(""In multi-tenant mode, keyProviderId must be aws-kms-hierarchy"")); var keyId: string :- UTF8.Decode(keys[0].keyProviderInfo).MapFailure((e: string) => E(e)); Success(Some(keyId))
    else
      Success(None)
  }

  function method {:opaque} RemoveBeacons(config: ValidTableConfig, item: DDB.AttributeMap): Result<DDB.AttributeMap, Error>
    decreases config, item
  {
    BS.RemoveBeacons(config.search, item).MapFailure((e: string) => E(e))
  }

  method {:opaque} QueryInputForBeacons(config: ValidTableConfig, req: DDB.QueryInput) returns (output: Result<DDB.QueryInput, Error>)
    requires OneSearchValidState(config)
    modifies OneSearchModifies(config)
    ensures OneSearchValidState(config)
    decreases config, req
  {
    var ret := BS.QueryInputForBeacons(config.search, config.itemEncryptor.config.attributeActionsOnEncrypt, req);
    return ret.MapFailure((e: Error) => AwsCryptographyDbEncryptionSdkDynamoDb(e));
  }

  method QueryOutputForBeacons(config: ValidTableConfig, req: DDB.QueryInput, resp: DDB.QueryOutput)
      returns (output: Result<DDB.QueryOutput, Error>)
    requires resp.Items.Some?
    requires OneSearchValidState(config)
    modifies OneSearchModifies(config)
    ensures output.Success? ==> output.value.Items.Some?
    ensures OneSearchValidState(config)
    decreases config, req, resp
  {
    var ret := BS.QueryOutputForBeacons(config.search, req, resp);
    return ret.MapFailure((e: Error) => AwsCryptographyDbEncryptionSdkDynamoDb(e));
  }

  method ScanInputForBeacons(config: ValidTableConfig, req: DDB.ScanInput) returns (output: Result<DDB.ScanInput, Error>)
    requires OneSearchValidState(config)
    modifies OneSearchModifies(config)
    ensures OneSearchValidState(config)
    decreases config, req
  {
    var ret := BS.ScanInputForBeacons(config.search, config.itemEncryptor.config.attributeActionsOnEncrypt, req);
    return ret.MapFailure((e: Error) => AwsCryptographyDbEncryptionSdkDynamoDb(e));
  }

  method ScanOutputForBeacons(config: ValidTableConfig, req: DDB.ScanInput, resp: DDB.ScanOutput)
      returns (output: Result<DDB.ScanOutput, Error>)
    requires resp.Items.Some?
    requires OneSearchValidState(config)
    modifies OneSearchModifies(config)
    ensures output.Success? ==> output.value.Items.Some?
    ensures OneSearchValidState(config)
    decreases config, req, resp
  {
    var ret := BS.ScanOutputForBeacons(config.search, req, resp);
    return ret.MapFailure((e: Error) => AwsCryptographyDbEncryptionSdkDynamoDb(e));
  }

  method GetVirtualFields(search: SearchableEncryptionInfo.ValidSearchInfo, item: DDB.AttributeMap, version: Option<ET.VersionNumber>)
      returns (output: Result<map<string, string>, Error>)
    decreases search, item, version
  {
    if version.Some? && version.value != 1 {
      return Failure(E(""Beacon Version Number must be '1'""));
    }
    var ret := BS.GetVirtualFields(search.curr(), item);
    return ret.MapFailure((e: Error) => AwsCryptographyDbEncryptionSdkDynamoDb(e));
  }

  method GetCompoundBeacons(search: SearchableEncryptionInfo.ValidSearchInfo, item: DDB.AttributeMap, version: Option<ET.VersionNumber>)
      returns (output: Result<map<string, string>, Error>)
    decreases search, item, version
  {
    if version.Some? && version.value != 1 {
      return Failure(E(""Beacon Version Number must be '1'""));
    }
    var ret := BS.GetCompoundBeacons(search.curr(), item);
    return ret.MapFailure((e: Error) => AwsCryptographyDbEncryptionSdkDynamoDb(e));
  }

  import DDB = ComAmazonawsDynamodbTypes

  import opened AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes

  import opened Wrappers

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import opened BS = DynamoDBSupport

  import opened DdbMiddlewareConfig

  import AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations

  import ET = AwsCryptographyDbEncryptionSdkDynamoDbTypes

  import Util = DynamoDbEncryptionUtil

  import SI = SearchableEncryptionInfo
}

module DdbMiddlewareConfig {
  predicate method IsPlainWrite(config: Config, tableName: string)
    decreases config, tableName
  {
    tableName !in config.tableEncryptionConfigs || config.tableEncryptionConfigs[tableName].plaintextOverride == AwsCryptographyDbEncryptionSdkDynamoDbTypes.PlaintextOverride.FORCE_PLAINTEXT_WRITE_ALLOW_PLAINTEXT_READ
  }

  predicate ValidTableConfig?(config: TableConfig)
    decreases config
  {
    ghost var encryptorConfig: Operations.InternalConfig := config.itemEncryptor.config;
    config.logicalTableName == encryptorConfig.logicalTableName &&
    config.partitionKeyName == encryptorConfig.partitionKeyName &&
    config.sortKeyName == encryptorConfig.sortKeyName &&
    config.itemEncryptor.ValidState() &&
    OneSearchValidState(config)
  }

  function OneSearchModifies(config: ValidTableConfig): set<object>
    decreases config
  {
    if config.search.Some? then
      config.search.value.Modifies()
    else
      {}
  }

  function SearchModifies(config: Config): set<object>
    decreases config
  {
    set versions: seq<BeaconVersion>, keyStore: ValidStore, obj: object | versions in (set configValue: ValidTableConfig {:trigger configValue.search} {:trigger configValue in config.tableEncryptionConfigs.Values} | configValue in config.tableEncryptionConfigs.Values && configValue.search.Some? :: configValue.search.value.versions) && keyStore in (set version: BeaconVersion {:trigger version.keySource} {:trigger version in versions} | version in versions :: version.keySource.store) && obj in keyStore.Modifies && obj in keyStore.Modifies :: obj
  }

  predicate OneSearchValidState(config: TableConfig)
    decreases config
  {
    true &&
    (config.search.Some? ==>
      config.search.value.ValidState())
  }

  predicate SearchValidState(config: Config)
    decreases config
  {
    forall k: seq<char> {:trigger config.tableEncryptionConfigs[k]} {:trigger k in config.tableEncryptionConfigs} | k in config.tableEncryptionConfigs :: 
      OneSearchValidState(config.tableEncryptionConfigs[k])
  }

  function ModifiesConfig(config: Config): set<object>
    decreases config
  {
    (set t: seq<char>, o: object {:trigger o in config.tableEncryptionConfigs[t].itemEncryptor.Modifies} | t in config.tableEncryptionConfigs.Keys && o in config.tableEncryptionConfigs[t].itemEncryptor.Modifies :: o) + set t: seq<char>, o: object {:trigger o in OneSearchModifies(config.tableEncryptionConfigs[t])} | t in config.tableEncryptionConfigs.Keys && o in OneSearchModifies(config.tableEncryptionConfigs[t]) :: o
  }

  predicate ValidConfig?(config: Config)
    decreases config
  {
    (forall tableName: seq<char> {:trigger config.tableEncryptionConfigs[tableName]} {:trigger tableName in config.tableEncryptionConfigs} | tableName in config.tableEncryptionConfigs :: 
      config.tableEncryptionConfigs[tableName].physicalTableName == tableName) &&
    forall c1: ValidTableConfig, c2: ValidTableConfig {:trigger c2.logicalTableName, c1.logicalTableName} {:trigger c2.logicalTableName, c1 in config.tableEncryptionConfigs.Values} {:trigger c1.logicalTableName, c2 in config.tableEncryptionConfigs.Values} {:trigger c2 in config.tableEncryptionConfigs.Values, c1 in config.tableEncryptionConfigs.Values} | c1 in config.tableEncryptionConfigs.Values && c2 in config.tableEncryptionConfigs.Values && c1 != c2 :: 
      c1.logicalTableName != c2.logicalTableName
  }

  function method AttrToString(attr: DDB.AttributeValue): string
    decreases attr
  {
    if attr.S? then
      attr.S
    else if attr.N? then
      attr.N
    else if attr.B? then
      HexStrings.ToHexString(attr.B)
    else
      ""unexpected key type""
  }

  function method KeyString(config: ValidTableConfig, item: DDB.AttributeMap): string
    decreases config, item
  {
    var partition: seq<char> := if config.partitionKeyName in item then config.partitionKeyName + "" = "" + AttrToString(item[config.partitionKeyName]) else """";
    var sort: seq<char> := if config.sortKeyName.Some? && config.sortKeyName.value in item then ""; "" + config.sortKeyName.value + "" = "" + AttrToString(item[config.sortKeyName.value]) else """";
    partition + sort
  }

  function method MapError<T>(r: Result<T, EncTypes.Error>): Result<T, Error>
    decreases r
  {
    r.MapFailure((e: EncTypes.Error) => AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptor(e))
  }

  function method MapString<T>(r: Result<T, string>): Result<T, Error>
    decreases r
  {
    r.MapFailure((e: string) => Error.DynamoDbEncryptionTransformsException(message := e))
  }

  function method E(s: string): Error
    decreases s
  {
    DynamoDbEncryptionTransformsException(message := s)
  }

  function method MakeError<X>(s: string): Result<X, Error>
    decreases s
  {
    Failure(Error.DynamoDbEncryptionTransformsException(message := s))
  }

  predicate SameOption<X>(x: Option<X>, y: Option<X>)
    decreases x, y
  {
    (x.Some? && y.Some?) || (x.None? && y.None?)
  }

  import opened Wrappers

  import opened AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes

  import DynamoDbItemEncryptor

  import EncTypes = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes

  import DDBE = AwsCryptographyDbEncryptionSdkDynamoDbTypes

  import SearchableEncryptionInfo

  import DDB = ComAmazonawsDynamodbTypes

  import HexStrings

  datatype TableConfig = TableConfig(physicalTableName: ComAmazonawsDynamodbTypes.TableName, logicalTableName: string, partitionKeyName: string, sortKeyName: Option<string>, itemEncryptor: DynamoDbItemEncryptor.DynamoDbItemEncryptorClient, search: Option<SearchableEncryptionInfo.ValidSearchInfo>, plaintextOverride: AwsCryptographyDbEncryptionSdkDynamoDbTypes.PlaintextOverride)

  type ValidTableConfig = c: TableConfig
    | ValidTableConfig?(c)
    witness *

  datatype Config = Config(tableEncryptionConfigs: map<string, ValidTableConfig>)
}

module {:extern ""software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types""} AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes {
  predicate method IsDummySubsetType(x: int)
    decreases x
  {
    0 < x
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import AwsCryptographyDbEncryptionSdkDynamoDbTypes

  import AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes

  import AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes

  import AwsCryptographyMaterialProvidersTypes

  import ComAmazonawsDynamodbTypes

  datatype DafnyCallEvent<I, O> = DafnyCallEvent(input: I, output: O)

  datatype BatchExecuteStatementInputTransformInput = BatchExecuteStatementInputTransformInput(nameonly sdkInput: ComAmazonawsDynamodbTypes.BatchExecuteStatementInput)

  datatype BatchExecuteStatementInputTransformOutput = BatchExecuteStatementInputTransformOutput(nameonly transformedInput: ComAmazonawsDynamodbTypes.BatchExecuteStatementInput)

  datatype BatchExecuteStatementOutputTransformInput = BatchExecuteStatementOutputTransformInput(nameonly sdkOutput: ComAmazonawsDynamodbTypes.BatchExecuteStatementOutput, nameonly originalInput: ComAmazonawsDynamodbTypes.BatchExecuteStatementInput)

  datatype BatchExecuteStatementOutputTransformOutput = BatchExecuteStatementOutputTransformOutput(nameonly transformedOutput: ComAmazonawsDynamodbTypes.BatchExecuteStatementOutput)

  datatype BatchGetItemInputTransformInput = BatchGetItemInputTransformInput(nameonly sdkInput: ComAmazonawsDynamodbTypes.BatchGetItemInput)

  datatype BatchGetItemInputTransformOutput = BatchGetItemInputTransformOutput(nameonly transformedInput: ComAmazonawsDynamodbTypes.BatchGetItemInput)

  datatype BatchGetItemOutputTransformInput = BatchGetItemOutputTransformInput(nameonly sdkOutput: ComAmazonawsDynamodbTypes.BatchGetItemOutput, nameonly originalInput: ComAmazonawsDynamodbTypes.BatchGetItemInput)

  datatype BatchGetItemOutputTransformOutput = BatchGetItemOutputTransformOutput(nameonly transformedOutput: ComAmazonawsDynamodbTypes.BatchGetItemOutput)

  datatype BatchWriteItemInputTransformInput = BatchWriteItemInputTransformInput(nameonly sdkInput: ComAmazonawsDynamodbTypes.BatchWriteItemInput)

  datatype BatchWriteItemInputTransformOutput = BatchWriteItemInputTransformOutput(nameonly transformedInput: ComAmazonawsDynamodbTypes.BatchWriteItemInput)

  datatype BatchWriteItemOutputTransformInput = BatchWriteItemOutputTransformInput(nameonly sdkOutput: ComAmazonawsDynamodbTypes.BatchWriteItemOutput, nameonly originalInput: ComAmazonawsDynamodbTypes.BatchWriteItemInput)

  datatype BatchWriteItemOutputTransformOutput = BatchWriteItemOutputTransformOutput(nameonly transformedOutput: ComAmazonawsDynamodbTypes.BatchWriteItemOutput)

  datatype DeleteItemInputTransformInput = DeleteItemInputTransformInput(nameonly sdkInput: ComAmazonawsDynamodbTypes.DeleteItemInput)

  datatype DeleteItemInputTransformOutput = DeleteItemInputTransformOutput(nameonly transformedInput: ComAmazonawsDynamodbTypes.DeleteItemInput)

  datatype DeleteItemOutputTransformInput = DeleteItemOutputTransformInput(nameonly sdkOutput: ComAmazonawsDynamodbTypes.DeleteItemOutput, nameonly originalInput: ComAmazonawsDynamodbTypes.DeleteItemInput)

  datatype DeleteItemOutputTransformOutput = DeleteItemOutputTransformOutput(nameonly transformedOutput: ComAmazonawsDynamodbTypes.DeleteItemOutput)

  class IDynamoDbEncryptionTransformsClientCallHistory {
    ghost constructor ()
    {
      PutItemInputTransform := [];
      PutItemOutputTransform := [];
      GetItemInputTransform := [];
      GetItemOutputTransform := [];
      BatchWriteItemInputTransform := [];
      BatchWriteItemOutputTransform := [];
      BatchGetItemInputTransform := [];
      BatchGetItemOutputTransform := [];
      ScanInputTransform := [];
      ScanOutputTransform := [];
      QueryInputTransform := [];
      QueryOutputTransform := [];
      TransactWriteItemsInputTransform := [];
      TransactWriteItemsOutputTransform := [];
      UpdateItemInputTransform := [];
      UpdateItemOutputTransform := [];
      DeleteItemInputTransform := [];
      DeleteItemOutputTransform := [];
      TransactGetItemsInputTransform := [];
      TransactGetItemsOutputTransform := [];
      ExecuteStatementInputTransform := [];
      ExecuteStatementOutputTransform := [];
      BatchExecuteStatementInputTransform := [];
      BatchExecuteStatementOutputTransform := [];
      ExecuteTransactionInputTransform := [];
      ExecuteTransactionOutputTransform := [];
      ResolveAttributes := [];
    }

    ghost var PutItemInputTransform: seq<DafnyCallEvent<PutItemInputTransformInput, Result<PutItemInputTransformOutput, Error>>>
    ghost var PutItemOutputTransform: seq<DafnyCallEvent<PutItemOutputTransformInput, Result<PutItemOutputTransformOutput, Error>>>
    ghost var GetItemInputTransform: seq<DafnyCallEvent<GetItemInputTransformInput, Result<GetItemInputTransformOutput, Error>>>
    ghost var GetItemOutputTransform: seq<DafnyCallEvent<GetItemOutputTransformInput, Result<GetItemOutputTransformOutput, Error>>>
    ghost var BatchWriteItemInputTransform: seq<DafnyCallEvent<BatchWriteItemInputTransformInput, Result<BatchWriteItemInputTransformOutput, Error>>>
    ghost var BatchWriteItemOutputTransform: seq<DafnyCallEvent<BatchWriteItemOutputTransformInput, Result<BatchWriteItemOutputTransformOutput, Error>>>
    ghost var BatchGetItemInputTransform: seq<DafnyCallEvent<BatchGetItemInputTransformInput, Result<BatchGetItemInputTransformOutput, Error>>>
    ghost var BatchGetItemOutputTransform: seq<DafnyCallEvent<BatchGetItemOutputTransformInput, Result<BatchGetItemOutputTransformOutput, Error>>>
    ghost var ScanInputTransform: seq<DafnyCallEvent<ScanInputTransformInput, Result<ScanInputTransformOutput, Error>>>
    ghost var ScanOutputTransform: seq<DafnyCallEvent<ScanOutputTransformInput, Result<ScanOutputTransformOutput, Error>>>
    ghost var QueryInputTransform: seq<DafnyCallEvent<QueryInputTransformInput, Result<QueryInputTransformOutput, Error>>>
    ghost var QueryOutputTransform: seq<DafnyCallEvent<QueryOutputTransformInput, Result<QueryOutputTransformOutput, Error>>>
    ghost var TransactWriteItemsInputTransform: seq<DafnyCallEvent<TransactWriteItemsInputTransformInput, Result<TransactWriteItemsInputTransformOutput, Error>>>
    ghost var TransactWriteItemsOutputTransform: seq<DafnyCallEvent<TransactWriteItemsOutputTransformInput, Result<TransactWriteItemsOutputTransformOutput, Error>>>
    ghost var UpdateItemInputTransform: seq<DafnyCallEvent<UpdateItemInputTransformInput, Result<UpdateItemInputTransformOutput, Error>>>
    ghost var UpdateItemOutputTransform: seq<DafnyCallEvent<UpdateItemOutputTransformInput, Result<UpdateItemOutputTransformOutput, Error>>>
    ghost var DeleteItemInputTransform: seq<DafnyCallEvent<DeleteItemInputTransformInput, Result<DeleteItemInputTransformOutput, Error>>>
    ghost var DeleteItemOutputTransform: seq<DafnyCallEvent<DeleteItemOutputTransformInput, Result<DeleteItemOutputTransformOutput, Error>>>
    ghost var TransactGetItemsInputTransform: seq<DafnyCallEvent<TransactGetItemsInputTransformInput, Result<TransactGetItemsInputTransformOutput, Error>>>
    ghost var TransactGetItemsOutputTransform: seq<DafnyCallEvent<TransactGetItemsOutputTransformInput, Result<TransactGetItemsOutputTransformOutput, Error>>>
    ghost var ExecuteStatementInputTransform: seq<DafnyCallEvent<ExecuteStatementInputTransformInput, Result<ExecuteStatementInputTransformOutput, Error>>>
    ghost var ExecuteStatementOutputTransform: seq<DafnyCallEvent<ExecuteStatementOutputTransformInput, Result<ExecuteStatementOutputTransformOutput, Error>>>
    ghost var BatchExecuteStatementInputTransform: seq<DafnyCallEvent<BatchExecuteStatementInputTransformInput, Result<BatchExecuteStatementInputTransformOutput, Error>>>
    ghost var BatchExecuteStatementOutputTransform: seq<DafnyCallEvent<BatchExecuteStatementOutputTransformInput, Result<BatchExecuteStatementOutputTransformOutput, Error>>>
    ghost var ExecuteTransactionInputTransform: seq<DafnyCallEvent<ExecuteTransactionInputTransformInput, Result<ExecuteTransactionInputTransformOutput, Error>>>
    ghost var ExecuteTransactionOutputTransform: seq<DafnyCallEvent<ExecuteTransactionOutputTransformInput, Result<ExecuteTransactionOutputTransformOutput, Error>>>
    ghost var ResolveAttributes: seq<DafnyCallEvent<ResolveAttributesInput, Result<ResolveAttributesOutput, Error>>>
  }

  trait {:termination false} IDynamoDbEncryptionTransformsClient {
    ghost const Modifies: set<object>

    predicate ValidState()
      ensures ValidState() ==> History in Modifies

    ghost const History: IDynamoDbEncryptionTransformsClientCallHistory

    predicate PutItemInputTransformEnsuresPublicly(input: PutItemInputTransformInput, output: Result<PutItemInputTransformOutput, Error>)
      decreases input, output

    method PutItemInputTransform(input: PutItemInputTransformInput) returns (output: Result<PutItemInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`PutItemInputTransform
      ensures true && ValidState()
      ensures PutItemInputTransformEnsuresPublicly(input, output)
      ensures History.PutItemInputTransform == old(History.PutItemInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate PutItemOutputTransformEnsuresPublicly(input: PutItemOutputTransformInput, output: Result<PutItemOutputTransformOutput, Error>)
      decreases input, output

    method PutItemOutputTransform(input: PutItemOutputTransformInput) returns (output: Result<PutItemOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`PutItemOutputTransform
      ensures true && ValidState()
      ensures PutItemOutputTransformEnsuresPublicly(input, output)
      ensures History.PutItemOutputTransform == old(History.PutItemOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate GetItemInputTransformEnsuresPublicly(input: GetItemInputTransformInput, output: Result<GetItemInputTransformOutput, Error>)
      decreases input, output

    method GetItemInputTransform(input: GetItemInputTransformInput) returns (output: Result<GetItemInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetItemInputTransform
      ensures true && ValidState()
      ensures GetItemInputTransformEnsuresPublicly(input, output)
      ensures History.GetItemInputTransform == old(History.GetItemInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate GetItemOutputTransformEnsuresPublicly(input: GetItemOutputTransformInput, output: Result<GetItemOutputTransformOutput, Error>)
      decreases input, output

    method GetItemOutputTransform(input: GetItemOutputTransformInput) returns (output: Result<GetItemOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetItemOutputTransform
      ensures true && ValidState()
      ensures GetItemOutputTransformEnsuresPublicly(input, output)
      ensures History.GetItemOutputTransform == old(History.GetItemOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate BatchWriteItemInputTransformEnsuresPublicly(input: BatchWriteItemInputTransformInput, output: Result<BatchWriteItemInputTransformOutput, Error>)
      decreases input, output

    method BatchWriteItemInputTransform(input: BatchWriteItemInputTransformInput) returns (output: Result<BatchWriteItemInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`BatchWriteItemInputTransform
      ensures true && ValidState()
      ensures BatchWriteItemInputTransformEnsuresPublicly(input, output)
      ensures History.BatchWriteItemInputTransform == old(History.BatchWriteItemInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate BatchWriteItemOutputTransformEnsuresPublicly(input: BatchWriteItemOutputTransformInput, output: Result<BatchWriteItemOutputTransformOutput, Error>)
      decreases input, output

    method BatchWriteItemOutputTransform(input: BatchWriteItemOutputTransformInput) returns (output: Result<BatchWriteItemOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`BatchWriteItemOutputTransform
      ensures true && ValidState()
      ensures BatchWriteItemOutputTransformEnsuresPublicly(input, output)
      ensures History.BatchWriteItemOutputTransform == old(History.BatchWriteItemOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate BatchGetItemInputTransformEnsuresPublicly(input: BatchGetItemInputTransformInput, output: Result<BatchGetItemInputTransformOutput, Error>)
      decreases input, output

    method BatchGetItemInputTransform(input: BatchGetItemInputTransformInput) returns (output: Result<BatchGetItemInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`BatchGetItemInputTransform
      ensures true && ValidState()
      ensures BatchGetItemInputTransformEnsuresPublicly(input, output)
      ensures History.BatchGetItemInputTransform == old(History.BatchGetItemInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate BatchGetItemOutputTransformEnsuresPublicly(input: BatchGetItemOutputTransformInput, output: Result<BatchGetItemOutputTransformOutput, Error>)
      decreases input, output

    method BatchGetItemOutputTransform(input: BatchGetItemOutputTransformInput) returns (output: Result<BatchGetItemOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`BatchGetItemOutputTransform
      ensures true && ValidState()
      ensures BatchGetItemOutputTransformEnsuresPublicly(input, output)
      ensures History.BatchGetItemOutputTransform == old(History.BatchGetItemOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ScanInputTransformEnsuresPublicly(input: ScanInputTransformInput, output: Result<ScanInputTransformOutput, Error>)
      decreases input, output

    method ScanInputTransform(input: ScanInputTransformInput) returns (output: Result<ScanInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ScanInputTransform
      ensures true && ValidState()
      ensures ScanInputTransformEnsuresPublicly(input, output)
      ensures History.ScanInputTransform == old(History.ScanInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ScanOutputTransformEnsuresPublicly(input: ScanOutputTransformInput, output: Result<ScanOutputTransformOutput, Error>)
      decreases input, output

    method ScanOutputTransform(input: ScanOutputTransformInput) returns (output: Result<ScanOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ScanOutputTransform
      ensures true && ValidState()
      ensures ScanOutputTransformEnsuresPublicly(input, output)
      ensures History.ScanOutputTransform == old(History.ScanOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate QueryInputTransformEnsuresPublicly(input: QueryInputTransformInput, output: Result<QueryInputTransformOutput, Error>)
      decreases input, output

    method QueryInputTransform(input: QueryInputTransformInput) returns (output: Result<QueryInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`QueryInputTransform
      ensures true && ValidState()
      ensures QueryInputTransformEnsuresPublicly(input, output)
      ensures History.QueryInputTransform == old(History.QueryInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate QueryOutputTransformEnsuresPublicly(input: QueryOutputTransformInput, output: Result<QueryOutputTransformOutput, Error>)
      decreases input, output

    method QueryOutputTransform(input: QueryOutputTransformInput) returns (output: Result<QueryOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`QueryOutputTransform
      ensures true && ValidState()
      ensures QueryOutputTransformEnsuresPublicly(input, output)
      ensures History.QueryOutputTransform == old(History.QueryOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate TransactWriteItemsInputTransformEnsuresPublicly(input: TransactWriteItemsInputTransformInput, output: Result<TransactWriteItemsInputTransformOutput, Error>)
      decreases input, output

    method TransactWriteItemsInputTransform(input: TransactWriteItemsInputTransformInput) returns (output: Result<TransactWriteItemsInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`TransactWriteItemsInputTransform
      ensures true && ValidState()
      ensures TransactWriteItemsInputTransformEnsuresPublicly(input, output)
      ensures History.TransactWriteItemsInputTransform == old(History.TransactWriteItemsInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate TransactWriteItemsOutputTransformEnsuresPublicly(input: TransactWriteItemsOutputTransformInput, output: Result<TransactWriteItemsOutputTransformOutput, Error>)
      decreases input, output

    method TransactWriteItemsOutputTransform(input: TransactWriteItemsOutputTransformInput) returns (output: Result<TransactWriteItemsOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`TransactWriteItemsOutputTransform
      ensures true && ValidState()
      ensures TransactWriteItemsOutputTransformEnsuresPublicly(input, output)
      ensures History.TransactWriteItemsOutputTransform == old(History.TransactWriteItemsOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate UpdateItemInputTransformEnsuresPublicly(input: UpdateItemInputTransformInput, output: Result<UpdateItemInputTransformOutput, Error>)
      decreases input, output

    method UpdateItemInputTransform(input: UpdateItemInputTransformInput) returns (output: Result<UpdateItemInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`UpdateItemInputTransform
      ensures true && ValidState()
      ensures UpdateItemInputTransformEnsuresPublicly(input, output)
      ensures History.UpdateItemInputTransform == old(History.UpdateItemInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate UpdateItemOutputTransformEnsuresPublicly(input: UpdateItemOutputTransformInput, output: Result<UpdateItemOutputTransformOutput, Error>)
      decreases input, output

    method UpdateItemOutputTransform(input: UpdateItemOutputTransformInput) returns (output: Result<UpdateItemOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`UpdateItemOutputTransform
      ensures true && ValidState()
      ensures UpdateItemOutputTransformEnsuresPublicly(input, output)
      ensures History.UpdateItemOutputTransform == old(History.UpdateItemOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DeleteItemInputTransformEnsuresPublicly(input: DeleteItemInputTransformInput, output: Result<DeleteItemInputTransformOutput, Error>)
      decreases input, output

    method DeleteItemInputTransform(input: DeleteItemInputTransformInput) returns (output: Result<DeleteItemInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DeleteItemInputTransform
      ensures true && ValidState()
      ensures DeleteItemInputTransformEnsuresPublicly(input, output)
      ensures History.DeleteItemInputTransform == old(History.DeleteItemInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DeleteItemOutputTransformEnsuresPublicly(input: DeleteItemOutputTransformInput, output: Result<DeleteItemOutputTransformOutput, Error>)
      decreases input, output

    method DeleteItemOutputTransform(input: DeleteItemOutputTransformInput) returns (output: Result<DeleteItemOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DeleteItemOutputTransform
      ensures true && ValidState()
      ensures DeleteItemOutputTransformEnsuresPublicly(input, output)
      ensures History.DeleteItemOutputTransform == old(History.DeleteItemOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate TransactGetItemsInputTransformEnsuresPublicly(input: TransactGetItemsInputTransformInput, output: Result<TransactGetItemsInputTransformOutput, Error>)
      decreases input, output

    method TransactGetItemsInputTransform(input: TransactGetItemsInputTransformInput) returns (output: Result<TransactGetItemsInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`TransactGetItemsInputTransform
      ensures true && ValidState()
      ensures TransactGetItemsInputTransformEnsuresPublicly(input, output)
      ensures History.TransactGetItemsInputTransform == old(History.TransactGetItemsInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate TransactGetItemsOutputTransformEnsuresPublicly(input: TransactGetItemsOutputTransformInput, output: Result<TransactGetItemsOutputTransformOutput, Error>)
      decreases input, output

    method TransactGetItemsOutputTransform(input: TransactGetItemsOutputTransformInput) returns (output: Result<TransactGetItemsOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`TransactGetItemsOutputTransform
      ensures true && ValidState()
      ensures TransactGetItemsOutputTransformEnsuresPublicly(input, output)
      ensures History.TransactGetItemsOutputTransform == old(History.TransactGetItemsOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ExecuteStatementInputTransformEnsuresPublicly(input: ExecuteStatementInputTransformInput, output: Result<ExecuteStatementInputTransformOutput, Error>)
      decreases input, output

    method ExecuteStatementInputTransform(input: ExecuteStatementInputTransformInput) returns (output: Result<ExecuteStatementInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ExecuteStatementInputTransform
      ensures true && ValidState()
      ensures ExecuteStatementInputTransformEnsuresPublicly(input, output)
      ensures History.ExecuteStatementInputTransform == old(History.ExecuteStatementInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ExecuteStatementOutputTransformEnsuresPublicly(input: ExecuteStatementOutputTransformInput, output: Result<ExecuteStatementOutputTransformOutput, Error>)
      decreases input, output

    method ExecuteStatementOutputTransform(input: ExecuteStatementOutputTransformInput) returns (output: Result<ExecuteStatementOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ExecuteStatementOutputTransform
      ensures true && ValidState()
      ensures ExecuteStatementOutputTransformEnsuresPublicly(input, output)
      ensures History.ExecuteStatementOutputTransform == old(History.ExecuteStatementOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate BatchExecuteStatementInputTransformEnsuresPublicly(input: BatchExecuteStatementInputTransformInput, output: Result<BatchExecuteStatementInputTransformOutput, Error>)
      decreases input, output

    method BatchExecuteStatementInputTransform(input: BatchExecuteStatementInputTransformInput) returns (output: Result<BatchExecuteStatementInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`BatchExecuteStatementInputTransform
      ensures true && ValidState()
      ensures BatchExecuteStatementInputTransformEnsuresPublicly(input, output)
      ensures History.BatchExecuteStatementInputTransform == old(History.BatchExecuteStatementInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate BatchExecuteStatementOutputTransformEnsuresPublicly(input: BatchExecuteStatementOutputTransformInput, output: Result<BatchExecuteStatementOutputTransformOutput, Error>)
      decreases input, output

    method BatchExecuteStatementOutputTransform(input: BatchExecuteStatementOutputTransformInput) returns (output: Result<BatchExecuteStatementOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`BatchExecuteStatementOutputTransform
      ensures true && ValidState()
      ensures BatchExecuteStatementOutputTransformEnsuresPublicly(input, output)
      ensures History.BatchExecuteStatementOutputTransform == old(History.BatchExecuteStatementOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ExecuteTransactionInputTransformEnsuresPublicly(input: ExecuteTransactionInputTransformInput, output: Result<ExecuteTransactionInputTransformOutput, Error>)
      decreases input, output

    method ExecuteTransactionInputTransform(input: ExecuteTransactionInputTransformInput) returns (output: Result<ExecuteTransactionInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ExecuteTransactionInputTransform
      ensures true && ValidState()
      ensures ExecuteTransactionInputTransformEnsuresPublicly(input, output)
      ensures History.ExecuteTransactionInputTransform == old(History.ExecuteTransactionInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ExecuteTransactionOutputTransformEnsuresPublicly(input: ExecuteTransactionOutputTransformInput, output: Result<ExecuteTransactionOutputTransformOutput, Error>)
      decreases input, output

    method ExecuteTransactionOutputTransform(input: ExecuteTransactionOutputTransformInput) returns (output: Result<ExecuteTransactionOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ExecuteTransactionOutputTransform
      ensures true && ValidState()
      ensures ExecuteTransactionOutputTransformEnsuresPublicly(input, output)
      ensures History.ExecuteTransactionOutputTransform == old(History.ExecuteTransactionOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ResolveAttributesEnsuresPublicly(input: ResolveAttributesInput, output: Result<ResolveAttributesOutput, Error>)
      decreases input, output

    method ResolveAttributes(input: ResolveAttributesInput) returns (output: Result<ResolveAttributesOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ResolveAttributes
      ensures true && ValidState()
      ensures ResolveAttributesEnsuresPublicly(input, output)
      ensures History.ResolveAttributes == old(History.ResolveAttributes) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
  }

  datatype ExecuteStatementInputTransformInput = ExecuteStatementInputTransformInput(nameonly sdkInput: ComAmazonawsDynamodbTypes.ExecuteStatementInput)

  datatype ExecuteStatementInputTransformOutput = ExecuteStatementInputTransformOutput(nameonly transformedInput: ComAmazonawsDynamodbTypes.ExecuteStatementInput)

  datatype ExecuteStatementOutputTransformInput = ExecuteStatementOutputTransformInput(nameonly sdkOutput: ComAmazonawsDynamodbTypes.ExecuteStatementOutput, nameonly originalInput: ComAmazonawsDynamodbTypes.ExecuteStatementInput)

  datatype ExecuteStatementOutputTransformOutput = ExecuteStatementOutputTransformOutput(nameonly transformedOutput: ComAmazonawsDynamodbTypes.ExecuteStatementOutput)

  datatype ExecuteTransactionInputTransformInput = ExecuteTransactionInputTransformInput(nameonly sdkInput: ComAmazonawsDynamodbTypes.ExecuteTransactionInput)

  datatype ExecuteTransactionInputTransformOutput = ExecuteTransactionInputTransformOutput(nameonly transformedInput: ComAmazonawsDynamodbTypes.ExecuteTransactionInput)

  datatype ExecuteTransactionOutputTransformInput = ExecuteTransactionOutputTransformInput(nameonly sdkOutput: ComAmazonawsDynamodbTypes.ExecuteTransactionOutput, nameonly originalInput: ComAmazonawsDynamodbTypes.ExecuteTransactionInput)

  datatype ExecuteTransactionOutputTransformOutput = ExecuteTransactionOutputTransformOutput(nameonly transformedOutput: ComAmazonawsDynamodbTypes.ExecuteTransactionOutput)

  datatype GetItemInputTransformInput = GetItemInputTransformInput(nameonly sdkInput: ComAmazonawsDynamodbTypes.GetItemInput)

  datatype GetItemInputTransformOutput = GetItemInputTransformOutput(nameonly transformedInput: ComAmazonawsDynamodbTypes.GetItemInput)

  datatype GetItemOutputTransformInput = GetItemOutputTransformInput(nameonly sdkOutput: ComAmazonawsDynamodbTypes.GetItemOutput, nameonly originalInput: ComAmazonawsDynamodbTypes.GetItemInput)

  datatype GetItemOutputTransformOutput = GetItemOutputTransformOutput(nameonly transformedOutput: ComAmazonawsDynamodbTypes.GetItemOutput)

  datatype PutItemInputTransformInput = PutItemInputTransformInput(nameonly sdkInput: ComAmazonawsDynamodbTypes.PutItemInput)

  datatype PutItemInputTransformOutput = PutItemInputTransformOutput(nameonly transformedInput: ComAmazonawsDynamodbTypes.PutItemInput)

  datatype PutItemOutputTransformInput = PutItemOutputTransformInput(nameonly sdkOutput: ComAmazonawsDynamodbTypes.PutItemOutput, nameonly originalInput: ComAmazonawsDynamodbTypes.PutItemInput)

  datatype PutItemOutputTransformOutput = PutItemOutputTransformOutput(nameonly transformedOutput: ComAmazonawsDynamodbTypes.PutItemOutput)

  datatype QueryInputTransformInput = QueryInputTransformInput(nameonly sdkInput: ComAmazonawsDynamodbTypes.QueryInput)

  datatype QueryInputTransformOutput = QueryInputTransformOutput(nameonly transformedInput: ComAmazonawsDynamodbTypes.QueryInput)

  datatype QueryOutputTransformInput = QueryOutputTransformInput(nameonly sdkOutput: ComAmazonawsDynamodbTypes.QueryOutput, nameonly originalInput: ComAmazonawsDynamodbTypes.QueryInput)

  datatype QueryOutputTransformOutput = QueryOutputTransformOutput(nameonly transformedOutput: ComAmazonawsDynamodbTypes.QueryOutput)

  datatype ResolveAttributesInput = ResolveAttributesInput(nameonly TableName: ComAmazonawsDynamodbTypes.TableName, nameonly Item: ComAmazonawsDynamodbTypes.AttributeMap, nameonly Version: Option<AwsCryptographyDbEncryptionSdkDynamoDbTypes.VersionNumber> := Option.None)

  datatype ResolveAttributesOutput = ResolveAttributesOutput(nameonly VirtualFields: StringMap, nameonly CompoundBeacons: StringMap)

  datatype ScanInputTransformInput = ScanInputTransformInput(nameonly sdkInput: ComAmazonawsDynamodbTypes.ScanInput)

  datatype ScanInputTransformOutput = ScanInputTransformOutput(nameonly transformedInput: ComAmazonawsDynamodbTypes.ScanInput)

  datatype ScanOutputTransformInput = ScanOutputTransformInput(nameonly sdkOutput: ComAmazonawsDynamodbTypes.ScanOutput, nameonly originalInput: ComAmazonawsDynamodbTypes.ScanInput)

  datatype ScanOutputTransformOutput = ScanOutputTransformOutput(nameonly transformedOutput: ComAmazonawsDynamodbTypes.ScanOutput)

  type StringMap = map<string, string>

  datatype TransactGetItemsInputTransformInput = TransactGetItemsInputTransformInput(nameonly sdkInput: ComAmazonawsDynamodbTypes.TransactGetItemsInput)

  datatype TransactGetItemsInputTransformOutput = TransactGetItemsInputTransformOutput(nameonly transformedInput: ComAmazonawsDynamodbTypes.TransactGetItemsInput)

  datatype TransactGetItemsOutputTransformInput = TransactGetItemsOutputTransformInput(nameonly sdkOutput: ComAmazonawsDynamodbTypes.TransactGetItemsOutput, nameonly originalInput: ComAmazonawsDynamodbTypes.TransactGetItemsInput)

  datatype TransactGetItemsOutputTransformOutput = TransactGetItemsOutputTransformOutput(nameonly transformedOutput: ComAmazonawsDynamodbTypes.TransactGetItemsOutput)

  datatype TransactWriteItemsInputTransformInput = TransactWriteItemsInputTransformInput(nameonly sdkInput: ComAmazonawsDynamodbTypes.TransactWriteItemsInput)

  datatype TransactWriteItemsInputTransformOutput = TransactWriteItemsInputTransformOutput(nameonly transformedInput: ComAmazonawsDynamodbTypes.TransactWriteItemsInput)

  datatype TransactWriteItemsOutputTransformInput = TransactWriteItemsOutputTransformInput(nameonly sdkOutput: ComAmazonawsDynamodbTypes.TransactWriteItemsOutput, nameonly originalInput: ComAmazonawsDynamodbTypes.TransactWriteItemsInput)

  datatype TransactWriteItemsOutputTransformOutput = TransactWriteItemsOutputTransformOutput(nameonly transformedOutput: ComAmazonawsDynamodbTypes.TransactWriteItemsOutput)

  datatype UpdateItemInputTransformInput = UpdateItemInputTransformInput(nameonly sdkInput: ComAmazonawsDynamodbTypes.UpdateItemInput)

  datatype UpdateItemInputTransformOutput = UpdateItemInputTransformOutput(nameonly transformedInput: ComAmazonawsDynamodbTypes.UpdateItemInput)

  datatype UpdateItemOutputTransformInput = UpdateItemOutputTransformInput(nameonly sdkOutput: ComAmazonawsDynamodbTypes.UpdateItemOutput, nameonly originalInput: ComAmazonawsDynamodbTypes.UpdateItemInput)

  datatype UpdateItemOutputTransformOutput = UpdateItemOutputTransformOutput(nameonly transformedOutput: ComAmazonawsDynamodbTypes.UpdateItemOutput)

  datatype Error = DynamoDbEncryptionTransformsException(nameonly message: string) | AwsCryptographyDbEncryptionSdkDynamoDb(AwsCryptographyDbEncryptionSdkDynamoDb: AwsCryptographyDbEncryptionSdkDynamoDbTypes.Error) | AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptor(AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptor: AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes.Error) | AwsCryptographyDbEncryptionSdkStructuredEncryption(AwsCryptographyDbEncryptionSdkStructuredEncryption: AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.Error) | AwsCryptographyMaterialProviders(AwsCryptographyMaterialProviders: AwsCryptographyMaterialProvidersTypes.Error) | ComAmazonawsDynamodb(ComAmazonawsDynamodb: ComAmazonawsDynamodbTypes.Error) | CollectionOfErrors(list: seq<Error>, nameonly message: string) | Opaque(obj: object) | OpaqueWithText(obj: object, objMessage: string)

  type OpaqueError = e: Error
    | e.Opaque? || e.OpaqueWithText?
    witness *

  type DummySubsetType = x: int
    | IsDummySubsetType(x)
    witness 1
}

abstract module AbstractAwsCryptographyDbEncryptionSdkDynamoDbTransformsService {
  function method DefaultDynamoDbTablesEncryptionConfig(): AwsCryptographyDbEncryptionSdkDynamoDbTypes.DynamoDbTablesEncryptionConfig

  method DynamoDbEncryptionTransforms(config: AwsCryptographyDbEncryptionSdkDynamoDbTypes.DynamoDbTablesEncryptionConfig := DefaultDynamoDbTablesEncryptionConfig()) returns (res: Result<DynamoDbEncryptionTransformsClient, Error>)
    requires var tmps0: set<DynamoDbTableEncryptionConfig> := set t0: DynamoDbTableEncryptionConfig {:trigger t0 in config.tableEncryptionConfigs.Values} | t0 in config.tableEncryptionConfigs.Values; forall tmp0: DynamoDbTableEncryptionConfig {:trigger tmp0.keyring} {:trigger tmp0 in tmps0} :: tmp0 in tmps0 ==> tmp0.keyring.Some? ==> tmp0.keyring.value.ValidState()
    requires var tmps1: set<DynamoDbTableEncryptionConfig> := set t1: DynamoDbTableEncryptionConfig {:trigger t1 in config.tableEncryptionConfigs.Values} | t1 in config.tableEncryptionConfigs.Values; forall tmp1: DynamoDbTableEncryptionConfig {:trigger tmp1.cmm} {:trigger tmp1 in tmps1} :: tmp1 in tmps1 ==> tmp1.cmm.Some? ==> tmp1.cmm.value.ValidState()
    requires var tmps2: set<DynamoDbTableEncryptionConfig> := set t2: DynamoDbTableEncryptionConfig {:trigger t2 in config.tableEncryptionConfigs.Values} | t2 in config.tableEncryptionConfigs.Values; forall tmp2: DynamoDbTableEncryptionConfig {:trigger tmp2.legacyOverride} {:trigger tmp2 in tmps2} :: tmp2 in tmps2 ==> tmp2.legacyOverride.Some? ==> tmp2.legacyOverride.value.encryptor.ValidState()
    requires var tmps3: set<DynamoDbTableEncryptionConfig> := set t3: DynamoDbTableEncryptionConfig {:trigger t3 in config.tableEncryptionConfigs.Values} | t3 in config.tableEncryptionConfigs.Values; forall tmp3: DynamoDbTableEncryptionConfig {:trigger tmp3.search} {:trigger tmp3 in tmps3} :: tmp3 in tmps3 ==> tmp3.search.Some? ==> var tmps4: set<BeaconVersion> := set t4: BeaconVersion {:trigger t4 in tmp3.search.value.versions} | t4 in tmp3.search.value.versions; forall tmp4: BeaconVersion {:trigger tmp4.keyStore} {:trigger tmp4 in tmps4} :: tmp4 in tmps4 ==> tmp4.keyStore.ValidState()
    requires var tmps5: set<DynamoDbTableEncryptionConfig> := set t5: DynamoDbTableEncryptionConfig {:trigger t5 in config.tableEncryptionConfigs.Values} | t5 in config.tableEncryptionConfigs.Values; forall tmp5: DynamoDbTableEncryptionConfig {:trigger tmp5.search} {:trigger tmp5 in tmps5} :: tmp5 in tmps5 ==> tmp5.search.Some? ==> var tmps6: set<BeaconVersion> := set t6: BeaconVersion {:trigger t6 in tmp5.search.value.versions} | t6 in tmp5.search.value.versions; forall tmp6: BeaconVersion {:trigger tmp6.keySource} {:trigger tmp6 in tmps6} :: tmp6 in tmps6 ==> tmp6.keySource.multi? ==> tmp6.keySource.multi.cache.Some? ==> tmp6.keySource.multi.cache.value.Shared? ==> tmp6.keySource.multi.cache.value.Shared.ValidState()
    modifies set tmps7: AwsCryptographyMaterialProvidersTypes.IKeyring, obj: object {:trigger obj in tmps7.Modifies} | tmps7 in (set t7: DynamoDbTableEncryptionConfig {:trigger t7.keyring} {:trigger t7 in config.tableEncryptionConfigs.Values} | t7 in config.tableEncryptionConfigs.Values && true && t7.keyring.Some? :: t7.keyring.value) && obj in tmps7.Modifies && obj in tmps7.Modifies :: obj, set tmps8: AwsCryptographyMaterialProvidersTypes.ICryptographicMaterialsManager, obj: object {:trigger obj in tmps8.Modifies} | tmps8 in (set t8: DynamoDbTableEncryptionConfig {:trigger t8.cmm} {:trigger t8 in config.tableEncryptionConfigs.Values} | t8 in config.tableEncryptionConfigs.Values && true && t8.cmm.Some? :: t8.cmm.value) && obj in tmps8.Modifies && obj in tmps8.Modifies :: obj, set tmps9: ILegacyDynamoDbEncryptor, obj: object {:trigger obj in tmps9.Modifies} | tmps9 in (set t9: DynamoDbTableEncryptionConfig {:trigger t9.legacyOverride} {:trigger t9 in config.tableEncryptionConfigs.Values} | t9 in config.tableEncryptionConfigs.Values && true && t9.legacyOverride.Some? :: t9.legacyOverride.value.encryptor) && obj in tmps9.Modifies && obj in tmps9.Modifies :: obj, set tmps10: AwsCryptographyKeyStoreTypes.IKeyStoreClient, obj: object {:trigger obj in tmps10.Modifies} | tmps10 in (set t10: DynamoDbTableEncryptionConfig, t11: BeaconVersion {:trigger t11.keyStore, t10.search} {:trigger t11.keyStore, t10 in config.tableEncryptionConfigs.Values} | t10 in config.tableEncryptionConfigs.Values && true && t10.search.Some? && t11 in t10.search.value.versions && true :: t11.keyStore) && obj in tmps10.Modifies && obj in tmps10.Modifies :: obj, set tmps12: ICryptographicMaterialsCache, obj: object {:trigger obj in tmps12.Modifies} | tmps12 in (set t12: DynamoDbTableEncryptionConfig, t13: BeaconVersion {:trigger t13.keySource, t12.search} {:trigger t13.keySource, t12 in config.tableEncryptionConfigs.Values} | t12 in config.tableEncryptionConfigs.Values && true && t12.search.Some? && t13 in t12.search.value.versions && true && t13.keySource.multi? && t13.keySource.multi.cache.Some? && t13.keySource.multi.cache.value.Shared? :: t13.keySource.multi.cache.value.Shared) && obj in tmps12.Modifies && obj in tmps12.Modifies :: obj
    ensures res.Success? ==> fresh(res.value) && fresh(res.value.Modifies - (set tmps14: AwsCryptographyMaterialProvidersTypes.IKeyring, obj: object {:trigger obj in tmps14.Modifies} | tmps14 in (set t14: DynamoDbTableEncryptionConfig {:trigger t14.keyring} {:trigger t14 in config.tableEncryptionConfigs.Values} | t14 in config.tableEncryptionConfigs.Values && true && t14.keyring.Some? :: t14.keyring.value) && obj in tmps14.Modifies && obj in tmps14.Modifies :: obj) - (set tmps15: AwsCryptographyMaterialProvidersTypes.ICryptographicMaterialsManager, obj: object {:trigger obj in tmps15.Modifies} | tmps15 in (set t15: DynamoDbTableEncryptionConfig {:trigger t15.cmm} {:trigger t15 in config.tableEncryptionConfigs.Values} | t15 in config.tableEncryptionConfigs.Values && true && t15.cmm.Some? :: t15.cmm.value) && obj in tmps15.Modifies && obj in tmps15.Modifies :: obj) - (set tmps16: ILegacyDynamoDbEncryptor, obj: object {:trigger obj in tmps16.Modifies} | tmps16 in (set t16: DynamoDbTableEncryptionConfig {:trigger t16.legacyOverride} {:trigger t16 in config.tableEncryptionConfigs.Values} | t16 in config.tableEncryptionConfigs.Values && true && t16.legacyOverride.Some? :: t16.legacyOverride.value.encryptor) && obj in tmps16.Modifies && obj in tmps16.Modifies :: obj) - (set tmps17: AwsCryptographyKeyStoreTypes.IKeyStoreClient, obj: object {:trigger obj in tmps17.Modifies} | tmps17 in (set t17: DynamoDbTableEncryptionConfig, t18: BeaconVersion {:trigger t18.keyStore, t17.search} {:trigger t18.keyStore, t17 in config.tableEncryptionConfigs.Values} | t17 in config.tableEncryptionConfigs.Values && true && t17.search.Some? && t18 in t17.search.value.versions && true :: t18.keyStore) && obj in tmps17.Modifies && obj in tmps17.Modifies :: obj) - set tmps19: ICryptographicMaterialsCache, obj: object {:trigger obj in tmps19.Modifies} | tmps19 in (set t19: DynamoDbTableEncryptionConfig, t20: BeaconVersion {:trigger t20.keySource, t19.search} {:trigger t20.keySource, t19 in config.tableEncryptionConfigs.Values} | t19 in config.tableEncryptionConfigs.Values && true && t19.search.Some? && t20 in t19.search.value.versions && true && t20.keySource.multi? && t20.keySource.multi.cache.Some? && t20.keySource.multi.cache.value.Shared? :: t20.keySource.multi.cache.value.Shared) && obj in tmps19.Modifies && obj in tmps19.Modifies :: obj) && fresh(res.value.History) && res.value.ValidState()
    ensures var tmps21: set<DynamoDbTableEncryptionConfig> := set t21: DynamoDbTableEncryptionConfig {:trigger t21 in config.tableEncryptionConfigs.Values} | t21 in config.tableEncryptionConfigs.Values; forall tmp21: DynamoDbTableEncryptionConfig {:trigger tmp21.keyring} {:trigger tmp21 in tmps21} :: tmp21 in tmps21 ==> tmp21.keyring.Some? ==> tmp21.keyring.value.ValidState()
    ensures var tmps22: set<DynamoDbTableEncryptionConfig> := set t22: DynamoDbTableEncryptionConfig {:trigger t22 in config.tableEncryptionConfigs.Values} | t22 in config.tableEncryptionConfigs.Values; forall tmp22: DynamoDbTableEncryptionConfig {:trigger tmp22.cmm} {:trigger tmp22 in tmps22} :: tmp22 in tmps22 ==> tmp22.cmm.Some? ==> tmp22.cmm.value.ValidState()
    ensures var tmps23: set<DynamoDbTableEncryptionConfig> := set t23: DynamoDbTableEncryptionConfig {:trigger t23 in config.tableEncryptionConfigs.Values} | t23 in config.tableEncryptionConfigs.Values; forall tmp23: DynamoDbTableEncryptionConfig {:trigger tmp23.legacyOverride} {:trigger tmp23 in tmps23} :: tmp23 in tmps23 ==> tmp23.legacyOverride.Some? ==> tmp23.legacyOverride.value.encryptor.ValidState()
    ensures var tmps24: set<DynamoDbTableEncryptionConfig> := set t24: DynamoDbTableEncryptionConfig {:trigger t24 in config.tableEncryptionConfigs.Values} | t24 in config.tableEncryptionConfigs.Values; forall tmp24: DynamoDbTableEncryptionConfig {:trigger tmp24.search} {:trigger tmp24 in tmps24} :: tmp24 in tmps24 ==> tmp24.search.Some? ==> var tmps25: set<BeaconVersion> := set t25: BeaconVersion {:trigger t25 in tmp24.search.value.versions} | t25 in tmp24.search.value.versions; forall tmp25: BeaconVersion {:trigger tmp25.keyStore} {:trigger tmp25 in tmps25} :: tmp25 in tmps25 ==> tmp25.keyStore.ValidState()
    ensures var tmps26: set<DynamoDbTableEncryptionConfig> := set t26: DynamoDbTableEncryptionConfig {:trigger t26 in config.tableEncryptionConfigs.Values} | t26 in config.tableEncryptionConfigs.Values; forall tmp26: DynamoDbTableEncryptionConfig {:trigger tmp26.search} {:trigger tmp26 in tmps26} :: tmp26 in tmps26 ==> tmp26.search.Some? ==> var tmps27: set<BeaconVersion> := set t27: BeaconVersion {:trigger t27 in tmp26.search.value.versions} | t27 in tmp26.search.value.versions; forall tmp27: BeaconVersion {:trigger tmp27.keySource} {:trigger tmp27 in tmps27} :: tmp27 in tmps27 ==> tmp27.keySource.multi? ==> tmp27.keySource.multi.cache.Some? ==> tmp27.keySource.multi.cache.value.Shared? ==> tmp27.keySource.multi.cache.value.Shared.ValidState()
    decreases config

  function method CreateSuccessOfClient(client: IDynamoDbEncryptionTransformsClient): Result<IDynamoDbEncryptionTransformsClient, Error>
    decreases client
  {
    Success(client)
  }

  function method CreateFailureOfError(error: Error): Result<IDynamoDbEncryptionTransformsClient, Error>
    decreases error
  {
    Failure(error)
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes

  import Operations : AbstractAwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations

  class DynamoDbEncryptionTransformsClient extends IDynamoDbEncryptionTransformsClient {
    constructor (config: Operations.InternalConfig)
      requires Operations.ValidInternalConfig?(config)
      ensures ValidState() && fresh(History) && this.config == config

    const config: Operations.InternalConfig

    predicate ValidState()
      ensures ValidState() ==> Operations.ValidInternalConfig?(config) && History !in Operations.ModifiesInternalConfig(config) && Modifies == Operations.ModifiesInternalConfig(config) + {History}

    predicate PutItemInputTransformEnsuresPublicly(input: PutItemInputTransformInput, output: Result<PutItemInputTransformOutput, Error>)
      decreases input, output
    {
      Operations.PutItemInputTransformEnsuresPublicly(input, output)
    }

    method PutItemInputTransform(input: PutItemInputTransformInput) returns (output: Result<PutItemInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`PutItemInputTransform
      ensures true && ValidState()
      ensures PutItemInputTransformEnsuresPublicly(input, output)
      ensures History.PutItemInputTransform == old(History.PutItemInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.PutItemInputTransform(config, input);
      History.PutItemInputTransform := History.PutItemInputTransform + [DafnyCallEvent(input, output)];
    }

    predicate PutItemOutputTransformEnsuresPublicly(input: PutItemOutputTransformInput, output: Result<PutItemOutputTransformOutput, Error>)
      decreases input, output
    {
      Operations.PutItemOutputTransformEnsuresPublicly(input, output)
    }

    method PutItemOutputTransform(input: PutItemOutputTransformInput) returns (output: Result<PutItemOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`PutItemOutputTransform
      ensures true && ValidState()
      ensures PutItemOutputTransformEnsuresPublicly(input, output)
      ensures History.PutItemOutputTransform == old(History.PutItemOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.PutItemOutputTransform(config, input);
      History.PutItemOutputTransform := History.PutItemOutputTransform + [DafnyCallEvent(input, output)];
    }

    predicate GetItemInputTransformEnsuresPublicly(input: GetItemInputTransformInput, output: Result<GetItemInputTransformOutput, Error>)
      decreases input, output
    {
      Operations.GetItemInputTransformEnsuresPublicly(input, output)
    }

    method GetItemInputTransform(input: GetItemInputTransformInput) returns (output: Result<GetItemInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetItemInputTransform
      ensures true && ValidState()
      ensures GetItemInputTransformEnsuresPublicly(input, output)
      ensures History.GetItemInputTransform == old(History.GetItemInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.GetItemInputTransform(config, input);
      History.GetItemInputTransform := History.GetItemInputTransform + [DafnyCallEvent(input, output)];
    }

    predicate GetItemOutputTransformEnsuresPublicly(input: GetItemOutputTransformInput, output: Result<GetItemOutputTransformOutput, Error>)
      decreases input, output
    {
      Operations.GetItemOutputTransformEnsuresPublicly(input, output)
    }

    method GetItemOutputTransform(input: GetItemOutputTransformInput) returns (output: Result<GetItemOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetItemOutputTransform
      ensures true && ValidState()
      ensures GetItemOutputTransformEnsuresPublicly(input, output)
      ensures History.GetItemOutputTransform == old(History.GetItemOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.GetItemOutputTransform(config, input);
      History.GetItemOutputTransform := History.GetItemOutputTransform + [DafnyCallEvent(input, output)];
    }

    predicate BatchWriteItemInputTransformEnsuresPublicly(input: BatchWriteItemInputTransformInput, output: Result<BatchWriteItemInputTransformOutput, Error>)
      decreases input, output
    {
      Operations.BatchWriteItemInputTransformEnsuresPublicly(input, output)
    }

    method BatchWriteItemInputTransform(input: BatchWriteItemInputTransformInput) returns (output: Result<BatchWriteItemInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`BatchWriteItemInputTransform
      ensures true && ValidState()
      ensures BatchWriteItemInputTransformEnsuresPublicly(input, output)
      ensures History.BatchWriteItemInputTransform == old(History.BatchWriteItemInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.BatchWriteItemInputTransform(config, input);
      History.BatchWriteItemInputTransform := History.BatchWriteItemInputTransform + [DafnyCallEvent(input, output)];
    }

    predicate BatchWriteItemOutputTransformEnsuresPublicly(input: BatchWriteItemOutputTransformInput, output: Result<BatchWriteItemOutputTransformOutput, Error>)
      decreases input, output
    {
      Operations.BatchWriteItemOutputTransformEnsuresPublicly(input, output)
    }

    method BatchWriteItemOutputTransform(input: BatchWriteItemOutputTransformInput) returns (output: Result<BatchWriteItemOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`BatchWriteItemOutputTransform
      ensures true && ValidState()
      ensures BatchWriteItemOutputTransformEnsuresPublicly(input, output)
      ensures History.BatchWriteItemOutputTransform == old(History.BatchWriteItemOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.BatchWriteItemOutputTransform(config, input);
      History.BatchWriteItemOutputTransform := History.BatchWriteItemOutputTransform + [DafnyCallEvent(input, output)];
    }

    predicate BatchGetItemInputTransformEnsuresPublicly(input: BatchGetItemInputTransformInput, output: Result<BatchGetItemInputTransformOutput, Error>)
      decreases input, output
    {
      Operations.BatchGetItemInputTransformEnsuresPublicly(input, output)
    }

    method BatchGetItemInputTransform(input: BatchGetItemInputTransformInput) returns (output: Result<BatchGetItemInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`BatchGetItemInputTransform
      ensures true && ValidState()
      ensures BatchGetItemInputTransformEnsuresPublicly(input, output)
      ensures History.BatchGetItemInputTransform == old(History.BatchGetItemInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.BatchGetItemInputTransform(config, input);
      History.BatchGetItemInputTransform := History.BatchGetItemInputTransform + [DafnyCallEvent(input, output)];
    }

    predicate BatchGetItemOutputTransformEnsuresPublicly(input: BatchGetItemOutputTransformInput, output: Result<BatchGetItemOutputTransformOutput, Error>)
      decreases input, output
    {
      Operations.BatchGetItemOutputTransformEnsuresPublicly(input, output)
    }

    method BatchGetItemOutputTransform(input: BatchGetItemOutputTransformInput) returns (output: Result<BatchGetItemOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`BatchGetItemOutputTransform
      ensures true && ValidState()
      ensures BatchGetItemOutputTransformEnsuresPublicly(input, output)
      ensures History.BatchGetItemOutputTransform == old(History.BatchGetItemOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.BatchGetItemOutputTransform(config, input);
      History.BatchGetItemOutputTransform := History.BatchGetItemOutputTransform + [DafnyCallEvent(input, output)];
    }

    predicate ScanInputTransformEnsuresPublicly(input: ScanInputTransformInput, output: Result<ScanInputTransformOutput, Error>)
      decreases input, output
    {
      Operations.ScanInputTransformEnsuresPublicly(input, output)
    }

    method ScanInputTransform(input: ScanInputTransformInput) returns (output: Result<ScanInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ScanInputTransform
      ensures true && ValidState()
      ensures ScanInputTransformEnsuresPublicly(input, output)
      ensures History.ScanInputTransform == old(History.ScanInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.ScanInputTransform(config, input);
      History.ScanInputTransform := History.ScanInputTransform + [DafnyCallEvent(input, output)];
    }

    predicate ScanOutputTransformEnsuresPublicly(input: ScanOutputTransformInput, output: Result<ScanOutputTransformOutput, Error>)
      decreases input, output
    {
      Operations.ScanOutputTransformEnsuresPublicly(input, output)
    }

    method ScanOutputTransform(input: ScanOutputTransformInput) returns (output: Result<ScanOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ScanOutputTransform
      ensures true && ValidState()
      ensures ScanOutputTransformEnsuresPublicly(input, output)
      ensures History.ScanOutputTransform == old(History.ScanOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.ScanOutputTransform(config, input);
      History.ScanOutputTransform := History.ScanOutputTransform + [DafnyCallEvent(input, output)];
    }

    predicate QueryInputTransformEnsuresPublicly(input: QueryInputTransformInput, output: Result<QueryInputTransformOutput, Error>)
      decreases input, output
    {
      Operations.QueryInputTransformEnsuresPublicly(input, output)
    }

    method QueryInputTransform(input: QueryInputTransformInput) returns (output: Result<QueryInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`QueryInputTransform
      ensures true && ValidState()
      ensures QueryInputTransformEnsuresPublicly(input, output)
      ensures History.QueryInputTransform == old(History.QueryInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.QueryInputTransform(config, input);
      History.QueryInputTransform := History.QueryInputTransform + [DafnyCallEvent(input, output)];
    }

    predicate QueryOutputTransformEnsuresPublicly(input: QueryOutputTransformInput, output: Result<QueryOutputTransformOutput, Error>)
      decreases input, output
    {
      Operations.QueryOutputTransformEnsuresPublicly(input, output)
    }

    method QueryOutputTransform(input: QueryOutputTransformInput) returns (output: Result<QueryOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`QueryOutputTransform
      ensures true && ValidState()
      ensures QueryOutputTransformEnsuresPublicly(input, output)
      ensures History.QueryOutputTransform == old(History.QueryOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.QueryOutputTransform(config, input);
      History.QueryOutputTransform := History.QueryOutputTransform + [DafnyCallEvent(input, output)];
    }

    predicate TransactWriteItemsInputTransformEnsuresPublicly(input: TransactWriteItemsInputTransformInput, output: Result<TransactWriteItemsInputTransformOutput, Error>)
      decreases input, output
    {
      Operations.TransactWriteItemsInputTransformEnsuresPublicly(input, output)
    }

    method TransactWriteItemsInputTransform(input: TransactWriteItemsInputTransformInput) returns (output: Result<TransactWriteItemsInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`TransactWriteItemsInputTransform
      ensures true && ValidState()
      ensures TransactWriteItemsInputTransformEnsuresPublicly(input, output)
      ensures History.TransactWriteItemsInputTransform == old(History.TransactWriteItemsInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.TransactWriteItemsInputTransform(config, input);
      History.TransactWriteItemsInputTransform := History.TransactWriteItemsInputTransform + [DafnyCallEvent(input, output)];
    }

    predicate TransactWriteItemsOutputTransformEnsuresPublicly(input: TransactWriteItemsOutputTransformInput, output: Result<TransactWriteItemsOutputTransformOutput, Error>)
      decreases input, output
    {
      Operations.TransactWriteItemsOutputTransformEnsuresPublicly(input, output)
    }

    method TransactWriteItemsOutputTransform(input: TransactWriteItemsOutputTransformInput) returns (output: Result<TransactWriteItemsOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`TransactWriteItemsOutputTransform
      ensures true && ValidState()
      ensures TransactWriteItemsOutputTransformEnsuresPublicly(input, output)
      ensures History.TransactWriteItemsOutputTransform == old(History.TransactWriteItemsOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.TransactWriteItemsOutputTransform(config, input);
      History.TransactWriteItemsOutputTransform := History.TransactWriteItemsOutputTransform + [DafnyCallEvent(input, output)];
    }

    predicate UpdateItemInputTransformEnsuresPublicly(input: UpdateItemInputTransformInput, output: Result<UpdateItemInputTransformOutput, Error>)
      decreases input, output
    {
      Operations.UpdateItemInputTransformEnsuresPublicly(input, output)
    }

    method UpdateItemInputTransform(input: UpdateItemInputTransformInput) returns (output: Result<UpdateItemInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`UpdateItemInputTransform
      ensures true && ValidState()
      ensures UpdateItemInputTransformEnsuresPublicly(input, output)
      ensures History.UpdateItemInputTransform == old(History.UpdateItemInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.UpdateItemInputTransform(config, input);
      History.UpdateItemInputTransform := History.UpdateItemInputTransform + [DafnyCallEvent(input, output)];
    }

    predicate UpdateItemOutputTransformEnsuresPublicly(input: UpdateItemOutputTransformInput, output: Result<UpdateItemOutputTransformOutput, Error>)
      decreases input, output
    {
      Operations.UpdateItemOutputTransformEnsuresPublicly(input, output)
    }

    method UpdateItemOutputTransform(input: UpdateItemOutputTransformInput) returns (output: Result<UpdateItemOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`UpdateItemOutputTransform
      ensures true && ValidState()
      ensures UpdateItemOutputTransformEnsuresPublicly(input, output)
      ensures History.UpdateItemOutputTransform == old(History.UpdateItemOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.UpdateItemOutputTransform(config, input);
      History.UpdateItemOutputTransform := History.UpdateItemOutputTransform + [DafnyCallEvent(input, output)];
    }

    predicate DeleteItemInputTransformEnsuresPublicly(input: DeleteItemInputTransformInput, output: Result<DeleteItemInputTransformOutput, Error>)
      decreases input, output
    {
      Operations.DeleteItemInputTransformEnsuresPublicly(input, output)
    }

    method DeleteItemInputTransform(input: DeleteItemInputTransformInput) returns (output: Result<DeleteItemInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DeleteItemInputTransform
      ensures true && ValidState()
      ensures DeleteItemInputTransformEnsuresPublicly(input, output)
      ensures History.DeleteItemInputTransform == old(History.DeleteItemInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.DeleteItemInputTransform(config, input);
      History.DeleteItemInputTransform := History.DeleteItemInputTransform + [DafnyCallEvent(input, output)];
    }

    predicate DeleteItemOutputTransformEnsuresPublicly(input: DeleteItemOutputTransformInput, output: Result<DeleteItemOutputTransformOutput, Error>)
      decreases input, output
    {
      Operations.DeleteItemOutputTransformEnsuresPublicly(input, output)
    }

    method DeleteItemOutputTransform(input: DeleteItemOutputTransformInput) returns (output: Result<DeleteItemOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DeleteItemOutputTransform
      ensures true && ValidState()
      ensures DeleteItemOutputTransformEnsuresPublicly(input, output)
      ensures History.DeleteItemOutputTransform == old(History.DeleteItemOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.DeleteItemOutputTransform(config, input);
      History.DeleteItemOutputTransform := History.DeleteItemOutputTransform + [DafnyCallEvent(input, output)];
    }

    predicate TransactGetItemsInputTransformEnsuresPublicly(input: TransactGetItemsInputTransformInput, output: Result<TransactGetItemsInputTransformOutput, Error>)
      decreases input, output
    {
      Operations.TransactGetItemsInputTransformEnsuresPublicly(input, output)
    }

    method TransactGetItemsInputTransform(input: TransactGetItemsInputTransformInput) returns (output: Result<TransactGetItemsInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`TransactGetItemsInputTransform
      ensures true && ValidState()
      ensures TransactGetItemsInputTransformEnsuresPublicly(input, output)
      ensures History.TransactGetItemsInputTransform == old(History.TransactGetItemsInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.TransactGetItemsInputTransform(config, input);
      History.TransactGetItemsInputTransform := History.TransactGetItemsInputTransform + [DafnyCallEvent(input, output)];
    }

    predicate TransactGetItemsOutputTransformEnsuresPublicly(input: TransactGetItemsOutputTransformInput, output: Result<TransactGetItemsOutputTransformOutput, Error>)
      decreases input, output
    {
      Operations.TransactGetItemsOutputTransformEnsuresPublicly(input, output)
    }

    method TransactGetItemsOutputTransform(input: TransactGetItemsOutputTransformInput) returns (output: Result<TransactGetItemsOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`TransactGetItemsOutputTransform
      ensures true && ValidState()
      ensures TransactGetItemsOutputTransformEnsuresPublicly(input, output)
      ensures History.TransactGetItemsOutputTransform == old(History.TransactGetItemsOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.TransactGetItemsOutputTransform(config, input);
      History.TransactGetItemsOutputTransform := History.TransactGetItemsOutputTransform + [DafnyCallEvent(input, output)];
    }

    predicate ExecuteStatementInputTransformEnsuresPublicly(input: ExecuteStatementInputTransformInput, output: Result<ExecuteStatementInputTransformOutput, Error>)
      decreases input, output
    {
      Operations.ExecuteStatementInputTransformEnsuresPublicly(input, output)
    }

    method ExecuteStatementInputTransform(input: ExecuteStatementInputTransformInput) returns (output: Result<ExecuteStatementInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ExecuteStatementInputTransform
      ensures true && ValidState()
      ensures ExecuteStatementInputTransformEnsuresPublicly(input, output)
      ensures History.ExecuteStatementInputTransform == old(History.ExecuteStatementInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.ExecuteStatementInputTransform(config, input);
      History.ExecuteStatementInputTransform := History.ExecuteStatementInputTransform + [DafnyCallEvent(input, output)];
    }

    predicate ExecuteStatementOutputTransformEnsuresPublicly(input: ExecuteStatementOutputTransformInput, output: Result<ExecuteStatementOutputTransformOutput, Error>)
      decreases input, output
    {
      Operations.ExecuteStatementOutputTransformEnsuresPublicly(input, output)
    }

    method ExecuteStatementOutputTransform(input: ExecuteStatementOutputTransformInput) returns (output: Result<ExecuteStatementOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ExecuteStatementOutputTransform
      ensures true && ValidState()
      ensures ExecuteStatementOutputTransformEnsuresPublicly(input, output)
      ensures History.ExecuteStatementOutputTransform == old(History.ExecuteStatementOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.ExecuteStatementOutputTransform(config, input);
      History.ExecuteStatementOutputTransform := History.ExecuteStatementOutputTransform + [DafnyCallEvent(input, output)];
    }

    predicate BatchExecuteStatementInputTransformEnsuresPublicly(input: BatchExecuteStatementInputTransformInput, output: Result<BatchExecuteStatementInputTransformOutput, Error>)
      decreases input, output
    {
      Operations.BatchExecuteStatementInputTransformEnsuresPublicly(input, output)
    }

    method BatchExecuteStatementInputTransform(input: BatchExecuteStatementInputTransformInput) returns (output: Result<BatchExecuteStatementInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`BatchExecuteStatementInputTransform
      ensures true && ValidState()
      ensures BatchExecuteStatementInputTransformEnsuresPublicly(input, output)
      ensures History.BatchExecuteStatementInputTransform == old(History.BatchExecuteStatementInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.BatchExecuteStatementInputTransform(config, input);
      History.BatchExecuteStatementInputTransform := History.BatchExecuteStatementInputTransform + [DafnyCallEvent(input, output)];
    }

    predicate BatchExecuteStatementOutputTransformEnsuresPublicly(input: BatchExecuteStatementOutputTransformInput, output: Result<BatchExecuteStatementOutputTransformOutput, Error>)
      decreases input, output
    {
      Operations.BatchExecuteStatementOutputTransformEnsuresPublicly(input, output)
    }

    method BatchExecuteStatementOutputTransform(input: BatchExecuteStatementOutputTransformInput) returns (output: Result<BatchExecuteStatementOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`BatchExecuteStatementOutputTransform
      ensures true && ValidState()
      ensures BatchExecuteStatementOutputTransformEnsuresPublicly(input, output)
      ensures History.BatchExecuteStatementOutputTransform == old(History.BatchExecuteStatementOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.BatchExecuteStatementOutputTransform(config, input);
      History.BatchExecuteStatementOutputTransform := History.BatchExecuteStatementOutputTransform + [DafnyCallEvent(input, output)];
    }

    predicate ExecuteTransactionInputTransformEnsuresPublicly(input: ExecuteTransactionInputTransformInput, output: Result<ExecuteTransactionInputTransformOutput, Error>)
      decreases input, output
    {
      Operations.ExecuteTransactionInputTransformEnsuresPublicly(input, output)
    }

    method ExecuteTransactionInputTransform(input: ExecuteTransactionInputTransformInput) returns (output: Result<ExecuteTransactionInputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ExecuteTransactionInputTransform
      ensures true && ValidState()
      ensures ExecuteTransactionInputTransformEnsuresPublicly(input, output)
      ensures History.ExecuteTransactionInputTransform == old(History.ExecuteTransactionInputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.ExecuteTransactionInputTransform(config, input);
      History.ExecuteTransactionInputTransform := History.ExecuteTransactionInputTransform + [DafnyCallEvent(input, output)];
    }

    predicate ExecuteTransactionOutputTransformEnsuresPublicly(input: ExecuteTransactionOutputTransformInput, output: Result<ExecuteTransactionOutputTransformOutput, Error>)
      decreases input, output
    {
      Operations.ExecuteTransactionOutputTransformEnsuresPublicly(input, output)
    }

    method ExecuteTransactionOutputTransform(input: ExecuteTransactionOutputTransformInput) returns (output: Result<ExecuteTransactionOutputTransformOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ExecuteTransactionOutputTransform
      ensures true && ValidState()
      ensures ExecuteTransactionOutputTransformEnsuresPublicly(input, output)
      ensures History.ExecuteTransactionOutputTransform == old(History.ExecuteTransactionOutputTransform) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.ExecuteTransactionOutputTransform(config, input);
      History.ExecuteTransactionOutputTransform := History.ExecuteTransactionOutputTransform + [DafnyCallEvent(input, output)];
    }

    predicate ResolveAttributesEnsuresPublicly(input: ResolveAttributesInput, output: Result<ResolveAttributesOutput, Error>)
      decreases input, output
    {
      Operations.ResolveAttributesEnsuresPublicly(input, output)
    }

    method ResolveAttributes(input: ResolveAttributesInput) returns (output: Result<ResolveAttributesOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ResolveAttributes
      ensures true && ValidState()
      ensures ResolveAttributesEnsuresPublicly(input, output)
      ensures History.ResolveAttributes == old(History.ResolveAttributes) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.ResolveAttributes(config, input);
      History.ResolveAttributes := History.ResolveAttributes + [DafnyCallEvent(input, output)];
    }
  }
}

abstract module AbstractAwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations {
  predicate ValidInternalConfig?(config: InternalConfig)

  function ModifiesInternalConfig(config: InternalConfig): set<object>

  predicate PutItemInputTransformEnsuresPublicly(input: PutItemInputTransformInput, output: Result<PutItemInputTransformOutput, Error>)
    decreases input, output

  method PutItemInputTransform(config: InternalConfig, input: PutItemInputTransformInput) returns (output: Result<PutItemInputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures PutItemInputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate PutItemOutputTransformEnsuresPublicly(input: PutItemOutputTransformInput, output: Result<PutItemOutputTransformOutput, Error>)
    decreases input, output

  method PutItemOutputTransform(config: InternalConfig, input: PutItemOutputTransformInput) returns (output: Result<PutItemOutputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures PutItemOutputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate GetItemInputTransformEnsuresPublicly(input: GetItemInputTransformInput, output: Result<GetItemInputTransformOutput, Error>)
    decreases input, output

  method GetItemInputTransform(config: InternalConfig, input: GetItemInputTransformInput) returns (output: Result<GetItemInputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GetItemInputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate GetItemOutputTransformEnsuresPublicly(input: GetItemOutputTransformInput, output: Result<GetItemOutputTransformOutput, Error>)
    decreases input, output

  method GetItemOutputTransform(config: InternalConfig, input: GetItemOutputTransformInput) returns (output: Result<GetItemOutputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GetItemOutputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate BatchWriteItemInputTransformEnsuresPublicly(input: BatchWriteItemInputTransformInput, output: Result<BatchWriteItemInputTransformOutput, Error>)
    decreases input, output

  method BatchWriteItemInputTransform(config: InternalConfig, input: BatchWriteItemInputTransformInput) returns (output: Result<BatchWriteItemInputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures BatchWriteItemInputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate BatchWriteItemOutputTransformEnsuresPublicly(input: BatchWriteItemOutputTransformInput, output: Result<BatchWriteItemOutputTransformOutput, Error>)
    decreases input, output

  method BatchWriteItemOutputTransform(config: InternalConfig, input: BatchWriteItemOutputTransformInput) returns (output: Result<BatchWriteItemOutputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures BatchWriteItemOutputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate BatchGetItemInputTransformEnsuresPublicly(input: BatchGetItemInputTransformInput, output: Result<BatchGetItemInputTransformOutput, Error>)
    decreases input, output

  method BatchGetItemInputTransform(config: InternalConfig, input: BatchGetItemInputTransformInput) returns (output: Result<BatchGetItemInputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures BatchGetItemInputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate BatchGetItemOutputTransformEnsuresPublicly(input: BatchGetItemOutputTransformInput, output: Result<BatchGetItemOutputTransformOutput, Error>)
    decreases input, output

  method BatchGetItemOutputTransform(config: InternalConfig, input: BatchGetItemOutputTransformInput) returns (output: Result<BatchGetItemOutputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures BatchGetItemOutputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ScanInputTransformEnsuresPublicly(input: ScanInputTransformInput, output: Result<ScanInputTransformOutput, Error>)
    decreases input, output

  method ScanInputTransform(config: InternalConfig, input: ScanInputTransformInput) returns (output: Result<ScanInputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ScanInputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ScanOutputTransformEnsuresPublicly(input: ScanOutputTransformInput, output: Result<ScanOutputTransformOutput, Error>)
    decreases input, output

  method ScanOutputTransform(config: InternalConfig, input: ScanOutputTransformInput) returns (output: Result<ScanOutputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ScanOutputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate QueryInputTransformEnsuresPublicly(input: QueryInputTransformInput, output: Result<QueryInputTransformOutput, Error>)
    decreases input, output

  method QueryInputTransform(config: InternalConfig, input: QueryInputTransformInput) returns (output: Result<QueryInputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures QueryInputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate QueryOutputTransformEnsuresPublicly(input: QueryOutputTransformInput, output: Result<QueryOutputTransformOutput, Error>)
    decreases input, output

  method QueryOutputTransform(config: InternalConfig, input: QueryOutputTransformInput) returns (output: Result<QueryOutputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures QueryOutputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate TransactWriteItemsInputTransformEnsuresPublicly(input: TransactWriteItemsInputTransformInput, output: Result<TransactWriteItemsInputTransformOutput, Error>)
    decreases input, output

  method TransactWriteItemsInputTransform(config: InternalConfig, input: TransactWriteItemsInputTransformInput) returns (output: Result<TransactWriteItemsInputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures TransactWriteItemsInputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate TransactWriteItemsOutputTransformEnsuresPublicly(input: TransactWriteItemsOutputTransformInput, output: Result<TransactWriteItemsOutputTransformOutput, Error>)
    decreases input, output

  method TransactWriteItemsOutputTransform(config: InternalConfig, input: TransactWriteItemsOutputTransformInput) returns (output: Result<TransactWriteItemsOutputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures TransactWriteItemsOutputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate UpdateItemInputTransformEnsuresPublicly(input: UpdateItemInputTransformInput, output: Result<UpdateItemInputTransformOutput, Error>)
    decreases input, output

  method UpdateItemInputTransform(config: InternalConfig, input: UpdateItemInputTransformInput) returns (output: Result<UpdateItemInputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures UpdateItemInputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate UpdateItemOutputTransformEnsuresPublicly(input: UpdateItemOutputTransformInput, output: Result<UpdateItemOutputTransformOutput, Error>)
    decreases input, output

  method UpdateItemOutputTransform(config: InternalConfig, input: UpdateItemOutputTransformInput) returns (output: Result<UpdateItemOutputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures UpdateItemOutputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DeleteItemInputTransformEnsuresPublicly(input: DeleteItemInputTransformInput, output: Result<DeleteItemInputTransformOutput, Error>)
    decreases input, output

  method DeleteItemInputTransform(config: InternalConfig, input: DeleteItemInputTransformInput) returns (output: Result<DeleteItemInputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DeleteItemInputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DeleteItemOutputTransformEnsuresPublicly(input: DeleteItemOutputTransformInput, output: Result<DeleteItemOutputTransformOutput, Error>)
    decreases input, output

  method DeleteItemOutputTransform(config: InternalConfig, input: DeleteItemOutputTransformInput) returns (output: Result<DeleteItemOutputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DeleteItemOutputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate TransactGetItemsInputTransformEnsuresPublicly(input: TransactGetItemsInputTransformInput, output: Result<TransactGetItemsInputTransformOutput, Error>)
    decreases input, output

  method TransactGetItemsInputTransform(config: InternalConfig, input: TransactGetItemsInputTransformInput) returns (output: Result<TransactGetItemsInputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures TransactGetItemsInputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate TransactGetItemsOutputTransformEnsuresPublicly(input: TransactGetItemsOutputTransformInput, output: Result<TransactGetItemsOutputTransformOutput, Error>)
    decreases input, output

  method TransactGetItemsOutputTransform(config: InternalConfig, input: TransactGetItemsOutputTransformInput) returns (output: Result<TransactGetItemsOutputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures TransactGetItemsOutputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ExecuteStatementInputTransformEnsuresPublicly(input: ExecuteStatementInputTransformInput, output: Result<ExecuteStatementInputTransformOutput, Error>)
    decreases input, output

  method ExecuteStatementInputTransform(config: InternalConfig, input: ExecuteStatementInputTransformInput) returns (output: Result<ExecuteStatementInputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ExecuteStatementInputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ExecuteStatementOutputTransformEnsuresPublicly(input: ExecuteStatementOutputTransformInput, output: Result<ExecuteStatementOutputTransformOutput, Error>)
    decreases input, output

  method ExecuteStatementOutputTransform(config: InternalConfig, input: ExecuteStatementOutputTransformInput) returns (output: Result<ExecuteStatementOutputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ExecuteStatementOutputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate BatchExecuteStatementInputTransformEnsuresPublicly(input: BatchExecuteStatementInputTransformInput, output: Result<BatchExecuteStatementInputTransformOutput, Error>)
    decreases input, output

  method BatchExecuteStatementInputTransform(config: InternalConfig, input: BatchExecuteStatementInputTransformInput) returns (output: Result<BatchExecuteStatementInputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures BatchExecuteStatementInputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate BatchExecuteStatementOutputTransformEnsuresPublicly(input: BatchExecuteStatementOutputTransformInput, output: Result<BatchExecuteStatementOutputTransformOutput, Error>)
    decreases input, output

  method BatchExecuteStatementOutputTransform(config: InternalConfig, input: BatchExecuteStatementOutputTransformInput) returns (output: Result<BatchExecuteStatementOutputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures BatchExecuteStatementOutputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ExecuteTransactionInputTransformEnsuresPublicly(input: ExecuteTransactionInputTransformInput, output: Result<ExecuteTransactionInputTransformOutput, Error>)
    decreases input, output

  method ExecuteTransactionInputTransform(config: InternalConfig, input: ExecuteTransactionInputTransformInput) returns (output: Result<ExecuteTransactionInputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ExecuteTransactionInputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ExecuteTransactionOutputTransformEnsuresPublicly(input: ExecuteTransactionOutputTransformInput, output: Result<ExecuteTransactionOutputTransformOutput, Error>)
    decreases input, output

  method ExecuteTransactionOutputTransform(config: InternalConfig, input: ExecuteTransactionOutputTransformInput) returns (output: Result<ExecuteTransactionOutputTransformOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ExecuteTransactionOutputTransformEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ResolveAttributesEnsuresPublicly(input: ResolveAttributesInput, output: Result<ResolveAttributesOutput, Error>)
    decreases input, output

  method ResolveAttributes(config: InternalConfig, input: ResolveAttributesInput) returns (output: Result<ResolveAttributesOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ResolveAttributesEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes

  type InternalConfig
}

module ExecuteTransactionTransform {
  method Input(config: Config, input: ExecuteTransactionInputTransformInput) returns (output: Result<ExecuteTransactionInputTransformOutput, Error>)
    requires ValidConfig?(config)
    modifies ModifiesConfig(config)
    ensures ValidConfig?(config)
    ensures output.Success? ==> forall i: nat {:trigger input.sdkInput.TransactStatements[i]} | 0 <= i < |input.sdkInput.TransactStatements| :: var statement: Result<DDB.TableName, string> := DdbStatement.TableFromStatement(input.sdkInput.TransactStatements[i].Statement); statement.Success? && statement.value !in config.tableEncryptionConfigs
    ensures output.Success? ==> output.value.transformedInput == input.sdkInput
    decreases config, input
  {
    for i: int := 0 to |input.sdkInput.TransactStatements|
      invariant forall x: nat {:trigger input.sdkInput.TransactStatements[x]} | 0 <= x < i :: var tableName: Result<DDB.TableName, string> := DdbStatement.TableFromStatement(input.sdkInput.TransactStatements[x].Statement); tableName.Success? && tableName.value !in config.tableEncryptionConfigs
    {
      var statement := input.sdkInput.TransactStatements[i].Statement;
      var tableName := DdbStatement.TableFromStatement(statement);
      if tableName.Failure? {
        return Failure(Error.DynamoDbEncryptionTransformsException(message := tableName.error));
      }
      if tableName.value in config.tableEncryptionConfigs {
        return MakeError(""ExecuteTransaction not Supported on encrypted tables."");
      }
    }
    return Success(ExecuteTransactionInputTransformOutput(transformedInput := input.sdkInput));
  }

  method Output(config: Config, input: ExecuteTransactionOutputTransformInput) returns (output: Result<ExecuteTransactionOutputTransformOutput, Error>)
    ensures output.Success? && output.value.transformedOutput == input.sdkOutput
    decreases config, input
  {
    return Success(ExecuteTransactionOutputTransformOutput(transformedOutput := input.sdkOutput));
  }

  import opened DdbMiddlewareConfig

  import opened DynamoDbMiddlewareSupport

  import opened Wrappers

  import DDB = ComAmazonawsDynamodbTypes

  import opened AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes

  import EncTypes = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes

  import Seq

  import DdbStatement
}

module DdbStatement {
  function method {:opaque} UnQuote(s: string): string
    decreases s
  {
    var s: seq<char> := if |s| > 0 && s[0] == '""' then s[1..] else s;
    if |s| > 0 && s[|s| - 1] == '""' then
      s[0 .. |s| - 1]
    else
      s
  }

  function method {:opaque} GetTableName(s: string): Option<DDB.TableName>
    decreases s
  {
    var s: string := UnQuote(s);
    if DDB.IsValid_TableName(s) then
      Some(s)
    else
      None
  }

  function method {:opaque} TableFromStatement(s: string): Result<DDB.TableName, string>
    decreases s
  {
    var ret: Option<DDB.TableName> := TableFromStatementInner(s);
    if ret.Some? then
      Success(ret.value)
    else
      Failure(""Unable to extract table name from PartiQL statement."")
  }

  function method {:opaque} TableFromStatementInner(s: string): Option<DDB.TableName>
    decreases s
  {
    var s: string := StripLeadingWhitespace(s);
    if |s| > 6 && AsciiLower(s[0 .. 6]) == ""exists"" then
      TableFromExistsStatement(s[6..])
    else
      var len: nat := FindTokenLen(s); var cmd: string := AsciiLower(s[..len]); if cmd == ""select"" then TableFromSelectStatement(s[len..]) else if cmd == ""update"" then TableFromUpdateStatement(s[len..]) else if cmd == ""delete"" then TableFromDeleteStatement(s[len..]) else if cmd == ""insert"" then TableFromInsertStatement(s[len..]) else None
  }

  function method {:tailrecursion} {:opaque} TableFromSelectStatementInner(s: string): Option<string>
    decreases |s|
  {
    if |s| == 0 then
      None
    else
      var t: string := StripLeadingWhitespace(s); var len: nat := FindTokenLen(t); if AsciiLower(t[..len]) == ""from"" then var t: string := StripLeadingWhitespace(t[len..]); var len: nat := FindTokenLen(t); Some(t[..len]) else if len == 0 then None else TableFromSelectStatementInner(t[len..])
  }

  function method {:tailrecursion} {:opaque} TableFromExistsStatement(s: string): Option<DDB.TableName>
    decreases s
  {
    var s: string := StripLeadingWhitespace(s);
    if |s| == 0 || s[0] != '(' then
      None
    else
      var s: string := StripLeadingWhitespace(s[1..]); var len: nat := FindTokenLen(s); if AsciiLower(s[..len]) == ""select"" then TableFromSelectStatement(s[len..]) else None
  }

  function method {:opaque} TableFromSelectStatement(s: string): Option<DDB.TableName>
    decreases s
  {
    var name: string :- TableFromSelectStatementInner(s); if '.' in name then var x: (seq<char>, seq<char>) := SplitOnce(name, '.'); GetTableName(x.0) else GetTableName(name)
  }

  function method {:opaque} TableFromUpdateStatement(s: string): Option<DDB.TableName>
    decreases s
  {
    var s: string := StripLeadingWhitespace(s);
    var len: nat := FindTokenLen(s);
    if len == 0 then
      None
    else
      GetTableName(s[..len])
  }

  function method {:opaque} TableFromDeleteStatement(s: string): Option<DDB.TableName>
    decreases s
  {
    var s: string := StripLeadingWhitespace(s);
    var len: nat := FindTokenLen(s);
    if AsciiLower(s[..len]) != ""from"" then
      None
    else
      var s: string := StripLeadingWhitespace(s[len..]); var len: nat := FindTokenLen(s); if len == 0 then None else GetTableName(s[..len])
  }

  function method {:opaque} TableFromInsertStatement(s: string): Option<DDB.TableName>
    decreases s
  {
    var s: string := StripLeadingWhitespace(s);
    var len: nat := FindTokenLen(s);
    if AsciiLower(s[..len]) != ""into"" then
      None
    else
      var s: string := StripLeadingWhitespace(s[len..]); var len: nat := FindTokenLen(s); if len == 0 then None else GetTableName(s[..len])
  }

  predicate method {:opaque} IsWhitespace(ch: char)
    decreases ch
  {
    ch <= ' '
  }

  function method {:tailrecursion} {:opaque} StripLeadingWhitespace(s: string): (ret: string)
    ensures |ret| <= |s|
    decreases s
  {
    if |s| == 0 || !IsWhitespace(s[0]) then
      s
    else
      StripLeadingWhitespace(s[1..])
  }

  function method {:opaque} AsciiLowerChar(ch: char): char
    decreases ch
  {
    if 'A' <= ch <= 'Z' then
      ch - 'A' + 'a'
    else
      ch
  }

  function method {:tailrecursion} {:opaque} AsciiLower(s: string): string
    decreases s
  {
    if |s| == 0 then
      s
    else
      [AsciiLowerChar(s[0])] + AsciiLower(s[1..])
  }

  function method {:opaque} FindTokenLen(s: string): (ret: nat)
    ensures ret <= |s|
    decreases s
  {
    if |s| == 0 || IsWhitespace(s[0]) then
      0
    else if s[0] == '""' then
      1 + FindTokenLenQuoted(s[1..])
    else
      FindTokenLenPlain(s)
  }

  function method {:tailrecursion} {:opaque} FindTokenLenPlain(s: string): (ret: nat)
    ensures ret <= |s|
    decreases s
  {
    if |s| == 0 || IsWhitespace(s[0]) then
      0
    else
      1 + FindTokenLenPlain(s[1..])
  }

  function method {:tailrecursion} {:opaque} FindTokenLenQuoted(s: string): (ret: nat)
    ensures ret <= |s|
    decreases s
  {
    if |s| == 0 then
      0
    else if s[0] == '""' then
      1
    else
      1 + FindTokenLenQuoted(s[1..])
  }

  import opened Wrappers

  import opened StandardLibrary

  import DDB = ComAmazonawsDynamodbTypes
}

module BatchExecuteStatementTransform {
  method Input(config: Config, input: BatchExecuteStatementInputTransformInput) returns (output: Result<BatchExecuteStatementInputTransformOutput, Error>)
    requires ValidConfig?(config)
    modifies ModifiesConfig(config)
    ensures ValidConfig?(config)
    ensures output.Success? ==> output.value.transformedInput == input.sdkInput
    decreases config, input
  {
    for i: int := 0 to |input.sdkInput.Statements| {
      var statement := input.sdkInput.Statements[i].Statement;
      var tableName :- MapString(DdbStatement.TableFromStatement(statement));
      if tableName in config.tableEncryptionConfigs {
        return MakeError(""BatchExecuteStatement not Supported on encrypted tables."");
      }
    }
    return Success(BatchExecuteStatementInputTransformOutput(transformedInput := input.sdkInput));
  }

  method Output(config: Config, input: BatchExecuteStatementOutputTransformInput) returns (output: Result<BatchExecuteStatementOutputTransformOutput, Error>)
    ensures output.Success? && output.value.transformedOutput == input.sdkOutput
    decreases config, input
  {
    return Success(BatchExecuteStatementOutputTransformOutput(transformedOutput := input.sdkOutput));
  }

  import opened DdbMiddlewareConfig

  import opened Wrappers

  import DDB = ComAmazonawsDynamodbTypes

  import opened AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes

  import EncTypes = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes

  import Seq

  import DdbStatement
}

module ExecuteStatementTransform {
  method Input(config: Config, input: ExecuteStatementInputTransformInput) returns (output: Result<ExecuteStatementInputTransformOutput, Error>)
    requires ValidConfig?(config)
    modifies ModifiesConfig(config)
    ensures ValidConfig?(config)
    ensures var statement: Result<DDB.TableName, string> := DdbStatement.TableFromStatement(input.sdkInput.Statement); statement.Failure? || statement.value in config.tableEncryptionConfigs ==> output.Failure?
    ensures var statement: Result<DDB.TableName, string> := DdbStatement.TableFromStatement(input.sdkInput.Statement); statement.Success? && statement.value !in config.tableEncryptionConfigs ==> output.Success? && output.value.transformedInput == input.sdkInput
    decreases config, input
  {
    var tableName :- MapString(DdbStatement.TableFromStatement(input.sdkInput.Statement));
    if tableName in config.tableEncryptionConfigs {
      return MakeError(""ExecuteStatement not Supported on encrypted tables."");
    } else {
      return Success(ExecuteStatementInputTransformOutput(transformedInput := input.sdkInput));
    }
  }

  method Output(config: Config, input: ExecuteStatementOutputTransformInput) returns (output: Result<ExecuteStatementOutputTransformOutput, Error>)
    ensures output.Success? && output.value.transformedOutput == input.sdkOutput
    decreases config, input
  {
    return Success(ExecuteStatementOutputTransformOutput(transformedOutput := input.sdkOutput));
  }

  import opened DdbMiddlewareConfig

  import opened DynamoDbMiddlewareSupport

  import opened Wrappers

  import DDB = ComAmazonawsDynamodbTypes

  import opened AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes

  import EncTypes = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes

  import Seq

  import DdbStatement
}

module DeleteItemTransform {
  method Input(config: Config, input: DeleteItemInputTransformInput) returns (output: Result<DeleteItemInputTransformOutput, Error>)
    requires ValidConfig?(config)
    modifies ModifiesConfig(config)
    ensures ValidConfig?(config)
    ensures output.Success? && input.sdkInput.TableName in config.tableEncryptionConfigs ==> NoMap(input.sdkInput.Expected) && input.sdkInput.ConditionalOperator.None? && var tableConfig: ValidTableConfig := config.tableEncryptionConfigs[input.sdkInput.TableName]; TestConditionExpression(tableConfig, input.sdkInput.ConditionExpression, input.sdkInput.ExpressionAttributeNames, input.sdkInput.ExpressionAttributeValues).Success? && output.value.transformedInput == input.sdkInput
    ensures input.sdkInput.TableName !in config.tableEncryptionConfigs ==> output.Success? && output.value.transformedInput == input.sdkInput
    decreases config, input
  {
    if input.sdkInput.TableName in config.tableEncryptionConfigs {
      :- Need(NoMap(input.sdkInput.Expected), E(""Legacy parameter 'Expected' not supported in UpdateItem with Encryption""));
      :- Need(input.sdkInput.ConditionalOperator.None?, E(""Legacy parameter 'ConditionalOperator' not supported in UpdateItem with Encryption""));
      var tableConfig := config.tableEncryptionConfigs[input.sdkInput.TableName];
      var _ /* _v0 */ :- TestConditionExpression(tableConfig, input.sdkInput.ConditionExpression, input.sdkInput.ExpressionAttributeNames, input.sdkInput.ExpressionAttributeValues);
    }
    return Success(DeleteItemInputTransformOutput(transformedInput := input.sdkInput));
  }

  method Output(config: Config, input: DeleteItemOutputTransformInput) returns (output: Result<DeleteItemOutputTransformOutput, Error>)
    requires ValidConfig?(config)
    modifies ModifiesConfig(config)
    ensures output.Success? && input.originalInput.TableName in config.tableEncryptionConfigs && !NoMap(input.sdkOutput.Attributes) ==> true && var tableConfig: TableConfig := config.tableEncryptionConfigs[input.originalInput.TableName]; true && var oldHistory: seq<DafnyCallEvent<DecryptItemInput, Result<DecryptItemOutput, Error>>> := old(tableConfig.itemEncryptor.History.DecryptItem); true && var newHistory: seq<DafnyCallEvent<DecryptItemInput, Result<DecryptItemOutput, Error>>> := tableConfig.itemEncryptor.History.DecryptItem; |newHistory| == |oldHistory| + 1 && Seq.Last(newHistory).output.Success? && Seq.Last(newHistory).input.encryptedItem == input.sdkOutput.Attributes.value && RemoveBeacons(tableConfig, Seq.Last(newHistory).output.value.plaintextItem).Success? && var item: DDB.AttributeMap := RemoveBeacons(tableConfig, Seq.Last(newHistory).output.value.plaintextItem).value; output.value.transformedOutput.Attributes.Some? && item == output.value.transformedOutput.Attributes.value
    ensures output.Success? && (input.originalInput.TableName !in config.tableEncryptionConfigs || input.sdkOutput.Attributes.None?) ==> output.value.transformedOutput == input.sdkOutput
    ensures ValidConfig?(config)
    decreases config, input
  {
    var tableName := input.originalInput.TableName;
    if tableName !in config.tableEncryptionConfigs || NoMap(input.sdkOutput.Attributes) {
      return Success(DeleteItemOutputTransformOutput(transformedOutput := input.sdkOutput));
    }
    var tableConfig := config.tableEncryptionConfigs[tableName];
    var decryptRes := tableConfig.itemEncryptor.DecryptItem(EncTypes.DecryptItemInput(encryptedItem := input.sdkOutput.Attributes.value));
    var decrypted :- MapError(decryptRes);
    var item :- RemoveBeacons(tableConfig, decrypted.plaintextItem);
    return Success(DeleteItemOutputTransformOutput(transformedOutput := input.sdkOutput.(Attributes := Some(item))));
  }

  import opened DdbMiddlewareConfig

  import opened DynamoDbMiddlewareSupport

  import opened Wrappers

  import DDB = ComAmazonawsDynamodbTypes

  import opened AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes

  import EncTypes = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes

  import Seq
}

module TransactGetItemsTransform {
  method Input(config: Config, input: TransactGetItemsInputTransformInput) returns (output: Result<TransactGetItemsInputTransformOutput, Error>)
    ensures output.Success? && output.value.transformedInput == input.sdkInput
    decreases config, input
  {
    return Success(TransactGetItemsInputTransformOutput(transformedInput := input.sdkInput));
  }

  method {:vcs_split_on_every_assert} Output(config: Config, input: TransactGetItemsOutputTransformInput) returns (output: Result<TransactGetItemsOutputTransformOutput, Error>)
    requires ValidConfig?(config)
    modifies ModifiesConfig(config)
    ensures ValidConfig?(config)
    ensures NoList(input.sdkOutput.Responses) ==> output.Success? && output.value.transformedOutput == input.sdkOutput
    ensures output.Success? && input.sdkOutput.Responses.Some? ==> output.value.transformedOutput.Responses.Some? && |output.value.transformedOutput.Responses.value| == |input.originalInput.TransactItems|
    decreases config, input
  {
    if NoList(input.sdkOutput.Responses) {
      return Success(TransactGetItemsOutputTransformOutput(transformedOutput := input.sdkOutput));
    }
    if |input.sdkOutput.Responses.value| != |input.originalInput.TransactItems| {
      return MakeError(""Invalid TransactGetItems response for original request: Number of items returned must equal number of items requested."");
    }
    var decryptedItems: seq<DDB.ItemResponse> := [];
    var encryptedItems := input.sdkOutput.Responses.value;
    for x: int := 0 to |encryptedItems|
      invariant |decryptedItems| == x
      invariant ValidConfig?(config)
    {
      var tableName := input.originalInput.TransactItems[x].Get.TableName;
      if tableName !in config.tableEncryptionConfigs {
        decryptedItems := decryptedItems + [encryptedItems[x]];
      } else {
        var tableConfig := config.tableEncryptionConfigs[tableName];
        if NoMap(encryptedItems[x].Item) {
          decryptedItems := decryptedItems + [DDB.ItemResponse(Item := None)];
        } else {
          var decryptRes := tableConfig.itemEncryptor.DecryptItem(EncTypes.DecryptItemInput(encryptedItem := encryptedItems[x].Item.value));
          var decrypted :- MapError(decryptRes);
          var item :- RemoveBeacons(tableConfig, decrypted.plaintextItem);
          decryptedItems := decryptedItems + [DDB.ItemResponse(Item := Some(item))];
        }
      }
    }
    return Success(TransactGetItemsOutputTransformOutput(transformedOutput := input.sdkOutput.(Responses := Some(decryptedItems))));
  }

  import opened DdbMiddlewareConfig

  import opened DynamoDbMiddlewareSupport

  import opened Wrappers

  import DDB = ComAmazonawsDynamodbTypes

  import opened AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes

  import EncTypes = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes

  import Seq
}

module QueryTransform {
  method Input(config: Config, input: QueryInputTransformInput) returns (output: Result<QueryInputTransformOutput, Error>)
    requires ValidConfig?(config)
    modifies ModifiesConfig(config)
    ensures ValidConfig?(config)
    ensures input.sdkInput.TableName !in config.tableEncryptionConfigs ==> output.Success? && output.value.transformedInput == input.sdkInput
    ensures output.Success? && input.sdkInput.TableName in config.tableEncryptionConfigs ==> NoList(input.sdkInput.AttributesToGet) && NoMap(input.sdkInput.KeyConditions) && NoMap(input.sdkInput.QueryFilter) && input.sdkInput.ConditionalOperator.None?
    decreases config, input
  {
    if input.sdkInput.TableName !in config.tableEncryptionConfigs {
      return Success(QueryInputTransformOutput(transformedInput := input.sdkInput));
    } else {
      :- Need(NoList(input.sdkInput.AttributesToGet), E(""Legacy parameter 'AttributesToGet' not supported in Query with Encryption""));
      :- Need(NoMap(input.sdkInput.KeyConditions), E(""Legacy parameter 'KeyConditions' not supported in Query with Encryption""));
      :- Need(NoMap(input.sdkInput.QueryFilter), E(""Legacy parameter 'QueryFilter' not supported in Query with Encryption""));
      :- Need(input.sdkInput.ConditionalOperator.None?, E(""Legacy parameter 'ConditionalOperator' not supported in Query with Encryption""));
      var tableConfig := config.tableEncryptionConfigs[input.sdkInput.TableName];
      var finalResult :- QueryInputForBeacons(tableConfig, input.sdkInput);
      return Success(QueryInputTransformOutput(transformedInput := finalResult));
    }
  }

  function Diff(x: nat, y: nat): nat
    requires x >= y
    decreases x, y
  {
    x - y
  }

  method {:vcs_split_on_every_assert} Output(config: Config, input: QueryOutputTransformInput) returns (output: Result<QueryOutputTransformOutput, Error>)
    requires ValidConfig?(config)
    modifies ModifiesConfig(config)
    ensures ValidConfig?(config)
    ensures input.originalInput.TableName !in config.tableEncryptionConfigs || NoList(input.sdkOutput.Items) ==> output.Success? && output.value.transformedOutput == input.sdkOutput
    ensures output.Success? && input.sdkOutput.Items.Some? ==> output.value.transformedOutput.Items.Some?
    ensures output.Success? && NoList(input.sdkOutput.Items) ==> NoList(output.value.transformedOutput.Items)
    decreases config, input
  {
    var tableName := input.originalInput.TableName;
    if tableName !in config.tableEncryptionConfigs || NoList(input.sdkOutput.Items) {
      return Success(QueryOutputTransformOutput(transformedOutput := input.sdkOutput));
    }
    var tableConfig := config.tableEncryptionConfigs[tableName];
    var decryptedItems: DDB.ItemList := [];
    var encryptedItems := input.sdkOutput.Items.value;
    var keyId :- GetBeaconKeyId(tableConfig, input.originalInput.KeyConditionExpression, input.originalInput.FilterExpression, input.originalInput.ExpressionAttributeValues, input.originalInput.ExpressionAttributeNames);
    var keyIdUtf8 := [];
    if keyId.KeyId? {
      keyIdUtf8 :- UTF8.Encode(keyId.value).MapFailure((e: string) => E(e));
    }
    ghost var originalHistory := tableConfig.itemEncryptor.History.DecryptItem;
    ghost var historySize := |originalHistory|;
    for x: int := 0 to |encryptedItems| {
      var decryptInput := EncTypes.DecryptItemInput(encryptedItem := encryptedItems[x]);
      var decryptRes := tableConfig.itemEncryptor.DecryptItem(decryptInput);
      var decrypted :- MapError(decryptRes);
      if keyId.KeyId? && decrypted.parsedHeader.Some? {
        :- Need(|decrypted.parsedHeader.value.encryptedDataKeys| == 1, E(""Query result has more than one Encrypted Data Key""));
        if decrypted.parsedHeader.value.encryptedDataKeys[0].keyProviderInfo == keyIdUtf8 {
          decryptedItems := decryptedItems + [decrypted.plaintextItem];
        }
      } else {
        decryptedItems := decryptedItems + [decrypted.plaintextItem];
      }
    }
    var decryptedOutput := input.sdkOutput.(Items := Some(decryptedItems));
    var finalResult :- QueryOutputForBeacons(tableConfig, input.originalInput, decryptedOutput);
    return Success(QueryOutputTransformOutput(transformedOutput := finalResult));
  }

  import opened DdbMiddlewareConfig

  import opened DynamoDbMiddlewareSupport

  import opened Wrappers

  import DDB = ComAmazonawsDynamodbTypes

  import opened AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes

  import EncTypes = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes

  import EncOps = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations
}

module ScanTransform {
  method Input(config: Config, input: ScanInputTransformInput) returns (output: Result<ScanInputTransformOutput, Error>)
    requires ValidConfig?(config)
    modifies ModifiesConfig(config)
    ensures ValidConfig?(config)
    ensures input.sdkInput.TableName !in config.tableEncryptionConfigs ==> output.Success? && output.value.transformedInput == input.sdkInput
    ensures output.Success? && input.sdkInput.TableName in config.tableEncryptionConfigs ==> NoList(input.sdkInput.AttributesToGet) && NoMap(input.sdkInput.ScanFilter) && input.sdkInput.ConditionalOperator.None?
    decreases config, input
  {
    if input.sdkInput.TableName !in config.tableEncryptionConfigs {
      return Success(ScanInputTransformOutput(transformedInput := input.sdkInput));
    } else {
      :- Need(NoList(input.sdkInput.AttributesToGet), E(""Legacy parameter 'AttributesToGet' not supported in UpdateItem with Encryption""));
      :- Need(NoMap(input.sdkInput.ScanFilter), E(""Legacy parameter 'ScanFilter' not supported in UpdateItem with Encryption""));
      :- Need(input.sdkInput.ConditionalOperator.None?, E(""Legacy parameter 'ConditionalOperator' not supported in UpdateItem with Encryption""));
      var tableConfig := config.tableEncryptionConfigs[input.sdkInput.TableName];
      var finalResult :- ScanInputForBeacons(tableConfig, input.sdkInput);
      return Success(ScanInputTransformOutput(transformedInput := finalResult));
    }
  }

  function Diff(x: nat, y: nat): nat
    requires x >= y
    decreases x, y
  {
    x - y
  }

  method {:vcs_split_on_every_assert} Output(config: Config, input: ScanOutputTransformInput) returns (output: Result<ScanOutputTransformOutput, Error>)
    requires ValidConfig?(config)
    modifies ModifiesConfig(config)
    ensures ValidConfig?(config)
    ensures input.originalInput.TableName !in config.tableEncryptionConfigs || NoList(input.sdkOutput.Items) ==> output.Success? && output.value.transformedOutput == input.sdkOutput
    ensures output.Success? && NoList(input.sdkOutput.Items) ==> NoList(output.value.transformedOutput.Items)
    ensures output.Success? && input.sdkOutput.Items.Some? ==> output.value.transformedOutput.Items.Some?
    decreases config, input
  {
    var tableName := input.originalInput.TableName;
    if tableName !in config.tableEncryptionConfigs || NoList(input.sdkOutput.Items) {
      return Success(ScanOutputTransformOutput(transformedOutput := input.sdkOutput));
    }
    var tableConfig := config.tableEncryptionConfigs[tableName];
    var decryptedItems: DDB.ItemList := [];
    var encryptedItems := input.sdkOutput.Items.value;
    var keyId :- GetBeaconKeyId(tableConfig, None, input.originalInput.FilterExpression, input.originalInput.ExpressionAttributeValues, input.originalInput.ExpressionAttributeNames);
    var keyIdUtf8 := [];
    if keyId.KeyId? {
      keyIdUtf8 :- UTF8.Encode(keyId.value).MapFailure((e: string) => E(e));
    }
    for x: int := 0 to |encryptedItems| {
      var decryptInput := EncTypes.DecryptItemInput(encryptedItem := encryptedItems[x]);
      var decryptRes := tableConfig.itemEncryptor.DecryptItem(decryptInput);
      var decrypted :- MapError(decryptRes);
      if keyId.KeyId? && decrypted.parsedHeader.Some? {
        :- Need(|decrypted.parsedHeader.value.encryptedDataKeys| == 1, E(""Scan result has more than one Encrypted Data Key""));
        if decrypted.parsedHeader.value.encryptedDataKeys[0].keyProviderInfo == keyIdUtf8 {
          decryptedItems := decryptedItems + [decrypted.plaintextItem];
        }
      } else {
        decryptedItems := decryptedItems + [decrypted.plaintextItem];
      }
    }
    var decryptedOutput := input.sdkOutput.(Items := Some(decryptedItems));
    var finalResult :- ScanOutputForBeacons(tableConfig, input.originalInput, decryptedOutput);
    return Success(ScanOutputTransformOutput(transformedOutput := finalResult));
  }

  import opened DdbMiddlewareConfig

  import opened DynamoDbMiddlewareSupport

  import opened Wrappers

  import DDB = ComAmazonawsDynamodbTypes

  import opened AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes

  import EncTypes = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes

  import EncOps = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations
}

module BatchGetItemTransform {
  method Input(config: Config, input: BatchGetItemInputTransformInput) returns (output: Result<BatchGetItemInputTransformOutput, Error>)
    ensures output.Success? && output.value.transformedInput == input.sdkInput
    decreases config, input
  {
    return Success(BatchGetItemInputTransformOutput(transformedInput := input.sdkInput));
  }

  method {:vcs_split_on_every_assert} Output(config: Config, input: BatchGetItemOutputTransformInput) returns (output: Result<BatchGetItemOutputTransformOutput, Error>)
    requires ValidConfig?(config)
    modifies ModifiesConfig(config)
    ensures ValidConfig?(config)
    ensures output.Success? ==> SameOption(input.sdkOutput.Responses, output.value.transformedOutput.Responses)
    ensures output.Success? && input.sdkOutput.Responses.Some? ==> true && output.value.transformedOutput.Responses.Some?
    decreases config, input
  {
    if NoMap(input.sdkOutput.Responses) {
      return Success(BatchGetItemOutputTransformOutput(transformedOutput := input.sdkOutput));
    }
    var tableNames := input.sdkOutput.Responses.value.Keys;
    var tableNamesSeq := SortedSets.ComputeSetToSequence(tableNames);
    ghost var tableNamesSet' := tableNames;
    var i := 0;
    var result := map[];
    while i < |tableNamesSeq|
      invariant tableNamesSet' <= input.sdkOutput.Responses.value.Keys
      decreases |tableNamesSeq| - i
    {
      var tableName := tableNamesSeq[i];
      var responses := input.sdkOutput.Responses.value[tableName];
      if tableName in config.tableEncryptionConfigs {
        var tableConfig := config.tableEncryptionConfigs[tableName];
        var decryptedItem: DDB.ItemList := [];
        for x: int := 0 to |responses| {
          var decryptRes := tableConfig.itemEncryptor.DecryptItem(EncTypes.DecryptItemInput(encryptedItem := responses[x]));
          var decrypted :- MapError(decryptRes);
          var item :- RemoveBeacons(tableConfig, decrypted.plaintextItem);
          decryptedItem := decryptedItem + [item];
        }
        result := result + map[tableName := decryptedItem];
      } else {
        result := result + map[tableName := responses];
      }
      i := i + 1;
    }
    return Success(BatchGetItemOutputTransformOutput(transformedOutput := input.sdkOutput.(Responses := Some(result))));
  }

  import opened DdbMiddlewareConfig

  import opened DynamoDbMiddlewareSupport

  import opened Wrappers

  import DDB = ComAmazonawsDynamodbTypes

  import opened AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes

  import EncTypes = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes

  import Seq

  import SortedSets
}

module TransactWriteItemsTransform {
  predicate method {:opaque} IsValid(item: DDB.TransactWriteItem)
    decreases item
  {
    item.Put.Some? || item.Update.Some? || item.Delete.Some? || item.ConditionCheck.Some?
  }

  method {:vcs_split_on_every_assert} Input(config: Config, input: TransactWriteItemsInputTransformInput) returns (output: Result<TransactWriteItemsInputTransformOutput, Error>)
    requires ValidConfig?(config)
    modifies ModifiesConfig(config)
    ensures ValidConfig?(config)
    ensures output.Success? ==> |output.value.transformedInput.TransactItems| == |input.sdkInput.TransactItems|
    ensures output.Success? ==> forall item: DDB.TransactWriteItem {:trigger IsValid(item)} {:trigger item in input.sdkInput.TransactItems} | item in input.sdkInput.TransactItems :: IsValid(item)
    decreases config, input
  {
    :- Need(forall item: DDB.TransactWriteItem {:trigger IsValid(item)} {:trigger item in input.sdkInput.TransactItems} | item in input.sdkInput.TransactItems :: IsValid(item), E(""Each item in TransactWriteItems must specify at least one supported operation""));
    var result: seq<DDB.TransactWriteItem> := [];
    for x: int := 0 to |input.sdkInput.TransactItems| {
      var item := input.sdkInput.TransactItems[x];
      if item.ConditionCheck.Some? && item.ConditionCheck.value.TableName in config.tableEncryptionConfigs {
        var tableConfig := config.tableEncryptionConfigs[item.ConditionCheck.value.TableName];
        var _ /* _v0 */ :- TestConditionExpression(tableConfig, Some(item.ConditionCheck.value.ConditionExpression), item.ConditionCheck.value.ExpressionAttributeNames, item.ConditionCheck.value.ExpressionAttributeValues);
      }
      if item.Delete.Some? && item.Delete.value.TableName in config.tableEncryptionConfigs {
        var tableConfig := config.tableEncryptionConfigs[item.Delete.value.TableName];
        var _ /* _v1 */ :- TestConditionExpression(tableConfig, item.Delete.value.ConditionExpression, item.Delete.value.ExpressionAttributeNames, item.Delete.value.ExpressionAttributeValues);
      }
      if item.Update.Some? && item.Update.value.TableName in config.tableEncryptionConfigs {
        var tableConfig := config.tableEncryptionConfigs[item.Update.value.TableName];
        var _ /* _v2 */ :- TestUpdateExpression(tableConfig, Some(item.Update.value.UpdateExpression), item.Update.value.ExpressionAttributeNames, item.Update.value.ExpressionAttributeValues);
        var _ /* _v3 */ :- TestConditionExpression(tableConfig, item.Update.value.ConditionExpression, item.Update.value.ExpressionAttributeNames, item.Update.value.ExpressionAttributeValues);
      }
      if item.Put.Some? && !IsPlainWrite(config, item.Put.value.TableName) {
        var tableConfig := config.tableEncryptionConfigs[item.Put.value.TableName];
        var _ /* _v4 */ :- IsWriteable(tableConfig, item.Put.value.Item);
        var _ /* _v5 */ :- TestConditionExpression(tableConfig, item.Put.value.ConditionExpression, item.Put.value.ExpressionAttributeNames, item.Put.value.ExpressionAttributeValues);
        var beaconItem :- AddSignedBeacons(tableConfig, item.Put.value.Item);
        var encryptRes := tableConfig.itemEncryptor.EncryptItem(EncTypes.EncryptItemInput(plaintextItem := beaconItem));
        var encrypted :- MapError(encryptRes);
        var keyId :- GetKeyIdFromHeader(tableConfig, encrypted);
        var beaconAttrs :- GetEncryptedBeacons(tableConfig, item.Put.value.Item, Util.MaybeFromOptionKeyId(keyId));
        var put := Some(item.Put.value.(Item := encrypted.encryptedItem + beaconAttrs));
        var newItem := item.(Put := put);
        ghost var oldResult := result;
        result := result + [newItem];
        assert |result| == |oldResult| + 1;
      } else {
        ghost var oldResult := result;
        result := result + [item];
        assert |result| == |oldResult| + 1;
      }
    }
    :- Need(|input.sdkInput.TransactItems| == |result|, E(""""));
    return Success(TransactWriteItemsInputTransformOutput(transformedInput := input.sdkInput.(TransactItems := result)));
  }

  method Output(config: Config, input: TransactWriteItemsOutputTransformInput) returns (output: Result<TransactWriteItemsOutputTransformOutput, Error>)
    ensures output.Success? && output.value.transformedOutput == input.sdkOutput
    decreases config, input
  {
    var finalResult := input.sdkOutput;
    return Success(TransactWriteItemsOutputTransformOutput(transformedOutput := finalResult));
  }

  import opened DdbMiddlewareConfig

  import opened DynamoDbMiddlewareSupport

  import opened Wrappers

  import DDB = ComAmazonawsDynamodbTypes

  import opened AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes

  import EncTypes = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes

  import Seq

  import Util = DynamoDbEncryptionUtil
}

module BatchWriteItemTransform {
  method {:vcs_split_on_every_assert} Input(config: Config, input: BatchWriteItemInputTransformInput) returns (output: Result<BatchWriteItemInputTransformOutput, Error>)
    requires ValidConfig?(config)
    modifies ModifiesConfig(config)
    ensures ValidConfig?(config)
    decreases config, input
  {
    var tableNames := input.sdkInput.RequestItems.Keys;
    var result: map<DDB.TableArn, DDB.WriteRequests> := map[];
    var tableNamesSeq := SortedSets.ComputeSetToSequence(tableNames);
    ghost var tableNamesSet' := tableNames;
    var i := 0;
    while i < |tableNamesSeq|
      invariant Seq.HasNoDuplicates(tableNamesSeq)
      invariant forall j: int {:trigger tableNamesSeq[j]} | i <= j < |tableNamesSeq| :: tableNamesSeq[j] in tableNamesSet'
      invariant |tableNamesSet'| == |tableNamesSeq| - i
      invariant tableNamesSet' <= input.sdkInput.RequestItems.Keys
      decreases |tableNamesSeq| - i
    {
      var tableName := tableNamesSeq[i];
      var writeRequests: DDB.WriteRequests := input.sdkInput.RequestItems[tableName];
      if !IsPlainWrite(config, tableName) {
        var tableConfig := config.tableEncryptionConfigs[tableName];
        var encryptedItems: seq<DDB.WriteRequest> := [];
        for x: int := 0 to |writeRequests|
          invariant |encryptedItems| == x
        {
          var req: DDB.WriteRequest := writeRequests[x];
          if req.PutRequest.None? {
            encryptedItems := encryptedItems + [req];
          } else {
            var _ /* _v0 */ :- IsWriteable(tableConfig, req.PutRequest.value.Item);
            var item :- AddSignedBeacons(tableConfig, req.PutRequest.value.Item);
            var encryptRes := tableConfig.itemEncryptor.EncryptItem(EncTypes.EncryptItemInput(plaintextItem := item));
            var encrypted :- MapError(encryptRes);
            var keyId :- GetKeyIdFromHeader(tableConfig, encrypted);
            var beaconAttrs :- GetEncryptedBeacons(tableConfig, req.PutRequest.value.Item, Util.MaybeFromOptionKeyId(keyId));
            encryptedItems := encryptedItems + [req.(PutRequest := Some(DDB.PutRequest(Item := encrypted.encryptedItem + beaconAttrs)))];
          }
        }
        writeRequests := encryptedItems;
      }
      tableNamesSet' := tableNamesSet' - {tableName};
      i := i + 1;
      assert forall j: int {:trigger tableNamesSeq[j]} | i <= j < |tableNamesSeq| :: tableNamesSeq[j] in tableNamesSet' by {
        reveal Seq.HasNoDuplicates();
      }
      result := result[tableName := writeRequests];
    }
    :- Need(|result| == |input.sdkInput.RequestItems|, E(""Internal Error""));
    return Success(BatchWriteItemInputTransformOutput(transformedInput := input.sdkInput.(RequestItems := result)));
  }

  method Output(config: Config, input: BatchWriteItemOutputTransformInput) returns (output: Result<BatchWriteItemOutputTransformOutput, Error>)
    ensures output.Success? && output.value.transformedOutput == input.sdkOutput
    decreases config, input
  {
    return Success(BatchWriteItemOutputTransformOutput(transformedOutput := input.sdkOutput));
  }

  import opened DdbMiddlewareConfig

  import opened DynamoDbMiddlewareSupport

  import opened Wrappers

  import DDB = ComAmazonawsDynamodbTypes

  import opened AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes

  import EncTypes = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes

  import Seq

  import SortedSets

  import Util = DynamoDbEncryptionUtil
}

module UpdateItemTransform {
  method Input(config: Config, input: UpdateItemInputTransformInput) returns (output: Result<UpdateItemInputTransformOutput, Error>)
    requires ValidConfig?(config)
    modifies ModifiesConfig(config)
    ensures ValidConfig?(config)
    ensures output.Success? && input.sdkInput.TableName in config.tableEncryptionConfigs ==> NoMap(input.sdkInput.Expected) && NoMap(input.sdkInput.AttributeUpdates) && input.sdkInput.ConditionalOperator.None? && var tableConfig: ValidTableConfig := config.tableEncryptionConfigs[input.sdkInput.TableName]; TestUpdateExpression(tableConfig, input.sdkInput.UpdateExpression, input.sdkInput.ExpressionAttributeNames, input.sdkInput.ExpressionAttributeValues).Success? && output.value.transformedInput == input.sdkInput
    ensures input.sdkInput.TableName !in config.tableEncryptionConfigs ==> output.Success? && output.value.transformedInput == input.sdkInput
    decreases config, input
  {
    if input.sdkInput.TableName in config.tableEncryptionConfigs {
      :- Need(NoMap(input.sdkInput.Expected), E(""Legacy parameter 'Expected' not supported in UpdateItem with Encryption""));
      :- Need(NoMap(input.sdkInput.AttributeUpdates), E(""Legacy parameter 'AttributeUpdates' not supported in UpdateItem with Encryption""));
      :- Need(input.sdkInput.ConditionalOperator.None?, E(""Legacy parameter 'ConditionalOperator' not supported in UpdateItem with Encryption""));
      var tableConfig := config.tableEncryptionConfigs[input.sdkInput.TableName];
      var _ /* _v0 */ :- TestUpdateExpression(tableConfig, input.sdkInput.UpdateExpression, input.sdkInput.ExpressionAttributeNames, input.sdkInput.ExpressionAttributeValues);
    }
    return Success(UpdateItemInputTransformOutput(transformedInput := input.sdkInput));
  }

  method Output(config: Config, input: UpdateItemOutputTransformInput) returns (output: Result<UpdateItemOutputTransformOutput, Error>)
    requires ValidConfig?(config)
    modifies ModifiesConfig(config)
    ensures output.Success? && input.originalInput.TableName in config.tableEncryptionConfigs && !NoMap(input.sdkOutput.Attributes) && input.originalInput.ReturnValues.Some? && (input.originalInput.ReturnValues.value.ALL_OLD? || input.originalInput.ReturnValues.value.ALL_NEW?) ==> true && var tableConfig: TableConfig := config.tableEncryptionConfigs[input.originalInput.TableName]; true && var oldHistory: seq<DafnyCallEvent<DecryptItemInput, Result<DecryptItemOutput, Error>>> := old(tableConfig.itemEncryptor.History.DecryptItem); true && var newHistory: seq<DafnyCallEvent<DecryptItemInput, Result<DecryptItemOutput, Error>>> := tableConfig.itemEncryptor.History.DecryptItem; |newHistory| == |oldHistory| + 1 && Seq.Last(newHistory).output.Success? && Seq.Last(newHistory).input.encryptedItem == input.sdkOutput.Attributes.value && RemoveBeacons(tableConfig, Seq.Last(newHistory).output.value.plaintextItem).Success? && var item: DDB.AttributeMap := RemoveBeacons(tableConfig, Seq.Last(newHistory).output.value.plaintextItem).value; output.value.transformedOutput.Attributes.Some? && item == output.value.transformedOutput.Attributes.value
    ensures output.Success? && (input.originalInput.TableName !in config.tableEncryptionConfigs || input.sdkOutput.Attributes.None?) ==> true && output.value.transformedOutput == input.sdkOutput
    ensures output.Success? && input.originalInput.TableName in config.tableEncryptionConfigs && input.sdkOutput.Attributes.Some? && (input.originalInput.ReturnValues.Some? ==> input.originalInput.ReturnValues.value.UPDATED_NEW? || input.originalInput.ReturnValues.value.UPDATED_OLD?) ==> true && var tableConfig: ValidTableConfig := config.tableEncryptionConfigs[input.originalInput.TableName]; output.value.transformedOutput == input.sdkOutput && forall k: string {:trigger IsSigned(tableConfig, k)} {:trigger k in input.sdkOutput.Attributes.value.Keys} | k in input.sdkOutput.Attributes.value.Keys :: !IsSigned(tableConfig, k)
    ensures input.originalInput.TableName in config.tableEncryptionConfigs && (var tableConfig: ValidTableConfig := config.tableEncryptionConfigs[input.originalInput.TableName]; input.sdkOutput.Attributes.Some? && (input.originalInput.ReturnValues.Some? ==> input.originalInput.ReturnValues.value.UPDATED_NEW? || input.originalInput.ReturnValues.value.UPDATED_OLD?) && exists k: string {:trigger IsSigned(tableConfig, k)} {:trigger k in input.sdkOutput.Attributes.value.Keys} | k in input.sdkOutput.Attributes.value.Keys :: IsSigned(tableConfig, k)) ==> output.Failure?
    ensures ValidConfig?(config)
    decreases config, input
  {
    var tableName := input.originalInput.TableName;
    if tableName !in config.tableEncryptionConfigs || NoMap(input.sdkOutput.Attributes) {
      return Success(UpdateItemOutputTransformOutput(transformedOutput := input.sdkOutput));
    }
    var tableConfig := config.tableEncryptionConfigs[tableName];
    var attributes := input.sdkOutput.Attributes.value;
    if !(input.originalInput.ReturnValues.Some? && (input.originalInput.ReturnValues.value.ALL_NEW? || input.originalInput.ReturnValues.value.ALL_OLD?)) {
      :- Need(forall k: string {:trigger IsSigned(tableConfig, k)} {:trigger k in attributes.Keys} | k in attributes.Keys :: !IsSigned(tableConfig, k), E(""UpdateItems response contains signed attributes, but does not include the entire item which is required for verification.""));
      return Success(UpdateItemOutputTransformOutput(transformedOutput := input.sdkOutput));
    }
    var decryptRes := tableConfig.itemEncryptor.DecryptItem(EncTypes.DecryptItemInput(encryptedItem := attributes));
    var decrypted :- MapError(decryptRes);
    var item :- RemoveBeacons(tableConfig, decrypted.plaintextItem);
    return Success(UpdateItemOutputTransformOutput(transformedOutput := input.sdkOutput.(Attributes := Some(item))));
  }

  import opened DdbMiddlewareConfig

  import opened DynamoDbMiddlewareSupport

  import opened Wrappers

  import DDB = ComAmazonawsDynamodbTypes

  import opened AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes

  import EncTypes = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes

  import Seq
}

module GetItemTransform {
  method Input(config: Config, input: GetItemInputTransformInput) returns (output: Result<GetItemInputTransformOutput, Error>)
    ensures output.Success? && output.value.transformedInput == input.sdkInput
    decreases config, input
  {
    return Success(GetItemInputTransformOutput(transformedInput := input.sdkInput));
  }

  method Output(config: Config, input: GetItemOutputTransformInput) returns (output: Result<GetItemOutputTransformOutput, Error>)
    requires ValidConfig?(config)
    modifies ModifiesConfig(config)
    ensures output.Success? && input.originalInput.TableName !in config.tableEncryptionConfigs ==> output.value.transformedOutput == input.sdkOutput
    ensures output.Success? && NoMap(input.sdkOutput.Item) ==> NoMap(output.value.transformedOutput.Item)
    ensures output.Success? && input.originalInput.TableName in config.tableEncryptionConfigs && !NoMap(input.sdkOutput.Item) ==> var tableConfig: TableConfig := config.tableEncryptionConfigs[input.originalInput.TableName]; var oldHistory: seq<DafnyCallEvent<DecryptItemInput, Result<DecryptItemOutput, Error>>> := old(tableConfig.itemEncryptor.History.DecryptItem); var newHistory: seq<DafnyCallEvent<DecryptItemInput, Result<DecryptItemOutput, Error>>> := tableConfig.itemEncryptor.History.DecryptItem; |newHistory| == |oldHistory| + 1 && Seq.Last(newHistory).output.Success? && Seq.Last(newHistory).input.encryptedItem == input.sdkOutput.Item.value && RemoveBeacons(tableConfig, Seq.Last(newHistory).output.value.plaintextItem).Success? && var item: DDB.AttributeMap := RemoveBeacons(tableConfig, Seq.Last(newHistory).output.value.plaintextItem).value; output.value.transformedOutput.Item.Some? && item == output.value.transformedOutput.Item.value
    ensures ValidConfig?(config)
    decreases config, input
  {
    var tableName := input.originalInput.TableName;
    if tableName !in config.tableEncryptionConfigs || NoMap(input.sdkOutput.Item) {
      return Success(GetItemOutputTransformOutput(transformedOutput := input.sdkOutput));
    }
    var tableConfig := config.tableEncryptionConfigs[tableName];
    var decryptRes := tableConfig.itemEncryptor.DecryptItem(EncTypes.DecryptItemInput(encryptedItem := input.sdkOutput.Item.value));
    var decrypted :- MapError(decryptRes);
    var item :- RemoveBeacons(tableConfig, decrypted.plaintextItem);
    return Success(GetItemOutputTransformOutput(transformedOutput := input.sdkOutput.(Item := Some(item))));
  }

  import opened DdbMiddlewareConfig

  import opened DynamoDbMiddlewareSupport

  import opened Wrappers

  import DDB = ComAmazonawsDynamodbTypes

  import opened AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes

  import EncTypes = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes

  import Seq
}

module PutItemTransform {
  method Input(config: Config, input: PutItemInputTransformInput) returns (output: Result<PutItemInputTransformOutput, Error>)
    requires ValidConfig?(config)
    modifies ModifiesConfig(config)
    ensures ValidConfig?(config)
    ensures output.Success? && input.sdkInput.TableName !in config.tableEncryptionConfigs ==> output.value.transformedInput == input.sdkInput
    ensures output.Success? && !IsPlainWrite(config, input.sdkInput.TableName) ==> true && var tableConfig: ValidTableConfig := config.tableEncryptionConfigs[input.sdkInput.TableName]; NoMap(input.sdkInput.Expected) && input.sdkInput.ConditionalOperator.None? && IsWriteable(tableConfig, input.sdkInput.Item).Success? && TestConditionExpression(tableConfig, input.sdkInput.ConditionExpression, input.sdkInput.ExpressionAttributeNames, input.sdkInput.ExpressionAttributeValues).Success?
    decreases config, input
  {
    if IsPlainWrite(config, input.sdkInput.TableName) {
      return Success(PutItemInputTransformOutput(transformedInput := input.sdkInput));
    }
    var tableConfig := config.tableEncryptionConfigs[input.sdkInput.TableName];
    :- Need(NoMap(input.sdkInput.Expected), E(""Legacy parameter 'Expected' not supported in PutItem with Encryption.""));
    :- Need(input.sdkInput.ConditionalOperator.None?, E(""Legacy parameter 'ConditionalOperator' not supported in PutItem with Encryption.""));
    var _ /* _v0 */ :- IsWriteable(tableConfig, input.sdkInput.Item);
    var _ /* _v1 */ :- TestConditionExpression(tableConfig, input.sdkInput.ConditionExpression, input.sdkInput.ExpressionAttributeNames, input.sdkInput.ExpressionAttributeValues);
    var item :- AddSignedBeacons(tableConfig, input.sdkInput.Item);
    var encryptRes := tableConfig.itemEncryptor.EncryptItem(EncTypes.EncryptItemInput(plaintextItem := item));
    var encrypted :- MapError(encryptRes);
    var keyId :- GetKeyIdFromHeader(tableConfig, encrypted);
    var beacons :- GetEncryptedBeacons(tableConfig, input.sdkInput.Item, Util.MaybeFromOptionKeyId(keyId));
    return Success(PutItemInputTransformOutput(transformedInput := input.sdkInput.(Item := encrypted.encryptedItem + beacons)));
  }

  method Output(config: Config, input: PutItemOutputTransformInput) returns (output: Result<PutItemOutputTransformOutput, Error>)
    requires ValidConfig?(config)
    modifies ModifiesConfig(config)
    ensures output.Success? && input.originalInput.TableName in config.tableEncryptionConfigs && !NoMap(input.sdkOutput.Attributes) ==> true && var tableConfig: TableConfig := config.tableEncryptionConfigs[input.originalInput.TableName]; true && var oldHistory: seq<DafnyCallEvent<DecryptItemInput, Result<DecryptItemOutput, Error>>> := old(tableConfig.itemEncryptor.History.DecryptItem); true && var newHistory: seq<DafnyCallEvent<DecryptItemInput, Result<DecryptItemOutput, Error>>> := tableConfig.itemEncryptor.History.DecryptItem; |newHistory| == |oldHistory| + 1 && Seq.Last(newHistory).output.Success? && Seq.Last(newHistory).input.encryptedItem == input.sdkOutput.Attributes.value && RemoveBeacons(tableConfig, Seq.Last(newHistory).output.value.plaintextItem).Success? && var item: DDB.AttributeMap := RemoveBeacons(tableConfig, Seq.Last(newHistory).output.value.plaintextItem).value; output.value.transformedOutput.Attributes.Some? && item == output.value.transformedOutput.Attributes.value
    ensures output.Success? && (input.originalInput.TableName !in config.tableEncryptionConfigs || input.sdkOutput.Attributes.None?) ==> output.value.transformedOutput == input.sdkOutput
    ensures ValidConfig?(config)
    decreases config, input
  {
    var tableName := input.originalInput.TableName;
    if tableName !in config.tableEncryptionConfigs || NoMap(input.sdkOutput.Attributes) {
      return Success(PutItemOutputTransformOutput(transformedOutput := input.sdkOutput));
    }
    var tableConfig := config.tableEncryptionConfigs[tableName];
    var decryptRes := tableConfig.itemEncryptor.DecryptItem(EncTypes.DecryptItemInput(encryptedItem := input.sdkOutput.Attributes.value));
    var decrypted :- MapError(decryptRes);
    var item :- RemoveBeacons(tableConfig, decrypted.plaintextItem);
    return Success(PutItemOutputTransformOutput(transformedOutput := input.sdkOutput.(Attributes := Some(item))));
  }

  import opened DdbMiddlewareConfig

  import opened DynamoDbMiddlewareSupport

  import opened Wrappers

  import DDB = ComAmazonawsDynamodbTypes

  import opened AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes

  import EncTypes = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes

  import Seq

  import Util = DynamoDbEncryptionUtil
}


")]

namespace Dafny {
  internal class ArrayHelpers {
    public static T[] InitNewArray1<T>(T z, BigInteger size0) {
      int s0 = (int)size0;
      T[] a = new T[s0];
      for (int i0 = 0; i0 < s0; i0++) {
        a[i0] = z;
      }
      return a;
    }
  }
} // end of namespace Dafny
internal static class FuncExtensions {
  public static Func<U, UResult> DowncastClone<T, TResult, U, UResult>(this Func<T, TResult> F, Func<U, T> ArgConv, Func<TResult, UResult> ResConv) {
    return arg => ResConv(F(ArgConv(arg)));
  }
  public static Func<UResult> DowncastClone<TResult, UResult>(this Func<TResult> F, Func<TResult, UResult> ResConv) {
    return () => ResConv(F());
  }
  public static Func<U1, U2, UResult> DowncastClone<T1, T2, TResult, U1, U2, UResult>(this Func<T1, T2, TResult> F, Func<U1, T1> ArgConv1, Func<U2, T2> ArgConv2, Func<TResult, UResult> ResConv) {
    return (arg1, arg2) => ResConv(F(ArgConv1(arg1), ArgConv2(arg2)));
  }
  public static Func<U1, U2, U3, U4, U5, U6, UResult> DowncastClone<T1, T2, T3, T4, T5, T6, TResult, U1, U2, U3, U4, U5, U6, UResult>(this Func<T1, T2, T3, T4, T5, T6, TResult> F, Func<U1, T1> ArgConv1, Func<U2, T2> ArgConv2, Func<U3, T3> ArgConv3, Func<U4, T4> ArgConv4, Func<U5, T5> ArgConv5, Func<U6, T6> ArgConv6, Func<TResult, UResult> ResConv) {
    return (arg1, arg2, arg3, arg4, arg5, arg6) => ResConv(F(ArgConv1(arg1), ArgConv2(arg2), ArgConv3(arg3), ArgConv4(arg4), ArgConv5(arg5), ArgConv6(arg6)));
  }
  public static Func<U1, U2, U3, UResult> DowncastClone<T1, T2, T3, TResult, U1, U2, U3, UResult>(this Func<T1, T2, T3, TResult> F, Func<U1, T1> ArgConv1, Func<U2, T2> ArgConv2, Func<U3, T3> ArgConv3, Func<TResult, UResult> ResConv) {
    return (arg1, arg2, arg3) => ResConv(F(ArgConv1(arg1), ArgConv2(arg2), ArgConv3(arg3)));
  }
  public static Func<U1, U2, U3, U4, U5, U6, U7, UResult> DowncastClone<T1, T2, T3, T4, T5, T6, T7, TResult, U1, U2, U3, U4, U5, U6, U7, UResult>(this Func<T1, T2, T3, T4, T5, T6, T7, TResult> F, Func<U1, T1> ArgConv1, Func<U2, T2> ArgConv2, Func<U3, T3> ArgConv3, Func<U4, T4> ArgConv4, Func<U5, T5> ArgConv5, Func<U6, T6> ArgConv6, Func<U7, T7> ArgConv7, Func<TResult, UResult> ResConv) {
    return (arg1, arg2, arg3, arg4, arg5, arg6, arg7) => ResConv(F(ArgConv1(arg1), ArgConv2(arg2), ArgConv3(arg3), ArgConv4(arg4), ArgConv5(arg5), ArgConv6(arg6), ArgConv7(arg7)));
  }
  public static Func<U1, U2, U3, U4, UResult> DowncastClone<T1, T2, T3, T4, TResult, U1, U2, U3, U4, UResult>(this Func<T1, T2, T3, T4, TResult> F, Func<U1, T1> ArgConv1, Func<U2, T2> ArgConv2, Func<U3, T3> ArgConv3, Func<U4, T4> ArgConv4, Func<TResult, UResult> ResConv) {
    return (arg1, arg2, arg3, arg4) => ResConv(F(ArgConv1(arg1), ArgConv2(arg2), ArgConv3(arg3), ArgConv4(arg4)));
  }
  public static Func<U1, U2, U3, U4, U5, UResult> DowncastClone<T1, T2, T3, T4, T5, TResult, U1, U2, U3, U4, U5, UResult>(this Func<T1, T2, T3, T4, T5, TResult> F, Func<U1, T1> ArgConv1, Func<U2, T2> ArgConv2, Func<U3, T3> ArgConv3, Func<U4, T4> ArgConv4, Func<U5, T5> ArgConv5, Func<TResult, UResult> ResConv) {
    return (arg1, arg2, arg3, arg4, arg5) => ResConv(F(ArgConv1(arg1), ArgConv2(arg2), ArgConv3(arg3), ArgConv4(arg4), ArgConv5(arg5)));
  }
  public static Func<U1, U2, U3, U4, U5, U6, U7, U8, UResult> DowncastClone<T1, T2, T3, T4, T5, T6, T7, T8, TResult, U1, U2, U3, U4, U5, U6, U7, U8, UResult>(this Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult> F, Func<U1, T1> ArgConv1, Func<U2, T2> ArgConv2, Func<U3, T3> ArgConv3, Func<U4, T4> ArgConv4, Func<U5, T5> ArgConv5, Func<U6, T6> ArgConv6, Func<U7, T7> ArgConv7, Func<U8, T8> ArgConv8, Func<TResult, UResult> ResConv) {
    return (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) => ResConv(F(ArgConv1(arg1), ArgConv2(arg2), ArgConv3(arg3), ArgConv4(arg4), ArgConv5(arg5), ArgConv6(arg6), ArgConv7(arg7), ArgConv8(arg8)));
  }
}
// end of class FuncExtensions
namespace software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types {

  public partial class __default {
    public static bool IsValid__TerminalTypeId(Dafny.ISequence<byte> x) {
      return ((new BigInteger(2)) <= (new BigInteger((x).Count))) && ((new BigInteger((x).Count)) <= (new BigInteger(2)));
    }
    public static bool IsDummySubsetType(BigInteger x) {
      return (x).Sign == 1;
    }
  }

  public interface _IDafnyCallEvent<I, O> {
    bool is_DafnyCallEvent { get; }
    I dtor_input { get; }
    O dtor_output { get; }
    _IDafnyCallEvent<__I, __O> DowncastClone<__I, __O>(Func<I, __I> converter0, Func<O, __O> converter1);
  }
  public class DafnyCallEvent<I, O> : _IDafnyCallEvent<I, O> {
    public readonly I _input;
    public readonly O _output;
    public DafnyCallEvent(I input, O output) {
      this._input = input;
      this._output = output;
    }
    public _IDafnyCallEvent<__I, __O> DowncastClone<__I, __O>(Func<I, __I> converter0, Func<O, __O> converter1) {
      if (this is _IDafnyCallEvent<__I, __O> dt) { return dt; }
      return new DafnyCallEvent<__I, __O>(converter0(_input), converter1(_output));
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.DafnyCallEvent<I, O>;
      return oth != null && object.Equals(this._input, oth._input) && object.Equals(this._output, oth._output);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._input));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._output));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.DafnyCallEvent.DafnyCallEvent";
      s += "(";
      s += Dafny.Helpers.ToString(this._input);
      s += ", ";
      s += Dafny.Helpers.ToString(this._output);
      s += ")";
      return s;
    }
    public static software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDafnyCallEvent<I, O> Default(I _default_I, O _default_O) {
      return create(_default_I, _default_O);
    }
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDafnyCallEvent<I, O>> _TypeDescriptor(Dafny.TypeDescriptor<I> _td_I, Dafny.TypeDescriptor<O> _td_O) {
      return new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDafnyCallEvent<I, O>>(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.DafnyCallEvent<I, O>.Default(_td_I.Default(), _td_O.Default()));
    }
    public static _IDafnyCallEvent<I, O> create(I input, O output) {
      return new DafnyCallEvent<I, O>(input, output);
    }
    public static _IDafnyCallEvent<I, O> create_DafnyCallEvent(I input, O output) {
      return create(input, output);
    }
    public bool is_DafnyCallEvent { get { return true; } }
    public I dtor_input {
      get {
        return this._input;
      }
    }
    public O dtor_output {
      get {
        return this._output;
      }
    }
  }

  public interface _IAuthenticateAction {
    bool is_SIGN { get; }
    bool is_DO__NOT__SIGN { get; }
    _IAuthenticateAction DowncastClone();
  }
  public abstract class AuthenticateAction : _IAuthenticateAction {
    public AuthenticateAction() {
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction theDefault = create_SIGN();
    public static software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction>(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.AuthenticateAction.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IAuthenticateAction create_SIGN() {
      return new AuthenticateAction_SIGN();
    }
    public static _IAuthenticateAction create_DO__NOT__SIGN() {
      return new AuthenticateAction_DO__NOT__SIGN();
    }
    public bool is_SIGN { get { return this is AuthenticateAction_SIGN; } }
    public bool is_DO__NOT__SIGN { get { return this is AuthenticateAction_DO__NOT__SIGN; } }
    public static System.Collections.Generic.IEnumerable<_IAuthenticateAction> AllSingletonConstructors {
      get {
        yield return AuthenticateAction.create_SIGN();
        yield return AuthenticateAction.create_DO__NOT__SIGN();
      }
    }
    public abstract _IAuthenticateAction DowncastClone();
  }
  public class AuthenticateAction_SIGN : AuthenticateAction {
    public AuthenticateAction_SIGN() : base() {
    }
    public override _IAuthenticateAction DowncastClone() {
      if (this is _IAuthenticateAction dt) { return dt; }
      return new AuthenticateAction_SIGN();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.AuthenticateAction_SIGN;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.AuthenticateAction.SIGN";
      return s;
    }
  }
  public class AuthenticateAction_DO__NOT__SIGN : AuthenticateAction {
    public AuthenticateAction_DO__NOT__SIGN() : base() {
    }
    public override _IAuthenticateAction DowncastClone() {
      if (this is _IAuthenticateAction dt) { return dt; }
      return new AuthenticateAction_DO__NOT__SIGN();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.AuthenticateAction_DO__NOT__SIGN;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.AuthenticateAction.DO_NOT_SIGN";
      return s;
    }
  }

  public interface _IAuthItem {
    bool is_AuthItem { get; }
    Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> dtor_key { get; }
    software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal dtor_data { get; }
    software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction dtor_action { get; }
    _IAuthItem DowncastClone();
  }
  public class AuthItem : _IAuthItem {
    public readonly Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> _key;
    public readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal _data;
    public readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction _action;
    public AuthItem(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> key, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal data, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction action) {
      this._key = key;
      this._data = data;
      this._action = action;
    }
    public _IAuthItem DowncastClone() {
      if (this is _IAuthItem dt) { return dt; }
      return new AuthItem(_key, _data, _action);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.AuthItem;
      return oth != null && object.Equals(this._key, oth._key) && object.Equals(this._data, oth._data) && object.Equals(this._action, oth._action);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._key));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._data));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._action));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.AuthItem.AuthItem";
      s += "(";
      s += Dafny.Helpers.ToString(this._key);
      s += ", ";
      s += Dafny.Helpers.ToString(this._data);
      s += ", ";
      s += Dafny.Helpers.ToString(this._action);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem theDefault = create(Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>.Empty, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.StructuredDataTerminal.Default(), software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.AuthenticateAction.Default());
    public static software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem>(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.AuthItem.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IAuthItem create(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> key, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal data, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction action) {
      return new AuthItem(key, data, action);
    }
    public static _IAuthItem create_AuthItem(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> key, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal data, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction action) {
      return create(key, data, action);
    }
    public bool is_AuthItem { get { return true; } }
    public Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> dtor_key {
      get {
        return this._key;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal dtor_data {
      get {
        return this._data;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction dtor_action {
      get {
        return this._action;
      }
    }
  }

  public interface _ICryptoAction {
    bool is_ENCRYPT__AND__SIGN { get; }
    bool is_SIGN__AND__INCLUDE__IN__ENCRYPTION__CONTEXT { get; }
    bool is_SIGN__ONLY { get; }
    bool is_DO__NOTHING { get; }
    _ICryptoAction DowncastClone();
  }
  public abstract class CryptoAction : _ICryptoAction {
    public CryptoAction() {
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction theDefault = create_ENCRYPT__AND__SIGN();
    public static software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICryptoAction create_ENCRYPT__AND__SIGN() {
      return new CryptoAction_ENCRYPT__AND__SIGN();
    }
    public static _ICryptoAction create_SIGN__AND__INCLUDE__IN__ENCRYPTION__CONTEXT() {
      return new CryptoAction_SIGN__AND__INCLUDE__IN__ENCRYPTION__CONTEXT();
    }
    public static _ICryptoAction create_SIGN__ONLY() {
      return new CryptoAction_SIGN__ONLY();
    }
    public static _ICryptoAction create_DO__NOTHING() {
      return new CryptoAction_DO__NOTHING();
    }
    public bool is_ENCRYPT__AND__SIGN { get { return this is CryptoAction_ENCRYPT__AND__SIGN; } }
    public bool is_SIGN__AND__INCLUDE__IN__ENCRYPTION__CONTEXT { get { return this is CryptoAction_SIGN__AND__INCLUDE__IN__ENCRYPTION__CONTEXT; } }
    public bool is_SIGN__ONLY { get { return this is CryptoAction_SIGN__ONLY; } }
    public bool is_DO__NOTHING { get { return this is CryptoAction_DO__NOTHING; } }
    public static System.Collections.Generic.IEnumerable<_ICryptoAction> AllSingletonConstructors {
      get {
        yield return CryptoAction.create_ENCRYPT__AND__SIGN();
        yield return CryptoAction.create_SIGN__AND__INCLUDE__IN__ENCRYPTION__CONTEXT();
        yield return CryptoAction.create_SIGN__ONLY();
        yield return CryptoAction.create_DO__NOTHING();
      }
    }
    public abstract _ICryptoAction DowncastClone();
  }
  public class CryptoAction_ENCRYPT__AND__SIGN : CryptoAction {
    public CryptoAction_ENCRYPT__AND__SIGN() : base() {
    }
    public override _ICryptoAction DowncastClone() {
      if (this is _ICryptoAction dt) { return dt; }
      return new CryptoAction_ENCRYPT__AND__SIGN();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction_ENCRYPT__AND__SIGN;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.CryptoAction.ENCRYPT_AND_SIGN";
      return s;
    }
  }
  public class CryptoAction_SIGN__AND__INCLUDE__IN__ENCRYPTION__CONTEXT : CryptoAction {
    public CryptoAction_SIGN__AND__INCLUDE__IN__ENCRYPTION__CONTEXT() : base() {
    }
    public override _ICryptoAction DowncastClone() {
      if (this is _ICryptoAction dt) { return dt; }
      return new CryptoAction_SIGN__AND__INCLUDE__IN__ENCRYPTION__CONTEXT();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction_SIGN__AND__INCLUDE__IN__ENCRYPTION__CONTEXT;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.CryptoAction.SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT";
      return s;
    }
  }
  public class CryptoAction_SIGN__ONLY : CryptoAction {
    public CryptoAction_SIGN__ONLY() : base() {
    }
    public override _ICryptoAction DowncastClone() {
      if (this is _ICryptoAction dt) { return dt; }
      return new CryptoAction_SIGN__ONLY();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction_SIGN__ONLY;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.CryptoAction.SIGN_ONLY";
      return s;
    }
  }
  public class CryptoAction_DO__NOTHING : CryptoAction {
    public CryptoAction_DO__NOTHING() : base() {
    }
    public override _ICryptoAction DowncastClone() {
      if (this is _ICryptoAction dt) { return dt; }
      return new CryptoAction_DO__NOTHING();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction_DO__NOTHING;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 3;
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.CryptoAction.DO_NOTHING";
      return s;
    }
  }

  public interface _ICryptoItem {
    bool is_CryptoItem { get; }
    Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> dtor_key { get; }
    software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal dtor_data { get; }
    software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction dtor_action { get; }
    _ICryptoItem DowncastClone();
  }
  public class CryptoItem : _ICryptoItem {
    public readonly Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> _key;
    public readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal _data;
    public readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction _action;
    public CryptoItem(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> key, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal data, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction action) {
      this._key = key;
      this._data = data;
      this._action = action;
    }
    public _ICryptoItem DowncastClone() {
      if (this is _ICryptoItem dt) { return dt; }
      return new CryptoItem(_key, _data, _action);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoItem;
      return oth != null && object.Equals(this._key, oth._key) && object.Equals(this._data, oth._data) && object.Equals(this._action, oth._action);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._key));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._data));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._action));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.CryptoItem.CryptoItem";
      s += "(";
      s += Dafny.Helpers.ToString(this._key);
      s += ", ";
      s += Dafny.Helpers.ToString(this._data);
      s += ", ";
      s += Dafny.Helpers.ToString(this._action);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem theDefault = create(Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>.Empty, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.StructuredDataTerminal.Default(), software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.Default());
    public static software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoItem.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICryptoItem create(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> key, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal data, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction action) {
      return new CryptoItem(key, data, action);
    }
    public static _ICryptoItem create_CryptoItem(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> key, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal data, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction action) {
      return create(key, data, action);
    }
    public bool is_CryptoItem { get { return true; } }
    public Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> dtor_key {
      get {
        return this._key;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal dtor_data {
      get {
        return this._data;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction dtor_action {
      get {
        return this._action;
      }
    }
  }

  public interface _IDecryptPathStructureInput {
    bool is_DecryptPathStructureInput { get; }
    Dafny.ISequence<char> dtor_tableName { get; }
    Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem> dtor_encryptedStructure { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager dtor_cmm { get; }
    Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> dtor_encryptionContext { get; }
    _IDecryptPathStructureInput DowncastClone();
  }
  public class DecryptPathStructureInput : _IDecryptPathStructureInput {
    public readonly Dafny.ISequence<char> _tableName;
    public readonly Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem> _encryptedStructure;
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager _cmm;
    public readonly Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> _encryptionContext;
    public DecryptPathStructureInput(Dafny.ISequence<char> tableName, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem> encryptedStructure, software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager cmm, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> encryptionContext) {
      this._tableName = tableName;
      this._encryptedStructure = encryptedStructure;
      this._cmm = cmm;
      this._encryptionContext = encryptionContext;
    }
    public _IDecryptPathStructureInput DowncastClone() {
      if (this is _IDecryptPathStructureInput dt) { return dt; }
      return new DecryptPathStructureInput(_tableName, _encryptedStructure, _cmm, _encryptionContext);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.DecryptPathStructureInput;
      return oth != null && object.Equals(this._tableName, oth._tableName) && object.Equals(this._encryptedStructure, oth._encryptedStructure) && this._cmm == oth._cmm && object.Equals(this._encryptionContext, oth._encryptionContext);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._tableName));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptedStructure));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._cmm));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptionContext));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.DecryptPathStructureInput.DecryptPathStructureInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._tableName);
      s += ", ";
      s += Dafny.Helpers.ToString(this._encryptedStructure);
      s += ", ";
      s += Dafny.Helpers.ToString(this._cmm);
      s += ", ";
      s += Dafny.Helpers.ToString(this._encryptionContext);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureInput theDefault = create(Dafny.Sequence<char>.Empty, Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem>.Empty, default(software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager), Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>.Default());
    public static software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureInput>(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.DecryptPathStructureInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IDecryptPathStructureInput create(Dafny.ISequence<char> tableName, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem> encryptedStructure, software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager cmm, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> encryptionContext) {
      return new DecryptPathStructureInput(tableName, encryptedStructure, cmm, encryptionContext);
    }
    public static _IDecryptPathStructureInput create_DecryptPathStructureInput(Dafny.ISequence<char> tableName, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem> encryptedStructure, software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager cmm, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> encryptionContext) {
      return create(tableName, encryptedStructure, cmm, encryptionContext);
    }
    public bool is_DecryptPathStructureInput { get { return true; } }
    public Dafny.ISequence<char> dtor_tableName {
      get {
        return this._tableName;
      }
    }
    public Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem> dtor_encryptedStructure {
      get {
        return this._encryptedStructure;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager dtor_cmm {
      get {
        return this._cmm;
      }
    }
    public Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> dtor_encryptionContext {
      get {
        return this._encryptionContext;
      }
    }
  }

  public interface _IDecryptPathStructureOutput {
    bool is_DecryptPathStructureOutput { get; }
    Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> dtor_plaintextStructure { get; }
    software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IParsedHeader dtor_parsedHeader { get; }
    _IDecryptPathStructureOutput DowncastClone();
  }
  public class DecryptPathStructureOutput : _IDecryptPathStructureOutput {
    public readonly Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> _plaintextStructure;
    public readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IParsedHeader _parsedHeader;
    public DecryptPathStructureOutput(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> plaintextStructure, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IParsedHeader parsedHeader) {
      this._plaintextStructure = plaintextStructure;
      this._parsedHeader = parsedHeader;
    }
    public _IDecryptPathStructureOutput DowncastClone() {
      if (this is _IDecryptPathStructureOutput dt) { return dt; }
      return new DecryptPathStructureOutput(_plaintextStructure, _parsedHeader);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.DecryptPathStructureOutput;
      return oth != null && object.Equals(this._plaintextStructure, oth._plaintextStructure) && object.Equals(this._parsedHeader, oth._parsedHeader);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._plaintextStructure));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._parsedHeader));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.DecryptPathStructureOutput.DecryptPathStructureOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._plaintextStructure);
      s += ", ";
      s += Dafny.Helpers.ToString(this._parsedHeader);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput theDefault = create(Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>.Empty, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.ParsedHeader.Default());
    public static software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput>(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.DecryptPathStructureOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IDecryptPathStructureOutput create(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> plaintextStructure, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IParsedHeader parsedHeader) {
      return new DecryptPathStructureOutput(plaintextStructure, parsedHeader);
    }
    public static _IDecryptPathStructureOutput create_DecryptPathStructureOutput(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> plaintextStructure, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IParsedHeader parsedHeader) {
      return create(plaintextStructure, parsedHeader);
    }
    public bool is_DecryptPathStructureOutput { get { return true; } }
    public Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> dtor_plaintextStructure {
      get {
        return this._plaintextStructure;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IParsedHeader dtor_parsedHeader {
      get {
        return this._parsedHeader;
      }
    }
  }

  public interface _IDecryptStructureInput {
    bool is_DecryptStructureInput { get; }
    Dafny.ISequence<char> dtor_tableName { get; }
    Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> dtor_encryptedStructure { get; }
    Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction> dtor_authenticateSchema { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager dtor_cmm { get; }
    Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> dtor_encryptionContext { get; }
    _IDecryptStructureInput DowncastClone();
  }
  public class DecryptStructureInput : _IDecryptStructureInput {
    public readonly Dafny.ISequence<char> _tableName;
    public readonly Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> _encryptedStructure;
    public readonly Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction> _authenticateSchema;
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager _cmm;
    public readonly Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> _encryptionContext;
    public DecryptStructureInput(Dafny.ISequence<char> tableName, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> encryptedStructure, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction> authenticateSchema, software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager cmm, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> encryptionContext) {
      this._tableName = tableName;
      this._encryptedStructure = encryptedStructure;
      this._authenticateSchema = authenticateSchema;
      this._cmm = cmm;
      this._encryptionContext = encryptionContext;
    }
    public _IDecryptStructureInput DowncastClone() {
      if (this is _IDecryptStructureInput dt) { return dt; }
      return new DecryptStructureInput(_tableName, _encryptedStructure, _authenticateSchema, _cmm, _encryptionContext);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.DecryptStructureInput;
      return oth != null && object.Equals(this._tableName, oth._tableName) && object.Equals(this._encryptedStructure, oth._encryptedStructure) && object.Equals(this._authenticateSchema, oth._authenticateSchema) && this._cmm == oth._cmm && object.Equals(this._encryptionContext, oth._encryptionContext);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._tableName));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptedStructure));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._authenticateSchema));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._cmm));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptionContext));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.DecryptStructureInput.DecryptStructureInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._tableName);
      s += ", ";
      s += Dafny.Helpers.ToString(this._encryptedStructure);
      s += ", ";
      s += Dafny.Helpers.ToString(this._authenticateSchema);
      s += ", ";
      s += Dafny.Helpers.ToString(this._cmm);
      s += ", ";
      s += Dafny.Helpers.ToString(this._encryptionContext);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptStructureInput theDefault = create(Dafny.Sequence<char>.Empty, Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>.Empty, Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction>.Empty, default(software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager), Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>.Default());
    public static software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptStructureInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptStructureInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptStructureInput>(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.DecryptStructureInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptStructureInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IDecryptStructureInput create(Dafny.ISequence<char> tableName, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> encryptedStructure, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction> authenticateSchema, software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager cmm, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> encryptionContext) {
      return new DecryptStructureInput(tableName, encryptedStructure, authenticateSchema, cmm, encryptionContext);
    }
    public static _IDecryptStructureInput create_DecryptStructureInput(Dafny.ISequence<char> tableName, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> encryptedStructure, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction> authenticateSchema, software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager cmm, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> encryptionContext) {
      return create(tableName, encryptedStructure, authenticateSchema, cmm, encryptionContext);
    }
    public bool is_DecryptStructureInput { get { return true; } }
    public Dafny.ISequence<char> dtor_tableName {
      get {
        return this._tableName;
      }
    }
    public Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> dtor_encryptedStructure {
      get {
        return this._encryptedStructure;
      }
    }
    public Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction> dtor_authenticateSchema {
      get {
        return this._authenticateSchema;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager dtor_cmm {
      get {
        return this._cmm;
      }
    }
    public Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> dtor_encryptionContext {
      get {
        return this._encryptionContext;
      }
    }
  }

  public interface _IDecryptStructureOutput {
    bool is_DecryptStructureOutput { get; }
    Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> dtor_plaintextStructure { get; }
    Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> dtor_cryptoSchema { get; }
    software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IParsedHeader dtor_parsedHeader { get; }
    _IDecryptStructureOutput DowncastClone();
  }
  public class DecryptStructureOutput : _IDecryptStructureOutput {
    public readonly Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> _plaintextStructure;
    public readonly Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> _cryptoSchema;
    public readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IParsedHeader _parsedHeader;
    public DecryptStructureOutput(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> plaintextStructure, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> cryptoSchema, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IParsedHeader parsedHeader) {
      this._plaintextStructure = plaintextStructure;
      this._cryptoSchema = cryptoSchema;
      this._parsedHeader = parsedHeader;
    }
    public _IDecryptStructureOutput DowncastClone() {
      if (this is _IDecryptStructureOutput dt) { return dt; }
      return new DecryptStructureOutput(_plaintextStructure, _cryptoSchema, _parsedHeader);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.DecryptStructureOutput;
      return oth != null && object.Equals(this._plaintextStructure, oth._plaintextStructure) && object.Equals(this._cryptoSchema, oth._cryptoSchema) && object.Equals(this._parsedHeader, oth._parsedHeader);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._plaintextStructure));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._cryptoSchema));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._parsedHeader));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.DecryptStructureOutput.DecryptStructureOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._plaintextStructure);
      s += ", ";
      s += Dafny.Helpers.ToString(this._cryptoSchema);
      s += ", ";
      s += Dafny.Helpers.ToString(this._parsedHeader);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptStructureOutput theDefault = create(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>.Empty, Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Empty, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.ParsedHeader.Default());
    public static software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptStructureOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptStructureOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptStructureOutput>(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.DecryptStructureOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptStructureOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IDecryptStructureOutput create(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> plaintextStructure, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> cryptoSchema, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IParsedHeader parsedHeader) {
      return new DecryptStructureOutput(plaintextStructure, cryptoSchema, parsedHeader);
    }
    public static _IDecryptStructureOutput create_DecryptStructureOutput(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> plaintextStructure, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> cryptoSchema, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IParsedHeader parsedHeader) {
      return create(plaintextStructure, cryptoSchema, parsedHeader);
    }
    public bool is_DecryptStructureOutput { get { return true; } }
    public Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> dtor_plaintextStructure {
      get {
        return this._plaintextStructure;
      }
    }
    public Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> dtor_cryptoSchema {
      get {
        return this._cryptoSchema;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IParsedHeader dtor_parsedHeader {
      get {
        return this._parsedHeader;
      }
    }
  }

  public interface _IEncryptPathStructureInput {
    bool is_EncryptPathStructureInput { get; }
    Dafny.ISequence<char> dtor_tableName { get; }
    Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> dtor_plaintextStructure { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager dtor_cmm { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> dtor_algorithmSuiteId { get; }
    Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> dtor_encryptionContext { get; }
    _IEncryptPathStructureInput DowncastClone();
  }
  public class EncryptPathStructureInput : _IEncryptPathStructureInput {
    public readonly Dafny.ISequence<char> _tableName;
    public readonly Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> _plaintextStructure;
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager _cmm;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> _algorithmSuiteId;
    public readonly Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> _encryptionContext;
    public EncryptPathStructureInput(Dafny.ISequence<char> tableName, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> plaintextStructure, software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager cmm, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> algorithmSuiteId, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> encryptionContext) {
      this._tableName = tableName;
      this._plaintextStructure = plaintextStructure;
      this._cmm = cmm;
      this._algorithmSuiteId = algorithmSuiteId;
      this._encryptionContext = encryptionContext;
    }
    public _IEncryptPathStructureInput DowncastClone() {
      if (this is _IEncryptPathStructureInput dt) { return dt; }
      return new EncryptPathStructureInput(_tableName, _plaintextStructure, _cmm, _algorithmSuiteId, _encryptionContext);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.EncryptPathStructureInput;
      return oth != null && object.Equals(this._tableName, oth._tableName) && object.Equals(this._plaintextStructure, oth._plaintextStructure) && this._cmm == oth._cmm && object.Equals(this._algorithmSuiteId, oth._algorithmSuiteId) && object.Equals(this._encryptionContext, oth._encryptionContext);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._tableName));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._plaintextStructure));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._cmm));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._algorithmSuiteId));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptionContext));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.EncryptPathStructureInput.EncryptPathStructureInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._tableName);
      s += ", ";
      s += Dafny.Helpers.ToString(this._plaintextStructure);
      s += ", ";
      s += Dafny.Helpers.ToString(this._cmm);
      s += ", ";
      s += Dafny.Helpers.ToString(this._algorithmSuiteId);
      s += ", ";
      s += Dafny.Helpers.ToString(this._encryptionContext);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureInput theDefault = create(Dafny.Sequence<char>.Empty, Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>.Empty, default(software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager), Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId>.Default(), Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>.Default());
    public static software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureInput>(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.EncryptPathStructureInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IEncryptPathStructureInput create(Dafny.ISequence<char> tableName, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> plaintextStructure, software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager cmm, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> algorithmSuiteId, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> encryptionContext) {
      return new EncryptPathStructureInput(tableName, plaintextStructure, cmm, algorithmSuiteId, encryptionContext);
    }
    public static _IEncryptPathStructureInput create_EncryptPathStructureInput(Dafny.ISequence<char> tableName, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> plaintextStructure, software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager cmm, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> algorithmSuiteId, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> encryptionContext) {
      return create(tableName, plaintextStructure, cmm, algorithmSuiteId, encryptionContext);
    }
    public bool is_EncryptPathStructureInput { get { return true; } }
    public Dafny.ISequence<char> dtor_tableName {
      get {
        return this._tableName;
      }
    }
    public Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> dtor_plaintextStructure {
      get {
        return this._plaintextStructure;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager dtor_cmm {
      get {
        return this._cmm;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> dtor_algorithmSuiteId {
      get {
        return this._algorithmSuiteId;
      }
    }
    public Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> dtor_encryptionContext {
      get {
        return this._encryptionContext;
      }
    }
  }

  public interface _IEncryptPathStructureOutput {
    bool is_EncryptPathStructureOutput { get; }
    Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> dtor_encryptedStructure { get; }
    software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IParsedHeader dtor_parsedHeader { get; }
    _IEncryptPathStructureOutput DowncastClone();
  }
  public class EncryptPathStructureOutput : _IEncryptPathStructureOutput {
    public readonly Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> _encryptedStructure;
    public readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IParsedHeader _parsedHeader;
    public EncryptPathStructureOutput(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> encryptedStructure, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IParsedHeader parsedHeader) {
      this._encryptedStructure = encryptedStructure;
      this._parsedHeader = parsedHeader;
    }
    public _IEncryptPathStructureOutput DowncastClone() {
      if (this is _IEncryptPathStructureOutput dt) { return dt; }
      return new EncryptPathStructureOutput(_encryptedStructure, _parsedHeader);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.EncryptPathStructureOutput;
      return oth != null && object.Equals(this._encryptedStructure, oth._encryptedStructure) && object.Equals(this._parsedHeader, oth._parsedHeader);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptedStructure));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._parsedHeader));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.EncryptPathStructureOutput.EncryptPathStructureOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._encryptedStructure);
      s += ", ";
      s += Dafny.Helpers.ToString(this._parsedHeader);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput theDefault = create(Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>.Empty, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.ParsedHeader.Default());
    public static software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput>(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.EncryptPathStructureOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IEncryptPathStructureOutput create(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> encryptedStructure, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IParsedHeader parsedHeader) {
      return new EncryptPathStructureOutput(encryptedStructure, parsedHeader);
    }
    public static _IEncryptPathStructureOutput create_EncryptPathStructureOutput(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> encryptedStructure, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IParsedHeader parsedHeader) {
      return create(encryptedStructure, parsedHeader);
    }
    public bool is_EncryptPathStructureOutput { get { return true; } }
    public Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> dtor_encryptedStructure {
      get {
        return this._encryptedStructure;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IParsedHeader dtor_parsedHeader {
      get {
        return this._parsedHeader;
      }
    }
  }

  public interface _IEncryptStructureInput {
    bool is_EncryptStructureInput { get; }
    Dafny.ISequence<char> dtor_tableName { get; }
    Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> dtor_plaintextStructure { get; }
    Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> dtor_cryptoSchema { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager dtor_cmm { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> dtor_algorithmSuiteId { get; }
    Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> dtor_encryptionContext { get; }
    _IEncryptStructureInput DowncastClone();
  }
  public class EncryptStructureInput : _IEncryptStructureInput {
    public readonly Dafny.ISequence<char> _tableName;
    public readonly Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> _plaintextStructure;
    public readonly Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> _cryptoSchema;
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager _cmm;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> _algorithmSuiteId;
    public readonly Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> _encryptionContext;
    public EncryptStructureInput(Dafny.ISequence<char> tableName, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> plaintextStructure, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> cryptoSchema, software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager cmm, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> algorithmSuiteId, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> encryptionContext) {
      this._tableName = tableName;
      this._plaintextStructure = plaintextStructure;
      this._cryptoSchema = cryptoSchema;
      this._cmm = cmm;
      this._algorithmSuiteId = algorithmSuiteId;
      this._encryptionContext = encryptionContext;
    }
    public _IEncryptStructureInput DowncastClone() {
      if (this is _IEncryptStructureInput dt) { return dt; }
      return new EncryptStructureInput(_tableName, _plaintextStructure, _cryptoSchema, _cmm, _algorithmSuiteId, _encryptionContext);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.EncryptStructureInput;
      return oth != null && object.Equals(this._tableName, oth._tableName) && object.Equals(this._plaintextStructure, oth._plaintextStructure) && object.Equals(this._cryptoSchema, oth._cryptoSchema) && this._cmm == oth._cmm && object.Equals(this._algorithmSuiteId, oth._algorithmSuiteId) && object.Equals(this._encryptionContext, oth._encryptionContext);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._tableName));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._plaintextStructure));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._cryptoSchema));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._cmm));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._algorithmSuiteId));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptionContext));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.EncryptStructureInput.EncryptStructureInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._tableName);
      s += ", ";
      s += Dafny.Helpers.ToString(this._plaintextStructure);
      s += ", ";
      s += Dafny.Helpers.ToString(this._cryptoSchema);
      s += ", ";
      s += Dafny.Helpers.ToString(this._cmm);
      s += ", ";
      s += Dafny.Helpers.ToString(this._algorithmSuiteId);
      s += ", ";
      s += Dafny.Helpers.ToString(this._encryptionContext);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureInput theDefault = create(Dafny.Sequence<char>.Empty, Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>.Empty, Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Empty, default(software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager), Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId>.Default(), Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>.Default());
    public static software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureInput>(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.EncryptStructureInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IEncryptStructureInput create(Dafny.ISequence<char> tableName, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> plaintextStructure, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> cryptoSchema, software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager cmm, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> algorithmSuiteId, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> encryptionContext) {
      return new EncryptStructureInput(tableName, plaintextStructure, cryptoSchema, cmm, algorithmSuiteId, encryptionContext);
    }
    public static _IEncryptStructureInput create_EncryptStructureInput(Dafny.ISequence<char> tableName, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> plaintextStructure, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> cryptoSchema, software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager cmm, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> algorithmSuiteId, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> encryptionContext) {
      return create(tableName, plaintextStructure, cryptoSchema, cmm, algorithmSuiteId, encryptionContext);
    }
    public bool is_EncryptStructureInput { get { return true; } }
    public Dafny.ISequence<char> dtor_tableName {
      get {
        return this._tableName;
      }
    }
    public Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> dtor_plaintextStructure {
      get {
        return this._plaintextStructure;
      }
    }
    public Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> dtor_cryptoSchema {
      get {
        return this._cryptoSchema;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager dtor_cmm {
      get {
        return this._cmm;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> dtor_algorithmSuiteId {
      get {
        return this._algorithmSuiteId;
      }
    }
    public Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> dtor_encryptionContext {
      get {
        return this._encryptionContext;
      }
    }
  }

  public interface _IEncryptStructureOutput {
    bool is_EncryptStructureOutput { get; }
    Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> dtor_encryptedStructure { get; }
    Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> dtor_cryptoSchema { get; }
    software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IParsedHeader dtor_parsedHeader { get; }
    _IEncryptStructureOutput DowncastClone();
  }
  public class EncryptStructureOutput : _IEncryptStructureOutput {
    public readonly Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> _encryptedStructure;
    public readonly Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> _cryptoSchema;
    public readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IParsedHeader _parsedHeader;
    public EncryptStructureOutput(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> encryptedStructure, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> cryptoSchema, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IParsedHeader parsedHeader) {
      this._encryptedStructure = encryptedStructure;
      this._cryptoSchema = cryptoSchema;
      this._parsedHeader = parsedHeader;
    }
    public _IEncryptStructureOutput DowncastClone() {
      if (this is _IEncryptStructureOutput dt) { return dt; }
      return new EncryptStructureOutput(_encryptedStructure, _cryptoSchema, _parsedHeader);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.EncryptStructureOutput;
      return oth != null && object.Equals(this._encryptedStructure, oth._encryptedStructure) && object.Equals(this._cryptoSchema, oth._cryptoSchema) && object.Equals(this._parsedHeader, oth._parsedHeader);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptedStructure));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._cryptoSchema));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._parsedHeader));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.EncryptStructureOutput.EncryptStructureOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._encryptedStructure);
      s += ", ";
      s += Dafny.Helpers.ToString(this._cryptoSchema);
      s += ", ";
      s += Dafny.Helpers.ToString(this._parsedHeader);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureOutput theDefault = create(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>.Empty, Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Empty, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.ParsedHeader.Default());
    public static software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureOutput>(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.EncryptStructureOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IEncryptStructureOutput create(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> encryptedStructure, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> cryptoSchema, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IParsedHeader parsedHeader) {
      return new EncryptStructureOutput(encryptedStructure, cryptoSchema, parsedHeader);
    }
    public static _IEncryptStructureOutput create_EncryptStructureOutput(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> encryptedStructure, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> cryptoSchema, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IParsedHeader parsedHeader) {
      return create(encryptedStructure, cryptoSchema, parsedHeader);
    }
    public bool is_EncryptStructureOutput { get { return true; } }
    public Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> dtor_encryptedStructure {
      get {
        return this._encryptedStructure;
      }
    }
    public Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> dtor_cryptoSchema {
      get {
        return this._cryptoSchema;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IParsedHeader dtor_parsedHeader {
      get {
        return this._parsedHeader;
      }
    }
  }

  public interface _IParsedHeader {
    bool is_ParsedHeader { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId dtor_algorithmSuiteId { get; }
    Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> dtor_encryptedDataKeys { get; }
    Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_storedEncryptionContext { get; }
    Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext { get; }
    _IParsedHeader DowncastClone();
  }
  public class ParsedHeader : _IParsedHeader {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId _algorithmSuiteId;
    public readonly Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> _encryptedDataKeys;
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _storedEncryptionContext;
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _encryptionContext;
    public ParsedHeader(software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId algorithmSuiteId, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> encryptedDataKeys, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> storedEncryptionContext, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext) {
      this._algorithmSuiteId = algorithmSuiteId;
      this._encryptedDataKeys = encryptedDataKeys;
      this._storedEncryptionContext = storedEncryptionContext;
      this._encryptionContext = encryptionContext;
    }
    public _IParsedHeader DowncastClone() {
      if (this is _IParsedHeader dt) { return dt; }
      return new ParsedHeader(_algorithmSuiteId, _encryptedDataKeys, _storedEncryptionContext, _encryptionContext);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.ParsedHeader;
      return oth != null && object.Equals(this._algorithmSuiteId, oth._algorithmSuiteId) && object.Equals(this._encryptedDataKeys, oth._encryptedDataKeys) && object.Equals(this._storedEncryptionContext, oth._storedEncryptionContext) && object.Equals(this._encryptionContext, oth._encryptionContext);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._algorithmSuiteId));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptedDataKeys));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._storedEncryptionContext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptionContext));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.ParsedHeader.ParsedHeader";
      s += "(";
      s += Dafny.Helpers.ToString(this._algorithmSuiteId);
      s += ", ";
      s += Dafny.Helpers.ToString(this._encryptedDataKeys);
      s += ", ";
      s += Dafny.Helpers.ToString(this._storedEncryptionContext);
      s += ", ";
      s += Dafny.Helpers.ToString(this._encryptionContext);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IParsedHeader theDefault = create(software.amazon.cryptography.materialproviders.internaldafny.types.DBEAlgorithmSuiteId.Default(), Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.Empty, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty);
    public static software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IParsedHeader Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IParsedHeader> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IParsedHeader>(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.ParsedHeader.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IParsedHeader> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IParsedHeader create(software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId algorithmSuiteId, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> encryptedDataKeys, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> storedEncryptionContext, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext) {
      return new ParsedHeader(algorithmSuiteId, encryptedDataKeys, storedEncryptionContext, encryptionContext);
    }
    public static _IParsedHeader create_ParsedHeader(software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId algorithmSuiteId, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> encryptedDataKeys, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> storedEncryptionContext, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext) {
      return create(algorithmSuiteId, encryptedDataKeys, storedEncryptionContext, encryptionContext);
    }
    public bool is_ParsedHeader { get { return true; } }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId dtor_algorithmSuiteId {
      get {
        return this._algorithmSuiteId;
      }
    }
    public Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> dtor_encryptedDataKeys {
      get {
        return this._encryptedDataKeys;
      }
    }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_storedEncryptionContext {
      get {
        return this._storedEncryptionContext;
      }
    }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this._encryptionContext;
      }
    }
  }

  public interface _IPathSegment {
    bool is_member { get; }
    software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructureSegment dtor_member { get; }
    _IPathSegment DowncastClone();
  }
  public class PathSegment : _IPathSegment {
    public readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructureSegment _member;
    public PathSegment(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructureSegment member) {
      this._member = member;
    }
    public _IPathSegment DowncastClone() {
      if (this is _IPathSegment dt) { return dt; }
      return new PathSegment(_member);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.PathSegment;
      return oth != null && object.Equals(this._member, oth._member);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._member));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.PathSegment.member";
      s += "(";
      s += Dafny.Helpers.ToString(this._member);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment theDefault = create(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.StructureSegment.Default());
    public static software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.PathSegment.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IPathSegment create(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructureSegment member) {
      return new PathSegment(member);
    }
    public static _IPathSegment create_member(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructureSegment member) {
      return create(member);
    }
    public bool is_member { get { return true; } }
    public software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructureSegment dtor_member {
      get {
        return this._member;
      }
    }
  }

  public interface _IResolveAuthActionsInput {
    bool is_ResolveAuthActionsInput { get; }
    Dafny.ISequence<char> dtor_tableName { get; }
    Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem> dtor_authActions { get; }
    Dafny.ISequence<byte> dtor_headerBytes { get; }
    _IResolveAuthActionsInput DowncastClone();
  }
  public class ResolveAuthActionsInput : _IResolveAuthActionsInput {
    public readonly Dafny.ISequence<char> _tableName;
    public readonly Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem> _authActions;
    public readonly Dafny.ISequence<byte> _headerBytes;
    public ResolveAuthActionsInput(Dafny.ISequence<char> tableName, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem> authActions, Dafny.ISequence<byte> headerBytes) {
      this._tableName = tableName;
      this._authActions = authActions;
      this._headerBytes = headerBytes;
    }
    public _IResolveAuthActionsInput DowncastClone() {
      if (this is _IResolveAuthActionsInput dt) { return dt; }
      return new ResolveAuthActionsInput(_tableName, _authActions, _headerBytes);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.ResolveAuthActionsInput;
      return oth != null && object.Equals(this._tableName, oth._tableName) && object.Equals(this._authActions, oth._authActions) && object.Equals(this._headerBytes, oth._headerBytes);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._tableName));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._authActions));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._headerBytes));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.ResolveAuthActionsInput.ResolveAuthActionsInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._tableName);
      s += ", ";
      s += Dafny.Helpers.ToString(this._authActions);
      s += ", ";
      s += Dafny.Helpers.ToString(this._headerBytes);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IResolveAuthActionsInput theDefault = create(Dafny.Sequence<char>.Empty, Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem>.Empty, Dafny.Sequence<byte>.Empty);
    public static software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IResolveAuthActionsInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IResolveAuthActionsInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IResolveAuthActionsInput>(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.ResolveAuthActionsInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IResolveAuthActionsInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IResolveAuthActionsInput create(Dafny.ISequence<char> tableName, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem> authActions, Dafny.ISequence<byte> headerBytes) {
      return new ResolveAuthActionsInput(tableName, authActions, headerBytes);
    }
    public static _IResolveAuthActionsInput create_ResolveAuthActionsInput(Dafny.ISequence<char> tableName, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem> authActions, Dafny.ISequence<byte> headerBytes) {
      return create(tableName, authActions, headerBytes);
    }
    public bool is_ResolveAuthActionsInput { get { return true; } }
    public Dafny.ISequence<char> dtor_tableName {
      get {
        return this._tableName;
      }
    }
    public Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem> dtor_authActions {
      get {
        return this._authActions;
      }
    }
    public Dafny.ISequence<byte> dtor_headerBytes {
      get {
        return this._headerBytes;
      }
    }
  }

  public interface _IResolveAuthActionsOutput {
    bool is_ResolveAuthActionsOutput { get; }
    Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> dtor_cryptoActions { get; }
    _IResolveAuthActionsOutput DowncastClone();
  }
  public class ResolveAuthActionsOutput : _IResolveAuthActionsOutput {
    public readonly Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> _cryptoActions;
    public ResolveAuthActionsOutput(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> cryptoActions) {
      this._cryptoActions = cryptoActions;
    }
    public _IResolveAuthActionsOutput DowncastClone() {
      if (this is _IResolveAuthActionsOutput dt) { return dt; }
      return new ResolveAuthActionsOutput(_cryptoActions);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.ResolveAuthActionsOutput;
      return oth != null && object.Equals(this._cryptoActions, oth._cryptoActions);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._cryptoActions));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.ResolveAuthActionsOutput.ResolveAuthActionsOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._cryptoActions);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IResolveAuthActionsOutput theDefault = create(Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>.Empty);
    public static software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IResolveAuthActionsOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IResolveAuthActionsOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IResolveAuthActionsOutput>(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.ResolveAuthActionsOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IResolveAuthActionsOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IResolveAuthActionsOutput create(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> cryptoActions) {
      return new ResolveAuthActionsOutput(cryptoActions);
    }
    public static _IResolveAuthActionsOutput create_ResolveAuthActionsOutput(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> cryptoActions) {
      return create(cryptoActions);
    }
    public bool is_ResolveAuthActionsOutput { get { return true; } }
    public Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> dtor_cryptoActions {
      get {
        return this._cryptoActions;
      }
    }
  }

  public interface _IStructuredDataTerminal {
    bool is_StructuredDataTerminal { get; }
    Dafny.ISequence<byte> dtor_value { get; }
    Dafny.ISequence<byte> dtor_typeId { get; }
    _IStructuredDataTerminal DowncastClone();
  }
  public class StructuredDataTerminal : _IStructuredDataTerminal {
    public readonly Dafny.ISequence<byte> _value;
    public readonly Dafny.ISequence<byte> _typeId;
    public StructuredDataTerminal(Dafny.ISequence<byte> @value, Dafny.ISequence<byte> typeId) {
      this._value = @value;
      this._typeId = typeId;
    }
    public _IStructuredDataTerminal DowncastClone() {
      if (this is _IStructuredDataTerminal dt) { return dt; }
      return new StructuredDataTerminal(_value, _typeId);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.StructuredDataTerminal;
      return oth != null && object.Equals(this._value, oth._value) && object.Equals(this._typeId, oth._typeId);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._value));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._typeId));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.StructuredDataTerminal.StructuredDataTerminal";
      s += "(";
      s += Dafny.Helpers.ToString(this._value);
      s += ", ";
      s += Dafny.Helpers.ToString(this._typeId);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal theDefault = create(Dafny.Sequence<byte>.Empty, Dafny.Sequence<byte>.Empty);
    public static software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.StructuredDataTerminal.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IStructuredDataTerminal create(Dafny.ISequence<byte> @value, Dafny.ISequence<byte> typeId) {
      return new StructuredDataTerminal(@value, typeId);
    }
    public static _IStructuredDataTerminal create_StructuredDataTerminal(Dafny.ISequence<byte> @value, Dafny.ISequence<byte> typeId) {
      return create(@value, typeId);
    }
    public bool is_StructuredDataTerminal { get { return true; } }
    public Dafny.ISequence<byte> dtor_value {
      get {
        return this._value;
      }
    }
    public Dafny.ISequence<byte> dtor_typeId {
      get {
        return this._typeId;
      }
    }
  }

  public partial class IStructuredEncryptionClientCallHistory {
    public IStructuredEncryptionClientCallHistory() {
    }
  }

  public interface IStructuredEncryptionClient {
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> EncryptStructure(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> DecryptStructure(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptStructureInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> EncryptPathStructure(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> DecryptPathStructure(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IResolveAuthActionsOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> ResolveAuthActions(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IResolveAuthActionsInput input);
  }
  public class _Companion_IStructuredEncryptionClient {
  }

  public interface _IStructuredEncryptionConfig {
    bool is_StructuredEncryptionConfig { get; }
    _IStructuredEncryptionConfig DowncastClone();
  }
  public class StructuredEncryptionConfig : _IStructuredEncryptionConfig {
    public StructuredEncryptionConfig() {
    }
    public _IStructuredEncryptionConfig DowncastClone() {
      if (this is _IStructuredEncryptionConfig dt) { return dt; }
      return new StructuredEncryptionConfig();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.StructuredEncryptionConfig;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.StructuredEncryptionConfig.StructuredEncryptionConfig";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredEncryptionConfig theDefault = create();
    public static software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredEncryptionConfig Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredEncryptionConfig> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredEncryptionConfig>(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.StructuredEncryptionConfig.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredEncryptionConfig> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IStructuredEncryptionConfig create() {
      return new StructuredEncryptionConfig();
    }
    public static _IStructuredEncryptionConfig create_StructuredEncryptionConfig() {
      return create();
    }
    public bool is_StructuredEncryptionConfig { get { return true; } }
    public static System.Collections.Generic.IEnumerable<_IStructuredEncryptionConfig> AllSingletonConstructors {
      get {
        yield return StructuredEncryptionConfig.create();
      }
    }
  }

  public interface _IStructureSegment {
    bool is_StructureSegment { get; }
    Dafny.ISequence<char> dtor_key { get; }
    _IStructureSegment DowncastClone();
  }
  public class StructureSegment : _IStructureSegment {
    public readonly Dafny.ISequence<char> _key;
    public StructureSegment(Dafny.ISequence<char> key) {
      this._key = key;
    }
    public _IStructureSegment DowncastClone() {
      if (this is _IStructureSegment dt) { return dt; }
      return new StructureSegment(_key);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.StructureSegment;
      return oth != null && object.Equals(this._key, oth._key);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._key));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.StructureSegment.StructureSegment";
      s += "(";
      s += Dafny.Helpers.ToString(this._key);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructureSegment theDefault = create(Dafny.Sequence<char>.Empty);
    public static software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructureSegment Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructureSegment> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructureSegment>(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.StructureSegment.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructureSegment> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IStructureSegment create(Dafny.ISequence<char> key) {
      return new StructureSegment(key);
    }
    public static _IStructureSegment create_StructureSegment(Dafny.ISequence<char> key) {
      return create(key);
    }
    public bool is_StructureSegment { get { return true; } }
    public Dafny.ISequence<char> dtor_key {
      get {
        return this._key;
      }
    }
  }

  public partial class TerminalTypeId {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<byte>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<byte>>(Dafny.Sequence<byte>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<byte>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.ISequence<byte> __source) {
      Dafny.ISequence<byte> _0_x = __source;
      return software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.__default.IsValid__TerminalTypeId(_0_x);
    }
  }

  public interface _IError {
    bool is_StructuredEncryptionException { get; }
    bool is_AwsCryptographyMaterialProviders { get; }
    bool is_AwsCryptographyPrimitives { get; }
    bool is_CollectionOfErrors { get; }
    bool is_Opaque { get; }
    bool is_OpaqueWithText { get; }
    Dafny.ISequence<char> dtor_message { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IError dtor_AwsCryptographyMaterialProviders { get; }
    software.amazon.cryptography.primitives.internaldafny.types._IError dtor_AwsCryptographyPrimitives { get; }
    Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> dtor_list { get; }
    object dtor_obj { get; }
    Dafny.ISequence<char> dtor_objMessage { get; }
    _IError DowncastClone();
  }
  public abstract class Error : _IError {
    public Error() {
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError theDefault = create_StructuredEncryptionException(Dafny.Sequence<char>.Empty);
    public static software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.Error.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IError create_StructuredEncryptionException(Dafny.ISequence<char> message) {
      return new Error_StructuredEncryptionException(message);
    }
    public static _IError create_AwsCryptographyMaterialProviders(software.amazon.cryptography.materialproviders.internaldafny.types._IError AwsCryptographyMaterialProviders) {
      return new Error_AwsCryptographyMaterialProviders(AwsCryptographyMaterialProviders);
    }
    public static _IError create_AwsCryptographyPrimitives(software.amazon.cryptography.primitives.internaldafny.types._IError AwsCryptographyPrimitives) {
      return new Error_AwsCryptographyPrimitives(AwsCryptographyPrimitives);
    }
    public static _IError create_CollectionOfErrors(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> list, Dafny.ISequence<char> message) {
      return new Error_CollectionOfErrors(list, message);
    }
    public static _IError create_Opaque(object obj) {
      return new Error_Opaque(obj);
    }
    public static _IError create_OpaqueWithText(object obj, Dafny.ISequence<char> objMessage) {
      return new Error_OpaqueWithText(obj, objMessage);
    }
    public bool is_StructuredEncryptionException { get { return this is Error_StructuredEncryptionException; } }
    public bool is_AwsCryptographyMaterialProviders { get { return this is Error_AwsCryptographyMaterialProviders; } }
    public bool is_AwsCryptographyPrimitives { get { return this is Error_AwsCryptographyPrimitives; } }
    public bool is_CollectionOfErrors { get { return this is Error_CollectionOfErrors; } }
    public bool is_Opaque { get { return this is Error_Opaque; } }
    public bool is_OpaqueWithText { get { return this is Error_OpaqueWithText; } }
    public Dafny.ISequence<char> dtor_message {
      get {
        var d = this;
        if (d is Error_StructuredEncryptionException) { return ((Error_StructuredEncryptionException)d)._message; }
        return ((Error_CollectionOfErrors)d)._message;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IError dtor_AwsCryptographyMaterialProviders {
      get {
        var d = this;
        return ((Error_AwsCryptographyMaterialProviders)d)._AwsCryptographyMaterialProviders;
      }
    }
    public software.amazon.cryptography.primitives.internaldafny.types._IError dtor_AwsCryptographyPrimitives {
      get {
        var d = this;
        return ((Error_AwsCryptographyPrimitives)d)._AwsCryptographyPrimitives;
      }
    }
    public Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> dtor_list {
      get {
        var d = this;
        return ((Error_CollectionOfErrors)d)._list;
      }
    }
    public object dtor_obj {
      get {
        var d = this;
        if (d is Error_Opaque) { return ((Error_Opaque)d)._obj; }
        return ((Error_OpaqueWithText)d)._obj;
      }
    }
    public Dafny.ISequence<char> dtor_objMessage {
      get {
        var d = this;
        return ((Error_OpaqueWithText)d)._objMessage;
      }
    }
    public abstract _IError DowncastClone();
  }
  public class Error_StructuredEncryptionException : Error {
    public readonly Dafny.ISequence<char> _message;
    public Error_StructuredEncryptionException(Dafny.ISequence<char> message) : base() {
      this._message = message;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_StructuredEncryptionException(_message);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.Error_StructuredEncryptionException;
      return oth != null && object.Equals(this._message, oth._message);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._message));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.Error.StructuredEncryptionException";
      s += "(";
      s += Dafny.Helpers.ToString(this._message);
      s += ")";
      return s;
    }
  }
  public class Error_AwsCryptographyMaterialProviders : Error {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IError _AwsCryptographyMaterialProviders;
    public Error_AwsCryptographyMaterialProviders(software.amazon.cryptography.materialproviders.internaldafny.types._IError AwsCryptographyMaterialProviders) : base() {
      this._AwsCryptographyMaterialProviders = AwsCryptographyMaterialProviders;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_AwsCryptographyMaterialProviders(_AwsCryptographyMaterialProviders);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.Error_AwsCryptographyMaterialProviders;
      return oth != null && object.Equals(this._AwsCryptographyMaterialProviders, oth._AwsCryptographyMaterialProviders);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._AwsCryptographyMaterialProviders));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.Error.AwsCryptographyMaterialProviders";
      s += "(";
      s += Dafny.Helpers.ToString(this._AwsCryptographyMaterialProviders);
      s += ")";
      return s;
    }
  }
  public class Error_AwsCryptographyPrimitives : Error {
    public readonly software.amazon.cryptography.primitives.internaldafny.types._IError _AwsCryptographyPrimitives;
    public Error_AwsCryptographyPrimitives(software.amazon.cryptography.primitives.internaldafny.types._IError AwsCryptographyPrimitives) : base() {
      this._AwsCryptographyPrimitives = AwsCryptographyPrimitives;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_AwsCryptographyPrimitives(_AwsCryptographyPrimitives);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.Error_AwsCryptographyPrimitives;
      return oth != null && object.Equals(this._AwsCryptographyPrimitives, oth._AwsCryptographyPrimitives);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._AwsCryptographyPrimitives));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.Error.AwsCryptographyPrimitives";
      s += "(";
      s += Dafny.Helpers.ToString(this._AwsCryptographyPrimitives);
      s += ")";
      return s;
    }
  }
  public class Error_CollectionOfErrors : Error {
    public readonly Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _list;
    public readonly Dafny.ISequence<char> _message;
    public Error_CollectionOfErrors(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> list, Dafny.ISequence<char> message) : base() {
      this._list = list;
      this._message = message;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_CollectionOfErrors(_list, _message);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.Error_CollectionOfErrors;
      return oth != null && object.Equals(this._list, oth._list) && object.Equals(this._message, oth._message);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 3;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._list));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._message));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.Error.CollectionOfErrors";
      s += "(";
      s += Dafny.Helpers.ToString(this._list);
      s += ", ";
      s += Dafny.Helpers.ToString(this._message);
      s += ")";
      return s;
    }
  }
  public class Error_Opaque : Error {
    public readonly object _obj;
    public Error_Opaque(object obj) : base() {
      this._obj = obj;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_Opaque(_obj);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.Error_Opaque;
      return oth != null && this._obj == oth._obj;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 4;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._obj));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.Error.Opaque";
      s += "(";
      s += Dafny.Helpers.ToString(this._obj);
      s += ")";
      return s;
    }
  }
  public class Error_OpaqueWithText : Error {
    public readonly object _obj;
    public readonly Dafny.ISequence<char> _objMessage;
    public Error_OpaqueWithText(object obj, Dafny.ISequence<char> objMessage) : base() {
      this._obj = obj;
      this._objMessage = objMessage;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_OpaqueWithText(_obj, _objMessage);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.Error_OpaqueWithText;
      return oth != null && this._obj == oth._obj && object.Equals(this._objMessage, oth._objMessage);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 5;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._obj));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._objMessage));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes.Error.OpaqueWithText";
      s += "(";
      s += Dafny.Helpers.ToString(this._obj);
      s += ", ";
      s += Dafny.Helpers.ToString(this._objMessage);
      s += ")";
      return s;
    }
  }

  public partial class OpaqueError {
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.Error.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError __source) {
      software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError _1_e = __source;
      return ((_1_e).is_Opaque) || ((_1_e).is_OpaqueWithText);
    }
  }

  public partial class DummySubsetType {
    private static readonly BigInteger Witness = BigInteger.One;
    public static BigInteger Default() {
      return Witness;
    }
    private static readonly Dafny.TypeDescriptor<BigInteger> _TYPE = new Dafny.TypeDescriptor<BigInteger>(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.DummySubsetType.Default());
    public static Dafny.TypeDescriptor<BigInteger> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(BigInteger __source) {
      BigInteger _2_x = __source;
      return software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.__default.IsDummySubsetType(_2_x);
    }
  }
} // end of namespace software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types
namespace StructuredEncryptionUtil_Compile {

  public partial class __default {
    public static Dafny.ISet<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>> CryptoListToSet(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> xs) {
      return Dafny.Helpers.Id<Func<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>, Dafny.ISet<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>>>>((_0_xs) => ((System.Func<Dafny.ISet<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>>>)(() => {
        var _coll0 = new System.Collections.Generic.List<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>>();
        foreach (software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem _compr_0 in (_0_xs).CloneAsArray()) {
          software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem _1_k = (software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem)_compr_0;
          if ((_0_xs).Contains(_1_k)) {
            _coll0.Add((_1_k).dtor_key);
          }
        }
        return Dafny.Set<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>>.FromCollection(_coll0);
      }))())(xs);
    }
    public static Dafny.ISet<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>> CanonCryptoListToSet(Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> xs) {
      return Dafny.Helpers.Id<Func<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, Dafny.ISet<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>>>>((_0_xs) => ((System.Func<Dafny.ISet<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>>>)(() => {
        var _coll0 = new System.Collections.Generic.List<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>>();
        foreach (StructuredEncryptionUtil_Compile._ICanonCryptoItem _compr_0 in (_0_xs).CloneAsArray()) {
          StructuredEncryptionUtil_Compile._ICanonCryptoItem _1_k = (StructuredEncryptionUtil_Compile._ICanonCryptoItem)_compr_0;
          if ((_0_xs).Contains(_1_k)) {
            _coll0.Add((_1_k).dtor_origKey);
          }
        }
        return Dafny.Set<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>>.FromCollection(_coll0);
      }))())(xs);
    }
    public static Dafny.ISet<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>> AuthListToSet(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem> xs) {
      return Dafny.Helpers.Id<Func<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem>, Dafny.ISet<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>>>>((_0_xs) => ((System.Func<Dafny.ISet<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>>>)(() => {
        var _coll0 = new System.Collections.Generic.List<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>>();
        foreach (software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem _compr_0 in (_0_xs).CloneAsArray()) {
          software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem _1_k = (software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem)_compr_0;
          if ((_0_xs).Contains(_1_k)) {
            _coll0.Add((_1_k).dtor_key);
          }
        }
        return Dafny.Set<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>>.FromCollection(_coll0);
      }))())(xs);
    }
    public static bool CryptoListHasNoDuplicatesFromSet(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> xs) {
      return (new BigInteger((StructuredEncryptionUtil_Compile.__default.CryptoListToSet(xs)).Count)) == (new BigInteger((xs).Count));
    }
    public static bool AuthListHasNoDuplicatesFromSet(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem> xs) {
      return (new BigInteger((StructuredEncryptionUtil_Compile.__default.AuthListToSet(xs)).Count)) == (new BigInteger((xs).Count));
    }
    public static bool ValidString(Dafny.ISequence<char> x) {
      return ((new BigInteger((x).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT64__LIMIT)) && ((UTF8.__default.Encode(x)).is_Success);
    }
    public static bool ValidSuite(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo alg) {
      return (((alg).dtor_id).is_DBE) && (AlgorithmSuites_Compile.__default.DBEAlgorithmSuite_q(alg));
    }
    public static software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError E(Dafny.ISequence<char> s) {
      return software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.Error.create_StructuredEncryptionException(s);
    }
    public static byte ConstantTimeCompare(Dafny.ISequence<byte> a, Dafny.ISequence<byte> b, byte acc)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((a).Count)).Sign == 0) {
        return acc;
      } else {
        byte _0_x = (byte)(((byte)((a).Select(BigInteger.Zero))) ^ ((byte)((b).Select(BigInteger.Zero))));
        Dafny.ISequence<byte> _in0 = (a).Drop(BigInteger.One);
        Dafny.ISequence<byte> _in1 = (b).Drop(BigInteger.One);
        byte _in2 = (byte)((_0_x) | (acc));
        a = _in0;
        b = _in1;
        acc = _in2;
        goto TAIL_CALL_START;
      }
    }
    public static bool ConstantTimeEquals(Dafny.ISequence<byte> a, Dafny.ISequence<byte> b)
    {
      return (StructuredEncryptionUtil_Compile.__default.ConstantTimeCompare(a, b, (byte)(0))) == ((byte)(0));
    }
    public static bool IsAuthAttr(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction x) {
      return (((x).is_ENCRYPT__AND__SIGN) || ((x).is_SIGN__AND__INCLUDE__IN__ENCRYPTION__CONTEXT)) || ((x).is_SIGN__ONLY);
    }
    public static software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal ValueToData(Dafny.ISequence<byte> @value, Dafny.ISequence<byte> typeId)
    {
      return software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.StructuredDataTerminal.create(@value, typeId);
    }
    public static Dafny.ISequence<byte> GetValue(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal data) {
      return (data).dtor_value;
    }
    public static bool ByteLess(byte x, byte y)
    {
      return (x) < (y);
    }
    public static bool CharLess(char x, char y)
    {
      return (x) < (y);
    }
    public static Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> EcAsString(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> ec)
    {
      Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> output = Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Empty;
      Dafny.ISequence<Dafny.ISequence<byte>> _0_keys;
      _0_keys = SortedSets.__default.SetToOrderedSequence2<byte>((ec).Keys, StructuredEncryptionUtil_Compile.__default.ByteLess);
      Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> _1_ret;
      _1_ret = Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.FromElements();
      BigInteger _hi0 = new BigInteger((_0_keys).Count);
      for (BigInteger _2_i = BigInteger.Zero; _2_i < _hi0; _2_i++) {
        Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _3_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
        _3_valueOrError0 = UTF8.__default.Decode((_0_keys).Select(_2_i));
        if (!(!((_3_valueOrError0).IsFailure()))) {
          throw new Dafny.HaltException("dafny/StructuredEncryption/src/Util.dfy(265,17): " + _3_valueOrError0);}
        Dafny.ISequence<char> _4_key;
        _4_key = (_3_valueOrError0).Extract();
        Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _5_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
        _5_valueOrError1 = UTF8.__default.Decode(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(ec,(_0_keys).Select(_2_i)));
        if (!(!((_5_valueOrError1).IsFailure()))) {
          throw new Dafny.HaltException("dafny/StructuredEncryption/src/Util.dfy(266,19): " + _5_valueOrError1);}
        Dafny.ISequence<char> _6_value;
        _6_value = (_5_valueOrError1).Extract();
        _1_ret = Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Update(_1_ret, _4_key, _6_value);
      }
      output = _1_ret;
      return output;
      return output;
    }
    public static void PrintEncryptionContext(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> ec, Dafny.ISequence<char> name)
    {
      Dafny.ISequence<Dafny.ISequence<byte>> _0_keys;
      _0_keys = SortedSets.__default.SetToOrderedSequence2<byte>((ec).Keys, StructuredEncryptionUtil_Compile.__default.ByteLess);
      Dafny.Helpers.Print((name));
      Dafny.Helpers.Print((Dafny.Sequence<char>.FromString(" := {\n")));
      BigInteger _hi0 = new BigInteger((_0_keys).Count);
      for (BigInteger _1_i = BigInteger.Zero; _1_i < _hi0; _1_i++) {
        Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _2_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
        _2_valueOrError0 = UTF8.__default.Decode((_0_keys).Select(_1_i));
        if (!(!((_2_valueOrError0).IsFailure()))) {
          throw new Dafny.HaltException("dafny/StructuredEncryption/src/Util.dfy(277,17): " + _2_valueOrError0);}
        Dafny.ISequence<char> _3_key;
        _3_key = (_2_valueOrError0).Extract();
        Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _4_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
        _4_valueOrError1 = UTF8.__default.Decode(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(ec,(_0_keys).Select(_1_i)));
        if (!(!((_4_valueOrError1).IsFailure()))) {
          throw new Dafny.HaltException("dafny/StructuredEncryption/src/Util.dfy(278,19): " + _4_valueOrError1);}
        Dafny.ISequence<char> _5_value;
        _5_value = (_4_valueOrError1).Extract();
        Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("  ")));
        Dafny.Helpers.Print((_3_key));
        Dafny.Helpers.Print((Dafny.Sequence<char>.FromString(" := ")));
        Dafny.Helpers.Print((_5_value));
        Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("\n")));
      }
      Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("}\n")));
    }
    public static Dafny.ISequence<byte> EncodeTerminal(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal t) {
      return UTF8.__default.EncodeAscii(Base64_Compile.__default.Encode(Dafny.Sequence<byte>.Concat((t).dtor_typeId, (t).dtor_value)));
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, Dafny.ISequence<char>> DecodeTerminal(Dafny.ISequence<byte> t) {
      Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _0_valueOrError0 = UTF8.__default.Decode(t);
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>();
      } else {
        Dafny.ISequence<char> _1_utf8DecodedVal = (_0_valueOrError0).Extract();
        Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> _2_valueOrError1 = Base64_Compile.__default.Decode(_1_utf8DecodedVal);
        if ((_2_valueOrError1).IsFailure()) {
          return (_2_valueOrError1).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>();
        } else {
          Dafny.ISequence<byte> _3_base64DecodedVal = (_2_valueOrError1).Extract();
          Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _4_valueOrError2 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((new BigInteger((_3_base64DecodedVal).Count)) >= (new BigInteger(2)), Dafny.Sequence<char>.FromString("Invalid serialization of DDB Attribute in encryption context."));
          if ((_4_valueOrError2).IsFailure()) {
            return (_4_valueOrError2).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>();
          } else {
            Dafny.ISequence<byte> _5_typeId = (_3_base64DecodedVal).Take(new BigInteger(2));
            Dafny.ISequence<byte> _6_serializedValue = (_3_base64DecodedVal).Drop(new BigInteger(2));
            return Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, Dafny.ISequence<char>>.create_Success(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.StructuredDataTerminal.create(_6_serializedValue, _5_typeId));
          }
        }
      }
    }
    public static Dafny.ISequence<char> ReservedPrefix { get {
      return Dafny.Sequence<char>.FromString("aws_dbe_");
    } }
    public static Dafny.ISequence<char> HeaderField { get {
      return Dafny.Sequence<char>.Concat(StructuredEncryptionUtil_Compile.__default.ReservedPrefix, Dafny.Sequence<char>.FromString("head"));
    } }
    public static Dafny.ISequence<char> FooterField { get {
      return Dafny.Sequence<char>.Concat(StructuredEncryptionUtil_Compile.__default.ReservedPrefix, Dafny.Sequence<char>.FromString("foot"));
    } }
    public static Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> HeaderPath { get {
      return Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>.FromElements(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.PathSegment.create(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.StructureSegment.create(StructuredEncryptionUtil_Compile.__default.HeaderField)));
    } }
    public static Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> FooterPath { get {
      return Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>.FromElements(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.PathSegment.create(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.StructureSegment.create(StructuredEncryptionUtil_Compile.__default.FooterField)));
    } }
    public static Dafny.ISequence<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>> HeaderPaths { get {
      return Dafny.Sequence<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>>.FromElements(StructuredEncryptionUtil_Compile.__default.HeaderPath, StructuredEncryptionUtil_Compile.__default.FooterPath);
    } }
    public static Dafny.ISequence<char> ReservedCryptoContextPrefixString { get {
      return Dafny.Sequence<char>.FromString("aws-crypto-");
    } }
    public static Dafny.ISequence<byte> ReservedCryptoContextPrefixUTF8 { get {
      return UTF8.__default.EncodeAscii(StructuredEncryptionUtil_Compile.__default.ReservedCryptoContextPrefixString);
    } }
    public static Dafny.ISequence<char> ATTR__PREFIX { get {
      return Dafny.Sequence<char>.Concat(StructuredEncryptionUtil_Compile.__default.ReservedCryptoContextPrefixString, Dafny.Sequence<char>.FromString("attr."));
    } }
    public static Dafny.ISequence<byte> EC__ATTR__PREFIX { get {
      return UTF8.__default.EncodeAscii(StructuredEncryptionUtil_Compile.__default.ATTR__PREFIX);
    } }
    public static Dafny.ISequence<char> LEGEND { get {
      return Dafny.Sequence<char>.Concat(StructuredEncryptionUtil_Compile.__default.ReservedCryptoContextPrefixString, Dafny.Sequence<char>.FromString("legend"));
    } }
    public static Dafny.ISequence<byte> LEGEND__UTF8 { get {
      return UTF8.__default.EncodeAscii(StructuredEncryptionUtil_Compile.__default.LEGEND);
    } }
    public static Dafny.ISequence<char> NULL__STR { get {
      return Dafny.Sequence<char>.FromString("null");
    } }
    public static Dafny.ISequence<byte> NULL__UTF8 { get {
      return UTF8.__default.EncodeAscii(StructuredEncryptionUtil_Compile.__default.NULL__STR);
    } }
    public static Dafny.ISequence<char> TRUE__STR { get {
      return Dafny.Sequence<char>.FromString("true");
    } }
    public static Dafny.ISequence<byte> TRUE__UTF8 { get {
      return UTF8.__default.EncodeAscii(StructuredEncryptionUtil_Compile.__default.TRUE__STR);
    } }
    public static Dafny.ISequence<char> FALSE__STR { get {
      return Dafny.Sequence<char>.FromString("false");
    } }
    public static Dafny.ISequence<byte> FALSE__UTF8 { get {
      return UTF8.__default.EncodeAscii(StructuredEncryptionUtil_Compile.__default.FALSE__STR);
    } }
    public static Dafny.ISequence<byte> BYTES__TYPE__ID { get {
      return Dafny.Sequence<byte>.FromElements((byte)(255), (byte)(255));
    } }
    public static BigInteger TYPEID__LEN { get {
      return new BigInteger(2);
    } }
    public static BigInteger KeySize { get {
      return new BigInteger(32);
    } }
    public static BigInteger AuthTagSize { get {
      return new BigInteger(16);
    } }
    public static BigInteger NonceSize { get {
      return new BigInteger(12);
    } }
    public static byte TERM__T { get {
      return (byte)(0);
    } }
    public static byte NULL__T { get {
      return (byte)(0);
    } }
    public static Dafny.ISequence<byte> NULL { get {
      return Dafny.Sequence<byte>.FromElements(StructuredEncryptionUtil_Compile.__default.TERM__T, StructuredEncryptionUtil_Compile.__default.NULL__T);
    } }
    public static byte STRING__T { get {
      return (byte)(1);
    } }
    public static Dafny.ISequence<byte> STRING { get {
      return Dafny.Sequence<byte>.FromElements(StructuredEncryptionUtil_Compile.__default.TERM__T, StructuredEncryptionUtil_Compile.__default.STRING__T);
    } }
    public static byte NUMBER__T { get {
      return (byte)(2);
    } }
    public static Dafny.ISequence<byte> NUMBER { get {
      return Dafny.Sequence<byte>.FromElements(StructuredEncryptionUtil_Compile.__default.TERM__T, StructuredEncryptionUtil_Compile.__default.NUMBER__T);
    } }
    public static byte BOOLEAN__T { get {
      return (byte)(4);
    } }
    public static Dafny.ISequence<byte> BOOLEAN { get {
      return Dafny.Sequence<byte>.FromElements(StructuredEncryptionUtil_Compile.__default.TERM__T, StructuredEncryptionUtil_Compile.__default.BOOLEAN__T);
    } }
    public static byte SET__T { get {
      return (byte)(1);
    } }
    public static Dafny.ISequence<byte> STRING__SET { get {
      return Dafny.Sequence<byte>.FromElements(StructuredEncryptionUtil_Compile.__default.SET__T, StructuredEncryptionUtil_Compile.__default.STRING__T);
    } }
    public static Dafny.ISequence<byte> NUMBER__SET { get {
      return Dafny.Sequence<byte>.FromElements(StructuredEncryptionUtil_Compile.__default.SET__T, StructuredEncryptionUtil_Compile.__default.NUMBER__T);
    } }
    public static byte BINARY__T { get {
      return (byte)(255);
    } }
    public static Dafny.ISequence<byte> BINARY__SET { get {
      return Dafny.Sequence<byte>.FromElements(StructuredEncryptionUtil_Compile.__default.SET__T, StructuredEncryptionUtil_Compile.__default.BINARY__T);
    } }
    public static byte MAP__T { get {
      return (byte)(2);
    } }
    public static Dafny.ISequence<byte> MAP { get {
      return Dafny.Sequence<byte>.FromElements(StructuredEncryptionUtil_Compile.__default.MAP__T, StructuredEncryptionUtil_Compile.__default.NULL__T);
    } }
    public static byte LIST__T { get {
      return (byte)(3);
    } }
    public static Dafny.ISequence<byte> LIST { get {
      return Dafny.Sequence<byte>.FromElements(StructuredEncryptionUtil_Compile.__default.LIST__T, StructuredEncryptionUtil_Compile.__default.NULL__T);
    } }
    public static BigInteger MSGID__LEN { get {
      return new BigInteger(32);
    } }
    public static char LEGEND__STRING { get {
      return 'S';
    } }
    public static char LEGEND__NUMBER { get {
      return 'N';
    } }
    public static char LEGEND__LITERAL { get {
      return 'L';
    } }
    public static char LEGEND__BINARY { get {
      return 'B';
    } }
    public static byte DbeAlgorithmFamily { get {
      return (byte)(103);
    } }
    public static Dafny.ISequence<byte> BINARY { get {
      return Dafny.Sequence<byte>.FromElements((byte)(255), (byte)(255));
    } }
  }

  public interface _ICanonCryptoItem {
    bool is_CanonCryptoItem { get; }
    Dafny.ISequence<byte> dtor_key { get; }
    Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> dtor_origKey { get; }
    software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal dtor_data { get; }
    software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction dtor_action { get; }
    _ICanonCryptoItem DowncastClone();
  }
  public class CanonCryptoItem : _ICanonCryptoItem {
    public readonly Dafny.ISequence<byte> _key;
    public readonly Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> _origKey;
    public readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal _data;
    public readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction _action;
    public CanonCryptoItem(Dafny.ISequence<byte> key, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> origKey, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal data, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction action) {
      this._key = key;
      this._origKey = origKey;
      this._data = data;
      this._action = action;
    }
    public _ICanonCryptoItem DowncastClone() {
      if (this is _ICanonCryptoItem dt) { return dt; }
      return new CanonCryptoItem(_key, _origKey, _data, _action);
    }
    public override bool Equals(object other) {
      var oth = other as StructuredEncryptionUtil_Compile.CanonCryptoItem;
      return oth != null && object.Equals(this._key, oth._key) && object.Equals(this._origKey, oth._origKey) && object.Equals(this._data, oth._data) && object.Equals(this._action, oth._action);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._key));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._origKey));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._data));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._action));
      return (int) hash;
    }
    public override string ToString() {
      string s = "StructuredEncryptionUtil.CanonCryptoItem.CanonCryptoItem";
      s += "(";
      s += Dafny.Helpers.ToString(this._key);
      s += ", ";
      s += Dafny.Helpers.ToString(this._origKey);
      s += ", ";
      s += Dafny.Helpers.ToString(this._data);
      s += ", ";
      s += Dafny.Helpers.ToString(this._action);
      s += ")";
      return s;
    }
    private static readonly StructuredEncryptionUtil_Compile._ICanonCryptoItem theDefault = create(Dafny.Sequence<byte>.Empty, Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>.Empty, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.StructuredDataTerminal.Default(), software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.Default());
    public static StructuredEncryptionUtil_Compile._ICanonCryptoItem Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<StructuredEncryptionUtil_Compile._ICanonCryptoItem> _TYPE = new Dafny.TypeDescriptor<StructuredEncryptionUtil_Compile._ICanonCryptoItem>(StructuredEncryptionUtil_Compile.CanonCryptoItem.Default());
    public static Dafny.TypeDescriptor<StructuredEncryptionUtil_Compile._ICanonCryptoItem> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICanonCryptoItem create(Dafny.ISequence<byte> key, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> origKey, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal data, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction action) {
      return new CanonCryptoItem(key, origKey, data, action);
    }
    public static _ICanonCryptoItem create_CanonCryptoItem(Dafny.ISequence<byte> key, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> origKey, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal data, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction action) {
      return create(key, origKey, data, action);
    }
    public bool is_CanonCryptoItem { get { return true; } }
    public Dafny.ISequence<byte> dtor_key {
      get {
        return this._key;
      }
    }
    public Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> dtor_origKey {
      get {
        return this._origKey;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal dtor_data {
      get {
        return this._data;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction dtor_action {
      get {
        return this._action;
      }
    }
  }

  public interface _ICanonAuthItem {
    bool is_CanonAuthItem { get; }
    Dafny.ISequence<byte> dtor_key { get; }
    Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> dtor_origKey { get; }
    software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal dtor_data { get; }
    software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction dtor_action { get; }
    _ICanonAuthItem DowncastClone();
  }
  public class CanonAuthItem : _ICanonAuthItem {
    public readonly Dafny.ISequence<byte> _key;
    public readonly Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> _origKey;
    public readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal _data;
    public readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction _action;
    public CanonAuthItem(Dafny.ISequence<byte> key, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> origKey, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal data, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction action) {
      this._key = key;
      this._origKey = origKey;
      this._data = data;
      this._action = action;
    }
    public _ICanonAuthItem DowncastClone() {
      if (this is _ICanonAuthItem dt) { return dt; }
      return new CanonAuthItem(_key, _origKey, _data, _action);
    }
    public override bool Equals(object other) {
      var oth = other as StructuredEncryptionUtil_Compile.CanonAuthItem;
      return oth != null && object.Equals(this._key, oth._key) && object.Equals(this._origKey, oth._origKey) && object.Equals(this._data, oth._data) && object.Equals(this._action, oth._action);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._key));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._origKey));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._data));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._action));
      return (int) hash;
    }
    public override string ToString() {
      string s = "StructuredEncryptionUtil.CanonAuthItem.CanonAuthItem";
      s += "(";
      s += Dafny.Helpers.ToString(this._key);
      s += ", ";
      s += Dafny.Helpers.ToString(this._origKey);
      s += ", ";
      s += Dafny.Helpers.ToString(this._data);
      s += ", ";
      s += Dafny.Helpers.ToString(this._action);
      s += ")";
      return s;
    }
    private static readonly StructuredEncryptionUtil_Compile._ICanonAuthItem theDefault = create(Dafny.Sequence<byte>.Empty, Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>.Empty, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.StructuredDataTerminal.Default(), software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.AuthenticateAction.Default());
    public static StructuredEncryptionUtil_Compile._ICanonAuthItem Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<StructuredEncryptionUtil_Compile._ICanonAuthItem> _TYPE = new Dafny.TypeDescriptor<StructuredEncryptionUtil_Compile._ICanonAuthItem>(StructuredEncryptionUtil_Compile.CanonAuthItem.Default());
    public static Dafny.TypeDescriptor<StructuredEncryptionUtil_Compile._ICanonAuthItem> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICanonAuthItem create(Dafny.ISequence<byte> key, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> origKey, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal data, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction action) {
      return new CanonAuthItem(key, origKey, data, action);
    }
    public static _ICanonAuthItem create_CanonAuthItem(Dafny.ISequence<byte> key, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> origKey, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal data, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction action) {
      return create(key, origKey, data, action);
    }
    public bool is_CanonAuthItem { get { return true; } }
    public Dafny.ISequence<byte> dtor_key {
      get {
        return this._key;
      }
    }
    public Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> dtor_origKey {
      get {
        return this._origKey;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal dtor_data {
      get {
        return this._data;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction dtor_action {
      get {
        return this._action;
      }
    }
  }

  public partial class Key {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<byte>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<byte>>(Dafny.Sequence<byte>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<byte>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.ISequence<byte> __source) {
      Dafny.ISequence<byte> _0_x = __source;
      return (new BigInteger((_0_x).Count)) == (StructuredEncryptionUtil_Compile.__default.KeySize);
    }
  }

  public partial class Nonce {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<byte>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<byte>>(Dafny.Sequence<byte>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<byte>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.ISequence<byte> __source) {
      Dafny.ISequence<byte> _1_x = __source;
      return (new BigInteger((_1_x).Count)) == (StructuredEncryptionUtil_Compile.__default.NonceSize);
    }
  }

  public partial class AuthTag {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<byte>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<byte>>(Dafny.Sequence<byte>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<byte>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.ISequence<byte> __source) {
      Dafny.ISequence<byte> _2_x = __source;
      return (new BigInteger((_2_x).Count)) == (StructuredEncryptionUtil_Compile.__default.AuthTagSize);
    }
  }

  public partial class MessageID {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<byte>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<byte>>(Dafny.Sequence<byte>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<byte>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.ISequence<byte> __source) {
      Dafny.ISequence<byte> _3_x = __source;
      return (new BigInteger((_3_x).Count)) == (StructuredEncryptionUtil_Compile.__default.MSGID__LEN);
    }
  }

  public partial class GoodString {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<char>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<char>>(Dafny.Sequence<char>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<char>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.ISequence<char> __source) {
      Dafny.ISequence<char> _4_x = __source;
      return StructuredEncryptionUtil_Compile.__default.ValidString(_4_x);
    }
  }
} // end of namespace StructuredEncryptionUtil_Compile
namespace Sets_Compile {

  public partial class __default {
    public static __T ExtractFromSingleton<__T>(Dafny.ISet<__T> s) {
      return Dafny.Helpers.Let<int, __T>(0, _let_dummy_0 =>  {
        __T _0_x = default(__T);
        foreach (__T _assign_such_that_0 in (s).Elements) {
          _0_x = (__T)_assign_such_that_0;
          if ((s).Contains(_0_x)) {
            goto after__ASSIGN_SUCH_THAT_0;
          }
        }
        throw new System.Exception("assign-such-that search produced no value");
      after__ASSIGN_SUCH_THAT_0: ;
        return _0_x;
      }
      );
    }
    public static Dafny.ISet<__Y> Map<__X, __Y>(Dafny.ISet<__X> xs, Func<__X, __Y> f)
    {
      Dafny.ISet<__Y> _0_ys = Dafny.Helpers.Id<Func<Dafny.ISet<__X>, Func<__X, __Y>, Dafny.ISet<__Y>>>((_1_xs, _2_f) => ((System.Func<Dafny.ISet<__Y>>)(() => {
        var _coll0 = new System.Collections.Generic.List<__Y>();
        foreach (__X _compr_0 in (_1_xs).Elements) {
          __X _3_x = (__X)_compr_0;
          if ((_1_xs).Contains(_3_x)) {
            _coll0.Add(Dafny.Helpers.Id<Func<__X, __Y>>(_2_f)(_3_x));
          }
        }
        return Dafny.Set<__Y>.FromCollection(_coll0);
      }))())(xs, f);
      return _0_ys;
    }
    public static Dafny.ISet<__X> Filter<__X>(Dafny.ISet<__X> xs, Func<__X, bool> f)
    {
      Dafny.ISet<__X> _0_ys = Dafny.Helpers.Id<Func<Dafny.ISet<__X>, Func<__X, bool>, Dafny.ISet<__X>>>((_1_xs, _2_f) => ((System.Func<Dafny.ISet<__X>>)(() => {
        var _coll0 = new System.Collections.Generic.List<__X>();
        foreach (__X _compr_0 in (_1_xs).Elements) {
          __X _3_x = (__X)_compr_0;
          if (((_1_xs).Contains(_3_x)) && (Dafny.Helpers.Id<Func<__X, bool>>(_2_f)(_3_x))) {
            _coll0.Add(_3_x);
          }
        }
        return Dafny.Set<__X>.FromCollection(_coll0);
      }))())(xs, f);
      return _0_ys;
    }
    public static Dafny.ISet<BigInteger> SetRange(BigInteger a, BigInteger b)
    {
      Dafny.ISet<BigInteger> _0___accumulator = Dafny.Set<BigInteger>.FromElements();
    TAIL_CALL_START: ;
      if ((a) == (b)) {
        return Dafny.Set<BigInteger>.Union(Dafny.Set<BigInteger>.FromElements(), _0___accumulator);
      } else {
        _0___accumulator = Dafny.Set<BigInteger>.Union(_0___accumulator, Dafny.Set<BigInteger>.FromElements(a));
        BigInteger _in0 = (a) + (BigInteger.One);
        BigInteger _in1 = b;
        a = _in0;
        b = _in1;
        goto TAIL_CALL_START;
      }
    }
    public static Dafny.ISet<BigInteger> SetRangeZeroBound(BigInteger n) {
      return Sets_Compile.__default.SetRange(BigInteger.Zero, n);
    }
  }
} // end of namespace Sets_Compile
namespace StructuredEncryptionPaths_Compile {

  public partial class __default {
    public static bool ValidTerminalSelector(Dafny.ISequence<StructuredEncryptionPaths_Compile._ISelector> s) {
      return (((new BigInteger((s).Count)).Sign == 1) && ((new BigInteger((s).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT64__LIMIT))) && (((s).Select(BigInteger.Zero)).is_Map);
    }
    public static Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> StringToUniPath(Dafny.ISequence<char> x) {
      return Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>.FromElements(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.PathSegment.create(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.StructureSegment.create(x)));
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> UniPathToString(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> x) {
      return Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success((((x).Select(BigInteger.Zero)).dtor_member).dtor_key);
    }
    public static bool ValidPath(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> path) {
      return ((new BigInteger((path).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT64__LIMIT)) && (Dafny.Helpers.Id<Func<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>, bool>>((_0_path) => Dafny.Helpers.Quantifier<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>((_0_path).UniqueElements, true, (((_forall_var_0) => {
        software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment _1_x = (software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment)_forall_var_0;
        return !((_0_path).Contains(_1_x)) || (StructuredEncryptionUtil_Compile.__default.ValidString(((_1_x).dtor_member).dtor_key));
      }))))(path));
    }
    public static Dafny.ISequence<byte> CanonPath(Dafny.ISequence<char> table, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> path)
    {
      Dafny.ISequence<byte> _0_tableName = (UTF8.__default.Encode(table)).dtor_value;
      Dafny.ISequence<byte> _1_depth = StandardLibrary_mUInt_Compile.__default.UInt64ToSeq((ulong)(path).LongCount);
      Dafny.ISequence<byte> _2_path = StructuredEncryptionPaths_Compile.__default.MakeCanonicalPath(path);
      return Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(_0_tableName, _1_depth), _2_path);
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> TermLocMap_q(Dafny.ISequence<char> attr) {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(StructuredEncryptionUtil_Compile.__default.ValidString(attr), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("invalid string : "), attr)));
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>>();
      } else {
        return Wrappers_Compile.Result<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>.FromElements(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.PathSegment.create(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.StructureSegment.create(attr))));
      }
    }
    public static Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> TermLocMap(Dafny.ISequence<char> attr) {
      return Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>.FromElements(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.PathSegment.create(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.StructureSegment.create(attr)));
    }
    public static Dafny.ISequence<byte> SimpleCanon(Dafny.ISequence<char> table, Dafny.ISequence<char> attr)
    {
      return StructuredEncryptionPaths_Compile.__default.CanonPath(table, StructuredEncryptionPaths_Compile.__default.TermLocMap(attr));
    }
    public static Dafny.ISequence<byte> CanonicalPart(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment s) {
      return Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.FromElements(StructuredEncryptionPaths_Compile.__default.MAP__TAG), StandardLibrary_mUInt_Compile.__default.UInt64ToSeq((ulong)(((s).dtor_member).dtor_key).LongCount)), (UTF8.__default.Encode(((s).dtor_member).dtor_key)).dtor_value);
    }
    public static Dafny.ISequence<byte> MakeCanonicalPath(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> path) {
      Dafny.ISequence<byte> _0___accumulator = Dafny.Sequence<byte>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((path).Count)).Sign == 0) {
        return Dafny.Sequence<byte>.Concat(_0___accumulator, Dafny.Sequence<byte>.FromElements());
      } else {
        _0___accumulator = Dafny.Sequence<byte>.Concat(_0___accumulator, StructuredEncryptionPaths_Compile.__default.CanonicalPart((path).Select(BigInteger.Zero)));
        Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> _in0 = (path).Drop(BigInteger.One);
        path = _in0;
        goto TAIL_CALL_START;
      }
    }
    public static Dafny.ISequence<char> PathToString(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> path) {
      Dafny.ISequence<char> _0___accumulator = Dafny.Sequence<char>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((path).Count)).Sign == 0) {
        return Dafny.Sequence<char>.Concat(_0___accumulator, Dafny.Sequence<char>.FromString(""));
      } else if ((new BigInteger((path).Count)) == (BigInteger.One)) {
        return Dafny.Sequence<char>.Concat(_0___accumulator, (((path).Select(BigInteger.Zero)).dtor_member).dtor_key);
      } else {
        _0___accumulator = Dafny.Sequence<char>.Concat(_0___accumulator, Dafny.Sequence<char>.Concat((((path).Select(BigInteger.Zero)).dtor_member).dtor_key, Dafny.Sequence<char>.FromString(".")));
        Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> _in0 = (path).Drop(BigInteger.One);
        path = _in0;
        goto TAIL_CALL_START;
      }
    }
    public static byte MAP__TAG { get {
      return (byte)('$');
    } }
    public static byte ARRAY__TAG { get {
      return (byte)('#');
    } }
  }

  public interface _ISelector {
    bool is_List { get; }
    bool is_Map { get; }
    ulong dtor_pos { get; }
    Dafny.ISequence<char> dtor_key { get; }
    _ISelector DowncastClone();
  }
  public abstract class Selector : _ISelector {
    public Selector() {
    }
    private static readonly StructuredEncryptionPaths_Compile._ISelector theDefault = create_List(0);
    public static StructuredEncryptionPaths_Compile._ISelector Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<StructuredEncryptionPaths_Compile._ISelector> _TYPE = new Dafny.TypeDescriptor<StructuredEncryptionPaths_Compile._ISelector>(StructuredEncryptionPaths_Compile.Selector.Default());
    public static Dafny.TypeDescriptor<StructuredEncryptionPaths_Compile._ISelector> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ISelector create_List(ulong pos) {
      return new Selector_List(pos);
    }
    public static _ISelector create_Map(Dafny.ISequence<char> key) {
      return new Selector_Map(key);
    }
    public bool is_List { get { return this is Selector_List; } }
    public bool is_Map { get { return this is Selector_Map; } }
    public ulong dtor_pos {
      get {
        var d = this;
        return ((Selector_List)d)._pos;
      }
    }
    public Dafny.ISequence<char> dtor_key {
      get {
        var d = this;
        return ((Selector_Map)d)._key;
      }
    }
    public abstract _ISelector DowncastClone();
  }
  public class Selector_List : Selector {
    public readonly ulong _pos;
    public Selector_List(ulong pos) : base() {
      this._pos = pos;
    }
    public override _ISelector DowncastClone() {
      if (this is _ISelector dt) { return dt; }
      return new Selector_List(_pos);
    }
    public override bool Equals(object other) {
      var oth = other as StructuredEncryptionPaths_Compile.Selector_List;
      return oth != null && this._pos == oth._pos;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._pos));
      return (int) hash;
    }
    public override string ToString() {
      string s = "StructuredEncryptionPaths.Selector.List";
      s += "(";
      s += Dafny.Helpers.ToString(this._pos);
      s += ")";
      return s;
    }
  }
  public class Selector_Map : Selector {
    public readonly Dafny.ISequence<char> _key;
    public Selector_Map(Dafny.ISequence<char> key) : base() {
      this._key = key;
    }
    public override _ISelector DowncastClone() {
      if (this is _ISelector dt) { return dt; }
      return new Selector_Map(_key);
    }
    public override bool Equals(object other) {
      var oth = other as StructuredEncryptionPaths_Compile.Selector_Map;
      return oth != null && object.Equals(this._key, oth._key);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._key));
      return (int) hash;
    }
    public override string ToString() {
      string s = "StructuredEncryptionPaths.Selector.Map";
      s += "(";
      s += Dafny.Helpers.ToString(this._key);
      s += ")";
      return s;
    }
  }

  public partial class SelectorList {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<StructuredEncryptionPaths_Compile._ISelector>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<StructuredEncryptionPaths_Compile._ISelector>>(Dafny.Sequence<StructuredEncryptionPaths_Compile._ISelector>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<StructuredEncryptionPaths_Compile._ISelector>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.ISequence<StructuredEncryptionPaths_Compile._ISelector> __source) {
      Dafny.ISequence<StructuredEncryptionPaths_Compile._ISelector> _0_x = __source;
      return (new BigInteger((_0_x).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT64__LIMIT);
    }
  }

  public partial class TerminalSelector {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<StructuredEncryptionPaths_Compile._ISelector>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<StructuredEncryptionPaths_Compile._ISelector>>(Dafny.Sequence<StructuredEncryptionPaths_Compile._ISelector>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<StructuredEncryptionPaths_Compile._ISelector>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.ISequence<StructuredEncryptionPaths_Compile._ISelector> __source) {
      Dafny.ISequence<StructuredEncryptionPaths_Compile._ISelector> _1_x = __source;
      return StructuredEncryptionPaths_Compile.__default.ValidTerminalSelector(_1_x);
    }
  }
} // end of namespace StructuredEncryptionPaths_Compile
namespace StructuredEncryptionHeader_Compile {

  public partial class __default {
    public static bool ValidVersion(byte x) {
      return ((x) == ((byte)(1))) || ((x) == ((byte)(2)));
    }
    public static bool IsVersion2Schema(Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> data) {
      return Dafny.Helpers.Id<Func<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, bool>>((_0_data) => Dafny.Helpers.Quantifier<StructuredEncryptionUtil_Compile._ICanonCryptoItem>((_0_data).UniqueElements, false, (((_exists_var_0) => {
        StructuredEncryptionUtil_Compile._ICanonCryptoItem _1_x = (StructuredEncryptionUtil_Compile._ICanonCryptoItem)_exists_var_0;
        return ((_0_data).Contains(_1_x)) && (object.Equals((_1_x).dtor_action, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_SIGN__AND__INCLUDE__IN__ENCRYPTION__CONTEXT()));
      }))))(data);
    }
    public static byte VersionFromSchema(Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> data) {
      if (StructuredEncryptionHeader_Compile.__default.IsVersion2Schema(data)) {
        return (byte)(2);
      } else {
        return (byte)(1);
      }
    }
    public static bool ValidFlavor(byte x) {
      return (Dafny.Sequence<byte>.FromElements((byte)(0), (byte)(1))).Contains(x);
    }
    public static bool ValidLegendByte(byte x) {
      return (Dafny.Sequence<byte>.FromElements(StructuredEncryptionHeader_Compile.__default.ENCRYPT__AND__SIGN__LEGEND, StructuredEncryptionHeader_Compile.__default.SIGN__AND__INCLUDE__IN__ENCRYPTION__CONTEXT__LEGEND, StructuredEncryptionHeader_Compile.__default.SIGN__ONLY__LEGEND)).Contains(x);
    }
    public static bool ValidEncryptionContext(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> x) {
      return ((new BigInteger((x).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT)) && (Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, bool>>((_0_x) => Dafny.Helpers.Quantifier<Dafny.ISequence<byte>>((_0_x).Keys.Elements, true, (((_forall_var_0) => {
        Dafny.ISequence<byte> _1_k = (Dafny.ISequence<byte>)_forall_var_0;
        return !((_0_x).Contains(_1_k)) || (((new BigInteger((_1_k).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT)) && ((new BigInteger((Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(_0_x,_1_k)).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT)));
      }))))(x));
    }
    public static bool ValidEncryptedDataKey(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey x) {
      return (((new BigInteger(((x).dtor_keyProviderId).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT)) && ((new BigInteger(((x).dtor_keyProviderInfo).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT))) && ((new BigInteger(((x).dtor_ciphertext).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT));
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> Serialize(software.amazon.cryptography.primitives.internaldafny.types.IAwsCryptographicPrimitivesClient client, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo alg, Dafny.ISequence<byte> commitKey, StructuredEncryptionHeader_Compile._IPartialHeader PartialHeader)
    {
      Dafny.ISequence<byte> _0_body = (PartialHeader).serialize();
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _1_valueOrError0 = StructuredEncryptionHeader_Compile.__default.CalculateHeaderCommitment(client, alg, commitKey, _0_body);
      if ((_1_valueOrError0).IsFailure()) {
        return (_1_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
      } else {
        Dafny.ISequence<byte> _2_commitment = (_1_valueOrError0).Extract();
        return Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(Dafny.Sequence<byte>.Concat(_0_body, _2_commitment));
      }
    }
    public static Wrappers_Compile._IResult<StructuredEncryptionHeader_Compile._IPartialHeader, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> Create(Dafny.ISequence<char> tableName, Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> schema, Dafny.ISequence<byte> msgID, software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials mat)
    {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(StructuredEncryptionHeader_Compile.__default.ValidEncryptionContext((mat).dtor_encryptionContext), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Invalid Encryption Context")));
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<StructuredEncryptionHeader_Compile._IPartialHeader>();
      } else {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _1_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((new BigInteger(((mat).dtor_encryptedDataKeys).Count)).Sign == 1, StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("There must be at least one data key")));
        if ((_1_valueOrError1).IsFailure()) {
          return (_1_valueOrError1).PropagateFailure<StructuredEncryptionHeader_Compile._IPartialHeader>();
        } else {
          Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _2_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((new BigInteger(((mat).dtor_encryptedDataKeys).Count)) < (StructuredEncryptionHeader_Compile.__default.UINT8__LIMIT), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Too many data keys.")));
          if ((_2_valueOrError2).IsFailure()) {
            return (_2_valueOrError2).PropagateFailure<StructuredEncryptionHeader_Compile._IPartialHeader>();
          } else {
            Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _3_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(Dafny.Helpers.Id<Func<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, bool>>((_4_mat) => Dafny.Helpers.Quantifier<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>(((_4_mat).dtor_encryptedDataKeys).UniqueElements, true, (((_forall_var_0) => {
              software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey _5_x = (software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey)_forall_var_0;
              return !(((_4_mat).dtor_encryptedDataKeys).Contains(_5_x)) || (StructuredEncryptionHeader_Compile.__default.ValidEncryptedDataKey(_5_x));
            }))))(mat), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Invalid Data Key")));
            if ((_3_valueOrError3).IsFailure()) {
              return (_3_valueOrError3).PropagateFailure<StructuredEncryptionHeader_Compile._IPartialHeader>();
            } else {
              Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _6_valueOrError4 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((new BigInteger((((mat).dtor_algorithmSuite).dtor_binaryId).Count)) == (new BigInteger(2)), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Invalid Algorithm Suite Binary ID")));
              if ((_6_valueOrError4).IsFailure()) {
                return (_6_valueOrError4).PropagateFailure<StructuredEncryptionHeader_Compile._IPartialHeader>();
              } else {
                Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _7_valueOrError5 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(((((mat).dtor_algorithmSuite).dtor_binaryId).Select(BigInteger.Zero)) == (StructuredEncryptionUtil_Compile.__default.DbeAlgorithmFamily), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Algorithm Suite not suitable for structured encryption.")));
                if ((_7_valueOrError5).IsFailure()) {
                  return (_7_valueOrError5).PropagateFailure<StructuredEncryptionHeader_Compile._IPartialHeader>();
                } else {
                  Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _8_valueOrError6 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(StructuredEncryptionHeader_Compile.__default.ValidFlavor((((mat).dtor_algorithmSuite).dtor_binaryId).Select(BigInteger.One)), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Algorithm Suite has unexpected flavor.")));
                  if ((_8_valueOrError6).IsFailure()) {
                    return (_8_valueOrError6).PropagateFailure<StructuredEncryptionHeader_Compile._IPartialHeader>();
                  } else {
                    Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _9_valueOrError7 = StructuredEncryptionHeader_Compile.__default.MakeLegend(schema);
                    if ((_9_valueOrError7).IsFailure()) {
                      return (_9_valueOrError7).PropagateFailure<StructuredEncryptionHeader_Compile._IPartialHeader>();
                    } else {
                      Dafny.ISequence<byte> _10_legend = (_9_valueOrError7).Extract();
                      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _11_storedEC = Dafny.Helpers.Id<Func<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>>((_12_mat) => ((System.Func<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>)(() => {
                        var _coll0 = new System.Collections.Generic.List<Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
                        foreach (Dafny.ISequence<byte> _compr_0 in ((_12_mat).dtor_encryptionContext).Keys.Elements) {
                          Dafny.ISequence<byte> _13_k = (Dafny.ISequence<byte>)_compr_0;
                          if (UTF8.ValidUTF8Bytes._Is(_13_k)) {
                            if ((((_12_mat).dtor_encryptionContext).Contains(_13_k)) && (!((_12_mat).dtor_requiredEncryptionContextKeys).Contains(_13_k))) {
                              _coll0.Add(new Dafny.Pair<Dafny.ISequence<byte>,Dafny.ISequence<byte>>(_13_k, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select((_12_mat).dtor_encryptionContext,_13_k)));
                            }
                          }
                        }
                        return Dafny.Map<Dafny.ISequence<byte>,Dafny.ISequence<byte>>.FromCollection(_coll0);
                      }))())(mat);
                      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _14_valueOrError8 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(StructuredEncryptionHeader_Compile.__default.ValidEncryptionContext(_11_storedEC), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Invalid Encryption Context")));
                      if ((_14_valueOrError8).IsFailure()) {
                        return (_14_valueOrError8).PropagateFailure<StructuredEncryptionHeader_Compile._IPartialHeader>();
                      } else {
                        return Wrappers_Compile.Result<StructuredEncryptionHeader_Compile._IPartialHeader, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(StructuredEncryptionHeader_Compile.PartialHeader.create(StructuredEncryptionHeader_Compile.__default.VersionFromSchema(schema), (((mat).dtor_algorithmSuite).dtor_binaryId).Select(BigInteger.One), msgID, _10_legend, _11_storedEC, (mat).dtor_encryptedDataKeys));
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<StructuredEncryptionHeader_Compile._IPartialHeader, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> PartialDeserialize(Dafny.ISequence<byte> data) {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((StructuredEncryptionHeader_Compile.__default.PREFIX__LEN) <= (new BigInteger((data).Count)), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Serialized PartialHeader too short.")));
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<StructuredEncryptionHeader_Compile._IPartialHeader>();
      } else {
        byte _1_version = (data).Select(BigInteger.Zero);
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _2_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(StructuredEncryptionHeader_Compile.__default.ValidVersion(_1_version), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Invalid Version Number")));
        if ((_2_valueOrError1).IsFailure()) {
          return (_2_valueOrError1).PropagateFailure<StructuredEncryptionHeader_Compile._IPartialHeader>();
        } else {
          byte _3_flavor = (data).Select(BigInteger.One);
          Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _4_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(StructuredEncryptionHeader_Compile.__default.ValidFlavor(_3_flavor), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Invalid Flavor")));
          if ((_4_valueOrError2).IsFailure()) {
            return (_4_valueOrError2).PropagateFailure<StructuredEncryptionHeader_Compile._IPartialHeader>();
          } else {
            Dafny.ISequence<byte> _5_msgID = (data).Subsequence(new BigInteger(2), StructuredEncryptionHeader_Compile.__default.PREFIX__LEN);
            Dafny.ISequence<byte> _6_legendData = (data).Drop(StructuredEncryptionHeader_Compile.__default.PREFIX__LEN);
            Wrappers_Compile._IResult<_System._ITuple2<Dafny.ISequence<byte>, BigInteger>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _7_valueOrError3 = StructuredEncryptionHeader_Compile.__default.GetLegend(_6_legendData);
            if ((_7_valueOrError3).IsFailure()) {
              return (_7_valueOrError3).PropagateFailure<StructuredEncryptionHeader_Compile._IPartialHeader>();
            } else {
              _System._ITuple2<Dafny.ISequence<byte>, BigInteger> _8_legendAndLen = (_7_valueOrError3).Extract();
              Dafny.ISequence<byte> _9_legend = (_8_legendAndLen).dtor__0;
              Dafny.ISequence<byte> _10_contextData = (_6_legendData).Drop((_8_legendAndLen).dtor__1);
              Wrappers_Compile._IResult<_System._ITuple2<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, BigInteger>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _11_valueOrError4 = StructuredEncryptionHeader_Compile.__default.GetContext(_10_contextData);
              if ((_11_valueOrError4).IsFailure()) {
                return (_11_valueOrError4).PropagateFailure<StructuredEncryptionHeader_Compile._IPartialHeader>();
              } else {
                _System._ITuple2<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, BigInteger> _12_contextAndLen = (_11_valueOrError4).Extract();
                Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _13_encContext = (_12_contextAndLen).dtor__0;
                Dafny.ISequence<byte> _14_keysData = (_10_contextData).Drop((_12_contextAndLen).dtor__1);
                Wrappers_Compile._IResult<_System._ITuple2<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>, BigInteger>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _15_valueOrError5 = StructuredEncryptionHeader_Compile.__default.GetDataKeys(_14_keysData);
                if ((_15_valueOrError5).IsFailure()) {
                  return (_15_valueOrError5).PropagateFailure<StructuredEncryptionHeader_Compile._IPartialHeader>();
                } else {
                  _System._ITuple2<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>, BigInteger> _16_keysAndLen = (_15_valueOrError5).Extract();
                  Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> _17_dataKeys = (_16_keysAndLen).dtor__0;
                  Dafny.ISequence<byte> _18_trailingData = (_14_keysData).Drop((_16_keysAndLen).dtor__1);
                  Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _19_valueOrError6 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((new BigInteger((_18_trailingData).Count)) >= (StructuredEncryptionHeader_Compile.__default.COMMITMENT__LEN), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Invalid header serialization: unexpected end of data.")));
                  if ((_19_valueOrError6).IsFailure()) {
                    return (_19_valueOrError6).PropagateFailure<StructuredEncryptionHeader_Compile._IPartialHeader>();
                  } else {
                    Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _20_valueOrError7 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((new BigInteger((_18_trailingData).Count)) <= (StructuredEncryptionHeader_Compile.__default.COMMITMENT__LEN), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Invalid header serialization: unexpected bytes.")));
                    if ((_20_valueOrError7).IsFailure()) {
                      return (_20_valueOrError7).PropagateFailure<StructuredEncryptionHeader_Compile._IPartialHeader>();
                    } else {
                      return Wrappers_Compile.Result<StructuredEncryptionHeader_Compile._IPartialHeader, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(StructuredEncryptionHeader_Compile.PartialHeader.create(_1_version, _3_flavor, _5_msgID, _9_legend, _13_encContext, _17_dataKeys));
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> CalculateHeaderCommitment(software.amazon.cryptography.primitives.internaldafny.types.IAwsCryptographicPrimitivesClient client, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo alg, Dafny.ISequence<byte> commitKey, Dafny.ISequence<byte> data)
    {
      software.amazon.cryptography.primitives.internaldafny.types._IHMacInput _0_input = software.amazon.cryptography.primitives.internaldafny.types.HMacInput.create((((alg).dtor_commitment).dtor_HKDF).dtor_hmac, commitKey, data);
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _1_outputR = (client).HMac(_0_input);
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _2_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(_1_outputR, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>)((_3_e) => {
        return software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.Error.create_AwsCryptographyPrimitives(_3_e);
      })));
      if ((_2_valueOrError0).IsFailure()) {
        return (_2_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
      } else {
        Dafny.ISequence<byte> _4_output = (_2_valueOrError0).Extract();
        if ((new BigInteger((_4_output).Count)) < (StructuredEncryptionHeader_Compile.__default.COMMITMENT__LEN)) {
          return Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Failure(StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("HMAC did not produce enough bits")));
        } else {
          return Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success((_4_output).Take(StructuredEncryptionHeader_Compile.__default.COMMITMENT__LEN));
        }
      }
    }
    public static Wrappers_Compile._IResult<ushort, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> ToUInt16(BigInteger x) {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((x) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Value too big for 16 bits")));
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<ushort>();
      } else {
        return Wrappers_Compile.Result<ushort, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success((ushort)(x));
      }
    }
    public static Dafny.IMap<__Y,__Z> MyMap<__X, __Y, __Z>(Func<__X, __Y> f, Dafny.IMap<__X,__Z> m)
    {
      return Dafny.Helpers.Id<Func<Dafny.IMap<__X,__Z>, Func<__X, __Y>, Dafny.IMap<__Y,__Z>>>((_0_m, _1_f) => ((System.Func<Dafny.IMap<__Y,__Z>>)(() => {
        var _coll0 = new System.Collections.Generic.List<Dafny.Pair<__Y,__Z>>();
        foreach (__X _compr_0 in (_0_m).Keys.Elements) {
          __X _2_k = (__X)_compr_0;
          if ((_0_m).Contains(_2_k)) {
            _coll0.Add(new Dafny.Pair<__Y,__Z>(Dafny.Helpers.Id<Func<__X, __Y>>(_1_f)(_2_k), Dafny.Map<__X, __Z>.Select(_0_m,_2_k)));
          }
        }
        return Dafny.Map<__Y,__Z>.FromCollection(_coll0);
      }))())(m, f);
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> MakeLegend(Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> schema) {
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = StructuredEncryptionHeader_Compile.__default.MakeLegend2(schema, StructuredEncryptionHeader_Compile.__default.EmptyLegend);
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
      } else {
        Dafny.ISequence<byte> _1_legend = (_0_valueOrError0).Extract();
        BigInteger _2_authCount = StructuredEncryptionHeader_Compile.__default.CountAuthAttrs(schema);
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _3_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((_2_authCount) == (new BigInteger((_1_legend).Count)), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Internal Error : bad legend calculation.")));
        if ((_3_valueOrError1).IsFailure()) {
          return (_3_valueOrError1).PropagateFailure<Dafny.ISequence<byte>>();
        } else {
          return Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(_1_legend);
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> MakeLegend2(Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> data, Dafny.ISequence<byte> serialized)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((data).Count)).Sign == 0) {
        return Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(serialized);
      } else if (StructuredEncryptionUtil_Compile.__default.IsAuthAttr(((data).Select(BigInteger.Zero)).dtor_action)) {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(((new BigInteger((serialized).Count)) + (BigInteger.One)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Legend Too Long.")));
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
        } else {
          byte _1_legendChar = StructuredEncryptionHeader_Compile.__default.GetActionLegend(((data).Select(BigInteger.Zero)).dtor_action);
          Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> _in0 = (data).Drop(BigInteger.One);
          Dafny.ISequence<byte> _in1 = Dafny.Sequence<byte>.Concat(serialized, Dafny.Sequence<byte>.FromElements(_1_legendChar));
          data = _in0;
          serialized = _in1;
          goto TAIL_CALL_START;
        }
      } else {
        Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> _in2 = (data).Drop(BigInteger.One);
        Dafny.ISequence<byte> _in3 = serialized;
        data = _in2;
        serialized = _in3;
        goto TAIL_CALL_START;
      }
    }
    public static byte GetActionLegend(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction x) {
      software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction _source0 = x;
      {
        if (_source0.is_ENCRYPT__AND__SIGN) {
          return StructuredEncryptionHeader_Compile.__default.ENCRYPT__AND__SIGN__LEGEND;
        }
      }
      {
        if (_source0.is_SIGN__AND__INCLUDE__IN__ENCRYPTION__CONTEXT) {
          return StructuredEncryptionHeader_Compile.__default.SIGN__AND__INCLUDE__IN__ENCRYPTION__CONTEXT__LEGEND;
        }
      }
      {
        return StructuredEncryptionHeader_Compile.__default.SIGN__ONLY__LEGEND;
      }
    }
    public static BigInteger CountAuthAttrs(Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> data) {
      BigInteger _0___accumulator = BigInteger.Zero;
    TAIL_CALL_START: ;
      if ((new BigInteger((data).Count)).Sign == 0) {
        return (BigInteger.Zero) + (_0___accumulator);
      } else if (StructuredEncryptionUtil_Compile.__default.IsAuthAttr(((data).Select(BigInteger.Zero)).dtor_action)) {
        _0___accumulator = (_0___accumulator) + (BigInteger.One);
        Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> _in0 = (data).Drop(BigInteger.One);
        data = _in0;
        goto TAIL_CALL_START;
      } else {
        Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> _in1 = (data).Drop(BigInteger.One);
        data = _in1;
        goto TAIL_CALL_START;
      }
    }
    public static Dafny.ISequence<byte> SerializeLegend(Dafny.ISequence<byte> x) {
      return Dafny.Sequence<byte>.Concat(StandardLibrary_mUInt_Compile.__default.UInt16ToSeq((ushort)(x).Count), x);
    }
    public static Wrappers_Compile._IResult<_System._ITuple2<Dafny.ISequence<byte>, BigInteger>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> GetLegend(Dafny.ISequence<byte> data) {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((new BigInteger(2)) <= (new BigInteger((data).Count)), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Unexpected end of header data.")));
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<_System._ITuple2<Dafny.ISequence<byte>, BigInteger>>();
      } else {
        ushort _1_len = StandardLibrary_mUInt_Compile.__default.SeqToUInt16((data).Subsequence(BigInteger.Zero, new BigInteger(2)));
        BigInteger _2_size = (new BigInteger(_1_len)) + (new BigInteger(2));
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _3_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((_2_size) <= (new BigInteger((data).Count)), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Unexpected end of header data.")));
        if ((_3_valueOrError1).IsFailure()) {
          return (_3_valueOrError1).PropagateFailure<_System._ITuple2<Dafny.ISequence<byte>, BigInteger>>();
        } else {
          Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _4_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(Dafny.Helpers.Id<Func<Dafny.ISequence<byte>, BigInteger, bool>>((_5_data, _6_size) => Dafny.Helpers.Quantifier<byte>(((_5_data).Subsequence(new BigInteger(2), _6_size)).UniqueElements, true, (((_forall_var_0) => {
            byte _7_x = (byte)_forall_var_0;
            return !(((_5_data).Subsequence(new BigInteger(2), _6_size)).Contains(_7_x)) || (StructuredEncryptionHeader_Compile.__default.ValidLegendByte(_7_x));
          }))))(data, _2_size), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Invalid byte in stored legend")));
          if ((_4_valueOrError2).IsFailure()) {
            return (_4_valueOrError2).PropagateFailure<_System._ITuple2<Dafny.ISequence<byte>, BigInteger>>();
          } else {
            return Wrappers_Compile.Result<_System._ITuple2<Dafny.ISequence<byte>, BigInteger>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(_System.Tuple2<Dafny.ISequence<byte>, BigInteger>.create((data).Subsequence(new BigInteger(2), _2_size), _2_size));
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<_System._ITuple2<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, BigInteger>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> GetContext(Dafny.ISequence<byte> data) {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((new BigInteger(2)) <= (new BigInteger((data).Count)), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Unexpected end of header data.")));
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<_System._ITuple2<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, BigInteger>>();
      } else {
        BigInteger _1_count = new BigInteger(StandardLibrary_mUInt_Compile.__default.SeqToUInt16((data).Subsequence(BigInteger.Zero, new BigInteger(2))));
        Wrappers_Compile._IResult<_System._ITuple2<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, BigInteger>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _2_valueOrError1 = StructuredEncryptionHeader_Compile.__default.GetContext2(_1_count, data, (data).Drop(new BigInteger(2)), _System.Tuple2<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, BigInteger>.create(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(), new BigInteger(2)), Dafny.Sequence<byte>.FromElements());
        if ((_2_valueOrError1).IsFailure()) {
          return (_2_valueOrError1).PropagateFailure<_System._ITuple2<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, BigInteger>>();
        } else {
          _System._ITuple2<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, BigInteger> _3_context = (_2_valueOrError1).Extract();
          return Wrappers_Compile.Result<_System._ITuple2<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, BigInteger>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(_3_context);
        }
      }
    }
    public static Wrappers_Compile._IResult<_System._ITuple3<Dafny.ISequence<byte>, Dafny.ISequence<byte>, BigInteger>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> GetOneKVPair(Dafny.ISequence<byte> data) {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((new BigInteger(2)) <= (new BigInteger((data).Count)), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Unexpected end of header data.")));
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<_System._ITuple3<Dafny.ISequence<byte>, Dafny.ISequence<byte>, BigInteger>>();
      } else {
        BigInteger _1_keyLen = new BigInteger(StandardLibrary_mUInt_Compile.__default.SeqToUInt16((data).Subsequence(BigInteger.Zero, new BigInteger(2))));
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _2_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(((_1_keyLen) + (new BigInteger(4))) <= (new BigInteger((data).Count)), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Unexpected end of header data.")));
        if ((_2_valueOrError1).IsFailure()) {
          return (_2_valueOrError1).PropagateFailure<_System._ITuple3<Dafny.ISequence<byte>, Dafny.ISequence<byte>, BigInteger>>();
        } else {
          Dafny.ISequence<byte> _3_key = (data).Subsequence(new BigInteger(2), (_1_keyLen) + (new BigInteger(2)));
          Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _4_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(UTF8.__default.ValidUTF8Seq(_3_key), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Invalid UTF8 found in header.")));
          if ((_4_valueOrError2).IsFailure()) {
            return (_4_valueOrError2).PropagateFailure<_System._ITuple3<Dafny.ISequence<byte>, Dafny.ISequence<byte>, BigInteger>>();
          } else {
            BigInteger _5_valueLen = new BigInteger(StandardLibrary_mUInt_Compile.__default.SeqToUInt16((data).Subsequence((_1_keyLen) + (new BigInteger(2)), (_1_keyLen) + (new BigInteger(4)))));
            BigInteger _6_kvLen = (((new BigInteger(2)) + (_1_keyLen)) + (new BigInteger(2))) + (_5_valueLen);
            Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _7_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((_6_kvLen) <= (new BigInteger((data).Count)), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Unexpected end of header data.")));
            if ((_7_valueOrError3).IsFailure()) {
              return (_7_valueOrError3).PropagateFailure<_System._ITuple3<Dafny.ISequence<byte>, Dafny.ISequence<byte>, BigInteger>>();
            } else {
              Dafny.ISequence<byte> _8_value = (data).Subsequence((_1_keyLen) + (new BigInteger(4)), _6_kvLen);
              Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _9_valueOrError4 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(UTF8.__default.ValidUTF8Seq(_8_value), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Invalid UTF8 found in header.")));
              if ((_9_valueOrError4).IsFailure()) {
                return (_9_valueOrError4).PropagateFailure<_System._ITuple3<Dafny.ISequence<byte>, Dafny.ISequence<byte>, BigInteger>>();
              } else {
                return Wrappers_Compile.Result<_System._ITuple3<Dafny.ISequence<byte>, Dafny.ISequence<byte>, BigInteger>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(_System.Tuple3<Dafny.ISequence<byte>, Dafny.ISequence<byte>, BigInteger>.create(_3_key, _8_value, _6_kvLen));
              }
            }
          }
        }
      }
    }
    public static bool BytesLess(Dafny.ISequence<byte> a, Dafny.ISequence<byte> b)
    {
    TAIL_CALL_START: ;
      if ((a).Equals(b)) {
        return false;
      } else if ((new BigInteger((a).Count)).Sign == 0) {
        return true;
      } else if ((new BigInteger((b).Count)).Sign == 0) {
        return false;
      } else if (((a).Select(BigInteger.Zero)) != ((b).Select(BigInteger.Zero))) {
        return ((a).Select(BigInteger.Zero)) < ((b).Select(BigInteger.Zero));
      } else {
        Dafny.ISequence<byte> _in0 = (a).Drop(BigInteger.One);
        Dafny.ISequence<byte> _in1 = (b).Drop(BigInteger.One);
        a = _in0;
        b = _in1;
        goto TAIL_CALL_START;
      }
    }
    public static Wrappers_Compile._IResult<_System._ITuple2<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, BigInteger>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> GetContext2(BigInteger count, Dafny.ISequence<byte> origData, Dafny.ISequence<byte> data, _System._ITuple2<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, BigInteger> deserialized, Dafny.ISequence<byte> prevKey)
    {
    TAIL_CALL_START: ;
      if ((count).Sign == 0) {
        return Wrappers_Compile.Result<_System._ITuple2<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, BigInteger>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(deserialized);
      } else {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(((new BigInteger(((deserialized).dtor__0).Count)) + (BigInteger.One)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Too much context")));
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<_System._ITuple2<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, BigInteger>>();
        } else {
          Wrappers_Compile._IResult<_System._ITuple3<Dafny.ISequence<byte>, Dafny.ISequence<byte>, BigInteger>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _1_valueOrError1 = StructuredEncryptionHeader_Compile.__default.GetOneKVPair(data);
          if ((_1_valueOrError1).IsFailure()) {
            return (_1_valueOrError1).PropagateFailure<_System._ITuple2<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, BigInteger>>();
          } else {
            _System._ITuple3<Dafny.ISequence<byte>, Dafny.ISequence<byte>, BigInteger> _2_kv = (_1_valueOrError1).Extract();
            Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _3_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(StructuredEncryptionHeader_Compile.__default.BytesLess(prevKey, (_2_kv).dtor__0), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Context keys out of order.")));
            if ((_3_valueOrError2).IsFailure()) {
              return (_3_valueOrError2).PropagateFailure<_System._ITuple2<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, BigInteger>>();
            } else {
              BigInteger _in0 = (count) - (BigInteger.One);
              Dafny.ISequence<byte> _in1 = origData;
              Dafny.ISequence<byte> _in2 = (data).Drop((((new BigInteger(2)) + (new BigInteger(((_2_kv).dtor__0).Count))) + (new BigInteger(2))) + (new BigInteger(((_2_kv).dtor__1).Count)));
              _System._ITuple2<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, BigInteger> _in3 = _System.Tuple2<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, BigInteger>.create(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Update((deserialized).dtor__0, (_2_kv).dtor__0, (_2_kv).dtor__1), ((deserialized).dtor__1) + ((_2_kv).dtor__2));
              Dafny.ISequence<byte> _in4 = (_2_kv).dtor__0;
              count = _in0;
              origData = _in1;
              data = _in2;
              deserialized = _in3;
              prevKey = _in4;
              goto TAIL_CALL_START;
            }
          }
        }
      }
    }
    public static Dafny.ISequence<byte> SerializeContext(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> x) {
      Dafny.ISequence<Dafny.ISequence<byte>> _0_keys = SortedSets.__default.SetToOrderedSequence2<byte>((x).Keys, StructuredEncryptionUtil_Compile.__default.ByteLess);
      return Dafny.Sequence<byte>.Concat(StandardLibrary_mUInt_Compile.__default.UInt16ToSeq((ushort)(x).Count), StructuredEncryptionHeader_Compile.__default.SerializeContext2(_0_keys, x));
    }
    public static Dafny.ISequence<byte> SerializeOneKVPair(Dafny.ISequence<byte> key, Dafny.ISequence<byte> @value)
    {
      return Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(StandardLibrary_mUInt_Compile.__default.UInt16ToSeq((ushort)(key).Count), key), StandardLibrary_mUInt_Compile.__default.UInt16ToSeq((ushort)(@value).Count)), @value);
    }
    public static Dafny.ISequence<byte> SerializeOneDataKey(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey k) {
      return Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(StandardLibrary_mUInt_Compile.__default.UInt16ToSeq((ushort)((k).dtor_keyProviderId).Count), (k).dtor_keyProviderId), StandardLibrary_mUInt_Compile.__default.UInt16ToSeq((ushort)((k).dtor_keyProviderInfo).Count)), (k).dtor_keyProviderInfo), StandardLibrary_mUInt_Compile.__default.UInt16ToSeq((ushort)((k).dtor_ciphertext).Count)), (k).dtor_ciphertext);
    }
    public static Wrappers_Compile._IResult<_System._ITuple2<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, BigInteger>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> GetOneDataKey(Dafny.ISequence<byte> data) {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((new BigInteger(2)) < (new BigInteger((data).Count)), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Unexpected end of header data.")));
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<_System._ITuple2<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, BigInteger>>();
      } else {
        BigInteger _1_provIdSize = new BigInteger(StandardLibrary_mUInt_Compile.__default.SeqToUInt16((data).Subsequence(BigInteger.Zero, new BigInteger(2))));
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _2_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(((_1_provIdSize) + (new BigInteger(2))) < (new BigInteger((data).Count)), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Unexpected end of header data.")));
        if ((_2_valueOrError1).IsFailure()) {
          return (_2_valueOrError1).PropagateFailure<_System._ITuple2<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, BigInteger>>();
        } else {
          Dafny.ISequence<byte> _3_provId = (data).Subsequence(new BigInteger(2), (new BigInteger(2)) + (_1_provIdSize));
          Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _4_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(UTF8.__default.ValidUTF8Seq(_3_provId), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Invalid UTF8 found in header.")));
          if ((_4_valueOrError2).IsFailure()) {
            return (_4_valueOrError2).PropagateFailure<_System._ITuple2<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, BigInteger>>();
          } else {
            BigInteger _5_part1Size = (new BigInteger(2)) + (_1_provIdSize);
            Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _6_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(((_5_part1Size) + (new BigInteger(2))) <= (new BigInteger((data).Count)), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Unexpected end of header data.")));
            if ((_6_valueOrError3).IsFailure()) {
              return (_6_valueOrError3).PropagateFailure<_System._ITuple2<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, BigInteger>>();
            } else {
              BigInteger _7_provInfoSize = new BigInteger(StandardLibrary_mUInt_Compile.__default.SeqToUInt16((data).Subsequence(_5_part1Size, (_5_part1Size) + (new BigInteger(2)))));
              Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _8_valueOrError4 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((((_5_part1Size) + (_7_provInfoSize)) + (new BigInteger(2))) < (new BigInteger((data).Count)), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Unexpected end of header data.")));
              if ((_8_valueOrError4).IsFailure()) {
                return (_8_valueOrError4).PropagateFailure<_System._ITuple2<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, BigInteger>>();
              } else {
                Dafny.ISequence<byte> _9_provInfo = (data).Subsequence((_5_part1Size) + (new BigInteger(2)), ((_5_part1Size) + (new BigInteger(2))) + (_7_provInfoSize));
                BigInteger _10_part2Size = ((_5_part1Size) + (new BigInteger(2))) + (_7_provInfoSize);
                Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _11_valueOrError5 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(((_10_part2Size) + (new BigInteger(2))) <= (new BigInteger((data).Count)), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Unexpected end of header data.")));
                if ((_11_valueOrError5).IsFailure()) {
                  return (_11_valueOrError5).PropagateFailure<_System._ITuple2<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, BigInteger>>();
                } else {
                  BigInteger _12_cipherSize = new BigInteger(StandardLibrary_mUInt_Compile.__default.SeqToUInt16((data).Subsequence(_10_part2Size, (_10_part2Size) + (new BigInteger(2)))));
                  Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _13_valueOrError6 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((((_10_part2Size) + (_12_cipherSize)) + (new BigInteger(2))) <= (new BigInteger((data).Count)), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Unexpected end of header data.")));
                  if ((_13_valueOrError6).IsFailure()) {
                    return (_13_valueOrError6).PropagateFailure<_System._ITuple2<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, BigInteger>>();
                  } else {
                    Dafny.ISequence<byte> _14_cipher = (data).Subsequence((_10_part2Size) + (new BigInteger(2)), ((_10_part2Size) + (new BigInteger(2))) + (_12_cipherSize));
                    BigInteger _15_part3Size = ((_10_part2Size) + (new BigInteger(2))) + (_12_cipherSize);
                    software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey _16_edk = software.amazon.cryptography.materialproviders.internaldafny.types.EncryptedDataKey.create(_3_provId, _9_provInfo, _14_cipher);
                    return Wrappers_Compile.Result<_System._ITuple2<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, BigInteger>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(_System.Tuple2<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, BigInteger>.create(_16_edk, _15_part3Size));
                  }
                }
              }
            }
          }
        }
      }
    }
    public static Dafny.ISequence<byte> SerializeContext2(Dafny.ISequence<Dafny.ISequence<byte>> keys, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> x)
    {
      Dafny.ISequence<byte> _0___accumulator = Dafny.Sequence<byte>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((keys).Count)).Sign == 0) {
        return Dafny.Sequence<byte>.Concat(_0___accumulator, Dafny.Sequence<byte>.FromElements());
      } else {
        _0___accumulator = Dafny.Sequence<byte>.Concat(_0___accumulator, StructuredEncryptionHeader_Compile.__default.SerializeOneKVPair((keys).Select(BigInteger.Zero), Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(x,(keys).Select(BigInteger.Zero))));
        Dafny.ISequence<Dafny.ISequence<byte>> _in0 = (keys).Drop(BigInteger.One);
        Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _in1 = x;
        keys = _in0;
        x = _in1;
        goto TAIL_CALL_START;
      }
    }
    public static Dafny.ISequence<byte> SerializeDataKeys(Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> x) {
      Dafny.ISequence<byte> _0_body = StructuredEncryptionHeader_Compile.__default.SerializeDataKeys2(x);
      return Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.FromElements((byte)(x).Count), _0_body);
    }
    public static Dafny.ISequence<byte> SerializeDataKeys2(Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> x) {
      Dafny.ISequence<byte> _0___accumulator = Dafny.Sequence<byte>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((x).Count)).Sign == 0) {
        return Dafny.Sequence<byte>.Concat(_0___accumulator, Dafny.Sequence<byte>.FromElements());
      } else {
        _0___accumulator = Dafny.Sequence<byte>.Concat(_0___accumulator, StructuredEncryptionHeader_Compile.__default.SerializeOneDataKey((x).Select(BigInteger.Zero)));
        Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> _in0 = (x).Drop(BigInteger.One);
        x = _in0;
        goto TAIL_CALL_START;
      }
    }
    public static Wrappers_Compile._IResult<_System._ITuple2<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>, BigInteger>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> GetDataKeys(Dafny.ISequence<byte> data) {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((BigInteger.One) <= (new BigInteger((data).Count)), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Unexpected end of header data.")));
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<_System._ITuple2<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>, BigInteger>>();
      } else {
        BigInteger _1_count = new BigInteger((data).Select(BigInteger.Zero));
        Wrappers_Compile._IResult<_System._ITuple2<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>, BigInteger>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _2_valueOrError1 = StructuredEncryptionHeader_Compile.__default.GetDataKeys2(_1_count, _1_count, data, (data).Drop(BigInteger.One), _System.Tuple2<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>, BigInteger>.create(Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.FromElements(), BigInteger.One));
        if ((_2_valueOrError1).IsFailure()) {
          return (_2_valueOrError1).PropagateFailure<_System._ITuple2<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>, BigInteger>>();
        } else {
          _System._ITuple2<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>, BigInteger> _3_keys = (_2_valueOrError1).Extract();
          if ((new BigInteger(((_3_keys).dtor__0).Count)).Sign == 0) {
            return Wrappers_Compile.Result<_System._ITuple2<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>, BigInteger>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Failure(StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("At least one Data Key required")));
          } else {
            return Wrappers_Compile.Result<_System._ITuple2<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>, BigInteger>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(_3_keys);
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<_System._ITuple2<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>, BigInteger>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> GetDataKeys2(BigInteger count, BigInteger origCount, Dafny.ISequence<byte> origData, Dafny.ISequence<byte> data, _System._ITuple2<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>, BigInteger> deserialized)
    {
    TAIL_CALL_START: ;
      if ((count).Sign == 0) {
        return Wrappers_Compile.Result<_System._ITuple2<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>, BigInteger>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(deserialized);
      } else if ((new BigInteger(((deserialized).dtor__0).Count)) >= (new BigInteger(255))) {
        return Wrappers_Compile.Result<_System._ITuple2<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>, BigInteger>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Failure(StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Too Many Data Keys")));
      } else {
        Wrappers_Compile._IResult<_System._ITuple2<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, BigInteger>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = StructuredEncryptionHeader_Compile.__default.GetOneDataKey(data);
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<_System._ITuple2<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>, BigInteger>>();
        } else {
          _System._ITuple2<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey, BigInteger> _1_edk = (_0_valueOrError0).Extract();
          BigInteger _in0 = (count) - (BigInteger.One);
          BigInteger _in1 = origCount;
          Dafny.ISequence<byte> _in2 = origData;
          Dafny.ISequence<byte> _in3 = (data).Drop((_1_edk).dtor__1);
          _System._ITuple2<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>, BigInteger> _in4 = _System.Tuple2<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>, BigInteger>.create(Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.Concat((deserialized).dtor__0, Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.FromElements((_1_edk).dtor__0)), ((deserialized).dtor__1) + ((_1_edk).dtor__1));
          count = _in0;
          origCount = _in1;
          origData = _in2;
          data = _in3;
          deserialized = _in4;
          goto TAIL_CALL_START;
        }
      }
    }
    public static BigInteger VERSION__LEN { get {
      return BigInteger.One;
    } }
    public static BigInteger FLAVOR__LEN { get {
      return BigInteger.One;
    } }
    public static BigInteger PREFIX__LEN { get {
      return ((StructuredEncryptionHeader_Compile.__default.VERSION__LEN) + (StructuredEncryptionHeader_Compile.__default.FLAVOR__LEN)) + (StructuredEncryptionUtil_Compile.__default.MSGID__LEN);
    } }
    public static byte ENCRYPT__AND__SIGN__LEGEND { get {
      return (byte)(101);
    } }
    public static byte SIGN__AND__INCLUDE__IN__ENCRYPTION__CONTEXT__LEGEND { get {
      return (byte)(99);
    } }
    public static byte SIGN__ONLY__LEGEND { get {
      return (byte)(115);
    } }
    public static BigInteger UINT8__LIMIT { get {
      return new BigInteger(256);
    } }
    public static BigInteger COMMITMENT__LEN { get {
      return new BigInteger(32);
    } }
    public static Dafny.ISequence<byte> EmptyLegend { get {
      return Dafny.Sequence<byte>.FromElements();
    } }
  }

  public partial class Version {
    private static readonly byte Witness = (byte)(1);
    public static byte Default() {
      return Witness;
    }
    private static readonly Dafny.TypeDescriptor<byte> _TYPE = new Dafny.TypeDescriptor<byte>(StructuredEncryptionHeader_Compile.Version.Default());
    public static Dafny.TypeDescriptor<byte> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(byte __source) {
      byte _0_x = (byte)(__source);
      if (true) {
        return StructuredEncryptionHeader_Compile.__default.ValidVersion(_0_x);
      }
      return false;
    }
  }

  public partial class Flavor {
    private static readonly Dafny.TypeDescriptor<byte> _TYPE = new Dafny.TypeDescriptor<byte>(0);
    public static Dafny.TypeDescriptor<byte> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(byte __source) {
      byte _1_x = (byte)(__source);
      if (true) {
        return StructuredEncryptionHeader_Compile.__default.ValidFlavor(_1_x);
      }
      return false;
    }
  }

  public partial class CMPEncryptedDataKeyList {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>>(Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> __source) {
      Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> _2_x = __source;
      return ((new BigInteger((_2_x).Count)).Sign == 1) && ((new BigInteger((_2_x).Count)) < (StructuredEncryptionHeader_Compile.__default.UINT8__LIMIT));
    }
  }

  public partial class Commitment {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<byte>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<byte>>(Dafny.Sequence<byte>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<byte>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.ISequence<byte> __source) {
      Dafny.ISequence<byte> _3_x = __source;
      return (new BigInteger((_3_x).Count)) == (StructuredEncryptionHeader_Compile.__default.COMMITMENT__LEN);
    }
  }

  public partial class CMPEncryptedDataKey {
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>(software.amazon.cryptography.materialproviders.internaldafny.types.EncryptedDataKey.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey __source) {
      software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey _4_x = __source;
      return StructuredEncryptionHeader_Compile.__default.ValidEncryptedDataKey(_4_x);
    }
  }

  public partial class CMPEncryptionContext {
    private static readonly Dafny.TypeDescriptor<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> _TYPE = new Dafny.TypeDescriptor<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty);
    public static Dafny.TypeDescriptor<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> __source) {
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _5_x = __source;
      return StructuredEncryptionHeader_Compile.__default.ValidEncryptionContext(_5_x);
    }
  }

  public partial class CMPEncryptedDataKeyListEmptyOK {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>>(Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> __source) {
      Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> _6_x = __source;
      return (new BigInteger((_6_x).Count)) < (StructuredEncryptionHeader_Compile.__default.UINT8__LIMIT);
    }
  }

  public partial class LegendByte {
    private static readonly byte Witness = StructuredEncryptionHeader_Compile.__default.SIGN__ONLY__LEGEND;
    public static byte Default() {
      return Witness;
    }
    private static readonly Dafny.TypeDescriptor<byte> _TYPE = new Dafny.TypeDescriptor<byte>(StructuredEncryptionHeader_Compile.LegendByte.Default());
    public static Dafny.TypeDescriptor<byte> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(byte __source) {
      byte _7_x = (byte)(__source);
      if (true) {
        return StructuredEncryptionHeader_Compile.__default.ValidLegendByte(_7_x);
      }
      return false;
    }
  }

  public partial class Legend {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<byte>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<byte>>(Dafny.Sequence<byte>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<byte>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.ISequence<byte> __source) {
      Dafny.ISequence<byte> _8_x = __source;
      return (new BigInteger((_8_x).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT);
    }
  }

  public partial class CMPUtf8Bytes {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<byte>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<byte>>(UTF8.ValidUTF8Bytes.Default());
    public static Dafny.TypeDescriptor<Dafny.ISequence<byte>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.ISequence<byte> __source) {
      Dafny.ISequence<byte> _9_x = __source;
      if (UTF8.ValidUTF8Bytes._Is(_9_x)) {
        return (new BigInteger((_9_x).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT16__LIMIT);
      }
      return false;
    }
  }

  public interface _IPartialHeader {
    bool is_PartialHeader { get; }
    byte dtor_version { get; }
    byte dtor_flavor { get; }
    Dafny.ISequence<byte> dtor_msgID { get; }
    Dafny.ISequence<byte> dtor_legend { get; }
    Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encContext { get; }
    Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> dtor_dataKeys { get; }
    _IPartialHeader DowncastClone();
    Dafny.ISequence<byte> serialize();
    Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> verifyCommitment(software.amazon.cryptography.primitives.internaldafny.types.IAwsCryptographicPrimitivesClient client, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo alg, Dafny.ISequence<byte> commitKey, Dafny.ISequence<byte> data);
    Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> GetAlgorithmSuite(software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient matProv);
  }
  public class PartialHeader : _IPartialHeader {
    public readonly byte _version;
    public readonly byte _flavor;
    public readonly Dafny.ISequence<byte> _msgID;
    public readonly Dafny.ISequence<byte> _legend;
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _encContext;
    public readonly Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> _dataKeys;
    public PartialHeader(byte version, byte flavor, Dafny.ISequence<byte> msgID, Dafny.ISequence<byte> legend, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encContext, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> dataKeys) {
      this._version = version;
      this._flavor = flavor;
      this._msgID = msgID;
      this._legend = legend;
      this._encContext = encContext;
      this._dataKeys = dataKeys;
    }
    public _IPartialHeader DowncastClone() {
      if (this is _IPartialHeader dt) { return dt; }
      return new PartialHeader(_version, _flavor, _msgID, _legend, _encContext, _dataKeys);
    }
    public override bool Equals(object other) {
      var oth = other as StructuredEncryptionHeader_Compile.PartialHeader;
      return oth != null && this._version == oth._version && this._flavor == oth._flavor && object.Equals(this._msgID, oth._msgID) && object.Equals(this._legend, oth._legend) && object.Equals(this._encContext, oth._encContext) && object.Equals(this._dataKeys, oth._dataKeys);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._version));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._flavor));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._msgID));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._legend));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encContext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._dataKeys));
      return (int) hash;
    }
    public override string ToString() {
      string s = "StructuredEncryptionHeader.PartialHeader.PartialHeader";
      s += "(";
      s += Dafny.Helpers.ToString(this._version);
      s += ", ";
      s += Dafny.Helpers.ToString(this._flavor);
      s += ", ";
      s += Dafny.Helpers.ToString(this._msgID);
      s += ", ";
      s += Dafny.Helpers.ToString(this._legend);
      s += ", ";
      s += Dafny.Helpers.ToString(this._encContext);
      s += ", ";
      s += Dafny.Helpers.ToString(this._dataKeys);
      s += ")";
      return s;
    }
    private static readonly StructuredEncryptionHeader_Compile._IPartialHeader theDefault = create(StructuredEncryptionHeader_Compile.Version.Default(), 0, Dafny.Sequence<byte>.Empty, Dafny.Sequence<byte>.Empty, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty, Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.Empty);
    public static StructuredEncryptionHeader_Compile._IPartialHeader Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<StructuredEncryptionHeader_Compile._IPartialHeader> _TYPE = new Dafny.TypeDescriptor<StructuredEncryptionHeader_Compile._IPartialHeader>(StructuredEncryptionHeader_Compile.PartialHeader.Default());
    public static Dafny.TypeDescriptor<StructuredEncryptionHeader_Compile._IPartialHeader> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IPartialHeader create(byte version, byte flavor, Dafny.ISequence<byte> msgID, Dafny.ISequence<byte> legend, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encContext, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> dataKeys) {
      return new PartialHeader(version, flavor, msgID, legend, encContext, dataKeys);
    }
    public static _IPartialHeader create_PartialHeader(byte version, byte flavor, Dafny.ISequence<byte> msgID, Dafny.ISequence<byte> legend, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encContext, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> dataKeys) {
      return create(version, flavor, msgID, legend, encContext, dataKeys);
    }
    public bool is_PartialHeader { get { return true; } }
    public byte dtor_version {
      get {
        return this._version;
      }
    }
    public byte dtor_flavor {
      get {
        return this._flavor;
      }
    }
    public Dafny.ISequence<byte> dtor_msgID {
      get {
        return this._msgID;
      }
    }
    public Dafny.ISequence<byte> dtor_legend {
      get {
        return this._legend;
      }
    }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encContext {
      get {
        return this._encContext;
      }
    }
    public Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> dtor_dataKeys {
      get {
        return this._dataKeys;
      }
    }
    public Dafny.ISequence<byte> serialize() {
      Dafny.ISequence<byte> _0_context = StructuredEncryptionHeader_Compile.__default.SerializeContext((this).dtor_encContext);
      Dafny.ISequence<byte> _1_keys = StructuredEncryptionHeader_Compile.__default.SerializeDataKeys((this).dtor_dataKeys);
      Dafny.ISequence<byte> _2_leg = StructuredEncryptionHeader_Compile.__default.SerializeLegend((this).dtor_legend);
      return Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.FromElements((this).dtor_version), Dafny.Sequence<byte>.FromElements((this).dtor_flavor)), (this).dtor_msgID), _2_leg), _0_context), _1_keys);
    }
    public Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> verifyCommitment(software.amazon.cryptography.primitives.internaldafny.types.IAwsCryptographicPrimitivesClient client, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo alg, Dafny.ISequence<byte> commitKey, Dafny.ISequence<byte> data)
    {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((StructuredEncryptionHeader_Compile.__default.COMMITMENT__LEN) < (new BigInteger((data).Count)), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Serialized header too short")));
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<bool>();
      } else {
        Dafny.ISequence<byte> _1_storedCommitment = (data).Drop((new BigInteger((data).Count)) - (StructuredEncryptionHeader_Compile.__default.COMMITMENT__LEN));
        Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _2_valueOrError1 = StructuredEncryptionHeader_Compile.__default.CalculateHeaderCommitment(client, alg, commitKey, (data).Take((new BigInteger((data).Count)) - (StructuredEncryptionHeader_Compile.__default.COMMITMENT__LEN)));
        if ((_2_valueOrError1).IsFailure()) {
          return (_2_valueOrError1).PropagateFailure<bool>();
        } else {
          Dafny.ISequence<byte> _3_calcCommitment = (_2_valueOrError1).Extract();
          Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _4_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(StructuredEncryptionUtil_Compile.__default.ConstantTimeEquals(_1_storedCommitment, _3_calcCommitment), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Key commitment mismatch.")));
          if ((_4_valueOrError2).IsFailure()) {
            return (_4_valueOrError2).PropagateFailure<bool>();
          } else {
            return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(true);
          }
        }
      }
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> GetAlgorithmSuite(software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient matProv)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> ret = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _0_algorithmSuiteR;
      _0_algorithmSuiteR = (matProv).GetAlgorithmSuiteInfo(Dafny.Sequence<byte>.FromElements(StructuredEncryptionUtil_Compile.__default.DbeAlgorithmFamily, (this).dtor_flavor));
      if ((_0_algorithmSuiteR).is_Success) {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _1_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
        _1_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(StructuredEncryptionUtil_Compile.__default.ValidSuite((_0_algorithmSuiteR).dtor_value), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Invalid Algorithm Suite")));
        if ((_1_valueOrError0).IsFailure()) {
          ret = (_1_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo>();
          return ret;
        }
        ret = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success((_0_algorithmSuiteR).dtor_value);
        return ret;
      } else {
        ret = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(_0_algorithmSuiteR, ((System.Func<software.amazon.cryptography.materialproviders.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>)((_2_e) => {
          return software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.Error.create_AwsCryptographyMaterialProviders(_2_e);
        })));
        return ret;
      }
      return ret;
    }
  }
} // end of namespace StructuredEncryptionHeader_Compile
namespace StructuredEncryptionFooter_Compile {

  public partial class __default {
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> GetCanonicalType(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal @value, bool isEncrypted)
    {
      if (isEncrypted) {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(((new BigInteger(2)) <= (new BigInteger(((@value).dtor_value).Count))) && ((new BigInteger(((@value).dtor_value).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT64__LIMIT)), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Bad length.")));
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
        } else {
          return Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(Dafny.Sequence<byte>.Concat(StandardLibrary_mUInt_Compile.__default.UInt64ToSeq((ulong)((new BigInteger(((@value).dtor_value).Count)) - (new BigInteger(2)))), UTF8.__default.EncodeAscii(Dafny.Sequence<char>.FromString("ENCRYPTED"))));
        }
      } else {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _1_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((new BigInteger(((@value).dtor_value).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT64__LIMIT), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Bad length.")));
        if ((_1_valueOrError1).IsFailure()) {
          return (_1_valueOrError1).PropagateFailure<Dafny.ISequence<byte>>();
        } else {
          return Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(StandardLibrary_mUInt_Compile.__default.UInt64ToSeq((ulong)((@value).dtor_value).LongCount), UTF8.__default.EncodeAscii(Dafny.Sequence<char>.FromString("PLAINTEXT"))), (@value).dtor_typeId));
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> GetCanonicalEncryptedField(Dafny.ISequence<byte> fieldName, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal @value)
    {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(((new BigInteger(2)) <= (new BigInteger(((@value).dtor_value).Count))) && ((new BigInteger(((@value).dtor_value).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT64__LIMIT)), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Bad length.")));
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
      } else {
        return Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(fieldName, StandardLibrary_mUInt_Compile.__default.UInt64ToSeq((ulong)((new BigInteger(((@value).dtor_value).Count)) - (new BigInteger(2))))), UTF8.__default.EncodeAscii(Dafny.Sequence<char>.FromString("ENCRYPTED"))), (@value).dtor_value));
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> GetCanonicalPlaintextField(Dafny.ISequence<byte> fieldName, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal @value)
    {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((new BigInteger(((@value).dtor_value).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT64__LIMIT), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Bad length.")));
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
      } else {
        return Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(fieldName, StandardLibrary_mUInt_Compile.__default.UInt64ToSeq((ulong)((@value).dtor_value).LongCount)), UTF8.__default.EncodeAscii(Dafny.Sequence<char>.FromString("PLAINTEXT"))), (@value).dtor_typeId), (@value).dtor_value));
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> GetCanonicalItem(StructuredEncryptionUtil_Compile._ICanonCryptoItem data) {
      if (object.Equals((data).dtor_action, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_ENCRYPT__AND__SIGN())) {
        return StructuredEncryptionFooter_Compile.__default.GetCanonicalEncryptedField((data).dtor_key, (data).dtor_data);
      } else {
        return StructuredEncryptionFooter_Compile.__default.GetCanonicalPlaintextField((data).dtor_key, (data).dtor_data);
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> CanonContent(Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> data, Dafny.ISequence<byte> canonized)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((data).Count)).Sign == 0) {
        return Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(canonized);
      } else if (object.Equals(((data).Select(BigInteger.Zero)).dtor_action, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_DO__NOTHING())) {
        Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> _in0 = (data).Drop(BigInteger.One);
        Dafny.ISequence<byte> _in1 = canonized;
        data = _in0;
        canonized = _in1;
        goto TAIL_CALL_START;
      } else {
        Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = StructuredEncryptionFooter_Compile.__default.GetCanonicalItem((data).Select(BigInteger.Zero));
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
        } else {
          Dafny.ISequence<byte> _1_newPart = (_0_valueOrError0).Extract();
          Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> _in2 = (data).Drop(BigInteger.One);
          Dafny.ISequence<byte> _in3 = Dafny.Sequence<byte>.Concat(canonized, _1_newPart);
          data = _in2;
          canonized = _in3;
          goto TAIL_CALL_START;
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> CanonRecord(Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> data, Dafny.ISequence<byte> header, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> enc)
    {
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = StructuredEncryptionFooter_Compile.__default.CanonContent(data, Dafny.Sequence<byte>.FromElements());
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
      } else {
        Dafny.ISequence<byte> _1_canon = (_0_valueOrError0).Extract();
        Dafny.ISequence<byte> _2_AAD = StructuredEncryptionHeader_Compile.__default.SerializeContext(enc);
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _3_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((new BigInteger((_2_AAD).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT64__LIMIT), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("AAD too long.")));
        if ((_3_valueOrError1).IsFailure()) {
          return (_3_valueOrError1).PropagateFailure<Dafny.ISequence<byte>>();
        } else {
          Dafny.ISequence<byte> _4_len = StandardLibrary_mUInt_Compile.__default.UInt64ToSeq((ulong)(_2_AAD).LongCount);
          return Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(header, _4_len), _2_AAD), _1_canon));
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> CanonHash(Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> data, Dafny.ISequence<byte> header, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> enc)
    {
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> ret = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _0_valueOrError0 = StructuredEncryptionFooter_Compile.__default.CanonRecord(data, header, enc);
      if ((_0_valueOrError0).IsFailure()) {
        ret = (_0_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
        return ret;
      }
      Dafny.ISequence<byte> _1_data;
      _1_data = (_0_valueOrError0).Extract();
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _2_resultR;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _out0;
      _out0 = Digest_Compile.__default.Digest(software.amazon.cryptography.primitives.internaldafny.types.DigestInput.create(software.amazon.cryptography.primitives.internaldafny.types.DigestAlgorithm.create_SHA__384(), _1_data));
      _2_resultR = _out0;
      ret = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(_2_resultR, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>)((_3_e) => {
        return software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.Error.create_AwsCryptographyPrimitives(_3_e);
      })));
      return ret;
      return ret;
    }
    public static Wrappers_Compile._IResult<StructuredEncryptionFooter_Compile._IFooter, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> CreateFooter(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient client, software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials mat, Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> data, Dafny.ISequence<byte> header)
    {
      Wrappers_Compile._IResult<StructuredEncryptionFooter_Compile._IFooter, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> ret = Wrappers_Compile.Result<StructuredEncryptionFooter_Compile._IFooter, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(StructuredEncryptionFooter_Compile.Footer.Default());
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _out0;
      _out0 = StructuredEncryptionFooter_Compile.__default.CanonHash(data, header, (mat).dtor_encryptionContext);
      _0_valueOrError0 = _out0;
      if ((_0_valueOrError0).IsFailure()) {
        ret = (_0_valueOrError0).PropagateFailure<StructuredEncryptionFooter_Compile._IFooter>();
        return ret;
      }
      Dafny.ISequence<byte> _1_canonicalHash;
      _1_canonicalHash = (_0_valueOrError0).Extract();
      Dafny.ISequence<Dafny.ISequence<byte>> _2_tags;
      _2_tags = Dafny.Sequence<Dafny.ISequence<byte>>.FromElements();
      BigInteger _hi0 = new BigInteger(((mat).dtor_encryptedDataKeys).Count);
      for (BigInteger _3_i = BigInteger.Zero; _3_i < _hi0; _3_i++) {
        software.amazon.cryptography.primitives.internaldafny.types._IHMacInput _4_input;
        _4_input = software.amazon.cryptography.primitives.internaldafny.types.HMacInput.create((((mat).dtor_algorithmSuite).dtor_symmetricSignature).dtor_HMAC, (((mat).dtor_symmetricSigningKeys).dtor_value).Select(_3_i), _1_canonicalHash);
        Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _5_hashR;
        _5_hashR = (client).HMac(_4_input);
        Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _6_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
        _6_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(_5_hashR, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>)((_7_e) => {
          return software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.Error.create_AwsCryptographyPrimitives(_7_e);
        })));
        if ((_6_valueOrError1).IsFailure()) {
          ret = (_6_valueOrError1).PropagateFailure<StructuredEncryptionFooter_Compile._IFooter>();
          return ret;
        }
        Dafny.ISequence<byte> _8_hash;
        _8_hash = (_6_valueOrError1).Extract();
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _9_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
        _9_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((new BigInteger((_8_hash).Count)) == (new BigInteger(48)), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Bad hash length")));
        if ((_9_valueOrError2).IsFailure()) {
          ret = (_9_valueOrError2).PropagateFailure<StructuredEncryptionFooter_Compile._IFooter>();
          return ret;
        }
        _2_tags = Dafny.Sequence<Dafny.ISequence<byte>>.Concat(_2_tags, Dafny.Sequence<Dafny.ISequence<byte>>.FromElements(_8_hash));
      }
      if ((((mat).dtor_algorithmSuite).dtor_signature).is_ECDSA) {
        software.amazon.cryptography.primitives.internaldafny.types._IECDSASignInput _10_verInput;
        _10_verInput = software.amazon.cryptography.primitives.internaldafny.types.ECDSASignInput.create(((((mat).dtor_algorithmSuite).dtor_signature).dtor_ECDSA).dtor_curve, ((mat).dtor_signingKey).dtor_value, _1_canonicalHash);
        Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _11_sigR;
        Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _out1;
        _out1 = (client).ECDSASign(_10_verInput);
        _11_sigR = _out1;
        Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _12_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
        _12_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(_11_sigR, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>)((_13_e) => {
          return software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.Error.create_AwsCryptographyPrimitives(_13_e);
        })));
        if ((_12_valueOrError3).IsFailure()) {
          ret = (_12_valueOrError3).PropagateFailure<StructuredEncryptionFooter_Compile._IFooter>();
          return ret;
        }
        Dafny.ISequence<byte> _14_sig;
        _14_sig = (_12_valueOrError3).Extract();
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _15_valueOrError4 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
        _15_valueOrError4 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((new BigInteger((_14_sig).Count)) == (StructuredEncryptionFooter_Compile.__default.SignatureSize), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Signature is "), StandardLibrary_mString_Compile.__default.Base10Int2String(new BigInteger((_14_sig).Count))), Dafny.Sequence<char>.FromString(" bytes, should have been ")), StandardLibrary_mString_Compile.__default.Base10Int2String(StructuredEncryptionFooter_Compile.__default.SignatureSize)), Dafny.Sequence<char>.FromString(" bytes."))));
        if ((_15_valueOrError4).IsFailure()) {
          ret = (_15_valueOrError4).PropagateFailure<StructuredEncryptionFooter_Compile._IFooter>();
          return ret;
        }
        ret = Wrappers_Compile.Result<StructuredEncryptionFooter_Compile._IFooter, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(StructuredEncryptionFooter_Compile.Footer.create(_2_tags, Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_14_sig)));
        return ret;
      } else {
        ret = Wrappers_Compile.Result<StructuredEncryptionFooter_Compile._IFooter, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(StructuredEncryptionFooter_Compile.Footer.create(_2_tags, Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None()));
        return ret;
      }
      return ret;
    }
    public static Dafny.ISequence<byte> SerializeTags(Dafny.ISequence<Dafny.ISequence<byte>> tags) {
      Dafny.ISequence<byte> _0___accumulator = Dafny.Sequence<byte>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((tags).Count)).Sign == 0) {
        return Dafny.Sequence<byte>.Concat(_0___accumulator, Dafny.Sequence<byte>.FromElements());
      } else {
        _0___accumulator = Dafny.Sequence<byte>.Concat(_0___accumulator, (tags).Select(BigInteger.Zero));
        Dafny.ISequence<Dafny.ISequence<byte>> _in0 = (tags).Drop(BigInteger.One);
        tags = _in0;
        goto TAIL_CALL_START;
      }
    }
    public static Dafny.ISequence<byte> SerializeSig(Wrappers_Compile._IOption<Dafny.ISequence<byte>> sig) {
      if ((sig).is_Some) {
        return (sig).dtor_value;
      } else {
        return Dafny.Sequence<byte>.FromElements();
      }
    }
    public static Dafny.ISequence<Dafny.ISequence<byte>> GatherTags(Dafny.ISequence<byte> data) {
      Dafny.ISequence<Dafny.ISequence<byte>> _0___accumulator = Dafny.Sequence<Dafny.ISequence<byte>>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((data).Count)).Sign == 0) {
        return Dafny.Sequence<Dafny.ISequence<byte>>.Concat(_0___accumulator, Dafny.Sequence<Dafny.ISequence<byte>>.FromElements());
      } else {
        _0___accumulator = Dafny.Sequence<Dafny.ISequence<byte>>.Concat(_0___accumulator, Dafny.Sequence<Dafny.ISequence<byte>>.FromElements((data).Subsequence(BigInteger.Zero, StructuredEncryptionFooter_Compile.__default.RecipientTagSize)));
        Dafny.ISequence<byte> _in0 = (data).Drop(StructuredEncryptionFooter_Compile.__default.RecipientTagSize);
        data = _in0;
        goto TAIL_CALL_START;
      }
    }
    public static Wrappers_Compile._IResult<StructuredEncryptionFooter_Compile._IFooter, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> DeserializeFooter(Dafny.ISequence<byte> data, bool hasSig)
    {
      if (hasSig) {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((Dafny.Helpers.EuclideanModulus((new BigInteger((data).Count)) - (StructuredEncryptionFooter_Compile.__default.SignatureSize), StructuredEncryptionFooter_Compile.__default.RecipientTagSize)).Sign == 0, StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Mangled signed footer has strange size")));
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<StructuredEncryptionFooter_Compile._IFooter>();
        } else {
          Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _1_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((new BigInteger((data).Count)) >= ((StructuredEncryptionFooter_Compile.__default.RecipientTagSize) + (StructuredEncryptionFooter_Compile.__default.SignatureSize)), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Footer too short.")));
          if ((_1_valueOrError1).IsFailure()) {
            return (_1_valueOrError1).PropagateFailure<StructuredEncryptionFooter_Compile._IFooter>();
          } else {
            return Wrappers_Compile.Result<StructuredEncryptionFooter_Compile._IFooter, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(StructuredEncryptionFooter_Compile.Footer.create(StructuredEncryptionFooter_Compile.__default.GatherTags((data).Take((new BigInteger((data).Count)) - (StructuredEncryptionFooter_Compile.__default.SignatureSize))), Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some((data).Drop((new BigInteger((data).Count)) - (StructuredEncryptionFooter_Compile.__default.SignatureSize)))));
          }
        }
      } else {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _2_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((Dafny.Helpers.EuclideanModulus(new BigInteger((data).Count), StructuredEncryptionFooter_Compile.__default.RecipientTagSize)).Sign == 0, StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Mangled unsigned footer has strange size")));
        if ((_2_valueOrError2).IsFailure()) {
          return (_2_valueOrError2).PropagateFailure<StructuredEncryptionFooter_Compile._IFooter>();
        } else {
          Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _3_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((new BigInteger((data).Count)) >= (StructuredEncryptionFooter_Compile.__default.RecipientTagSize), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Footer too short.")));
          if ((_3_valueOrError3).IsFailure()) {
            return (_3_valueOrError3).PropagateFailure<StructuredEncryptionFooter_Compile._IFooter>();
          } else {
            return Wrappers_Compile.Result<StructuredEncryptionFooter_Compile._IFooter, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(StructuredEncryptionFooter_Compile.Footer.create(StructuredEncryptionFooter_Compile.__default.GatherTags(data), Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None()));
          }
        }
      }
    }
    public static BigInteger RecipientTagSize { get {
      return new BigInteger(48);
    } }
    public static BigInteger SignatureSize { get {
      return new BigInteger(103);
    } }
  }

  public partial class RecipientTag {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<byte>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<byte>>(Dafny.Sequence<byte>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<byte>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.ISequence<byte> __source) {
      Dafny.ISequence<byte> _0_x = __source;
      return (new BigInteger((_0_x).Count)) == (StructuredEncryptionFooter_Compile.__default.RecipientTagSize);
    }
  }

  public partial class Signature {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<byte>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<byte>>(Dafny.Sequence<byte>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<byte>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.ISequence<byte> __source) {
      Dafny.ISequence<byte> _1_x = __source;
      return (new BigInteger((_1_x).Count)) == (StructuredEncryptionFooter_Compile.__default.SignatureSize);
    }
  }

  public interface _IFooter {
    bool is_Footer { get; }
    Dafny.ISequence<Dafny.ISequence<byte>> dtor_tags { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<byte>> dtor_sig { get; }
    _IFooter DowncastClone();
    Dafny.ISequence<byte> serialize();
    software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal makeTerminal();
    Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> validate(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient client, software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials mat, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> edks, Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> data, Dafny.ISequence<byte> header);
  }
  public class Footer : _IFooter {
    public readonly Dafny.ISequence<Dafny.ISequence<byte>> _tags;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<byte>> _sig;
    public Footer(Dafny.ISequence<Dafny.ISequence<byte>> tags, Wrappers_Compile._IOption<Dafny.ISequence<byte>> sig) {
      this._tags = tags;
      this._sig = sig;
    }
    public _IFooter DowncastClone() {
      if (this is _IFooter dt) { return dt; }
      return new Footer(_tags, _sig);
    }
    public override bool Equals(object other) {
      var oth = other as StructuredEncryptionFooter_Compile.Footer;
      return oth != null && object.Equals(this._tags, oth._tags) && object.Equals(this._sig, oth._sig);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._tags));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sig));
      return (int) hash;
    }
    public override string ToString() {
      string s = "StructuredEncryptionFooter.Footer.Footer";
      s += "(";
      s += Dafny.Helpers.ToString(this._tags);
      s += ", ";
      s += Dafny.Helpers.ToString(this._sig);
      s += ")";
      return s;
    }
    private static readonly StructuredEncryptionFooter_Compile._IFooter theDefault = create(Dafny.Sequence<Dafny.ISequence<byte>>.Empty, Wrappers_Compile.Option<Dafny.ISequence<byte>>.Default());
    public static StructuredEncryptionFooter_Compile._IFooter Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<StructuredEncryptionFooter_Compile._IFooter> _TYPE = new Dafny.TypeDescriptor<StructuredEncryptionFooter_Compile._IFooter>(StructuredEncryptionFooter_Compile.Footer.Default());
    public static Dafny.TypeDescriptor<StructuredEncryptionFooter_Compile._IFooter> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IFooter create(Dafny.ISequence<Dafny.ISequence<byte>> tags, Wrappers_Compile._IOption<Dafny.ISequence<byte>> sig) {
      return new Footer(tags, sig);
    }
    public static _IFooter create_Footer(Dafny.ISequence<Dafny.ISequence<byte>> tags, Wrappers_Compile._IOption<Dafny.ISequence<byte>> sig) {
      return create(tags, sig);
    }
    public bool is_Footer { get { return true; } }
    public Dafny.ISequence<Dafny.ISequence<byte>> dtor_tags {
      get {
        return this._tags;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<byte>> dtor_sig {
      get {
        return this._sig;
      }
    }
    public Dafny.ISequence<byte> serialize() {
      return Dafny.Sequence<byte>.Concat(StructuredEncryptionFooter_Compile.__default.SerializeTags((this).dtor_tags), StructuredEncryptionFooter_Compile.__default.SerializeSig((this).dtor_sig));
    }
    public software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal makeTerminal() {
      return StructuredEncryptionUtil_Compile.__default.ValueToData((this).serialize(), StructuredEncryptionUtil_Compile.__default.BYTES__TYPE__ID);
    }
    public Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> validate(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient client, software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials mat, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> edks, Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> data, Dafny.ISequence<byte> header)
    {
      Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> ret = Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(false);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
      _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((new BigInteger((edks).Count)) == (new BigInteger(((this).dtor_tags).Count)), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("There are a different number of recipient tags in the stored header than there are in the decryption materials.")));
      if ((_0_valueOrError0).IsFailure()) {
        ret = (_0_valueOrError0).PropagateFailure<bool>();
        return ret;
      }
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _1_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _out0;
      _out0 = StructuredEncryptionFooter_Compile.__default.CanonHash(data, header, (mat).dtor_encryptionContext);
      _1_valueOrError1 = _out0;
      if ((_1_valueOrError1).IsFailure()) {
        ret = (_1_valueOrError1).PropagateFailure<bool>();
        return ret;
      }
      Dafny.ISequence<byte> _2_canonicalHash;
      _2_canonicalHash = (_1_valueOrError1).Extract();
      software.amazon.cryptography.primitives.internaldafny.types._IHMacInput _3_input;
      _3_input = software.amazon.cryptography.primitives.internaldafny.types.HMacInput.create((((mat).dtor_algorithmSuite).dtor_symmetricSignature).dtor_HMAC, ((mat).dtor_symmetricSigningKey).dtor_value, _2_canonicalHash);
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _4_hashR;
      _4_hashR = (client).HMac(_3_input);
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _5_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _5_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(_4_hashR, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>)((_6_e) => {
        return software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.Error.create_AwsCryptographyPrimitives(_6_e);
      })));
      if ((_5_valueOrError2).IsFailure()) {
        ret = (_5_valueOrError2).PropagateFailure<bool>();
        return ret;
      }
      Dafny.ISequence<byte> _7_hash;
      _7_hash = (_5_valueOrError2).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _8_valueOrError3 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
      _8_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((new BigInteger((_7_hash).Count)) == (new BigInteger(48)), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Bad hash length")));
      if ((_8_valueOrError3).IsFailure()) {
        ret = (_8_valueOrError3).PropagateFailure<bool>();
        return ret;
      }
      bool _9_foundTag;
      _9_foundTag = false;
      BigInteger _hi0 = new BigInteger(((this).dtor_tags).Count);
      for (BigInteger _10_i = BigInteger.Zero; _10_i < _hi0; _10_i++) {
        if (StructuredEncryptionUtil_Compile.__default.ConstantTimeEquals(_7_hash, ((this).dtor_tags).Select(_10_i))) {
          _9_foundTag = true;
          goto after_0;
        }
      continue_0: ;
      }
    after_0: ;
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _11_valueOrError4 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
      _11_valueOrError4 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(_9_foundTag, StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Signature of record does not match the signature computed when the record was encrypted.")));
      if ((_11_valueOrError4).IsFailure()) {
        ret = (_11_valueOrError4).PropagateFailure<bool>();
        return ret;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _12_valueOrError5 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
      _12_valueOrError5 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((((this).dtor_sig).is_Some) == ((((mat).dtor_algorithmSuite).dtor_signature).is_ECDSA), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Internal error. Signature both does and does not exist.")));
      if ((_12_valueOrError5).IsFailure()) {
        ret = (_12_valueOrError5).PropagateFailure<bool>();
        return ret;
      }
      if (((this).dtor_sig).is_Some) {
        software.amazon.cryptography.primitives.internaldafny.types._IECDSAVerifyInput _13_verInput;
        _13_verInput = software.amazon.cryptography.primitives.internaldafny.types.ECDSAVerifyInput.create(((((mat).dtor_algorithmSuite).dtor_signature).dtor_ECDSA).dtor_curve, ((mat).dtor_verificationKey).dtor_value, _2_canonicalHash, ((this).dtor_sig).dtor_value);
        Wrappers_Compile._IResult<bool, software.amazon.cryptography.primitives.internaldafny.types._IError> _14_verR;
        Wrappers_Compile._IResult<bool, software.amazon.cryptography.primitives.internaldafny.types._IError> _out1;
        _out1 = (client).ECDSAVerify(_13_verInput);
        _14_verR = _out1;
        Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _15_valueOrError6 = Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(false);
        _15_valueOrError6 = Wrappers_Compile.Result<bool, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(_14_verR, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>)((_16_e) => {
          return software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.Error.create_AwsCryptographyPrimitives(_16_e);
        })));
        if ((_15_valueOrError6).IsFailure()) {
          ret = (_15_valueOrError6).PropagateFailure<bool>();
          return ret;
        }
        bool _17_ver;
        _17_ver = (_15_valueOrError6).Extract();
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _18_valueOrError7 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
        _18_valueOrError7 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(_17_ver, StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Signature did not verify")));
        if ((_18_valueOrError7).IsFailure()) {
          ret = (_18_valueOrError7).PropagateFailure<bool>();
          return ret;
        }
      }
      ret = Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(true);
      return ret;
      return ret;
    }
  }
} // end of namespace StructuredEncryptionFooter_Compile
namespace SortCanon_Compile {

  public partial class __default {
    public static bool AuthBelow(StructuredEncryptionUtil_Compile._ICanonAuthItem x, StructuredEncryptionUtil_Compile._ICanonAuthItem y)
    {
      return SortCanon_Compile.__default.Below((x).dtor_key, (y).dtor_key);
    }
    public static bool CryptoBelow(StructuredEncryptionUtil_Compile._ICanonCryptoItem x, StructuredEncryptionUtil_Compile._ICanonCryptoItem y)
    {
      return SortCanon_Compile.__default.Below((x).dtor_key, (y).dtor_key);
    }
    public static bool Below(Dafny.ISequence<byte> x, Dafny.ISequence<byte> y)
    {
      return !((new BigInteger((x).Count)).Sign != 0) || ((((new BigInteger((y).Count)).Sign != 0) && (((x).Select(BigInteger.Zero)) <= ((y).Select(BigInteger.Zero)))) && (!(((x).Select(BigInteger.Zero)) == ((y).Select(BigInteger.Zero))) || (SortCanon_Compile.__default.Below((x).Drop(BigInteger.One), (y).Drop(BigInteger.One)))));
    }
    public static Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonAuthItem> AuthSort(Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonAuthItem> x) {
      Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonAuthItem> _0_ret = Seq_mMergeSort_Compile.__default.MergeSortBy<StructuredEncryptionUtil_Compile._ICanonAuthItem>(x, SortCanon_Compile.__default.AuthBelow);
      return _0_ret;
    }
    public static Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> CryptoSort(Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> x) {
      Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> _0_ret = Seq_mMergeSort_Compile.__default.MergeSortBy<StructuredEncryptionUtil_Compile._ICanonCryptoItem>(x, SortCanon_Compile.__default.CryptoBelow);
      return _0_ret;
    }
  }
} // end of namespace SortCanon_Compile
namespace Canonize_Compile {

  public partial class __default {
    public static bool IsCanonPath(Dafny.ISequence<char> table, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> origKey, Dafny.ISequence<byte> key)
    {
      return (key).Equals(StructuredEncryptionPaths_Compile.__default.CanonPath(table, origKey));
    }
    public static StructuredEncryptionUtil_Compile._ICanonCryptoItem MakeCanon(Dafny.ISequence<char> tableName, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem data)
    {
      return StructuredEncryptionUtil_Compile.CanonCryptoItem.create(StructuredEncryptionPaths_Compile.__default.CanonPath(tableName, (data).dtor_key), (data).dtor_key, (data).dtor_data, (data).dtor_action);
    }
    public static StructuredEncryptionUtil_Compile._ICanonAuthItem MakeCanonAuth(Dafny.ISequence<char> tableName, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem data)
    {
      return StructuredEncryptionUtil_Compile.CanonAuthItem.create(StructuredEncryptionPaths_Compile.__default.CanonPath(tableName, (data).dtor_key), (data).dtor_key, (data).dtor_data, (data).dtor_action);
    }
    public static bool Same(StructuredEncryptionUtil_Compile._ICanonAuthItem x, StructuredEncryptionUtil_Compile._ICanonCryptoItem y)
    {
      return ((((x).dtor_key).Equals((y).dtor_key)) && (((x).dtor_origKey).Equals((y).dtor_origKey))) && (object.Equals((x).dtor_data, (y).dtor_data));
    }
    public static StructuredEncryptionUtil_Compile._ICanonCryptoItem MakeCryptoItem(StructuredEncryptionUtil_Compile._ICanonAuthItem x, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction action)
    {
      return StructuredEncryptionUtil_Compile.CanonCryptoItem.create((x).dtor_key, (x).dtor_origKey, (x).dtor_data, action);
    }
    public static software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction LegendToAction(byte v) {
      if ((v) == (StructuredEncryptionHeader_Compile.__default.ENCRYPT__AND__SIGN__LEGEND)) {
        return software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_ENCRYPT__AND__SIGN();
      } else if ((v) == (StructuredEncryptionHeader_Compile.__default.SIGN__AND__INCLUDE__IN__ENCRYPTION__CONTEXT__LEGEND)) {
        return software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_SIGN__AND__INCLUDE__IN__ENCRYPTION__CONTEXT();
      } else {
        return software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_SIGN__ONLY();
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> ResolveLegend(Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonAuthItem> fields, Dafny.ISequence<byte> legend, Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> acc)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((fields).Count)).Sign == 0) {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((new BigInteger((legend).Count)).Sign == 0, StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Schema changed : something that was signed is now unsigned.")));
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>>();
        } else {
          return Wrappers_Compile.Result<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(acc);
        }
      } else if (object.Equals(((fields).Select(BigInteger.Zero)).dtor_action, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.AuthenticateAction.create_DO__NOT__SIGN())) {
        Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonAuthItem> _in0 = (fields).Drop(BigInteger.One);
        Dafny.ISequence<byte> _in1 = legend;
        Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> _in2 = Dafny.Sequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>.Concat(acc, Dafny.Sequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>.FromElements(Canonize_Compile.__default.MakeCryptoItem((fields).Select(BigInteger.Zero), software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_DO__NOTHING())));
        fields = _in0;
        legend = _in1;
        acc = _in2;
        goto TAIL_CALL_START;
      } else {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _1_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((new BigInteger((legend).Count)).Sign == 1, StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Schema changed : something that was unsigned is now signed.")));
        if ((_1_valueOrError1).IsFailure()) {
          return (_1_valueOrError1).PropagateFailure<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>>();
        } else {
          Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonAuthItem> _in3 = (fields).Drop(BigInteger.One);
          Dafny.ISequence<byte> _in4 = (legend).Drop(BigInteger.One);
          Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> _in5 = Dafny.Sequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>.Concat(acc, Dafny.Sequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>.FromElements(Canonize_Compile.__default.MakeCryptoItem((fields).Select(BigInteger.Zero), Canonize_Compile.__default.LegendToAction((legend).Select(BigInteger.Zero)))));
          fields = _in3;
          legend = _in4;
          acc = _in5;
          goto TAIL_CALL_START;
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> ForEncrypt(Dafny.ISequence<char> tableName, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> data)
    {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(Dafny.Helpers.Id<Func<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>, bool>>((_1_data) => Dafny.Helpers.Quantifier<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>((_1_data).UniqueElements, true, (((_forall_var_0) => {
        software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem _2_k = (software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem)_forall_var_0;
        return !((_1_data).Contains(_2_k)) || (StructuredEncryptionPaths_Compile.__default.ValidPath((_2_k).dtor_key));
      }))))(data), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Invalid Paths")));
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>>();
      } else {
        Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> _3_canonList = Canonize_Compile.__default.CryptoToCanonCrypto(tableName, data);
        return Wrappers_Compile.Result<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(Canonize_Compile.__default.CryptoSort(_3_canonList));
      }
    }
    public static Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonAuthItem> AuthToCanonAuth(Dafny.ISequence<char> tableName, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem> data)
    {
      Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonAuthItem> _0_canonList = Seq_Compile.__default.Map<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem, StructuredEncryptionUtil_Compile._ICanonAuthItem>(Dafny.Helpers.Id<Func<Dafny.ISequence<char>, Func<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem, StructuredEncryptionUtil_Compile._ICanonAuthItem>>>((_1_tableName) => ((System.Func<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem, StructuredEncryptionUtil_Compile._ICanonAuthItem>)((_2_s) => {
        return Canonize_Compile.__default.MakeCanonAuth(_1_tableName, _2_s);
      })))(tableName), data);
      return _0_canonList;
    }
    public static Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> CryptoToCanonCrypto(Dafny.ISequence<char> tableName, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> data)
    {
      Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> _0_canonList = Seq_Compile.__default.Map<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem, StructuredEncryptionUtil_Compile._ICanonCryptoItem>(Dafny.Helpers.Id<Func<Dafny.ISequence<char>, Func<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem, StructuredEncryptionUtil_Compile._ICanonCryptoItem>>>((_1_tableName) => ((System.Func<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem, StructuredEncryptionUtil_Compile._ICanonCryptoItem>)((_2_s) => {
        return Canonize_Compile.__default.MakeCanon(_1_tableName, _2_s);
      })))(tableName), data);
      return _0_canonList;
    }
    public static Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonAuthItem> AuthSort(Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonAuthItem> canonList)
    {
      Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonAuthItem> _0_canonSorted = SortCanon_Compile.__default.AuthSort(canonList);
      return _0_canonSorted;
    }
    public static Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> CryptoSort(Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> canonList)
    {
      Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> _0_canonSorted = SortCanon_Compile.__default.CryptoSort(canonList);
      return _0_canonSorted;
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> DoResolveLegend(Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonAuthItem> canonSorted, Dafny.ISequence<byte> legend)
    {
      Wrappers_Compile._IResult<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = Canonize_Compile.__default.ResolveLegend(canonSorted, legend, Dafny.Sequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>.FromElements());
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>>();
      } else {
        Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> _1_canonResolved = (_0_valueOrError0).Extract();
        return Wrappers_Compile.Result<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(_1_canonResolved);
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> ForDecrypt(Dafny.ISequence<char> tableName, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem> data, Dafny.ISequence<byte> legend)
    {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(Dafny.Helpers.Id<Func<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem>, bool>>((_1_data) => Dafny.Helpers.Quantifier<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem>((_1_data).UniqueElements, true, (((_forall_var_0) => {
        software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem _2_k = (software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem)_forall_var_0;
        return !((_1_data).Contains(_2_k)) || (StructuredEncryptionPaths_Compile.__default.ValidPath((_2_k).dtor_key));
      }))))(data), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Invalid Paths")));
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>>();
      } else {
        Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonAuthItem> _3_canonList = Canonize_Compile.__default.AuthToCanonAuth(tableName, data);
        Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonAuthItem> _4_canonSorted = Canonize_Compile.__default.AuthSort(_3_canonList);
        return Canonize_Compile.__default.DoResolveLegend(_4_canonSorted, legend);
      }
    }
    public static bool SameUnCanon(StructuredEncryptionUtil_Compile._ICanonCryptoItem x, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem y)
    {
      return ((((x).dtor_origKey).Equals((y).dtor_key)) && (object.Equals((x).dtor_data, (y).dtor_data))) && (object.Equals((x).dtor_action, (y).dtor_action));
    }
    public static Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> UnCanon(Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> input) {
      Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> _0___accumulator = Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((input).Count)).Sign == 0) {
        return Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>.Concat(_0___accumulator, Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>.FromElements());
      } else {
        software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem _1_newItem = software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoItem.create(((input).Select(BigInteger.Zero)).dtor_origKey, ((input).Select(BigInteger.Zero)).dtor_data, ((input).Select(BigInteger.Zero)).dtor_action);
        _0___accumulator = Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>.Concat(_0___accumulator, Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>.FromElements(_1_newItem));
        Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> _in0 = (input).Drop(BigInteger.One);
        input = _in0;
        goto TAIL_CALL_START;
      }
    }
    public static Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> UnCanonDecrypt(Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> input)
    {
      Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> _0_results = Canonize_Compile.__default.UnCanon(input);
      return _0_results;
    }
    public static Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> UnCanonEncrypt(Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> input)
    {
      Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> _0_results = Canonize_Compile.__default.UnCanon(input);
      return _0_results;
    }
    public static Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> AddHeaders(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> input, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal headerData, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal footerData)
    {
      software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem _0_headItem = software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoItem.create(StructuredEncryptionUtil_Compile.__default.HeaderPath, headerData, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_DO__NOTHING());
      software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem _1_footItem = software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoItem.create(StructuredEncryptionUtil_Compile.__default.FooterPath, footerData, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_DO__NOTHING());
      Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> _2_largeResult = Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>.Concat(input, Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>.FromElements(_0_headItem, _1_footItem));
      return _2_largeResult;
    }
    public static Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> RemoveHeaderPaths(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> xs) {
      Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> _0___accumulator = Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((xs).Count)).Sign == 0) {
        return Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>.Concat(_0___accumulator, Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>.FromElements());
      } else {
        _0___accumulator = Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>.Concat(_0___accumulator, (((Dafny.Sequence<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>>.FromElements(StructuredEncryptionUtil_Compile.__default.HeaderPath, StructuredEncryptionUtil_Compile.__default.FooterPath)).Contains(((xs).Select(BigInteger.Zero)).dtor_key)) ? (Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>.FromElements()) : (Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>.FromElements((xs).Select(BigInteger.Zero)))));
        Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> _in0 = (xs).Drop(BigInteger.One);
        xs = _in0;
        goto TAIL_CALL_START;
      }
    }
    public static Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> RemoveHeaders(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> input)
    {
      Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> _0_finalData = Canonize_Compile.__default.RemoveHeaderPaths(input);
      return _0_finalData;
    }
  }

  public interface _IEncryptionSelector {
    bool is_DoEncrypt { get; }
    bool is_DoDecrypt { get; }
    _IEncryptionSelector DowncastClone();
  }
  public abstract class EncryptionSelector : _IEncryptionSelector {
    public EncryptionSelector() {
    }
    private static readonly Canonize_Compile._IEncryptionSelector theDefault = create_DoEncrypt();
    public static Canonize_Compile._IEncryptionSelector Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<Canonize_Compile._IEncryptionSelector> _TYPE = new Dafny.TypeDescriptor<Canonize_Compile._IEncryptionSelector>(Canonize_Compile.EncryptionSelector.Default());
    public static Dafny.TypeDescriptor<Canonize_Compile._IEncryptionSelector> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IEncryptionSelector create_DoEncrypt() {
      return new EncryptionSelector_DoEncrypt();
    }
    public static _IEncryptionSelector create_DoDecrypt() {
      return new EncryptionSelector_DoDecrypt();
    }
    public bool is_DoEncrypt { get { return this is EncryptionSelector_DoEncrypt; } }
    public bool is_DoDecrypt { get { return this is EncryptionSelector_DoDecrypt; } }
    public static System.Collections.Generic.IEnumerable<_IEncryptionSelector> AllSingletonConstructors {
      get {
        yield return EncryptionSelector.create_DoEncrypt();
        yield return EncryptionSelector.create_DoDecrypt();
      }
    }
    public abstract _IEncryptionSelector DowncastClone();
  }
  public class EncryptionSelector_DoEncrypt : EncryptionSelector {
    public EncryptionSelector_DoEncrypt() : base() {
    }
    public override _IEncryptionSelector DowncastClone() {
      if (this is _IEncryptionSelector dt) { return dt; }
      return new EncryptionSelector_DoEncrypt();
    }
    public override bool Equals(object other) {
      var oth = other as Canonize_Compile.EncryptionSelector_DoEncrypt;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Canonize.EncryptionSelector.DoEncrypt";
      return s;
    }
  }
  public class EncryptionSelector_DoDecrypt : EncryptionSelector {
    public EncryptionSelector_DoDecrypt() : base() {
    }
    public override _IEncryptionSelector DowncastClone() {
      if (this is _IEncryptionSelector dt) { return dt; }
      return new EncryptionSelector_DoDecrypt();
    }
    public override bool Equals(object other) {
      var oth = other as Canonize_Compile.EncryptionSelector_DoDecrypt;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "Canonize.EncryptionSelector.DoDecrypt";
      return s;
    }
  }
} // end of namespace Canonize_Compile
namespace StructuredEncryptionCrypt_Compile {

  public partial class __default {
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> FieldKey(Dafny.ISequence<byte> HKDFOutput, uint offset)
    {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(((new BigInteger(offset)) * (new BigInteger(3))) < (StandardLibrary_mUInt_Compile.__default.UINT32__LIMIT), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Too many encrypted fields.")));
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
      } else {
        Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _1_keyR = AesKdfCtr.__default.AesKdfCtrStream(StructuredEncryptionCrypt_Compile.__default.FieldKeyNonce((offset) * (3U)), HKDFOutput, (uint)((StructuredEncryptionUtil_Compile.__default.KeySize) + (StructuredEncryptionUtil_Compile.__default.NonceSize)));
        return Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(_1_keyR, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>)((_2_e) => {
          return software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.Error.create_AwsCryptographyPrimitives(_2_e);
        })));
      }
    }
    public static Dafny.ISequence<byte> FieldKeyNonce(uint offset) {
      return Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(UTF8.__default.EncodeAscii(Dafny.Sequence<char>.FromString("AwsDbeField")), Dafny.Sequence<byte>.FromElements((byte)((StructuredEncryptionUtil_Compile.__default.KeySize) + (StructuredEncryptionUtil_Compile.__default.NonceSize)))), StandardLibrary_mUInt_Compile.__default.UInt32ToSeq(offset));
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> GetCommitKey(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient client, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo alg, Dafny.ISequence<byte> key, Dafny.ISequence<byte> msgID)
    {
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> ret = default(Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>);
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _0_commitKey;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _out0;
      _out0 = (client).Hkdf(software.amazon.cryptography.primitives.internaldafny.types.HkdfInput.create((((alg).dtor_commitment).dtor_HKDF).dtor_hmac, Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None(), key, Dafny.Sequence<byte>.Concat(StructuredEncryptionCrypt_Compile.__default.LABEL__COMMITMENT__KEY, msgID), (((alg).dtor_commitment).dtor_HKDF).dtor_outputKeyLength));
      _0_commitKey = _out0;
      ret = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(_0_commitKey, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>)((_1_e) => {
        return software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.Error.create_AwsCryptographyPrimitives(_1_e);
      })));
      return ret;
      return ret;
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> Encrypt(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient client, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo alg, Dafny.ISequence<byte> key, StructuredEncryptionHeader_Compile._IPartialHeader head, Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> data)
    {
      Wrappers_Compile._IResult<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> ret = Wrappers_Compile.Result<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(Dafny.Sequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>.Empty);
      Wrappers_Compile._IResult<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(Dafny.Sequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>.Empty);
      Wrappers_Compile._IResult<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _out0;
      _out0 = StructuredEncryptionCrypt_Compile.__default.Crypt(Canonize_Compile.EncryptionSelector.create_DoEncrypt(), client, alg, key, head, data);
      _0_valueOrError0 = _out0;
      if ((_0_valueOrError0).IsFailure()) {
        ret = (_0_valueOrError0).PropagateFailure<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>>();
        return ret;
      }
      Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> _1_result;
      _1_result = (_0_valueOrError0).Extract();
      ret = Wrappers_Compile.Result<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(_1_result);
      return ret;
      return ret;
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> Decrypt(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient client, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo alg, Dafny.ISequence<byte> key, StructuredEncryptionHeader_Compile._IPartialHeader head, Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> data)
    {
      Wrappers_Compile._IResult<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> ret = Wrappers_Compile.Result<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(Dafny.Sequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>.Empty);
      Wrappers_Compile._IResult<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(Dafny.Sequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>.Empty);
      Wrappers_Compile._IResult<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _out0;
      _out0 = StructuredEncryptionCrypt_Compile.__default.Crypt(Canonize_Compile.EncryptionSelector.create_DoDecrypt(), client, alg, key, head, data);
      _0_valueOrError0 = _out0;
      if ((_0_valueOrError0).IsFailure()) {
        ret = (_0_valueOrError0).PropagateFailure<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>>();
        return ret;
      }
      Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> _1_result;
      _1_result = (_0_valueOrError0).Extract();
      ret = Wrappers_Compile.Result<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(_1_result);
      return ret;
      return ret;
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> Crypt(Canonize_Compile._IEncryptionSelector mode, software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient client, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo alg, Dafny.ISequence<byte> key, StructuredEncryptionHeader_Compile._IPartialHeader head, Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> data)
    {
      Wrappers_Compile._IResult<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> ret = Wrappers_Compile.Result<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(Dafny.Sequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>.Empty);
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _0_fieldRootKeyR;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _out0;
      _out0 = (client).Hkdf(software.amazon.cryptography.primitives.internaldafny.types.HkdfInput.create((((alg).dtor_kdf).dtor_HKDF).dtor_hmac, Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None(), key, Dafny.Sequence<byte>.Concat(StructuredEncryptionCrypt_Compile.__default.LABEL__ENCRYPTION__KEY, (head).dtor_msgID), (((alg).dtor_kdf).dtor_HKDF).dtor_outputKeyLength));
      _0_fieldRootKeyR = _out0;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _1_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _1_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(_0_fieldRootKeyR, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>)((_2_e) => {
        return software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.Error.create_AwsCryptographyPrimitives(_2_e);
      })));
      if ((_1_valueOrError0).IsFailure()) {
        ret = (_1_valueOrError0).PropagateFailure<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>>();
        return ret;
      }
      Dafny.ISequence<byte> _3_fieldRootKey;
      _3_fieldRootKey = (_1_valueOrError0).Extract();
      Wrappers_Compile._IResult<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _4_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(Dafny.Sequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>.Empty);
      Wrappers_Compile._IResult<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _out1;
      _out1 = StructuredEncryptionCrypt_Compile.__default.CryptList(mode, client, alg, _3_fieldRootKey, data);
      _4_valueOrError1 = _out1;
      if ((_4_valueOrError1).IsFailure()) {
        ret = (_4_valueOrError1).PropagateFailure<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>>();
        return ret;
      }
      Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> _5_result;
      _5_result = (_4_valueOrError1).Extract();
      ret = Wrappers_Compile.Result<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(_5_result);
      return ret;
      return ret;
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> CryptList(Canonize_Compile._IEncryptionSelector mode, software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient client, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo alg, Dafny.ISequence<byte> fieldRootKey, Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> data)
    {
      Wrappers_Compile._IResult<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> ret = Wrappers_Compile.Result<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(Dafny.Sequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>.Empty);
      Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> _0_result;
      _0_result = Dafny.Sequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>.FromElements();
      uint _1_pos;
      _1_pos = 0U;
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _2_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
      _2_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((new BigInteger((data).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT32__LIMIT), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Too many fields.")));
      if ((_2_valueOrError0).IsFailure()) {
        ret = (_2_valueOrError0).PropagateFailure<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>>();
        return ret;
      }
      BigInteger _hi0 = new BigInteger((data).Count);
      for (BigInteger _3_i = BigInteger.Zero; _3_i < _hi0; _3_i++) {
        if (object.Equals(((data).Select(_3_i)).dtor_action, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_ENCRYPT__AND__SIGN())) {
          software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal _4_newTerminal = default(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal);
          if (object.Equals(mode, Canonize_Compile.EncryptionSelector.create_DoEncrypt())) {
            Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _5_valueOrError1 = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>);
            Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _out0;
            _out0 = StructuredEncryptionCrypt_Compile.__default.EncryptTerminal(client, alg, fieldRootKey, _1_pos, ((data).Select(_3_i)).dtor_key, ((data).Select(_3_i)).dtor_data);
            _5_valueOrError1 = _out0;
            if ((_5_valueOrError1).IsFailure()) {
              ret = (_5_valueOrError1).PropagateFailure<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>>();
              return ret;
            }
            _4_newTerminal = (_5_valueOrError1).Extract();
          } else {
            Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _6_valueOrError2 = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>);
            Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _out1;
            _out1 = StructuredEncryptionCrypt_Compile.__default.DecryptTerminal(client, alg, fieldRootKey, _1_pos, ((data).Select(_3_i)).dtor_key, ((data).Select(_3_i)).dtor_data);
            _6_valueOrError2 = _out1;
            if ((_6_valueOrError2).IsFailure()) {
              ret = (_6_valueOrError2).PropagateFailure<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>>();
              return ret;
            }
            _4_newTerminal = (_6_valueOrError2).Extract();
          }
          _1_pos = (_1_pos) + (1U);
          StructuredEncryptionUtil_Compile._ICanonCryptoItem _7_newItem;
          StructuredEncryptionUtil_Compile._ICanonCryptoItem _8_dt__update__tmp_h0 = (data).Select(_3_i);
          software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal _9_dt__update_hdata_h0 = _4_newTerminal;
          _7_newItem = StructuredEncryptionUtil_Compile.CanonCryptoItem.create((_8_dt__update__tmp_h0).dtor_key, (_8_dt__update__tmp_h0).dtor_origKey, _9_dt__update_hdata_h0, (_8_dt__update__tmp_h0).dtor_action);
          _0_result = Dafny.Sequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>.Concat(_0_result, Dafny.Sequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>.FromElements(_7_newItem));
        } else {
          _0_result = Dafny.Sequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>.Concat(_0_result, Dafny.Sequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>.FromElements((data).Select(_3_i)));
        }
      }
      ret = Wrappers_Compile.Result<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(_0_result);
      return ret;
      return ret;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> EncryptTerminal(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient client, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo alg, Dafny.ISequence<byte> fieldRootKey, uint offset, Dafny.ISequence<byte> path, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal data)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> ret = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>);
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _0_valueOrError0 = StructuredEncryptionCrypt_Compile.__default.FieldKey(fieldRootKey, offset);
      if ((_0_valueOrError0).IsFailure()) {
        ret = (_0_valueOrError0).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>();
        return ret;
      }
      Dafny.ISequence<byte> _1_fieldKey;
      _1_fieldKey = (_0_valueOrError0).Extract();
      Dafny.ISequence<byte> _2_cipherkey;
      _2_cipherkey = (_1_fieldKey).Subsequence(BigInteger.Zero, StructuredEncryptionUtil_Compile.__default.KeySize);
      Dafny.ISequence<byte> _3_nonce;
      _3_nonce = (_1_fieldKey).Drop(StructuredEncryptionUtil_Compile.__default.KeySize);
      Dafny.ISequence<byte> _4_value;
      _4_value = (data).dtor_value;
      software.amazon.cryptography.primitives.internaldafny.types._IAESEncryptInput _5_encInput;
      _5_encInput = software.amazon.cryptography.primitives.internaldafny.types.AESEncryptInput.create(((alg).dtor_encrypt).dtor_AES__GCM, _3_nonce, _2_cipherkey, _4_value, path);
      Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.types._IAESEncryptOutput, software.amazon.cryptography.primitives.internaldafny.types._IError> _6_encOutR;
      Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.types._IAESEncryptOutput, software.amazon.cryptography.primitives.internaldafny.types._IError> _out0;
      _out0 = (client).AESEncrypt(_5_encInput);
      _6_encOutR = _out0;
      Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.types._IAESEncryptOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _7_valueOrError1 = Wrappers_Compile.Result<software.amazon.cryptography.primitives.internaldafny.types._IAESEncryptOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(software.amazon.cryptography.primitives.internaldafny.types.AESEncryptOutput.Default());
      _7_valueOrError1 = Wrappers_Compile.Result<software.amazon.cryptography.primitives.internaldafny.types._IAESEncryptOutput, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(_6_encOutR, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>)((_8_e) => {
        return software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.Error.create_AwsCryptographyPrimitives(_8_e);
      })));
      if ((_7_valueOrError1).IsFailure()) {
        ret = (_7_valueOrError1).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>();
        return ret;
      }
      software.amazon.cryptography.primitives.internaldafny.types._IAESEncryptOutput _9_encOut;
      _9_encOut = (_7_valueOrError1).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _10_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
      _10_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((new BigInteger(((_9_encOut).dtor_authTag).Count)) == (StructuredEncryptionUtil_Compile.__default.AuthTagSize), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Auth Tag Wrong Size.")));
      if ((_10_valueOrError2).IsFailure()) {
        ret = (_10_valueOrError2).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>();
        return ret;
      }
      ret = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(StructuredEncryptionUtil_Compile.__default.ValueToData(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat((data).dtor_typeId, (_9_encOut).dtor_cipherText), (_9_encOut).dtor_authTag), StructuredEncryptionUtil_Compile.__default.BYTES__TYPE__ID));
      return ret;
      return ret;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> DecryptTerminal(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient client, software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo alg, Dafny.ISequence<byte> fieldRootKey, uint offset, Dafny.ISequence<byte> path, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal data)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> ret = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>);
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _0_valueOrError0 = StructuredEncryptionCrypt_Compile.__default.FieldKey(fieldRootKey, offset);
      if ((_0_valueOrError0).IsFailure()) {
        ret = (_0_valueOrError0).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>();
        return ret;
      }
      Dafny.ISequence<byte> _1_dataKey;
      _1_dataKey = (_0_valueOrError0).Extract();
      Dafny.ISequence<byte> _2_encryptionKey;
      _2_encryptionKey = (_1_dataKey).Subsequence(BigInteger.Zero, StructuredEncryptionUtil_Compile.__default.KeySize);
      Dafny.ISequence<byte> _3_nonce;
      _3_nonce = (_1_dataKey).Drop(StructuredEncryptionUtil_Compile.__default.KeySize);
      Dafny.ISequence<byte> _4_value;
      _4_value = (data).dtor_value;
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _5_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
      _5_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(((StructuredEncryptionUtil_Compile.__default.AuthTagSize) + (new BigInteger(2))) <= (new BigInteger((_4_value).Count)), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("cipherTxt too short.")));
      if ((_5_valueOrError1).IsFailure()) {
        ret = (_5_valueOrError1).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>();
        return ret;
      }
      software.amazon.cryptography.primitives.internaldafny.types._IAESDecryptInput _6_decInput;
      _6_decInput = software.amazon.cryptography.primitives.internaldafny.types.AESDecryptInput.create(((alg).dtor_encrypt).dtor_AES__GCM, _2_encryptionKey, (_4_value).Subsequence(StructuredEncryptionUtil_Compile.__default.TYPEID__LEN, (new BigInteger((_4_value).Count)) - (StructuredEncryptionUtil_Compile.__default.AuthTagSize)), (_4_value).Drop((new BigInteger((_4_value).Count)) - (StructuredEncryptionUtil_Compile.__default.AuthTagSize)), _3_nonce, path);
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _7_decOutR;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _out0;
      _out0 = (client).AESDecrypt(_6_decInput);
      _7_decOutR = _out0;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _8_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _8_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(_7_decOutR, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>)((_9_e) => {
        return software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.Error.create_AwsCryptographyPrimitives(_9_e);
      })));
      if ((_8_valueOrError2).IsFailure()) {
        ret = (_8_valueOrError2).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>();
        return ret;
      }
      Dafny.ISequence<byte> _10_decOut;
      _10_decOut = (_8_valueOrError2).Extract();
      ret = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(StructuredEncryptionUtil_Compile.__default.ValueToData(_10_decOut, (_4_value).Take(StructuredEncryptionUtil_Compile.__default.TYPEID__LEN)));
      return ret;
      return ret;
    }
    public static Dafny.ISequence<byte> LABEL__COMMITMENT__KEY { get {
      return UTF8.__default.EncodeAscii(Dafny.Sequence<char>.FromString("AWS_DBE_COMMIT_KEY"));
    } }
    public static Dafny.ISequence<byte> LABEL__ENCRYPTION__KEY { get {
      return UTF8.__default.EncodeAscii(Dafny.Sequence<char>.FromString("AWS_DBE_DERIVE_KEY"));
    } }
  }
} // end of namespace StructuredEncryptionCrypt_Compile
namespace Maps_Compile {

  public partial class __default {
    public static Wrappers_Compile._IOption<__Y> Get<__X, __Y>(Dafny.IMap<__X,__Y> m, __X x)
    {
      if ((m).Contains(x)) {
        return Wrappers_Compile.Option<__Y>.create_Some(Dafny.Map<__X, __Y>.Select(m,x));
      } else {
        return Wrappers_Compile.Option<__Y>.create_None();
      }
    }
    public static Dafny.IMap<__X,__Y> ToImap<__X, __Y>(Dafny.IMap<__X,__Y> m) {
      return Dafny.Helpers.Id<Func<Dafny.IMap<__X,__Y>, Dafny.IMap<__X,__Y>>>((_0_m) => ((System.Func<Dafny.IMap<__X,__Y>>)(() => {
        var _coll0 = new System.Collections.Generic.List<Dafny.Pair<__X,__Y>>();
        foreach (__X _compr_0 in (_0_m).Keys.Elements) {
          __X _1_x = (__X)_compr_0;
          if ((_0_m).Contains(_1_x)) {
            _coll0.Add(new Dafny.Pair<__X,__Y>(_1_x, Dafny.Map<__X, __Y>.Select(_0_m,_1_x)));
          }
        }
        return Dafny.Map<__X,__Y>.FromCollection(_coll0);
      }))())(m);
    }
    public static Dafny.IMap<__X,__Y> RemoveKeys<__X, __Y>(Dafny.IMap<__X,__Y> m, Dafny.ISet<__X> xs)
    {
      return Dafny.Map<__X, __Y>.Subtract(m, xs);
    }
    public static Dafny.IMap<__X,__Y> Remove<__X, __Y>(Dafny.IMap<__X,__Y> m, __X x)
    {
      Dafny.IMap<__X,__Y> _0_m_k = Dafny.Helpers.Id<Func<Dafny.IMap<__X,__Y>, __X, Dafny.IMap<__X,__Y>>>((_1_m, _2_x) => ((System.Func<Dafny.IMap<__X,__Y>>)(() => {
        var _coll0 = new System.Collections.Generic.List<Dafny.Pair<__X,__Y>>();
        foreach (__X _compr_0 in (_1_m).Keys.Elements) {
          __X _3_x_k = (__X)_compr_0;
          if (((_1_m).Contains(_3_x_k)) && (!object.Equals(_3_x_k, _2_x))) {
            _coll0.Add(new Dafny.Pair<__X,__Y>(_3_x_k, Dafny.Map<__X, __Y>.Select(_1_m,_3_x_k)));
          }
        }
        return Dafny.Map<__X,__Y>.FromCollection(_coll0);
      }))())(m, x);
      return _0_m_k;
    }
    public static Dafny.IMap<__X,__Y> Restrict<__X, __Y>(Dafny.IMap<__X,__Y> m, Dafny.ISet<__X> xs)
    {
      return Dafny.Helpers.Id<Func<Dafny.ISet<__X>, Dafny.IMap<__X,__Y>, Dafny.IMap<__X,__Y>>>((_0_xs, _1_m) => ((System.Func<Dafny.IMap<__X,__Y>>)(() => {
        var _coll0 = new System.Collections.Generic.List<Dafny.Pair<__X,__Y>>();
        foreach (__X _compr_0 in (_0_xs).Elements) {
          __X _2_x = (__X)_compr_0;
          if (((_0_xs).Contains(_2_x)) && ((_1_m).Contains(_2_x))) {
            _coll0.Add(new Dafny.Pair<__X,__Y>(_2_x, Dafny.Map<__X, __Y>.Select(_1_m,_2_x)));
          }
        }
        return Dafny.Map<__X,__Y>.FromCollection(_coll0);
      }))())(xs, m);
    }
    public static Dafny.IMap<__X,__Y> Union<__X, __Y>(Dafny.IMap<__X,__Y> m, Dafny.IMap<__X,__Y> m_k)
    {
      return Dafny.Map<__X, __Y>.Merge(m, m_k);
    }
  }
} // end of namespace Maps_Compile
namespace AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile {

  public partial class __default {
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IResolveAuthActionsOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> ResolveAuthActions(AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IResolveAuthActionsInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IResolveAuthActionsOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IResolveAuthActionsOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.ResolveAuthActionsOutput.Default());
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
      _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(StructuredEncryptionUtil_Compile.__default.AuthListHasNoDuplicatesFromSet((input).dtor_authActions), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Duplicate Paths")));
      if ((_0_valueOrError0).IsFailure()) {
        output = (_0_valueOrError0).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IResolveAuthActionsOutput>();
        return output;
      }
      Wrappers_Compile._IResult<StructuredEncryptionHeader_Compile._IPartialHeader, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _1_valueOrError1 = default(Wrappers_Compile._IResult<StructuredEncryptionHeader_Compile._IPartialHeader, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>);
      _1_valueOrError1 = StructuredEncryptionHeader_Compile.__default.PartialDeserialize((input).dtor_headerBytes);
      if ((_1_valueOrError1).IsFailure()) {
        output = (_1_valueOrError1).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IResolveAuthActionsOutput>();
        return output;
      }
      StructuredEncryptionHeader_Compile._IPartialHeader _2_head;
      _2_head = (_1_valueOrError1).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _3_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
      _3_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(StructuredEncryptionUtil_Compile.__default.ValidString((input).dtor_tableName), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Bad Table Name")));
      if ((_3_valueOrError2).IsFailure()) {
        output = (_3_valueOrError2).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IResolveAuthActionsOutput>();
        return output;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _4_valueOrError3 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
      _4_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(Dafny.Helpers.Id<Func<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IResolveAuthActionsInput, bool>>((_5_input) => Dafny.Helpers.Quantifier<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem>(((_5_input).dtor_authActions).UniqueElements, false, (((_exists_var_0) => {
        software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem _6_x = (software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem)_exists_var_0;
        return (((_5_input).dtor_authActions).Contains(_6_x)) && (((_6_x).dtor_key).Equals(StructuredEncryptionUtil_Compile.__default.HeaderPath));
      }))))(input), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Header Required")));
      if ((_4_valueOrError3).IsFailure()) {
        output = (_4_valueOrError3).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IResolveAuthActionsOutput>();
        return output;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _7_valueOrError4 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
      _7_valueOrError4 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(Dafny.Helpers.Id<Func<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IResolveAuthActionsInput, bool>>((_8_input) => Dafny.Helpers.Quantifier<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem>(((_8_input).dtor_authActions).UniqueElements, false, (((_exists_var_1) => {
        software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem _9_x = (software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem)_exists_var_1;
        return (((_8_input).dtor_authActions).Contains(_9_x)) && (((_9_x).dtor_key).Equals(StructuredEncryptionUtil_Compile.__default.FooterPath));
      }))))(input), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Footer Required")));
      if ((_7_valueOrError4).IsFailure()) {
        output = (_7_valueOrError4).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IResolveAuthActionsOutput>();
        return output;
      }
      Wrappers_Compile._IResult<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _10_valueOrError5 = Wrappers_Compile.Result<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(Dafny.Sequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>.Empty);
      _10_valueOrError5 = Canonize_Compile.__default.ForDecrypt((input).dtor_tableName, (input).dtor_authActions, (_2_head).dtor_legend);
      if ((_10_valueOrError5).IsFailure()) {
        output = (_10_valueOrError5).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IResolveAuthActionsOutput>();
        return output;
      }
      Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> _11_canonData;
      _11_canonData = (_10_valueOrError5).Extract();
      output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IResolveAuthActionsOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.ResolveAuthActionsOutput.create(Canonize_Compile.__default.UnCanon(_11_canonData)));
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> GetBinary(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem> data, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> path)
    {
      Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem> _0_data = AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.__default.FindAuth(data, path);
      if ((_0_data).is_None) {
        return Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Failure(StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("The field name "), StructuredEncryptionPaths_Compile.__default.PathToString(path)), Dafny.Sequence<char>.FromString(" is required."))));
      } else if (!((((_0_data).dtor_value).dtor_data).dtor_typeId).Equals(StructuredEncryptionUtil_Compile.__default.BYTES__TYPE__ID)) {
        return Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Failure(StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(StructuredEncryptionPaths_Compile.__default.PathToString(path), Dafny.Sequence<char>.FromString(" must be a binary Terminal."))));
      } else if (!object.Equals(((_0_data).dtor_value).dtor_action, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.AuthenticateAction.create_DO__NOT__SIGN())) {
        return Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Failure(StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(StructuredEncryptionPaths_Compile.__default.PathToString(path), Dafny.Sequence<char>.FromString(" must be DO_NOT_SIGN."))));
      } else {
        return Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(((_0_data).dtor_value).dtor_data);
      }
    }
    public static BigInteger SumValueSize(Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> fields) {
      BigInteger _0___accumulator = BigInteger.Zero;
    TAIL_CALL_START: ;
      if ((new BigInteger((fields).Count)).Sign == 0) {
        return (BigInteger.Zero) + (_0___accumulator);
      } else if (object.Equals(((fields).Select(BigInteger.Zero)).dtor_action, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_ENCRYPT__AND__SIGN())) {
        _0___accumulator = (_0___accumulator) + (new BigInteger(((((fields).Select(BigInteger.Zero)).dtor_data).dtor_value).Count));
        Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> _in0 = (fields).Drop(BigInteger.One);
        fields = _in0;
        goto TAIL_CALL_START;
      } else {
        Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> _in1 = (fields).Drop(BigInteger.One);
        fields = _in1;
        goto TAIL_CALL_START;
      }
    }
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId GetAlgorithmSuiteId(Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> alg) {
      if ((alg).is_Some) {
        return software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteId.create_DBE((alg).dtor_value);
      } else {
        return software.amazon.cryptography.materialproviders.internaldafny.types.AlgorithmSuiteId.create_DBE(software.amazon.cryptography.materialproviders.internaldafny.types.DBEAlgorithmSuiteId.create_ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384__SYMSIG__HMAC__SHA384());
      }
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> GetStructuredEncryptionMaterials(software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager cmm, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>> encryptionContext, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> algorithmSuiteId, BigInteger encryptedTerminalDataNum, BigInteger totalEncryptedTerminalValuesSize)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> ret = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>);
      BigInteger _0_maxLength;
      _0_maxLength = ((encryptedTerminalDataNum) * (new BigInteger(2))) + (totalEncryptedTerminalValuesSize);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _1_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
      _1_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((_0_maxLength) < (StandardLibrary_mUInt_Compile.__default.INT64__MAX__LIMIT), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Encrypted Size too long.")));
      if ((_1_valueOrError0).IsFailure()) {
        ret = (_1_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials>();
        return ret;
      }
      software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId _2_algId;
      _2_algId = AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.__default.GetAlgorithmSuiteId(algorithmSuiteId);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _3_matR;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out0;
      _out0 = (cmm).GetEncryptionMaterials(software.amazon.cryptography.materialproviders.internaldafny.types.GetEncryptionMaterialsInput.create(Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>.UnwrapOr(encryptionContext, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements()), AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.__default.DBE__COMMITMENT__POLICY, Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteId>.create_Some(_2_algId), Wrappers_Compile.Option<long>.create_Some((long)(_0_maxLength)), Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<byte>>>.create_None()));
      _3_matR = _out0;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _4_valueOrError1 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>);
      _4_valueOrError1 = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(_3_matR, ((System.Func<software.amazon.cryptography.materialproviders.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>)((_5_e) => {
        return software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.Error.create_AwsCryptographyMaterialProviders(_5_e);
      })));
      if ((_4_valueOrError1).IsFailure()) {
        ret = (_4_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials>();
        return ret;
      }
      software.amazon.cryptography.materialproviders.internaldafny.types._IGetEncryptionMaterialsOutput _6_matOutput;
      _6_matOutput = (_4_valueOrError1).Extract();
      software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials _7_mat;
      _7_mat = (_6_matOutput).dtor_encryptionMaterials;
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _8_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
      _8_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(Materials_Compile.__default.EncryptionMaterialsHasPlaintextDataKey(_7_mat), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Encryption material has no key")));
      if ((_8_valueOrError2).IsFailure()) {
        ret = (_8_valueOrError2).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials>();
        return ret;
      }
      software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _9_alg;
      _9_alg = (_7_mat).dtor_algorithmSuite;
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _10_valueOrError3 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
      _10_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(StructuredEncryptionUtil_Compile.__default.ValidSuite(_9_alg), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Invalid Algorithm Suite")));
      if ((_10_valueOrError3).IsFailure()) {
        ret = (_10_valueOrError3).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials>();
        return ret;
      }
      Dafny.ISequence<byte> _11_key;
      _11_key = ((_7_mat).dtor_plaintextDataKey).dtor_value;
      ret = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(_7_mat);
      return ret;
      return ret;
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> GetV2EncryptionContextCanon(Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> schema)
    {
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty);
      Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> _0_canonAttrs;
      _0_canonAttrs = Seq_Compile.__default.Filter<StructuredEncryptionUtil_Compile._ICanonCryptoItem>(((System.Func<StructuredEncryptionUtil_Compile._ICanonCryptoItem, bool>)((_1_s) => {
        return object.Equals((_1_s).dtor_action, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_SIGN__AND__INCLUDE__IN__ENCRYPTION__CONTEXT());
      })), schema);
      Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> _2_contextAttrs;
      _2_contextAttrs = Seq_Compile.__default.Map<StructuredEncryptionUtil_Compile._ICanonCryptoItem, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>(((System.Func<StructuredEncryptionUtil_Compile._ICanonCryptoItem, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>)((_3_s) => {
        return software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoItem.create((_3_s).dtor_origKey, (_3_s).dtor_data, (_3_s).dtor_action);
      })), _0_canonAttrs);
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.__default.GetV2EncryptionContext2(_2_contextAttrs);
      output = _out0;
      return output;
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> GetV2EncryptionContext(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> schema)
    {
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty);
      Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> _0_contextAttrs;
      _0_contextAttrs = Seq_Compile.__default.Filter<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>(((System.Func<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem, bool>)((_1_s) => {
        return object.Equals((_1_s).dtor_action, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_SIGN__AND__INCLUDE__IN__ENCRYPTION__CONTEXT());
      })), schema);
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.__default.GetV2EncryptionContext2(_0_contextAttrs);
      output = _out0;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> Find(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> haystack, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> needle)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((haystack).Count)).Sign == 0) {
        return Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Failure(StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Not Found")));
      } else if ((((haystack).Select(BigInteger.Zero)).dtor_key).Equals(needle)) {
        return Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success((haystack).Select(BigInteger.Zero));
      } else {
        Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> _in0 = (haystack).Drop(BigInteger.One);
        Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> _in1 = needle;
        haystack = _in0;
        needle = _in1;
        goto TAIL_CALL_START;
      }
    }
    public static Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem> FindAuth(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem> haystack, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> needle)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((haystack).Count)).Sign == 0) {
        return Wrappers_Compile.Option<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem>.create_None();
      } else if ((((haystack).Select(BigInteger.Zero)).dtor_key).Equals(needle)) {
        return Wrappers_Compile.Option<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem>.create_Some((haystack).Select(BigInteger.Zero));
      } else {
        Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem> _in0 = (haystack).Drop(BigInteger.One);
        Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> _in1 = needle;
        haystack = _in0;
        needle = _in1;
        goto TAIL_CALL_START;
      }
    }
    public static BigInteger CountEncrypted(Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> list) {
      BigInteger _0___accumulator = BigInteger.Zero;
    TAIL_CALL_START: ;
      if ((new BigInteger((list).Count)).Sign == 0) {
        return (BigInteger.Zero) + (_0___accumulator);
      } else if (object.Equals(((list).Select(BigInteger.Zero)).dtor_action, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_ENCRYPT__AND__SIGN())) {
        _0___accumulator = (_0___accumulator) + (BigInteger.One);
        Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> _in0 = (list).Drop(BigInteger.One);
        list = _in0;
        goto TAIL_CALL_START;
      } else {
        Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> _in1 = (list).Drop(BigInteger.One);
        list = _in1;
        goto TAIL_CALL_START;
      }
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> GetV2EncryptionContext2(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> fields)
    {
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty);
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>> _0_fieldMap;
      _0_fieldMap = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>>.FromElements();
      BigInteger _hi0 = new BigInteger((fields).Count);
      for (BigInteger _1_i = BigInteger.Zero; _1_i < _hi0; _1_i++) {
        Dafny.ISequence<char> _2_keyVal;
        _2_keyVal = Dafny.Sequence<char>.Concat(StructuredEncryptionUtil_Compile.__default.ATTR__PREFIX, StructuredEncryptionPaths_Compile.__default.PathToString(((fields).Select(_1_i)).dtor_key));
        Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _3_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(UTF8.ValidUTF8Bytes.Default());
        _3_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(UTF8.__default.Encode(_2_keyVal), ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>)((_4_e) => {
          return StructuredEncryptionUtil_Compile.__default.E(_4_e);
        })));
        if ((_3_valueOrError0).IsFailure()) {
          output = (_3_valueOrError0).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
          return output;
        }
        Dafny.ISequence<byte> _5_utf8Value;
        _5_utf8Value = (_3_valueOrError0).Extract();
        if ((_0_fieldMap).Contains(_5_utf8Value)) {
          output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Failure(StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(_2_keyVal, Dafny.Sequence<char>.FromString(" appears twice in encryption context."))));
          return output;
        }
        _0_fieldMap = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>>.Update(_0_fieldMap, _5_utf8Value, ((fields).Select(_1_i)).dtor_key);
      }
      Dafny.ISequence<Dafny.ISequence<byte>> _6_keys;
      _6_keys = SortedSets.__default.SetToOrderedSequence2<byte>((_0_fieldMap).Keys, StructuredEncryptionUtil_Compile.__default.ByteLess);
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _7_newContext;
      _7_newContext = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements();
      Dafny.ISequence<char> _8_legend;
      _8_legend = Dafny.Sequence<char>.FromString("");
      BigInteger _hi1 = new BigInteger((_6_keys).Count);
      for (BigInteger _9_i = BigInteger.Zero; _9_i < _hi1; _9_i++) {
        Dafny.ISequence<byte> _10_fieldUtf8;
        _10_fieldUtf8 = (_6_keys).Select(_9_i);
        Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> _11_fieldStr;
        _11_fieldStr = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>>.Select(_0_fieldMap,_10_fieldUtf8);
        Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _12_valueOrError1 = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>);
        _12_valueOrError1 = AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.__default.Find(fields, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment>>.Select(_0_fieldMap,_10_fieldUtf8));
        if ((_12_valueOrError1).IsFailure()) {
          output = (_12_valueOrError1).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
          return output;
        }
        software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem _13_item;
        _13_item = (_12_valueOrError1).Extract();
        software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal _14_attr;
        _14_attr = (_13_item).dtor_data;
        Dafny.ISequence<byte> _15_attrStr = UTF8.ValidUTF8Bytes.Default();
        char _16_legendChar = 'D';
        if (((_14_attr).dtor_typeId).Equals(StructuredEncryptionUtil_Compile.__default.NULL)) {
          _16_legendChar = StructuredEncryptionUtil_Compile.__default.LEGEND__LITERAL;
          _15_attrStr = StructuredEncryptionUtil_Compile.__default.NULL__UTF8;
        } else if (((_14_attr).dtor_typeId).Equals(StructuredEncryptionUtil_Compile.__default.STRING)) {
          _16_legendChar = StructuredEncryptionUtil_Compile.__default.LEGEND__STRING;
          Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _17_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
          _17_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(UTF8.__default.ValidUTF8Seq((_14_attr).dtor_value), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Internal Error : string was not UTF8.")));
          if ((_17_valueOrError2).IsFailure()) {
            output = (_17_valueOrError2).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
            return output;
          }
          _15_attrStr = (_14_attr).dtor_value;
          Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _18_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.Default(Dafny.Sequence<char>.Empty);
          _18_valueOrError3 = UTF8.__default.Decode(_15_attrStr);
          if (!(!((_18_valueOrError3).IsFailure()))) {
            throw new Dafny.HaltException("dafny/StructuredEncryption/src/AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations.dfy(357,18): " + _18_valueOrError3);}
          Dafny.ISequence<char> _19_yy;
          _19_yy = (_18_valueOrError3).Extract();
        } else if (((_14_attr).dtor_typeId).Equals(StructuredEncryptionUtil_Compile.__default.NUMBER)) {
          _16_legendChar = StructuredEncryptionUtil_Compile.__default.LEGEND__NUMBER;
          Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _20_valueOrError4 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
          _20_valueOrError4 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(UTF8.__default.ValidUTF8Seq((_14_attr).dtor_value), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Internal Error : number was not UTF8.")));
          if ((_20_valueOrError4).IsFailure()) {
            output = (_20_valueOrError4).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
            return output;
          }
          _15_attrStr = (_14_attr).dtor_value;
        } else if (((_14_attr).dtor_typeId).Equals(StructuredEncryptionUtil_Compile.__default.BOOLEAN)) {
          _16_legendChar = StructuredEncryptionUtil_Compile.__default.LEGEND__LITERAL;
          Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _21_valueOrError5 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
          _21_valueOrError5 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((new BigInteger(((_14_attr).dtor_value).Count)) == (BigInteger.One), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Internal Error : boolean was not of length 1.")));
          if ((_21_valueOrError5).IsFailure()) {
            output = (_21_valueOrError5).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
            return output;
          }
          if ((((_14_attr).dtor_value).Select(BigInteger.Zero)) == ((byte)(0))) {
            _15_attrStr = StructuredEncryptionUtil_Compile.__default.FALSE__UTF8;
          } else {
            _15_attrStr = StructuredEncryptionUtil_Compile.__default.TRUE__UTF8;
          }
        } else {
          _16_legendChar = StructuredEncryptionUtil_Compile.__default.LEGEND__BINARY;
          _15_attrStr = StructuredEncryptionUtil_Compile.__default.EncodeTerminal(_14_attr);
        }
        _7_newContext = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Update(_7_newContext, _10_fieldUtf8, _15_attrStr);
        _8_legend = Dafny.Sequence<char>.Concat(_8_legend, Dafny.Sequence<char>.FromElements(_16_legendChar));
      }
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _22_valueOrError6 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(UTF8.ValidUTF8Bytes.Default());
      _22_valueOrError6 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(UTF8.__default.Encode(_8_legend), ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>)((_23_e) => {
        return StructuredEncryptionUtil_Compile.__default.E(_23_e);
      })));
      if ((_22_valueOrError6).IsFailure()) {
        output = (_22_valueOrError6).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
        return output;
      }
      Dafny.ISequence<byte> _24_utf8Legend;
      _24_utf8Legend = (_22_valueOrError6).Extract();
      _7_newContext = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Update(_7_newContext, StructuredEncryptionUtil_Compile.__default.LEGEND__UTF8, _24_utf8Legend);
      output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(_7_newContext);
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> BuildCryptoMap2(Dafny.ISequence<Dafny.ISequence<char>> keys, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> plaintextStructure, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> cryptoSchema, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> acc)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((keys).Count)).Sign == 0) {
        return Wrappers_Compile.Result<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(acc);
      } else {
        Dafny.ISequence<char> _0_key = (keys).Select(BigInteger.Zero);
        Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> _1_path = StructuredEncryptionPaths_Compile.__default.StringToUniPath(_0_key);
        software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem _2_item = software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoItem.create(_1_path, Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>.Select(plaintextStructure,_0_key), Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Select(cryptoSchema,_0_key));
        Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> _3_newAcc = Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>.Concat(acc, Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>.FromElements(_2_item));
        Dafny.ISequence<Dafny.ISequence<char>> _in0 = (keys).Drop(BigInteger.One);
        Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> _in1 = plaintextStructure;
        Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> _in2 = cryptoSchema;
        Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> _in3 = _3_newAcc;
        keys = _in0;
        plaintextStructure = _in1;
        cryptoSchema = _in2;
        acc = _in3;
        goto TAIL_CALL_START;
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> BuildCryptoMap(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> plaintextStructure, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> cryptoSchema)
    {
      Dafny.ISequence<Dafny.ISequence<char>> _0_keys = SortedSets.__default.SetToOrderedSequence2<char>((plaintextStructure).Keys, StructuredEncryptionUtil_Compile.__default.CharLess);
      return AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.__default.BuildCryptoMap2(_0_keys, plaintextStructure, cryptoSchema, Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>.FromElements());
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> BuildAuthMap2(Dafny.ISequence<Dafny.ISequence<char>> keys, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> plaintextStructure, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction> authSchema, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem> acc)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((keys).Count)).Sign == 0) {
        return Wrappers_Compile.Result<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(acc);
      } else {
        Dafny.ISequence<char> _0_key = (keys).Select(BigInteger.Zero);
        Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IPathSegment> _1_path = StructuredEncryptionPaths_Compile.__default.StringToUniPath(_0_key);
        software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem _2_item = software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.AuthItem.create(_1_path, Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>.Select(plaintextStructure,_0_key), Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction>.Select(authSchema,_0_key));
        Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem> _3_newAcc = Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem>.Concat(acc, Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem>.FromElements(_2_item));
        Dafny.ISequence<Dafny.ISequence<char>> _in0 = (keys).Drop(BigInteger.One);
        Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> _in1 = plaintextStructure;
        Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction> _in2 = authSchema;
        Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem> _in3 = _3_newAcc;
        keys = _in0;
        plaintextStructure = _in1;
        authSchema = _in2;
        acc = _in3;
        goto TAIL_CALL_START;
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> BuildAuthMap(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> plaintextStructure, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction> authSchema)
    {
      Dafny.ISequence<Dafny.ISequence<char>> _0_keys = SortedSets.__default.SetToOrderedSequence2<char>((plaintextStructure).Keys, StructuredEncryptionUtil_Compile.__default.CharLess);
      return AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.__default.BuildAuthMap2(_0_keys, plaintextStructure, authSchema, Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem>.FromElements());
    }
    public static Wrappers_Compile._IResult<_System._ITuple2<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> UnBuildCryptoMap(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> list, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> dataSoFar, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> actionsSoFar)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((list).Count)).Sign == 0) {
        return Wrappers_Compile.Result<_System._ITuple2<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(_System.Tuple2<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>>.create(dataSoFar, actionsSoFar));
      } else {
        Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = StructuredEncryptionPaths_Compile.__default.UniPathToString(((list).Select(BigInteger.Zero)).dtor_key);
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<_System._ITuple2<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>>>();
        } else {
          Dafny.ISequence<char> _1_key = (_0_valueOrError0).Extract();
          Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _2_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(!(dataSoFar).Contains(_1_key), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Duplicate Key "), _1_key)));
          if ((_2_valueOrError1).IsFailure()) {
            return (_2_valueOrError1).PropagateFailure<_System._ITuple2<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>>>();
          } else if (StructuredEncryptionUtil_Compile.__default.IsAuthAttr(((list).Select(BigInteger.Zero)).dtor_action)) {
            Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> _in0 = (list).Drop(BigInteger.One);
            Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> _in1 = Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>.Update(dataSoFar, _1_key, ((list).Select(BigInteger.Zero)).dtor_data);
            Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> _in2 = Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Update(actionsSoFar, _1_key, ((list).Select(BigInteger.Zero)).dtor_action);
            list = _in0;
            dataSoFar = _in1;
            actionsSoFar = _in2;
            goto TAIL_CALL_START;
          } else {
            Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> _in3 = (list).Drop(BigInteger.One);
            Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> _in4 = Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>.Update(dataSoFar, _1_key, ((list).Select(BigInteger.Zero)).dtor_data);
            Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> _in5 = actionsSoFar;
            list = _in3;
            dataSoFar = _in4;
            actionsSoFar = _in5;
            goto TAIL_CALL_START;
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> EncryptStructure(AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.EncryptStructureOutput.Default());
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
      _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((((input).dtor_plaintextStructure).Keys).Equals(((input).dtor_cryptoSchema).Keys), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Crypto Keys don't match.")));
      if ((_0_valueOrError0).IsFailure()) {
        output = (_0_valueOrError0).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureOutput>();
        return output;
      }
      Wrappers_Compile._IResult<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _1_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>.Empty);
      _1_valueOrError1 = AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.__default.BuildCryptoMap((input).dtor_plaintextStructure, (input).dtor_cryptoSchema);
      if ((_1_valueOrError1).IsFailure()) {
        output = (_1_valueOrError1).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureOutput>();
        return output;
      }
      Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> _2_cryptoMap;
      _2_cryptoMap = (_1_valueOrError1).Extract();
      software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureInput _3_pathInput;
      _3_pathInput = software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.EncryptPathStructureInput.create((input).dtor_tableName, _2_cryptoMap, (input).dtor_cmm, (input).dtor_algorithmSuiteId, (input).dtor_encryptionContext);
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _4_valueOrError2 = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.EncryptPathStructureOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.__default.EncryptPathStructure(config, _3_pathInput);
      _4_valueOrError2 = _out0;
      if ((_4_valueOrError2).IsFailure()) {
        output = (_4_valueOrError2).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureOutput>();
        return output;
      }
      software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput _5_pathOutput;
      _5_pathOutput = (_4_valueOrError2).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _6_valueOrError3 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
      _6_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(Dafny.Helpers.Id<Func<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput, bool>>((_7_pathOutput) => Dafny.Helpers.Quantifier<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>(((_7_pathOutput).dtor_encryptedStructure).UniqueElements, true, (((_forall_var_0) => {
        software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem _8_k = (software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem)_forall_var_0;
        return !(((_7_pathOutput).dtor_encryptedStructure).Contains(_8_k)) || ((new BigInteger(((_8_k).dtor_key).Count)) == (BigInteger.One));
      }))))(_5_pathOutput), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Internal Error")));
      if ((_6_valueOrError3).IsFailure()) {
        output = (_6_valueOrError3).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureOutput>();
        return output;
      }
      Wrappers_Compile._IResult<_System._ITuple2<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _9_valueOrError4 = Wrappers_Compile.Result<_System._ITuple2<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(_System.Tuple2<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>.Empty, Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Empty));
      _9_valueOrError4 = AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.__default.UnBuildCryptoMap((_5_pathOutput).dtor_encryptedStructure, Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>.FromElements(), Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.FromElements());
      if ((_9_valueOrError4).IsFailure()) {
        output = (_9_valueOrError4).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureOutput>();
        return output;
      }
      _System._ITuple2<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>> _10_parts;
      _10_parts = (_9_valueOrError4).Extract();
      software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureOutput _11_plainOutput;
      _11_plainOutput = software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.EncryptStructureOutput.create((_10_parts).dtor__0, (_10_parts).dtor__1, (_5_pathOutput).dtor_parsedHeader);
      output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(_11_plainOutput);
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> EncryptPathStructure(AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.EncryptPathStructureOutput.Default());
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
      _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((((input).dtor_encryptionContext).is_None) || (!(Dafny.Helpers.Id<Func<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureInput, bool>>((_1_input) => Dafny.Helpers.Quantifier<Dafny.ISequence<byte>>((((_1_input).dtor_encryptionContext).dtor_value).Keys.Elements, false, (((_exists_var_0) => {
        Dafny.ISequence<byte> _2_k = (Dafny.ISequence<byte>)_exists_var_0;
        return ((((_1_input).dtor_encryptionContext).dtor_value).Contains(_2_k)) && (Dafny.Sequence<byte>.IsPrefixOf(StructuredEncryptionUtil_Compile.__default.ReservedCryptoContextPrefixUTF8, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(((_1_input).dtor_encryptionContext).dtor_value,_2_k)));
      }))))(input))), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Encryption Context must not contain members beginning with "), StructuredEncryptionUtil_Compile.__default.ReservedCryptoContextPrefixString)));
      if ((_0_valueOrError0).IsFailure()) {
        output = (_0_valueOrError0).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput>();
        return output;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _3_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
      _3_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(Dafny.Helpers.Id<Func<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureInput, bool>>((_4_input) => Dafny.Helpers.Quantifier<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>(((_4_input).dtor_plaintextStructure).UniqueElements, false, (((_exists_var_1) => {
        software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem _5_k = (software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem)_exists_var_1;
        return (((_4_input).dtor_plaintextStructure).Contains(_5_k)) && (StructuredEncryptionUtil_Compile.__default.IsAuthAttr((_5_k).dtor_action));
      }))))(input), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("At least one field in the Crypto Schema must be ENCRYPT_AND_SIGN, SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT or SIGN_ONLY.")));
      if ((_3_valueOrError1).IsFailure()) {
        output = (_3_valueOrError1).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput>();
        return output;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _6_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
      _6_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(!(Dafny.Helpers.Id<Func<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureInput, bool>>((_7_input) => Dafny.Helpers.Quantifier<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>(((_7_input).dtor_plaintextStructure).UniqueElements, false, (((_exists_var_2) => {
        software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem _8_x = (software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem)_exists_var_2;
        return (((_7_input).dtor_plaintextStructure).Contains(_8_x)) && ((StructuredEncryptionUtil_Compile.__default.HeaderPaths).Contains((_8_x).dtor_key));
      }))))(input)), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("The paths "), StructuredEncryptionUtil_Compile.__default.HeaderField), Dafny.Sequence<char>.FromString(" and ")), StructuredEncryptionUtil_Compile.__default.FooterField), Dafny.Sequence<char>.FromString(" are reserved."))));
      if ((_6_valueOrError2).IsFailure()) {
        output = (_6_valueOrError2).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput>();
        return output;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _9_valueOrError3 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
      _9_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(StructuredEncryptionUtil_Compile.__default.CryptoListHasNoDuplicatesFromSet((input).dtor_plaintextStructure), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Duplicate Paths")));
      if ((_9_valueOrError3).IsFailure()) {
        output = (_9_valueOrError3).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput>();
        return output;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _10_valueOrError4 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
      _10_valueOrError4 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(StructuredEncryptionUtil_Compile.__default.ValidString((input).dtor_tableName), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Bad Table Name")));
      if ((_10_valueOrError4).IsFailure()) {
        output = (_10_valueOrError4).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput>();
        return output;
      }
      Wrappers_Compile._IResult<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _11_valueOrError5 = Wrappers_Compile.Result<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(Dafny.Sequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>.Empty);
      _11_valueOrError5 = Canonize_Compile.__default.ForEncrypt((input).dtor_tableName, (input).dtor_plaintextStructure);
      if ((_11_valueOrError5).IsFailure()) {
        output = (_11_valueOrError5).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput>();
        return output;
      }
      Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> _12_canonData;
      _12_canonData = (_11_valueOrError5).Extract();
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _13_encryptionContext;
      _13_encryptionContext = Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>.UnwrapOr((input).dtor_encryptionContext, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements());
      software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager _14_cmm;
      _14_cmm = (input).dtor_cmm;
      if (Dafny.Helpers.Id<Func<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureInput, bool>>((_15_input) => Dafny.Helpers.Quantifier<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem>(((_15_input).dtor_plaintextStructure).UniqueElements, false, (((_exists_var_3) => {
        software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem _16_x = (software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem)_exists_var_3;
        return (((_15_input).dtor_plaintextStructure).Contains(_16_x)) && (object.Equals((_16_x).dtor_action, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_SIGN__AND__INCLUDE__IN__ENCRYPTION__CONTEXT()));
      }))))(input)) {
        Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _17_valueOrError6 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty);
        Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _out0;
        _out0 = AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.__default.GetV2EncryptionContext((input).dtor_plaintextStructure);
        _17_valueOrError6 = _out0;
        if ((_17_valueOrError6).IsFailure()) {
          output = (_17_valueOrError6).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput>();
          return output;
        }
        Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18_newEncryptionContext;
        _18_newEncryptionContext = (_17_valueOrError6).Extract();
        if ((new BigInteger((_18_newEncryptionContext).Count)).Sign != 0) {
          Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _19_valueOrError7 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
          _19_valueOrError7 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(Dafny.Set<Dafny.ISequence<byte>>.IsDisjointFrom((_13_encryptionContext).Keys, (_18_newEncryptionContext).Keys), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Internal Error - Structured Encryption encryption context overlaps with Item Encryptor encryption context.")));
          if ((_19_valueOrError7).IsFailure()) {
            output = (_19_valueOrError7).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput>();
            return output;
          }
          _13_encryptionContext = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Merge(_13_encryptionContext, _18_newEncryptionContext);
          Dafny.ISequence<Dafny.ISequence<byte>> _20_contextKeysX;
          _20_contextKeysX = SortedSets.__default.SetToOrderedSequence2<byte>((_18_newEncryptionContext).Keys, StructuredEncryptionUtil_Compile.__default.ByteLess);
          Dafny.ISequence<Dafny.ISequence<byte>> _21_contextKeys;
          _21_contextKeys = _20_contextKeysX;
          Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _22_cmmR;
          Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out1;
          _out1 = ((config).dtor_materialProviders).CreateRequiredEncryptionContextCMM(software.amazon.cryptography.materialproviders.internaldafny.types.CreateRequiredEncryptionContextCMMInput.create(Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager>.create_Some((input).dtor_cmm), Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>.create_None(), _21_contextKeys));
          _22_cmmR = _out1;
          Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _23_valueOrError8 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>);
          _23_valueOrError8 = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(_22_cmmR, ((System.Func<software.amazon.cryptography.materialproviders.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>)((_24_e) => {
            return software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.Error.create_AwsCryptographyMaterialProviders(_24_e);
          })));
          if ((_23_valueOrError8).IsFailure()) {
            output = (_23_valueOrError8).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput>();
            return output;
          }
          _14_cmm = (_23_valueOrError8).Extract();
        }
      }
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _25_valueOrError9 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _out2;
      _out2 = AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.__default.GetStructuredEncryptionMaterials(_14_cmm, Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>.create_Some(_13_encryptionContext), (input).dtor_algorithmSuiteId, AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.__default.CountEncrypted(_12_canonData), AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.__default.SumValueSize(_12_canonData));
      _25_valueOrError9 = _out2;
      if ((_25_valueOrError9).IsFailure()) {
        output = (_25_valueOrError9).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput>();
        return output;
      }
      software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptionMaterials _26_mat;
      _26_mat = (_25_valueOrError9).Extract();
      Dafny.ISequence<byte> _27_key;
      _27_key = ((_26_mat).dtor_plaintextDataKey).dtor_value;
      software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _28_alg;
      _28_alg = (_26_mat).dtor_algorithmSuite;
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _29_valueOrError10 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
      _29_valueOrError10 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(StructuredEncryptionHeader_Compile.__default.ValidEncryptionContext((_26_mat).dtor_encryptionContext), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Bad encryption context")));
      if ((_29_valueOrError10).IsFailure()) {
        output = (_29_valueOrError10).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput>();
        return output;
      }
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _30_randBytes;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _out3;
      _out3 = Random_Compile.__default.GenerateBytes((int)(StructuredEncryptionUtil_Compile.__default.MSGID__LEN));
      _30_randBytes = _out3;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _31_valueOrError11 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _31_valueOrError11 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(_30_randBytes, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>)((_32_e) => {
        return software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.Error.create_AwsCryptographyPrimitives(_32_e);
      })));
      if ((_31_valueOrError11).IsFailure()) {
        output = (_31_valueOrError11).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput>();
        return output;
      }
      Dafny.ISequence<byte> _33_msgID;
      _33_msgID = (_31_valueOrError11).Extract();
      Wrappers_Compile._IResult<StructuredEncryptionHeader_Compile._IPartialHeader, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _34_valueOrError12 = default(Wrappers_Compile._IResult<StructuredEncryptionHeader_Compile._IPartialHeader, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>);
      _34_valueOrError12 = StructuredEncryptionHeader_Compile.__default.Create((input).dtor_tableName, _12_canonData, _33_msgID, _26_mat);
      if ((_34_valueOrError12).IsFailure()) {
        output = (_34_valueOrError12).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput>();
        return output;
      }
      StructuredEncryptionHeader_Compile._IPartialHeader _35_head;
      _35_head = (_34_valueOrError12).Extract();
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _36_valueOrError13 = default(Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>);
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _out4;
      _out4 = StructuredEncryptionCrypt_Compile.__default.GetCommitKey((config).dtor_primitives, _28_alg, _27_key, (_35_head).dtor_msgID);
      _36_valueOrError13 = _out4;
      if ((_36_valueOrError13).IsFailure()) {
        output = (_36_valueOrError13).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput>();
        return output;
      }
      Dafny.ISequence<byte> _37_commitKey;
      _37_commitKey = (_36_valueOrError13).Extract();
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _38_valueOrError14 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _38_valueOrError14 = StructuredEncryptionHeader_Compile.__default.Serialize((config).dtor_primitives, _28_alg, _37_commitKey, _35_head);
      if ((_38_valueOrError14).IsFailure()) {
        output = (_38_valueOrError14).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput>();
        return output;
      }
      Dafny.ISequence<byte> _39_headerSerialized;
      _39_headerSerialized = (_38_valueOrError14).Extract();
      software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal _40_headerAttribute;
      _40_headerAttribute = StructuredEncryptionUtil_Compile.__default.ValueToData(_39_headerSerialized, StructuredEncryptionUtil_Compile.__default.BYTES__TYPE__ID);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _41_valueOrError15 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
      _41_valueOrError15 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((new BigInteger((_12_canonData).Count)) < (Dafny.Helpers.EuclideanDivision(StandardLibrary_mUInt_Compile.__default.UINT32__LIMIT, new BigInteger(3))), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Too many encrypted fields")));
      if ((_41_valueOrError15).IsFailure()) {
        output = (_41_valueOrError15).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput>();
        return output;
      }
      Wrappers_Compile._IResult<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _42_valueOrError16 = Wrappers_Compile.Result<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(Dafny.Sequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>.Empty);
      Wrappers_Compile._IResult<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _out5;
      _out5 = StructuredEncryptionCrypt_Compile.__default.Encrypt((config).dtor_primitives, _28_alg, _27_key, _35_head, _12_canonData);
      _42_valueOrError16 = _out5;
      if ((_42_valueOrError16).IsFailure()) {
        output = (_42_valueOrError16).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput>();
        return output;
      }
      Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> _43_encryptedItems;
      _43_encryptedItems = (_42_valueOrError16).Extract();
      Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> _44_smallResult;
      _44_smallResult = Canonize_Compile.__default.UnCanonEncrypt(_43_encryptedItems);
      Wrappers_Compile._IResult<StructuredEncryptionFooter_Compile._IFooter, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _45_valueOrError17 = Wrappers_Compile.Result<StructuredEncryptionFooter_Compile._IFooter, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(StructuredEncryptionFooter_Compile.Footer.Default());
      Wrappers_Compile._IResult<StructuredEncryptionFooter_Compile._IFooter, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _out6;
      _out6 = StructuredEncryptionFooter_Compile.__default.CreateFooter((config).dtor_primitives, _26_mat, _43_encryptedItems, _39_headerSerialized);
      _45_valueOrError17 = _out6;
      if ((_45_valueOrError17).IsFailure()) {
        output = (_45_valueOrError17).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput>();
        return output;
      }
      StructuredEncryptionFooter_Compile._IFooter _46_footer;
      _46_footer = (_45_valueOrError17).Extract();
      software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal _47_footerAttribute;
      _47_footerAttribute = (_46_footer).makeTerminal();
      Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> _48_largeResult;
      _48_largeResult = Canonize_Compile.__default.AddHeaders(_44_smallResult, _40_headerAttribute, _47_footerAttribute);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _49_valueOrError18 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _out7;
      _out7 = (_35_head).GetAlgorithmSuite((config).dtor_materialProviders);
      _49_valueOrError18 = _out7;
      if ((_49_valueOrError18).IsFailure()) {
        output = (_49_valueOrError18).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput>();
        return output;
      }
      software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _50_headerAlgorithmSuite;
      _50_headerAlgorithmSuite = (_49_valueOrError18).Extract();
      software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IParsedHeader _51_parsedHeader;
      _51_parsedHeader = software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.ParsedHeader.create(((_50_headerAlgorithmSuite).dtor_id).dtor_DBE, (_35_head).dtor_dataKeys, (_35_head).dtor_encContext, (_26_mat).dtor_encryptionContext);
      software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput _52_encryptOutput;
      _52_encryptOutput = software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.EncryptPathStructureOutput.create(_48_largeResult, _51_parsedHeader);
      output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(_52_encryptOutput);
      return output;
      return output;
    }
    public static Dafny.ISequence<char> SafeDecode(Dafny.ISequence<byte> data) {
      Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _0_x = UTF8.__default.Decode(data);
      if ((_0_x).is_Success) {
        return (_0_x).dtor_value;
      } else {
        return Dafny.Sequence<char>.FromString("[corrupt value]");
      }
    }
    public static Dafny.ISequence<char> DescribeMismatch(Dafny.ISequence<Dafny.ISequence<byte>> inputFields, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> inputContext, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> headContext)
    {
      Dafny.ISequence<char> _0___accumulator = Dafny.Sequence<char>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((inputFields).Count)).Sign == 0) {
        return Dafny.Sequence<char>.Concat(_0___accumulator, Dafny.Sequence<char>.FromString(""));
      } else {
        Dafny.ISequence<byte> _1_key = (inputFields).Select(BigInteger.Zero);
        if (((headContext).Contains(_1_key)) && (!(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(headContext,_1_key)).Equals(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(inputContext,_1_key)))) {
          Dafny.ISequence<char> _2_keyStr = AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.__default.SafeDecode(_1_key);
          Dafny.ISequence<char> _3_headStr = AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.__default.SafeDecode(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(headContext,_1_key));
          Dafny.ISequence<char> _4_inputStr = AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.__default.SafeDecode(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(inputContext,_1_key));
          Dafny.ISequence<char> _5_msg = Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("input context for "), _2_keyStr), Dafny.Sequence<char>.FromString(" was ")), _4_inputStr), Dafny.Sequence<char>.FromString(" but stored context had ")), _3_headStr), Dafny.Sequence<char>.FromString("\n"));
          _0___accumulator = Dafny.Sequence<char>.Concat(_0___accumulator, _5_msg);
          Dafny.ISequence<Dafny.ISequence<byte>> _in0 = (inputFields).Drop(BigInteger.One);
          Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _in1 = inputContext;
          Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _in2 = headContext;
          inputFields = _in0;
          inputContext = _in1;
          headContext = _in2;
          goto TAIL_CALL_START;
        } else {
          Dafny.ISequence<Dafny.ISequence<byte>> _in3 = (inputFields).Drop(BigInteger.One);
          Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _in4 = inputContext;
          Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _in5 = headContext;
          inputFields = _in3;
          inputContext = _in4;
          headContext = _in5;
          goto TAIL_CALL_START;
        }
      }
    }
    public static Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> DetectMismatch(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> inputContext, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> headContext)
    {
      Dafny.ISequence<Dafny.ISequence<byte>> _0_inputFields = SortedSets.__default.SetToOrderedSequence2<byte>((inputContext).Keys, StructuredEncryptionUtil_Compile.__default.ByteLess);
      Dafny.ISequence<char> _1_str = AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.__default.DescribeMismatch(_0_inputFields, inputContext, headContext);
      if ((new BigInteger((_1_str).Count)).Sign == 0) {
        return Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Pass();
      } else {
        return Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Fail(StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Encryption Context Mismatch\n"), _1_str)));
      }
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> NewCmm(AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile._IConfig config, software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager cmm, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> context)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> ret = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>);
      Dafny.ISequence<Dafny.ISequence<byte>> _0_contextKeysX;
      _0_contextKeysX = SortedSets.__default.SetToOrderedSequence2<byte>((context).Keys, StructuredEncryptionUtil_Compile.__default.ByteLess);
      Dafny.ISequence<Dafny.ISequence<byte>> _1_contextKeys;
      _1_contextKeys = _0_contextKeysX;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _2_cmmR;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out0;
      _out0 = ((config).dtor_materialProviders).CreateRequiredEncryptionContextCMM(software.amazon.cryptography.materialproviders.internaldafny.types.CreateRequiredEncryptionContextCMMInput.create(Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager>.create_Some(cmm), Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>.create_None(), _1_contextKeys));
      _2_cmmR = _out0;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _3_valueOrError0 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>);
      _3_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(_2_cmmR, ((System.Func<software.amazon.cryptography.materialproviders.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>)((_4_e) => {
        return software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.Error.create_AwsCryptographyMaterialProviders(_4_e);
      })));
      if ((_3_valueOrError0).IsFailure()) {
        ret = (_3_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager>();
        return ret;
      }
      software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager _5_newCmm;
      _5_newCmm = (_3_valueOrError0).Extract();
      ret = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(_5_newCmm);
      return ret;
      return ret;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> DecryptStructure(AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptStructureInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.DecryptStructureOutput.Default());
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
      _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>((((input).dtor_encryptedStructure).Keys).Equals(((input).dtor_authenticateSchema).Keys), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("DecryptStructure requires encryptedStructure and authenticateSchema have the same keys.")));
      if ((_0_valueOrError0).IsFailure()) {
        output = (_0_valueOrError0).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptStructureOutput>();
        return output;
      }
      Wrappers_Compile._IResult<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _1_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem>.Empty);
      _1_valueOrError1 = AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.__default.BuildAuthMap((input).dtor_encryptedStructure, (input).dtor_authenticateSchema);
      if ((_1_valueOrError1).IsFailure()) {
        output = (_1_valueOrError1).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptStructureOutput>();
        return output;
      }
      Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem> _2_cryptoMap;
      _2_cryptoMap = (_1_valueOrError1).Extract();
      software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureInput _3_pathInput;
      _3_pathInput = software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.DecryptPathStructureInput.create((input).dtor_tableName, _2_cryptoMap, (input).dtor_cmm, (input).dtor_encryptionContext);
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _4_valueOrError2 = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.DecryptPathStructureOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.__default.DecryptPathStructure(config, _3_pathInput);
      _4_valueOrError2 = _out0;
      if ((_4_valueOrError2).IsFailure()) {
        output = (_4_valueOrError2).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptStructureOutput>();
        return output;
      }
      software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput _5_pathOutput;
      _5_pathOutput = (_4_valueOrError2).Extract();
      Wrappers_Compile._IResult<_System._ITuple2<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _6_valueOrError3 = Wrappers_Compile.Result<_System._ITuple2<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(_System.Tuple2<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>.Empty, Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Empty));
      _6_valueOrError3 = AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.__default.UnBuildCryptoMap((_5_pathOutput).dtor_plaintextStructure, Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>.FromElements(), Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.FromElements());
      if ((_6_valueOrError3).IsFailure()) {
        output = (_6_valueOrError3).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptStructureOutput>();
        return output;
      }
      _System._ITuple2<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>> _7_parts;
      _7_parts = (_6_valueOrError3).Extract();
      software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptStructureOutput _8_plainOutput;
      _8_plainOutput = software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.DecryptStructureOutput.create((_7_parts).dtor__0, (_7_parts).dtor__1, (_5_pathOutput).dtor_parsedHeader);
      output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(_8_plainOutput);
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> DecryptPathStructure(AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.DecryptPathStructureOutput.Default());
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
      _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(Dafny.Helpers.Id<Func<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureInput, bool>>((_1_input) => Dafny.Helpers.Quantifier<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem>(((_1_input).dtor_encryptedStructure).UniqueElements, false, (((_exists_var_0) => {
        software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem _2_x = (software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthItem)_exists_var_0;
        return (((_1_input).dtor_encryptedStructure).Contains(_2_x)) && (object.Equals((_2_x).dtor_action, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.AuthenticateAction.create_SIGN()));
      }))))(input), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("At least one Authenticate Action must be SIGN")));
      if ((_0_valueOrError0).IsFailure()) {
        output = (_0_valueOrError0).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput>();
        return output;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _3_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
      _3_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(StructuredEncryptionUtil_Compile.__default.AuthListHasNoDuplicatesFromSet((input).dtor_encryptedStructure), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Duplicate Paths")));
      if ((_3_valueOrError1).IsFailure()) {
        output = (_3_valueOrError1).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput>();
        return output;
      }
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _4_valueOrError2 = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>);
      _4_valueOrError2 = AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.__default.GetBinary((input).dtor_encryptedStructure, StructuredEncryptionUtil_Compile.__default.HeaderPath);
      if ((_4_valueOrError2).IsFailure()) {
        output = (_4_valueOrError2).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput>();
        return output;
      }
      software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal _5_headerSerialized;
      _5_headerSerialized = (_4_valueOrError2).Extract();
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _6_valueOrError3 = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>);
      _6_valueOrError3 = AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.__default.GetBinary((input).dtor_encryptedStructure, StructuredEncryptionUtil_Compile.__default.FooterPath);
      if ((_6_valueOrError3).IsFailure()) {
        output = (_6_valueOrError3).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput>();
        return output;
      }
      software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal _7_footerSerialized;
      _7_footerSerialized = (_6_valueOrError3).Extract();
      Wrappers_Compile._IResult<StructuredEncryptionHeader_Compile._IPartialHeader, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _8_valueOrError4 = default(Wrappers_Compile._IResult<StructuredEncryptionHeader_Compile._IPartialHeader, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>);
      _8_valueOrError4 = StructuredEncryptionHeader_Compile.__default.PartialDeserialize((_5_headerSerialized).dtor_value);
      if ((_8_valueOrError4).IsFailure()) {
        output = (_8_valueOrError4).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput>();
        return output;
      }
      StructuredEncryptionHeader_Compile._IPartialHeader _9_head;
      _9_head = (_8_valueOrError4).Extract();
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _10_valueOrError5 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _out0;
      _out0 = (_9_head).GetAlgorithmSuite((config).dtor_materialProviders);
      _10_valueOrError5 = _out0;
      if ((_10_valueOrError5).IsFailure()) {
        output = (_10_valueOrError5).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput>();
        return output;
      }
      software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _11_headerAlgorithmSuite;
      _11_headerAlgorithmSuite = (_10_valueOrError5).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _12_valueOrError6 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
      _12_valueOrError6 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(StructuredEncryptionUtil_Compile.__default.ValidString((input).dtor_tableName), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Bad Table Name")));
      if ((_12_valueOrError6).IsFailure()) {
        output = (_12_valueOrError6).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput>();
        return output;
      }
      Wrappers_Compile._IResult<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _13_valueOrError7 = Wrappers_Compile.Result<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(Dafny.Sequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>.Empty);
      _13_valueOrError7 = Canonize_Compile.__default.ForDecrypt((input).dtor_tableName, (input).dtor_encryptedStructure, (_9_head).dtor_legend);
      if ((_13_valueOrError7).IsFailure()) {
        output = (_13_valueOrError7).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput>();
        return output;
      }
      Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> _14_canonData;
      _14_canonData = (_13_valueOrError7).Extract();
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _15_encryptionContext;
      _15_encryptionContext = Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>.UnwrapOr((input).dtor_encryptionContext, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements());
      software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager _16_cmm;
      _16_cmm = (input).dtor_cmm;
      if (((_9_head).dtor_version) == ((byte)(2))) {
        Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _17_valueOrError8 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty);
        Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _out1;
        _out1 = AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.__default.GetV2EncryptionContext(Canonize_Compile.__default.UnCanon(_14_canonData));
        _17_valueOrError8 = _out1;
        if ((_17_valueOrError8).IsFailure()) {
          output = (_17_valueOrError8).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput>();
          return output;
        }
        Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18_newEncryptionContext;
        _18_newEncryptionContext = (_17_valueOrError8).Extract();
        if ((new BigInteger((_18_newEncryptionContext).Count)).Sign != 0) {
          Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _19_valueOrError9 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
          _19_valueOrError9 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(Dafny.Set<Dafny.ISequence<byte>>.IsDisjointFrom((_15_encryptionContext).Keys, (_18_newEncryptionContext).Keys), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Internal Error - Structured Encryption encryption context overlaps with Item Encryptor encryption context.")));
          if ((_19_valueOrError9).IsFailure()) {
            output = (_19_valueOrError9).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput>();
            return output;
          }
          _15_encryptionContext = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Merge(_15_encryptionContext, _18_newEncryptionContext);
          Dafny.ISequence<Dafny.ISequence<byte>> _20_contextKeysX;
          _20_contextKeysX = SortedSets.__default.SetToOrderedSequence2<byte>((_18_newEncryptionContext).Keys, StructuredEncryptionUtil_Compile.__default.ByteLess);
          Dafny.ISequence<Dafny.ISequence<byte>> _21_contextKeys;
          _21_contextKeys = _20_contextKeysX;
          Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _22_cmmR;
          Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out2;
          _out2 = ((config).dtor_materialProviders).CreateRequiredEncryptionContextCMM(software.amazon.cryptography.materialproviders.internaldafny.types.CreateRequiredEncryptionContextCMMInput.create(Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager>.create_Some((input).dtor_cmm), Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>.create_None(), _21_contextKeys));
          _22_cmmR = _out2;
          Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _23_valueOrError10 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>);
          _23_valueOrError10 = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(_22_cmmR, ((System.Func<software.amazon.cryptography.materialproviders.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>)((_24_e) => {
            return software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.Error.create_AwsCryptographyMaterialProviders(_24_e);
          })));
          if ((_23_valueOrError10).IsFailure()) {
            output = (_23_valueOrError10).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput>();
            return output;
          }
          _16_cmm = (_23_valueOrError10).Extract();
        }
      }
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _25_matR;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out3;
      _out3 = (_16_cmm).DecryptMaterials(software.amazon.cryptography.materialproviders.internaldafny.types.DecryptMaterialsInput.create((_11_headerAlgorithmSuite).dtor_id, AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.__default.DBE__COMMITMENT__POLICY, (_9_head).dtor_dataKeys, (_9_head).dtor_encContext, Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>.create_Some(_15_encryptionContext)));
      _25_matR = _out3;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _26_valueOrError11 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>);
      _26_valueOrError11 = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(_25_matR, ((System.Func<software.amazon.cryptography.materialproviders.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>)((_27_e) => {
        return software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.Error.create_AwsCryptographyMaterialProviders(_27_e);
      })));
      if ((_26_valueOrError11).IsFailure()) {
        output = (_26_valueOrError11).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput>();
        return output;
      }
      software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptMaterialsOutput _28_matOutput;
      _28_matOutput = (_26_valueOrError11).Extract();
      software.amazon.cryptography.materialproviders.internaldafny.types._IDecryptionMaterials _29_mat;
      _29_mat = (_28_matOutput).dtor_decryptionMaterials;
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _30_valueOrError12 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
      _30_valueOrError12 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(StructuredEncryptionHeader_Compile.__default.ValidEncryptionContext((_29_mat).dtor_encryptionContext), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Bad encryption context")));
      if ((_30_valueOrError12).IsFailure()) {
        output = (_30_valueOrError12).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput>();
        return output;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _31_valueOrError13 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
      _31_valueOrError13 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(Materials_Compile.__default.DecryptionMaterialsWithPlaintextDataKey(_29_mat), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Encryption material has no key")));
      if ((_31_valueOrError13).IsFailure()) {
        output = (_31_valueOrError13).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput>();
        return output;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _32_valueOrError14 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default();
      _32_valueOrError14 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(StructuredEncryptionUtil_Compile.__default.ValidSuite((_29_mat).dtor_algorithmSuite), StructuredEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Invalid Algorithm Suite")));
      if ((_32_valueOrError14).IsFailure()) {
        output = (_32_valueOrError14).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput>();
        return output;
      }
      software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _33_postCMMAlg;
      _33_postCMMAlg = (_29_mat).dtor_algorithmSuite;
      Dafny.ISequence<byte> _34_key;
      _34_key = ((_29_mat).dtor_plaintextDataKey).dtor_value;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _35_valueOrError15 = default(Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>);
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _out4;
      _out4 = StructuredEncryptionCrypt_Compile.__default.GetCommitKey((config).dtor_primitives, _33_postCMMAlg, _34_key, (_9_head).dtor_msgID);
      _35_valueOrError15 = _out4;
      if ((_35_valueOrError15).IsFailure()) {
        output = (_35_valueOrError15).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput>();
        return output;
      }
      Dafny.ISequence<byte> _36_commitKey;
      _36_commitKey = (_35_valueOrError15).Extract();
      Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _37_valueOrError16 = Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(false);
      _37_valueOrError16 = (_9_head).verifyCommitment((config).dtor_primitives, _33_postCMMAlg, _36_commitKey, (_5_headerSerialized).dtor_value);
      if ((_37_valueOrError16).IsFailure()) {
        output = (_37_valueOrError16).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput>();
        return output;
      }
      bool _38_ok;
      _38_ok = (_37_valueOrError16).Extract();
      Wrappers_Compile._IResult<StructuredEncryptionFooter_Compile._IFooter, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _39_valueOrError17 = Wrappers_Compile.Result<StructuredEncryptionFooter_Compile._IFooter, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(StructuredEncryptionFooter_Compile.Footer.Default());
      _39_valueOrError17 = StructuredEncryptionFooter_Compile.__default.DeserializeFooter((_7_footerSerialized).dtor_value, ((_33_postCMMAlg).dtor_signature).is_ECDSA);
      if ((_39_valueOrError17).IsFailure()) {
        output = (_39_valueOrError17).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput>();
        return output;
      }
      StructuredEncryptionFooter_Compile._IFooter _40_footer;
      _40_footer = (_39_valueOrError17).Extract();
      Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _41_valueOrError18 = Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(false);
      Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _out5;
      _out5 = (_40_footer).validate((config).dtor_primitives, _29_mat, (_9_head).dtor_dataKeys, _14_canonData, (_5_headerSerialized).dtor_value);
      _41_valueOrError18 = _out5;
      if ((_41_valueOrError18).IsFailure()) {
        output = (_41_valueOrError18).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput>();
        return output;
      }
      bool _42___v0;
      _42___v0 = (_41_valueOrError18).Extract();
      Wrappers_Compile._IResult<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _43_valueOrError19 = Wrappers_Compile.Result<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(Dafny.Sequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>.Empty);
      Wrappers_Compile._IResult<Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _out6;
      _out6 = StructuredEncryptionCrypt_Compile.__default.Decrypt((config).dtor_primitives, _33_postCMMAlg, _34_key, _9_head, _14_canonData);
      _43_valueOrError19 = _out6;
      if ((_43_valueOrError19).IsFailure()) {
        output = (_43_valueOrError19).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput>();
        return output;
      }
      Dafny.ISequence<StructuredEncryptionUtil_Compile._ICanonCryptoItem> _44_decryptedItems;
      _44_decryptedItems = (_43_valueOrError19).Extract();
      Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> _45_largeResult;
      _45_largeResult = Canonize_Compile.__default.UnCanonDecrypt(_44_decryptedItems);
      Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoItem> _46_smallResult;
      _46_smallResult = Canonize_Compile.__default.RemoveHeaders(_45_largeResult);
      software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IParsedHeader _47_parsedHeader;
      _47_parsedHeader = software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.ParsedHeader.create(((_11_headerAlgorithmSuite).dtor_id).dtor_DBE, (_9_head).dtor_dataKeys, (_9_head).dtor_encContext, (_29_mat).dtor_encryptionContext);
      software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput _48_decryptOutput;
      _48_decryptOutput = software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.DecryptPathStructureOutput.create(_46_smallResult, _47_parsedHeader);
      output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(_48_decryptOutput);
      return output;
    }
    public static software.amazon.cryptography.materialproviders.internaldafny.types._ICommitmentPolicy DBE__COMMITMENT__POLICY { get {
      return software.amazon.cryptography.materialproviders.internaldafny.types.CommitmentPolicy.create_DBE(software.amazon.cryptography.materialproviders.internaldafny.types.DBECommitmentPolicy.create());
    } }
  }

  public interface _IConfig {
    bool is_Config { get; }
    software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient dtor_primitives { get; }
    software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient dtor_materialProviders { get; }
    _IConfig DowncastClone();
  }
  public class Config : _IConfig {
    public readonly software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient _primitives;
    public readonly software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient _materialProviders;
    public Config(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient primitives, software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient materialProviders) {
      this._primitives = primitives;
      this._materialProviders = materialProviders;
    }
    public _IConfig DowncastClone() {
      if (this is _IConfig dt) { return dt; }
      return new Config(_primitives, _materialProviders);
    }
    public override bool Equals(object other) {
      var oth = other as AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.Config;
      return oth != null && this._primitives == oth._primitives && this._materialProviders == oth._materialProviders;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._primitives));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._materialProviders));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations.Config.Config";
      s += "(";
      s += Dafny.Helpers.ToString(this._primitives);
      s += ", ";
      s += Dafny.Helpers.ToString(this._materialProviders);
      s += ")";
      return s;
    }
    private static readonly AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile._IConfig theDefault = create(default(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient), default(software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient));
    public static AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile._IConfig Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile._IConfig> _TYPE = new Dafny.TypeDescriptor<AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile._IConfig>(AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.Config.Default());
    public static Dafny.TypeDescriptor<AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile._IConfig> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IConfig create(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient primitives, software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient materialProviders) {
      return new Config(primitives, materialProviders);
    }
    public static _IConfig create_Config(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient primitives, software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient materialProviders) {
      return create(primitives, materialProviders);
    }
    public bool is_Config { get { return true; } }
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient dtor_primitives {
      get {
        return this._primitives;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient dtor_materialProviders {
      get {
        return this._materialProviders;
      }
    }
  }
} // end of namespace AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile
namespace software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny {

  public partial class __default {
    public static software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredEncryptionConfig DefaultStructuredEncryptionConfig() {
      return software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.StructuredEncryptionConfig.create();
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.StructuredEncryptionClient, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> StructuredEncryption(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredEncryptionConfig config)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.StructuredEncryptionClient, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> res = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.StructuredEncryptionClient, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.primitives.internaldafny.types._IError> _0_maybePrimitives;
      Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.primitives.internaldafny.types._IError> _out0;
      _out0 = software.amazon.cryptography.primitives.internaldafny.__default.AtomicPrimitives(software.amazon.cryptography.primitives.internaldafny.__default.DefaultCryptoConfig());
      _0_maybePrimitives = _out0;
      Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _1_valueOrError0 = default(Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>);
      _1_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(_0_maybePrimitives, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>)((_2_e) => {
        return software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.Error.create_AwsCryptographyPrimitives(_2_e);
      })));
      if ((_1_valueOrError0).IsFailure()) {
        res = (_1_valueOrError0).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.StructuredEncryptionClient>();
        return res;
      }
      software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient _3_primitives;
      _3_primitives = (_1_valueOrError0).Extract();
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _4_maybeMatProv;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out1;
      _out1 = software.amazon.cryptography.materialproviders.internaldafny.__default.MaterialProviders(software.amazon.cryptography.materialproviders.internaldafny.__default.DefaultMaterialProvidersConfig());
      _4_maybeMatProv = _out1;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _5_valueOrError1 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>);
      _5_valueOrError1 = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>(_4_maybeMatProv, ((System.Func<software.amazon.cryptography.materialproviders.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>)((_6_e) => {
        return software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.Error.create_AwsCryptographyMaterialProviders(_6_e);
      })));
      if ((_5_valueOrError1).IsFailure()) {
        res = (_5_valueOrError1).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.StructuredEncryptionClient>();
        return res;
      }
      software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient _7_matProv;
      _7_matProv = (_5_valueOrError1).Extract();
      software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.StructuredEncryptionClient _8_client;
      software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.StructuredEncryptionClient _nw0 = new software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.StructuredEncryptionClient();
      _nw0.__ctor(AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.Config.create(_3_primitives, _7_matProv));
      _8_client = _nw0;
      res = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.StructuredEncryptionClient, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(_8_client);
      return res;
      return res;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.IStructuredEncryptionClient, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> CreateSuccessOfClient(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.IStructuredEncryptionClient client) {
      return Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.IStructuredEncryptionClient, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Success(client);
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.IStructuredEncryptionClient, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> CreateFailureOfError(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError error) {
      return Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.IStructuredEncryptionClient, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.create_Failure(error);
    }
  }

  public partial class StructuredEncryptionClient : software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.IStructuredEncryptionClient {
    public StructuredEncryptionClient() {
      this._config = default(AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile._IConfig);
    }
    public void __ctor(AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile._IConfig config)
    {
      (this)._config = config;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> EncryptStructure(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.EncryptStructureOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.__default.EncryptStructure((this).config, input);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> DecryptStructure(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptStructureInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.DecryptStructureOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.__default.DecryptStructure((this).config, input);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> EncryptPathStructure(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.EncryptPathStructureOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptPathStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.__default.EncryptPathStructure((this).config, input);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> DecryptPathStructure(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.DecryptPathStructureOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptPathStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.__default.DecryptPathStructure((this).config, input);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IResolveAuthActionsOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> ResolveAuthActions(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IResolveAuthActionsInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IResolveAuthActionsOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IResolveAuthActionsOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.ResolveAuthActionsOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IResolveAuthActionsOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile.__default.ResolveAuthActions((this).config, input);
      output = _out0;
      return output;
    }
    public AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile._IConfig _config {get; set;}
    public AwsCryptographyDbEncryptionSdkStructuredEncryptionOperations_Compile._IConfig config { get {
      return this._config;
    } }
  }
} // end of namespace software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny
namespace software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types {

  public partial class __default {
    public static bool IsValid__BeaconBitLength(int x) {
      return ((1) <= (x)) && ((x) <= (63));
    }
    public static bool IsValid__BeaconVersionList(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconVersion> x) {
      return ((BigInteger.One) <= (new BigInteger((x).Count))) && ((new BigInteger((x).Count)) <= (BigInteger.One));
    }
    public static bool IsValid__Char(Dafny.ISequence<char> x) {
      return ((BigInteger.One) <= (new BigInteger((x).Count))) && ((new BigInteger((x).Count)) <= (BigInteger.One));
    }
    public static bool IsValid__CompoundBeaconList(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICompoundBeacon> x) {
      return (BigInteger.One) <= (new BigInteger((x).Count));
    }
    public static bool IsValid__ConstructorList(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructor> x) {
      return (BigInteger.One) <= (new BigInteger((x).Count));
    }
    public static bool IsValid__ConstructorPartList(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructorPart> x) {
      return (BigInteger.One) <= (new BigInteger((x).Count));
    }
    public static bool IsValid__EncryptedPartsList(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedPart> x) {
      return (BigInteger.One) <= (new BigInteger((x).Count));
    }
    public static bool IsValid__Prefix(Dafny.ISequence<char> x) {
      return (BigInteger.One) <= (new BigInteger((x).Count));
    }
    public static bool IsValid__SignedPartsList(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart> x) {
      return (BigInteger.One) <= (new BigInteger((x).Count));
    }
    public static bool IsValid__StandardBeaconList(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IStandardBeacon> x) {
      return (BigInteger.One) <= (new BigInteger((x).Count));
    }
    public static bool IsValid__TerminalLocation(Dafny.ISequence<char> x) {
      return (BigInteger.One) <= (new BigInteger((x).Count));
    }
    public static bool IsValid__VersionNumber(int x) {
      return (1) <= (x);
    }
    public static bool IsValid__VirtualFieldList(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualField> x) {
      return (BigInteger.One) <= (new BigInteger((x).Count));
    }
    public static bool IsValid__VirtualPartList(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualPart> x) {
      return (BigInteger.One) <= (new BigInteger((x).Count));
    }
    public static bool IsValid__VirtualTransformList(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualTransform> x) {
      return (BigInteger.One) <= (new BigInteger((x).Count));
    }
    public static bool IsDummySubsetType(BigInteger x) {
      return (x).Sign == 1;
    }
  }

  public interface _IDafnyCallEvent<I, O> {
    bool is_DafnyCallEvent { get; }
    I dtor_input { get; }
    O dtor_output { get; }
    _IDafnyCallEvent<__I, __O> DowncastClone<__I, __O>(Func<I, __I> converter0, Func<O, __O> converter1);
  }
  public class DafnyCallEvent<I, O> : _IDafnyCallEvent<I, O> {
    public readonly I _input;
    public readonly O _output;
    public DafnyCallEvent(I input, O output) {
      this._input = input;
      this._output = output;
    }
    public _IDafnyCallEvent<__I, __O> DowncastClone<__I, __O>(Func<I, __I> converter0, Func<O, __O> converter1) {
      if (this is _IDafnyCallEvent<__I, __O> dt) { return dt; }
      return new DafnyCallEvent<__I, __O>(converter0(_input), converter1(_output));
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.DafnyCallEvent<I, O>;
      return oth != null && object.Equals(this._input, oth._input) && object.Equals(this._output, oth._output);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._input));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._output));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.DafnyCallEvent.DafnyCallEvent";
      s += "(";
      s += Dafny.Helpers.ToString(this._input);
      s += ", ";
      s += Dafny.Helpers.ToString(this._output);
      s += ")";
      return s;
    }
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDafnyCallEvent<I, O> Default(I _default_I, O _default_O) {
      return create(_default_I, _default_O);
    }
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDafnyCallEvent<I, O>> _TypeDescriptor(Dafny.TypeDescriptor<I> _td_I, Dafny.TypeDescriptor<O> _td_O) {
      return new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDafnyCallEvent<I, O>>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.DafnyCallEvent<I, O>.Default(_td_I.Default(), _td_O.Default()));
    }
    public static _IDafnyCallEvent<I, O> create(I input, O output) {
      return new DafnyCallEvent<I, O>(input, output);
    }
    public static _IDafnyCallEvent<I, O> create_DafnyCallEvent(I input, O output) {
      return create(input, output);
    }
    public bool is_DafnyCallEvent { get { return true; } }
    public I dtor_input {
      get {
        return this._input;
      }
    }
    public O dtor_output {
      get {
        return this._output;
      }
    }
  }

  public interface _IAsSet {
    bool is_AsSet { get; }
    _IAsSet DowncastClone();
  }
  public class AsSet : _IAsSet {
    public AsSet() {
    }
    public _IAsSet DowncastClone() {
      if (this is _IAsSet dt) { return dt; }
      return new AsSet();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.AsSet;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.AsSet.AsSet";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IAsSet theDefault = create();
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IAsSet Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IAsSet> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IAsSet>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.AsSet.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IAsSet> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IAsSet create() {
      return new AsSet();
    }
    public static _IAsSet create_AsSet() {
      return create();
    }
    public bool is_AsSet { get { return true; } }
    public static System.Collections.Generic.IEnumerable<_IAsSet> AllSingletonConstructors {
      get {
        yield return AsSet.create();
      }
    }
  }

  public partial class BeaconBitLength {
    private static readonly Dafny.TypeDescriptor<int> _TYPE = new Dafny.TypeDescriptor<int>(0);
    public static Dafny.TypeDescriptor<int> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(int __source) {
      int _0_x = (int)(__source);
      if (true) {
        return software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.__default.IsValid__BeaconBitLength(_0_x);
      }
      return false;
    }
  }

  public interface _IBeaconKeySource {
    bool is_single { get; }
    bool is_multi { get; }
    software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISingleKeyStore dtor_single { get; }
    software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IMultiKeyStore dtor_multi { get; }
    _IBeaconKeySource DowncastClone();
  }
  public abstract class BeaconKeySource : _IBeaconKeySource {
    public BeaconKeySource() {
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconKeySource theDefault = create_single(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.SingleKeyStore.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconKeySource Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconKeySource> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconKeySource>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.BeaconKeySource.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconKeySource> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IBeaconKeySource create_single(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISingleKeyStore single) {
      return new BeaconKeySource_single(single);
    }
    public static _IBeaconKeySource create_multi(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IMultiKeyStore multi) {
      return new BeaconKeySource_multi(multi);
    }
    public bool is_single { get { return this is BeaconKeySource_single; } }
    public bool is_multi { get { return this is BeaconKeySource_multi; } }
    public software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISingleKeyStore dtor_single {
      get {
        var d = this;
        return ((BeaconKeySource_single)d)._single;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IMultiKeyStore dtor_multi {
      get {
        var d = this;
        return ((BeaconKeySource_multi)d)._multi;
      }
    }
    public abstract _IBeaconKeySource DowncastClone();
  }
  public class BeaconKeySource_single : BeaconKeySource {
    public readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISingleKeyStore _single;
    public BeaconKeySource_single(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISingleKeyStore single) : base() {
      this._single = single;
    }
    public override _IBeaconKeySource DowncastClone() {
      if (this is _IBeaconKeySource dt) { return dt; }
      return new BeaconKeySource_single(_single);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.BeaconKeySource_single;
      return oth != null && object.Equals(this._single, oth._single);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._single));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.BeaconKeySource.single";
      s += "(";
      s += Dafny.Helpers.ToString(this._single);
      s += ")";
      return s;
    }
  }
  public class BeaconKeySource_multi : BeaconKeySource {
    public readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IMultiKeyStore _multi;
    public BeaconKeySource_multi(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IMultiKeyStore multi) : base() {
      this._multi = multi;
    }
    public override _IBeaconKeySource DowncastClone() {
      if (this is _IBeaconKeySource dt) { return dt; }
      return new BeaconKeySource_multi(_multi);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.BeaconKeySource_multi;
      return oth != null && object.Equals(this._multi, oth._multi);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._multi));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.BeaconKeySource.multi";
      s += "(";
      s += Dafny.Helpers.ToString(this._multi);
      s += ")";
      return s;
    }
  }

  public interface _IBeaconStyle {
    bool is_partOnly { get; }
    bool is_shared { get; }
    bool is_asSet { get; }
    bool is_sharedSet { get; }
    software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPartOnly dtor_partOnly { get; }
    software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IShared dtor_shared { get; }
    software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IAsSet dtor_asSet { get; }
    software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISharedSet dtor_sharedSet { get; }
    _IBeaconStyle DowncastClone();
  }
  public abstract class BeaconStyle : _IBeaconStyle {
    public BeaconStyle() {
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconStyle theDefault = create_partOnly(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.PartOnly.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconStyle Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconStyle> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconStyle>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.BeaconStyle.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconStyle> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IBeaconStyle create_partOnly(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPartOnly partOnly) {
      return new BeaconStyle_partOnly(partOnly);
    }
    public static _IBeaconStyle create_shared(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IShared shared) {
      return new BeaconStyle_shared(shared);
    }
    public static _IBeaconStyle create_asSet(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IAsSet asSet) {
      return new BeaconStyle_asSet(asSet);
    }
    public static _IBeaconStyle create_sharedSet(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISharedSet sharedSet) {
      return new BeaconStyle_sharedSet(sharedSet);
    }
    public bool is_partOnly { get { return this is BeaconStyle_partOnly; } }
    public bool is_shared { get { return this is BeaconStyle_shared; } }
    public bool is_asSet { get { return this is BeaconStyle_asSet; } }
    public bool is_sharedSet { get { return this is BeaconStyle_sharedSet; } }
    public software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPartOnly dtor_partOnly {
      get {
        var d = this;
        return ((BeaconStyle_partOnly)d)._partOnly;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IShared dtor_shared {
      get {
        var d = this;
        return ((BeaconStyle_shared)d)._shared;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IAsSet dtor_asSet {
      get {
        var d = this;
        return ((BeaconStyle_asSet)d)._asSet;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISharedSet dtor_sharedSet {
      get {
        var d = this;
        return ((BeaconStyle_sharedSet)d)._sharedSet;
      }
    }
    public abstract _IBeaconStyle DowncastClone();
  }
  public class BeaconStyle_partOnly : BeaconStyle {
    public readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPartOnly _partOnly;
    public BeaconStyle_partOnly(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPartOnly partOnly) : base() {
      this._partOnly = partOnly;
    }
    public override _IBeaconStyle DowncastClone() {
      if (this is _IBeaconStyle dt) { return dt; }
      return new BeaconStyle_partOnly(_partOnly);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.BeaconStyle_partOnly;
      return oth != null && object.Equals(this._partOnly, oth._partOnly);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._partOnly));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.BeaconStyle.partOnly";
      s += "(";
      s += Dafny.Helpers.ToString(this._partOnly);
      s += ")";
      return s;
    }
  }
  public class BeaconStyle_shared : BeaconStyle {
    public readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IShared _shared;
    public BeaconStyle_shared(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IShared shared) : base() {
      this._shared = shared;
    }
    public override _IBeaconStyle DowncastClone() {
      if (this is _IBeaconStyle dt) { return dt; }
      return new BeaconStyle_shared(_shared);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.BeaconStyle_shared;
      return oth != null && object.Equals(this._shared, oth._shared);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._shared));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.BeaconStyle.shared";
      s += "(";
      s += Dafny.Helpers.ToString(this._shared);
      s += ")";
      return s;
    }
  }
  public class BeaconStyle_asSet : BeaconStyle {
    public readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IAsSet _asSet;
    public BeaconStyle_asSet(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IAsSet asSet) : base() {
      this._asSet = asSet;
    }
    public override _IBeaconStyle DowncastClone() {
      if (this is _IBeaconStyle dt) { return dt; }
      return new BeaconStyle_asSet(_asSet);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.BeaconStyle_asSet;
      return oth != null && object.Equals(this._asSet, oth._asSet);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._asSet));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.BeaconStyle.asSet";
      s += "(";
      s += Dafny.Helpers.ToString(this._asSet);
      s += ")";
      return s;
    }
  }
  public class BeaconStyle_sharedSet : BeaconStyle {
    public readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISharedSet _sharedSet;
    public BeaconStyle_sharedSet(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISharedSet sharedSet) : base() {
      this._sharedSet = sharedSet;
    }
    public override _IBeaconStyle DowncastClone() {
      if (this is _IBeaconStyle dt) { return dt; }
      return new BeaconStyle_sharedSet(_sharedSet);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.BeaconStyle_sharedSet;
      return oth != null && object.Equals(this._sharedSet, oth._sharedSet);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 3;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sharedSet));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.BeaconStyle.sharedSet";
      s += "(";
      s += Dafny.Helpers.ToString(this._sharedSet);
      s += ")";
      return s;
    }
  }

  public interface _IBeaconVersion {
    bool is_BeaconVersion { get; }
    int dtor_version { get; }
    software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient dtor_keyStore { get; }
    software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconKeySource dtor_keySource { get; }
    Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IStandardBeacon> dtor_standardBeacons { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICompoundBeacon>> dtor_compoundBeacons { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualField>> dtor_virtualFields { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedPart>> dtor_encryptedParts { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart>> dtor_signedParts { get; }
    _IBeaconVersion DowncastClone();
  }
  public class BeaconVersion : _IBeaconVersion {
    public readonly int _version;
    public readonly software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient _keyStore;
    public readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconKeySource _keySource;
    public readonly Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IStandardBeacon> _standardBeacons;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICompoundBeacon>> _compoundBeacons;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualField>> _virtualFields;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedPart>> _encryptedParts;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart>> _signedParts;
    public BeaconVersion(int version, software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient keyStore, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconKeySource keySource, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IStandardBeacon> standardBeacons, Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICompoundBeacon>> compoundBeacons, Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualField>> virtualFields, Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedPart>> encryptedParts, Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart>> signedParts) {
      this._version = version;
      this._keyStore = keyStore;
      this._keySource = keySource;
      this._standardBeacons = standardBeacons;
      this._compoundBeacons = compoundBeacons;
      this._virtualFields = virtualFields;
      this._encryptedParts = encryptedParts;
      this._signedParts = signedParts;
    }
    public _IBeaconVersion DowncastClone() {
      if (this is _IBeaconVersion dt) { return dt; }
      return new BeaconVersion(_version, _keyStore, _keySource, _standardBeacons, _compoundBeacons, _virtualFields, _encryptedParts, _signedParts);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.BeaconVersion;
      return oth != null && this._version == oth._version && this._keyStore == oth._keyStore && object.Equals(this._keySource, oth._keySource) && object.Equals(this._standardBeacons, oth._standardBeacons) && object.Equals(this._compoundBeacons, oth._compoundBeacons) && object.Equals(this._virtualFields, oth._virtualFields) && object.Equals(this._encryptedParts, oth._encryptedParts) && object.Equals(this._signedParts, oth._signedParts);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._version));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._keyStore));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._keySource));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._standardBeacons));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._compoundBeacons));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._virtualFields));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptedParts));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._signedParts));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.BeaconVersion.BeaconVersion";
      s += "(";
      s += Dafny.Helpers.ToString(this._version);
      s += ", ";
      s += Dafny.Helpers.ToString(this._keyStore);
      s += ", ";
      s += Dafny.Helpers.ToString(this._keySource);
      s += ", ";
      s += Dafny.Helpers.ToString(this._standardBeacons);
      s += ", ";
      s += Dafny.Helpers.ToString(this._compoundBeacons);
      s += ", ";
      s += Dafny.Helpers.ToString(this._virtualFields);
      s += ", ";
      s += Dafny.Helpers.ToString(this._encryptedParts);
      s += ", ";
      s += Dafny.Helpers.ToString(this._signedParts);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconVersion theDefault = create(0, default(software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient), software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.BeaconKeySource.Default(), Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IStandardBeacon>.Empty, Wrappers_Compile.Option<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICompoundBeacon>>.Default(), Wrappers_Compile.Option<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualField>>.Default(), Wrappers_Compile.Option<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedPart>>.Default(), Wrappers_Compile.Option<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart>>.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconVersion Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconVersion> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconVersion>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.BeaconVersion.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconVersion> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IBeaconVersion create(int version, software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient keyStore, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconKeySource keySource, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IStandardBeacon> standardBeacons, Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICompoundBeacon>> compoundBeacons, Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualField>> virtualFields, Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedPart>> encryptedParts, Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart>> signedParts) {
      return new BeaconVersion(version, keyStore, keySource, standardBeacons, compoundBeacons, virtualFields, encryptedParts, signedParts);
    }
    public static _IBeaconVersion create_BeaconVersion(int version, software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient keyStore, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconKeySource keySource, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IStandardBeacon> standardBeacons, Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICompoundBeacon>> compoundBeacons, Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualField>> virtualFields, Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedPart>> encryptedParts, Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart>> signedParts) {
      return create(version, keyStore, keySource, standardBeacons, compoundBeacons, virtualFields, encryptedParts, signedParts);
    }
    public bool is_BeaconVersion { get { return true; } }
    public int dtor_version {
      get {
        return this._version;
      }
    }
    public software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient dtor_keyStore {
      get {
        return this._keyStore;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconKeySource dtor_keySource {
      get {
        return this._keySource;
      }
    }
    public Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IStandardBeacon> dtor_standardBeacons {
      get {
        return this._standardBeacons;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICompoundBeacon>> dtor_compoundBeacons {
      get {
        return this._compoundBeacons;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualField>> dtor_virtualFields {
      get {
        return this._virtualFields;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedPart>> dtor_encryptedParts {
      get {
        return this._encryptedParts;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart>> dtor_signedParts {
      get {
        return this._signedParts;
      }
    }
  }

  public partial class BeaconVersionList {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconVersion>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconVersion>>(Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconVersion>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconVersion>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconVersion> __source) {
      Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconVersion> _1_x = __source;
      return software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.__default.IsValid__BeaconVersionList(_1_x);
    }
  }

  public partial class Char {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<char>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<char>>(Dafny.Sequence<char>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<char>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.ISequence<char> __source) {
      Dafny.ISequence<char> _2_x = __source;
      return software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.__default.IsValid__Char(_2_x);
    }
  }

  public interface _ICompoundBeacon {
    bool is_CompoundBeacon { get; }
    Dafny.ISequence<char> dtor_name { get; }
    Dafny.ISequence<char> dtor_split { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedPart>> dtor_encrypted { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart>> dtor_signed { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructor>> dtor_constructors { get; }
    _ICompoundBeacon DowncastClone();
  }
  public class CompoundBeacon : _ICompoundBeacon {
    public readonly Dafny.ISequence<char> _name;
    public readonly Dafny.ISequence<char> _split;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedPart>> _encrypted;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart>> _signed;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructor>> _constructors;
    public CompoundBeacon(Dafny.ISequence<char> name, Dafny.ISequence<char> split, Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedPart>> encrypted, Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart>> signed, Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructor>> constructors) {
      this._name = name;
      this._split = split;
      this._encrypted = encrypted;
      this._signed = signed;
      this._constructors = constructors;
    }
    public _ICompoundBeacon DowncastClone() {
      if (this is _ICompoundBeacon dt) { return dt; }
      return new CompoundBeacon(_name, _split, _encrypted, _signed, _constructors);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.CompoundBeacon;
      return oth != null && object.Equals(this._name, oth._name) && object.Equals(this._split, oth._split) && object.Equals(this._encrypted, oth._encrypted) && object.Equals(this._signed, oth._signed) && object.Equals(this._constructors, oth._constructors);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._name));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._split));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encrypted));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._signed));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._constructors));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.CompoundBeacon.CompoundBeacon";
      s += "(";
      s += Dafny.Helpers.ToString(this._name);
      s += ", ";
      s += Dafny.Helpers.ToString(this._split);
      s += ", ";
      s += Dafny.Helpers.ToString(this._encrypted);
      s += ", ";
      s += Dafny.Helpers.ToString(this._signed);
      s += ", ";
      s += Dafny.Helpers.ToString(this._constructors);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICompoundBeacon theDefault = create(Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty, Wrappers_Compile.Option<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedPart>>.Default(), Wrappers_Compile.Option<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart>>.Default(), Wrappers_Compile.Option<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructor>>.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICompoundBeacon Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICompoundBeacon> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICompoundBeacon>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.CompoundBeacon.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICompoundBeacon> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICompoundBeacon create(Dafny.ISequence<char> name, Dafny.ISequence<char> split, Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedPart>> encrypted, Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart>> signed, Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructor>> constructors) {
      return new CompoundBeacon(name, split, encrypted, signed, constructors);
    }
    public static _ICompoundBeacon create_CompoundBeacon(Dafny.ISequence<char> name, Dafny.ISequence<char> split, Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedPart>> encrypted, Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart>> signed, Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructor>> constructors) {
      return create(name, split, encrypted, signed, constructors);
    }
    public bool is_CompoundBeacon { get { return true; } }
    public Dafny.ISequence<char> dtor_name {
      get {
        return this._name;
      }
    }
    public Dafny.ISequence<char> dtor_split {
      get {
        return this._split;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedPart>> dtor_encrypted {
      get {
        return this._encrypted;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart>> dtor_signed {
      get {
        return this._signed;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructor>> dtor_constructors {
      get {
        return this._constructors;
      }
    }
  }

  public partial class CompoundBeaconList {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICompoundBeacon>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICompoundBeacon>>(Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICompoundBeacon>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICompoundBeacon>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICompoundBeacon> __source) {
      Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICompoundBeacon> _3_x = __source;
      return software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.__default.IsValid__CompoundBeaconList(_3_x);
    }
  }

  public interface _IConstructor {
    bool is_Constructor { get; }
    Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructorPart> dtor_parts { get; }
    _IConstructor DowncastClone();
  }
  public class Constructor : _IConstructor {
    public readonly Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructorPart> _parts;
    public Constructor(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructorPart> parts) {
      this._parts = parts;
    }
    public _IConstructor DowncastClone() {
      if (this is _IConstructor dt) { return dt; }
      return new Constructor(_parts);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Constructor;
      return oth != null && object.Equals(this._parts, oth._parts);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._parts));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.Constructor.Constructor";
      s += "(";
      s += Dafny.Helpers.ToString(this._parts);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructor theDefault = create(Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructorPart>.Empty);
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructor Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructor> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructor>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Constructor.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructor> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IConstructor create(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructorPart> parts) {
      return new Constructor(parts);
    }
    public static _IConstructor create_Constructor(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructorPart> parts) {
      return create(parts);
    }
    public bool is_Constructor { get { return true; } }
    public Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructorPart> dtor_parts {
      get {
        return this._parts;
      }
    }
  }

  public partial class ConstructorList {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructor>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructor>>(Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructor>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructor>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructor> __source) {
      Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructor> _4_x = __source;
      return software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.__default.IsValid__ConstructorList(_4_x);
    }
  }

  public interface _IConstructorPart {
    bool is_ConstructorPart { get; }
    Dafny.ISequence<char> dtor_name { get; }
    bool dtor_required { get; }
    _IConstructorPart DowncastClone();
  }
  public class ConstructorPart : _IConstructorPart {
    public readonly Dafny.ISequence<char> _name;
    public readonly bool _required;
    public ConstructorPart(Dafny.ISequence<char> name, bool required) {
      this._name = name;
      this._required = required;
    }
    public _IConstructorPart DowncastClone() {
      if (this is _IConstructorPart dt) { return dt; }
      return new ConstructorPart(_name, _required);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.ConstructorPart;
      return oth != null && object.Equals(this._name, oth._name) && this._required == oth._required;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._name));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._required));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.ConstructorPart.ConstructorPart";
      s += "(";
      s += Dafny.Helpers.ToString(this._name);
      s += ", ";
      s += Dafny.Helpers.ToString(this._required);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructorPart theDefault = create(Dafny.Sequence<char>.Empty, false);
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructorPart Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructorPart> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructorPart>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.ConstructorPart.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructorPart> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IConstructorPart create(Dafny.ISequence<char> name, bool required) {
      return new ConstructorPart(name, required);
    }
    public static _IConstructorPart create_ConstructorPart(Dafny.ISequence<char> name, bool required) {
      return create(name, required);
    }
    public bool is_ConstructorPart { get { return true; } }
    public Dafny.ISequence<char> dtor_name {
      get {
        return this._name;
      }
    }
    public bool dtor_required {
      get {
        return this._required;
      }
    }
  }

  public partial class ConstructorPartList {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructorPart>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructorPart>>(Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructorPart>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructorPart>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructorPart> __source) {
      Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructorPart> _5_x = __source;
      return software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.__default.IsValid__ConstructorPartList(_5_x);
    }
  }

  public interface _ICreateDynamoDbEncryptionBranchKeyIdSupplierInput {
    bool is_CreateDynamoDbEncryptionBranchKeyIdSupplierInput { get; }
    software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.IDynamoDbKeyBranchKeyIdSupplier dtor_ddbKeyBranchKeyIdSupplier { get; }
    _ICreateDynamoDbEncryptionBranchKeyIdSupplierInput DowncastClone();
  }
  public class CreateDynamoDbEncryptionBranchKeyIdSupplierInput : _ICreateDynamoDbEncryptionBranchKeyIdSupplierInput {
    public readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.IDynamoDbKeyBranchKeyIdSupplier _ddbKeyBranchKeyIdSupplier;
    public CreateDynamoDbEncryptionBranchKeyIdSupplierInput(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.IDynamoDbKeyBranchKeyIdSupplier ddbKeyBranchKeyIdSupplier) {
      this._ddbKeyBranchKeyIdSupplier = ddbKeyBranchKeyIdSupplier;
    }
    public _ICreateDynamoDbEncryptionBranchKeyIdSupplierInput DowncastClone() {
      if (this is _ICreateDynamoDbEncryptionBranchKeyIdSupplierInput dt) { return dt; }
      return new CreateDynamoDbEncryptionBranchKeyIdSupplierInput(_ddbKeyBranchKeyIdSupplier);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.CreateDynamoDbEncryptionBranchKeyIdSupplierInput;
      return oth != null && this._ddbKeyBranchKeyIdSupplier == oth._ddbKeyBranchKeyIdSupplier;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._ddbKeyBranchKeyIdSupplier));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.CreateDynamoDbEncryptionBranchKeyIdSupplierInput.CreateDynamoDbEncryptionBranchKeyIdSupplierInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._ddbKeyBranchKeyIdSupplier);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICreateDynamoDbEncryptionBranchKeyIdSupplierInput theDefault = create(default(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.IDynamoDbKeyBranchKeyIdSupplier));
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICreateDynamoDbEncryptionBranchKeyIdSupplierInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICreateDynamoDbEncryptionBranchKeyIdSupplierInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICreateDynamoDbEncryptionBranchKeyIdSupplierInput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.CreateDynamoDbEncryptionBranchKeyIdSupplierInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICreateDynamoDbEncryptionBranchKeyIdSupplierInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICreateDynamoDbEncryptionBranchKeyIdSupplierInput create(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.IDynamoDbKeyBranchKeyIdSupplier ddbKeyBranchKeyIdSupplier) {
      return new CreateDynamoDbEncryptionBranchKeyIdSupplierInput(ddbKeyBranchKeyIdSupplier);
    }
    public static _ICreateDynamoDbEncryptionBranchKeyIdSupplierInput create_CreateDynamoDbEncryptionBranchKeyIdSupplierInput(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.IDynamoDbKeyBranchKeyIdSupplier ddbKeyBranchKeyIdSupplier) {
      return create(ddbKeyBranchKeyIdSupplier);
    }
    public bool is_CreateDynamoDbEncryptionBranchKeyIdSupplierInput { get { return true; } }
    public software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.IDynamoDbKeyBranchKeyIdSupplier dtor_ddbKeyBranchKeyIdSupplier {
      get {
        return this._ddbKeyBranchKeyIdSupplier;
      }
    }
  }

  public interface _ICreateDynamoDbEncryptionBranchKeyIdSupplierOutput {
    bool is_CreateDynamoDbEncryptionBranchKeyIdSupplierOutput { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types.IBranchKeyIdSupplier dtor_branchKeyIdSupplier { get; }
    _ICreateDynamoDbEncryptionBranchKeyIdSupplierOutput DowncastClone();
  }
  public class CreateDynamoDbEncryptionBranchKeyIdSupplierOutput : _ICreateDynamoDbEncryptionBranchKeyIdSupplierOutput {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types.IBranchKeyIdSupplier _branchKeyIdSupplier;
    public CreateDynamoDbEncryptionBranchKeyIdSupplierOutput(software.amazon.cryptography.materialproviders.internaldafny.types.IBranchKeyIdSupplier branchKeyIdSupplier) {
      this._branchKeyIdSupplier = branchKeyIdSupplier;
    }
    public _ICreateDynamoDbEncryptionBranchKeyIdSupplierOutput DowncastClone() {
      if (this is _ICreateDynamoDbEncryptionBranchKeyIdSupplierOutput dt) { return dt; }
      return new CreateDynamoDbEncryptionBranchKeyIdSupplierOutput(_branchKeyIdSupplier);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.CreateDynamoDbEncryptionBranchKeyIdSupplierOutput;
      return oth != null && this._branchKeyIdSupplier == oth._branchKeyIdSupplier;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._branchKeyIdSupplier));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.CreateDynamoDbEncryptionBranchKeyIdSupplierOutput.CreateDynamoDbEncryptionBranchKeyIdSupplierOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._branchKeyIdSupplier);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICreateDynamoDbEncryptionBranchKeyIdSupplierOutput theDefault = create(default(software.amazon.cryptography.materialproviders.internaldafny.types.IBranchKeyIdSupplier));
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICreateDynamoDbEncryptionBranchKeyIdSupplierOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICreateDynamoDbEncryptionBranchKeyIdSupplierOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICreateDynamoDbEncryptionBranchKeyIdSupplierOutput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.CreateDynamoDbEncryptionBranchKeyIdSupplierOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICreateDynamoDbEncryptionBranchKeyIdSupplierOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICreateDynamoDbEncryptionBranchKeyIdSupplierOutput create(software.amazon.cryptography.materialproviders.internaldafny.types.IBranchKeyIdSupplier branchKeyIdSupplier) {
      return new CreateDynamoDbEncryptionBranchKeyIdSupplierOutput(branchKeyIdSupplier);
    }
    public static _ICreateDynamoDbEncryptionBranchKeyIdSupplierOutput create_CreateDynamoDbEncryptionBranchKeyIdSupplierOutput(software.amazon.cryptography.materialproviders.internaldafny.types.IBranchKeyIdSupplier branchKeyIdSupplier) {
      return create(branchKeyIdSupplier);
    }
    public bool is_CreateDynamoDbEncryptionBranchKeyIdSupplierOutput { get { return true; } }
    public software.amazon.cryptography.materialproviders.internaldafny.types.IBranchKeyIdSupplier dtor_branchKeyIdSupplier {
      get {
        return this._branchKeyIdSupplier;
      }
    }
  }

  public partial class IDynamoDbEncryptionClientCallHistory {
    public IDynamoDbEncryptionClientCallHistory() {
    }
  }

  public interface IDynamoDbEncryptionClient {
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICreateDynamoDbEncryptionBranchKeyIdSupplierOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> CreateDynamoDbEncryptionBranchKeyIdSupplier(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICreateDynamoDbEncryptionBranchKeyIdSupplierInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetEncryptedDataKeyDescription(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionInput input);
  }
  public class _Companion_IDynamoDbEncryptionClient {
  }

  public interface _IDynamoDbEncryptionConfig {
    bool is_DynamoDbEncryptionConfig { get; }
    _IDynamoDbEncryptionConfig DowncastClone();
  }
  public class DynamoDbEncryptionConfig : _IDynamoDbEncryptionConfig {
    public DynamoDbEncryptionConfig() {
    }
    public _IDynamoDbEncryptionConfig DowncastClone() {
      if (this is _IDynamoDbEncryptionConfig dt) { return dt; }
      return new DynamoDbEncryptionConfig();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.DynamoDbEncryptionConfig;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.DynamoDbEncryptionConfig.DynamoDbEncryptionConfig";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbEncryptionConfig theDefault = create();
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbEncryptionConfig Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbEncryptionConfig> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbEncryptionConfig>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.DynamoDbEncryptionConfig.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbEncryptionConfig> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IDynamoDbEncryptionConfig create() {
      return new DynamoDbEncryptionConfig();
    }
    public static _IDynamoDbEncryptionConfig create_DynamoDbEncryptionConfig() {
      return create();
    }
    public bool is_DynamoDbEncryptionConfig { get { return true; } }
    public static System.Collections.Generic.IEnumerable<_IDynamoDbEncryptionConfig> AllSingletonConstructors {
      get {
        yield return DynamoDbEncryptionConfig.create();
      }
    }
  }

  public partial class IDynamoDbKeyBranchKeyIdSupplierCallHistory {
    public IDynamoDbKeyBranchKeyIdSupplierCallHistory() {
    }
  }

  public interface IDynamoDbKeyBranchKeyIdSupplier {
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetBranchKeyIdFromDdbKeyOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetBranchKeyIdFromDdbKey(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetBranchKeyIdFromDdbKeyInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetBranchKeyIdFromDdbKeyOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetBranchKeyIdFromDdbKey_k(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetBranchKeyIdFromDdbKeyInput input);
  }
  public class _Companion_IDynamoDbKeyBranchKeyIdSupplier {
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetBranchKeyIdFromDdbKeyOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetBranchKeyIdFromDdbKey(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.IDynamoDbKeyBranchKeyIdSupplier _this, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetBranchKeyIdFromDdbKeyInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetBranchKeyIdFromDdbKeyOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetBranchKeyIdFromDdbKeyOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.GetBranchKeyIdFromDdbKeyOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetBranchKeyIdFromDdbKeyOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
      _out0 = (_this).GetBranchKeyIdFromDdbKey_k(input);
      output = _out0;
      return output;
    }
  }

  public interface _IDynamoDbTableEncryptionConfig {
    bool is_DynamoDbTableEncryptionConfig { get; }
    Dafny.ISequence<char> dtor_logicalTableName { get; }
    Dafny.ISequence<char> dtor_partitionKeyName { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_sortKeyName { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISearchConfig> dtor_search { get; }
    Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> dtor_attributeActionsOnEncrypt { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> dtor_allowedUnsignedAttributes { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_allowedUnsignedAttributePrefix { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> dtor_algorithmSuiteId { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> dtor_keyring { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager> dtor_cmm { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILegacyOverride> dtor_legacyOverride { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride> dtor_plaintextOverride { get; }
    _IDynamoDbTableEncryptionConfig DowncastClone();
  }
  public class DynamoDbTableEncryptionConfig : _IDynamoDbTableEncryptionConfig {
    public readonly Dafny.ISequence<char> _logicalTableName;
    public readonly Dafny.ISequence<char> _partitionKeyName;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<char>> _sortKeyName;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISearchConfig> _search;
    public readonly Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> _attributeActionsOnEncrypt;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> _allowedUnsignedAttributes;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<char>> _allowedUnsignedAttributePrefix;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> _algorithmSuiteId;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> _keyring;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager> _cmm;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILegacyOverride> _legacyOverride;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride> _plaintextOverride;
    public DynamoDbTableEncryptionConfig(Dafny.ISequence<char> logicalTableName, Dafny.ISequence<char> partitionKeyName, Wrappers_Compile._IOption<Dafny.ISequence<char>> sortKeyName, Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISearchConfig> search, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> attributeActionsOnEncrypt, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> allowedUnsignedAttributes, Wrappers_Compile._IOption<Dafny.ISequence<char>> allowedUnsignedAttributePrefix, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> algorithmSuiteId, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> keyring, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager> cmm, Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILegacyOverride> legacyOverride, Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride> plaintextOverride) {
      this._logicalTableName = logicalTableName;
      this._partitionKeyName = partitionKeyName;
      this._sortKeyName = sortKeyName;
      this._search = search;
      this._attributeActionsOnEncrypt = attributeActionsOnEncrypt;
      this._allowedUnsignedAttributes = allowedUnsignedAttributes;
      this._allowedUnsignedAttributePrefix = allowedUnsignedAttributePrefix;
      this._algorithmSuiteId = algorithmSuiteId;
      this._keyring = keyring;
      this._cmm = cmm;
      this._legacyOverride = legacyOverride;
      this._plaintextOverride = plaintextOverride;
    }
    public _IDynamoDbTableEncryptionConfig DowncastClone() {
      if (this is _IDynamoDbTableEncryptionConfig dt) { return dt; }
      return new DynamoDbTableEncryptionConfig(_logicalTableName, _partitionKeyName, _sortKeyName, _search, _attributeActionsOnEncrypt, _allowedUnsignedAttributes, _allowedUnsignedAttributePrefix, _algorithmSuiteId, _keyring, _cmm, _legacyOverride, _plaintextOverride);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.DynamoDbTableEncryptionConfig;
      return oth != null && object.Equals(this._logicalTableName, oth._logicalTableName) && object.Equals(this._partitionKeyName, oth._partitionKeyName) && object.Equals(this._sortKeyName, oth._sortKeyName) && object.Equals(this._search, oth._search) && object.Equals(this._attributeActionsOnEncrypt, oth._attributeActionsOnEncrypt) && object.Equals(this._allowedUnsignedAttributes, oth._allowedUnsignedAttributes) && object.Equals(this._allowedUnsignedAttributePrefix, oth._allowedUnsignedAttributePrefix) && object.Equals(this._algorithmSuiteId, oth._algorithmSuiteId) && object.Equals(this._keyring, oth._keyring) && object.Equals(this._cmm, oth._cmm) && object.Equals(this._legacyOverride, oth._legacyOverride) && object.Equals(this._plaintextOverride, oth._plaintextOverride);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._logicalTableName));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._partitionKeyName));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sortKeyName));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._search));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._attributeActionsOnEncrypt));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._allowedUnsignedAttributes));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._allowedUnsignedAttributePrefix));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._algorithmSuiteId));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._keyring));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._cmm));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._legacyOverride));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._plaintextOverride));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.DynamoDbTableEncryptionConfig.DynamoDbTableEncryptionConfig";
      s += "(";
      s += Dafny.Helpers.ToString(this._logicalTableName);
      s += ", ";
      s += Dafny.Helpers.ToString(this._partitionKeyName);
      s += ", ";
      s += Dafny.Helpers.ToString(this._sortKeyName);
      s += ", ";
      s += Dafny.Helpers.ToString(this._search);
      s += ", ";
      s += Dafny.Helpers.ToString(this._attributeActionsOnEncrypt);
      s += ", ";
      s += Dafny.Helpers.ToString(this._allowedUnsignedAttributes);
      s += ", ";
      s += Dafny.Helpers.ToString(this._allowedUnsignedAttributePrefix);
      s += ", ";
      s += Dafny.Helpers.ToString(this._algorithmSuiteId);
      s += ", ";
      s += Dafny.Helpers.ToString(this._keyring);
      s += ", ";
      s += Dafny.Helpers.ToString(this._cmm);
      s += ", ";
      s += Dafny.Helpers.ToString(this._legacyOverride);
      s += ", ";
      s += Dafny.Helpers.ToString(this._plaintextOverride);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig theDefault = create(Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty, Wrappers_Compile.Option<Dafny.ISequence<char>>.Default(), Wrappers_Compile.Option<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISearchConfig>.Default(), Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Empty, Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.Default(), Wrappers_Compile.Option<Dafny.ISequence<char>>.Default(), Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId>.Default(), Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>.Default(), Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager>.Default(), Wrappers_Compile.Option<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILegacyOverride>.Default(), Wrappers_Compile.Option<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride>.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.DynamoDbTableEncryptionConfig.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IDynamoDbTableEncryptionConfig create(Dafny.ISequence<char> logicalTableName, Dafny.ISequence<char> partitionKeyName, Wrappers_Compile._IOption<Dafny.ISequence<char>> sortKeyName, Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISearchConfig> search, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> attributeActionsOnEncrypt, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> allowedUnsignedAttributes, Wrappers_Compile._IOption<Dafny.ISequence<char>> allowedUnsignedAttributePrefix, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> algorithmSuiteId, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> keyring, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager> cmm, Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILegacyOverride> legacyOverride, Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride> plaintextOverride) {
      return new DynamoDbTableEncryptionConfig(logicalTableName, partitionKeyName, sortKeyName, search, attributeActionsOnEncrypt, allowedUnsignedAttributes, allowedUnsignedAttributePrefix, algorithmSuiteId, keyring, cmm, legacyOverride, plaintextOverride);
    }
    public static _IDynamoDbTableEncryptionConfig create_DynamoDbTableEncryptionConfig(Dafny.ISequence<char> logicalTableName, Dafny.ISequence<char> partitionKeyName, Wrappers_Compile._IOption<Dafny.ISequence<char>> sortKeyName, Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISearchConfig> search, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> attributeActionsOnEncrypt, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> allowedUnsignedAttributes, Wrappers_Compile._IOption<Dafny.ISequence<char>> allowedUnsignedAttributePrefix, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> algorithmSuiteId, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> keyring, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager> cmm, Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILegacyOverride> legacyOverride, Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride> plaintextOverride) {
      return create(logicalTableName, partitionKeyName, sortKeyName, search, attributeActionsOnEncrypt, allowedUnsignedAttributes, allowedUnsignedAttributePrefix, algorithmSuiteId, keyring, cmm, legacyOverride, plaintextOverride);
    }
    public bool is_DynamoDbTableEncryptionConfig { get { return true; } }
    public Dafny.ISequence<char> dtor_logicalTableName {
      get {
        return this._logicalTableName;
      }
    }
    public Dafny.ISequence<char> dtor_partitionKeyName {
      get {
        return this._partitionKeyName;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_sortKeyName {
      get {
        return this._sortKeyName;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISearchConfig> dtor_search {
      get {
        return this._search;
      }
    }
    public Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> dtor_attributeActionsOnEncrypt {
      get {
        return this._attributeActionsOnEncrypt;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> dtor_allowedUnsignedAttributes {
      get {
        return this._allowedUnsignedAttributes;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_allowedUnsignedAttributePrefix {
      get {
        return this._allowedUnsignedAttributePrefix;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> dtor_algorithmSuiteId {
      get {
        return this._algorithmSuiteId;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> dtor_keyring {
      get {
        return this._keyring;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager> dtor_cmm {
      get {
        return this._cmm;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILegacyOverride> dtor_legacyOverride {
      get {
        return this._legacyOverride;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride> dtor_plaintextOverride {
      get {
        return this._plaintextOverride;
      }
    }
  }

  public interface _IDynamoDbTablesEncryptionConfig {
    bool is_DynamoDbTablesEncryptionConfig { get; }
    Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig> dtor_tableEncryptionConfigs { get; }
    _IDynamoDbTablesEncryptionConfig DowncastClone();
  }
  public class DynamoDbTablesEncryptionConfig : _IDynamoDbTablesEncryptionConfig {
    public readonly Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig> _tableEncryptionConfigs;
    public DynamoDbTablesEncryptionConfig(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig> tableEncryptionConfigs) {
      this._tableEncryptionConfigs = tableEncryptionConfigs;
    }
    public _IDynamoDbTablesEncryptionConfig DowncastClone() {
      if (this is _IDynamoDbTablesEncryptionConfig dt) { return dt; }
      return new DynamoDbTablesEncryptionConfig(_tableEncryptionConfigs);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.DynamoDbTablesEncryptionConfig;
      return oth != null && object.Equals(this._tableEncryptionConfigs, oth._tableEncryptionConfigs);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._tableEncryptionConfigs));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.DynamoDbTablesEncryptionConfig.DynamoDbTablesEncryptionConfig";
      s += "(";
      s += Dafny.Helpers.ToString(this._tableEncryptionConfigs);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTablesEncryptionConfig theDefault = create(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig>.Empty);
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTablesEncryptionConfig Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTablesEncryptionConfig> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTablesEncryptionConfig>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.DynamoDbTablesEncryptionConfig.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTablesEncryptionConfig> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IDynamoDbTablesEncryptionConfig create(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig> tableEncryptionConfigs) {
      return new DynamoDbTablesEncryptionConfig(tableEncryptionConfigs);
    }
    public static _IDynamoDbTablesEncryptionConfig create_DynamoDbTablesEncryptionConfig(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig> tableEncryptionConfigs) {
      return create(tableEncryptionConfigs);
    }
    public bool is_DynamoDbTablesEncryptionConfig { get { return true; } }
    public Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig> dtor_tableEncryptionConfigs {
      get {
        return this._tableEncryptionConfigs;
      }
    }
  }

  public interface _IEncryptedDataKeyDescription {
    bool is_EncryptedDataKeyDescription { get; }
    Dafny.ISequence<char> dtor_keyProviderId { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_keyProviderInfo { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_branchKeyId { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_branchKeyVersion { get; }
    _IEncryptedDataKeyDescription DowncastClone();
  }
  public class EncryptedDataKeyDescription : _IEncryptedDataKeyDescription {
    public readonly Dafny.ISequence<char> _keyProviderId;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<char>> _keyProviderInfo;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<char>> _branchKeyId;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<char>> _branchKeyVersion;
    public EncryptedDataKeyDescription(Dafny.ISequence<char> keyProviderId, Wrappers_Compile._IOption<Dafny.ISequence<char>> keyProviderInfo, Wrappers_Compile._IOption<Dafny.ISequence<char>> branchKeyId, Wrappers_Compile._IOption<Dafny.ISequence<char>> branchKeyVersion) {
      this._keyProviderId = keyProviderId;
      this._keyProviderInfo = keyProviderInfo;
      this._branchKeyId = branchKeyId;
      this._branchKeyVersion = branchKeyVersion;
    }
    public _IEncryptedDataKeyDescription DowncastClone() {
      if (this is _IEncryptedDataKeyDescription dt) { return dt; }
      return new EncryptedDataKeyDescription(_keyProviderId, _keyProviderInfo, _branchKeyId, _branchKeyVersion);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.EncryptedDataKeyDescription;
      return oth != null && object.Equals(this._keyProviderId, oth._keyProviderId) && object.Equals(this._keyProviderInfo, oth._keyProviderInfo) && object.Equals(this._branchKeyId, oth._branchKeyId) && object.Equals(this._branchKeyVersion, oth._branchKeyVersion);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._keyProviderId));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._keyProviderInfo));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._branchKeyId));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._branchKeyVersion));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.EncryptedDataKeyDescription.EncryptedDataKeyDescription";
      s += "(";
      s += Dafny.Helpers.ToString(this._keyProviderId);
      s += ", ";
      s += Dafny.Helpers.ToString(this._keyProviderInfo);
      s += ", ";
      s += Dafny.Helpers.ToString(this._branchKeyId);
      s += ", ";
      s += Dafny.Helpers.ToString(this._branchKeyVersion);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedDataKeyDescription theDefault = create(Dafny.Sequence<char>.Empty, Wrappers_Compile.Option<Dafny.ISequence<char>>.Default(), Wrappers_Compile.Option<Dafny.ISequence<char>>.Default(), Wrappers_Compile.Option<Dafny.ISequence<char>>.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedDataKeyDescription Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedDataKeyDescription> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedDataKeyDescription>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.EncryptedDataKeyDescription.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedDataKeyDescription> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IEncryptedDataKeyDescription create(Dafny.ISequence<char> keyProviderId, Wrappers_Compile._IOption<Dafny.ISequence<char>> keyProviderInfo, Wrappers_Compile._IOption<Dafny.ISequence<char>> branchKeyId, Wrappers_Compile._IOption<Dafny.ISequence<char>> branchKeyVersion) {
      return new EncryptedDataKeyDescription(keyProviderId, keyProviderInfo, branchKeyId, branchKeyVersion);
    }
    public static _IEncryptedDataKeyDescription create_EncryptedDataKeyDescription(Dafny.ISequence<char> keyProviderId, Wrappers_Compile._IOption<Dafny.ISequence<char>> keyProviderInfo, Wrappers_Compile._IOption<Dafny.ISequence<char>> branchKeyId, Wrappers_Compile._IOption<Dafny.ISequence<char>> branchKeyVersion) {
      return create(keyProviderId, keyProviderInfo, branchKeyId, branchKeyVersion);
    }
    public bool is_EncryptedDataKeyDescription { get { return true; } }
    public Dafny.ISequence<char> dtor_keyProviderId {
      get {
        return this._keyProviderId;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_keyProviderInfo {
      get {
        return this._keyProviderInfo;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_branchKeyId {
      get {
        return this._branchKeyId;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_branchKeyVersion {
      get {
        return this._branchKeyVersion;
      }
    }
  }

  public interface _IEncryptedPart {
    bool is_EncryptedPart { get; }
    Dafny.ISequence<char> dtor_name { get; }
    Dafny.ISequence<char> dtor_prefix { get; }
    _IEncryptedPart DowncastClone();
  }
  public class EncryptedPart : _IEncryptedPart {
    public readonly Dafny.ISequence<char> _name;
    public readonly Dafny.ISequence<char> _prefix;
    public EncryptedPart(Dafny.ISequence<char> name, Dafny.ISequence<char> prefix) {
      this._name = name;
      this._prefix = prefix;
    }
    public _IEncryptedPart DowncastClone() {
      if (this is _IEncryptedPart dt) { return dt; }
      return new EncryptedPart(_name, _prefix);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.EncryptedPart;
      return oth != null && object.Equals(this._name, oth._name) && object.Equals(this._prefix, oth._prefix);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._name));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._prefix));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.EncryptedPart.EncryptedPart";
      s += "(";
      s += Dafny.Helpers.ToString(this._name);
      s += ", ";
      s += Dafny.Helpers.ToString(this._prefix);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedPart theDefault = create(Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty);
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedPart Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedPart> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedPart>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.EncryptedPart.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedPart> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IEncryptedPart create(Dafny.ISequence<char> name, Dafny.ISequence<char> prefix) {
      return new EncryptedPart(name, prefix);
    }
    public static _IEncryptedPart create_EncryptedPart(Dafny.ISequence<char> name, Dafny.ISequence<char> prefix) {
      return create(name, prefix);
    }
    public bool is_EncryptedPart { get { return true; } }
    public Dafny.ISequence<char> dtor_name {
      get {
        return this._name;
      }
    }
    public Dafny.ISequence<char> dtor_prefix {
      get {
        return this._prefix;
      }
    }
  }

  public partial class EncryptedPartsList {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedPart>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedPart>>(Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedPart>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedPart>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedPart> __source) {
      Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedPart> _0_x = __source;
      return software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.__default.IsValid__EncryptedPartsList(_0_x);
    }
  }

  public interface _IGetBranchKeyIdFromDdbKeyInput {
    bool is_GetBranchKeyIdFromDdbKeyInput { get; }
    Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> dtor_ddbKey { get; }
    _IGetBranchKeyIdFromDdbKeyInput DowncastClone();
  }
  public class GetBranchKeyIdFromDdbKeyInput : _IGetBranchKeyIdFromDdbKeyInput {
    public readonly Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _ddbKey;
    public GetBranchKeyIdFromDdbKeyInput(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> ddbKey) {
      this._ddbKey = ddbKey;
    }
    public _IGetBranchKeyIdFromDdbKeyInput DowncastClone() {
      if (this is _IGetBranchKeyIdFromDdbKeyInput dt) { return dt; }
      return new GetBranchKeyIdFromDdbKeyInput(_ddbKey);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.GetBranchKeyIdFromDdbKeyInput;
      return oth != null && object.Equals(this._ddbKey, oth._ddbKey);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._ddbKey));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.GetBranchKeyIdFromDdbKeyInput.GetBranchKeyIdFromDdbKeyInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._ddbKey);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetBranchKeyIdFromDdbKeyInput theDefault = create(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetBranchKeyIdFromDdbKeyInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetBranchKeyIdFromDdbKeyInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetBranchKeyIdFromDdbKeyInput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.GetBranchKeyIdFromDdbKeyInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetBranchKeyIdFromDdbKeyInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IGetBranchKeyIdFromDdbKeyInput create(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> ddbKey) {
      return new GetBranchKeyIdFromDdbKeyInput(ddbKey);
    }
    public static _IGetBranchKeyIdFromDdbKeyInput create_GetBranchKeyIdFromDdbKeyInput(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> ddbKey) {
      return create(ddbKey);
    }
    public bool is_GetBranchKeyIdFromDdbKeyInput { get { return true; } }
    public Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> dtor_ddbKey {
      get {
        return this._ddbKey;
      }
    }
  }

  public interface _IGetBranchKeyIdFromDdbKeyOutput {
    bool is_GetBranchKeyIdFromDdbKeyOutput { get; }
    Dafny.ISequence<char> dtor_branchKeyId { get; }
    _IGetBranchKeyIdFromDdbKeyOutput DowncastClone();
  }
  public class GetBranchKeyIdFromDdbKeyOutput : _IGetBranchKeyIdFromDdbKeyOutput {
    public readonly Dafny.ISequence<char> _branchKeyId;
    public GetBranchKeyIdFromDdbKeyOutput(Dafny.ISequence<char> branchKeyId) {
      this._branchKeyId = branchKeyId;
    }
    public _IGetBranchKeyIdFromDdbKeyOutput DowncastClone() {
      if (this is _IGetBranchKeyIdFromDdbKeyOutput dt) { return dt; }
      return new GetBranchKeyIdFromDdbKeyOutput(_branchKeyId);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.GetBranchKeyIdFromDdbKeyOutput;
      return oth != null && object.Equals(this._branchKeyId, oth._branchKeyId);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._branchKeyId));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.GetBranchKeyIdFromDdbKeyOutput.GetBranchKeyIdFromDdbKeyOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._branchKeyId);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetBranchKeyIdFromDdbKeyOutput theDefault = create(Dafny.Sequence<char>.Empty);
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetBranchKeyIdFromDdbKeyOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetBranchKeyIdFromDdbKeyOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetBranchKeyIdFromDdbKeyOutput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.GetBranchKeyIdFromDdbKeyOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetBranchKeyIdFromDdbKeyOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IGetBranchKeyIdFromDdbKeyOutput create(Dafny.ISequence<char> branchKeyId) {
      return new GetBranchKeyIdFromDdbKeyOutput(branchKeyId);
    }
    public static _IGetBranchKeyIdFromDdbKeyOutput create_GetBranchKeyIdFromDdbKeyOutput(Dafny.ISequence<char> branchKeyId) {
      return create(branchKeyId);
    }
    public bool is_GetBranchKeyIdFromDdbKeyOutput { get { return true; } }
    public Dafny.ISequence<char> dtor_branchKeyId {
      get {
        return this._branchKeyId;
      }
    }
  }

  public interface _IGetEncryptedDataKeyDescriptionInput {
    bool is_GetEncryptedDataKeyDescriptionInput { get; }
    software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionUnion dtor_input { get; }
    _IGetEncryptedDataKeyDescriptionInput DowncastClone();
  }
  public class GetEncryptedDataKeyDescriptionInput : _IGetEncryptedDataKeyDescriptionInput {
    public readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionUnion _input;
    public GetEncryptedDataKeyDescriptionInput(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionUnion input) {
      this._input = input;
    }
    public _IGetEncryptedDataKeyDescriptionInput DowncastClone() {
      if (this is _IGetEncryptedDataKeyDescriptionInput dt) { return dt; }
      return new GetEncryptedDataKeyDescriptionInput(_input);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.GetEncryptedDataKeyDescriptionInput;
      return oth != null && object.Equals(this._input, oth._input);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._input));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.GetEncryptedDataKeyDescriptionInput.GetEncryptedDataKeyDescriptionInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._input);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionInput theDefault = create(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.GetEncryptedDataKeyDescriptionUnion.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionInput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.GetEncryptedDataKeyDescriptionInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IGetEncryptedDataKeyDescriptionInput create(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionUnion input) {
      return new GetEncryptedDataKeyDescriptionInput(input);
    }
    public static _IGetEncryptedDataKeyDescriptionInput create_GetEncryptedDataKeyDescriptionInput(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionUnion input) {
      return create(input);
    }
    public bool is_GetEncryptedDataKeyDescriptionInput { get { return true; } }
    public software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionUnion dtor_input {
      get {
        return this._input;
      }
    }
  }

  public interface _IGetEncryptedDataKeyDescriptionOutput {
    bool is_GetEncryptedDataKeyDescriptionOutput { get; }
    Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedDataKeyDescription> dtor_EncryptedDataKeyDescriptionOutput { get; }
    _IGetEncryptedDataKeyDescriptionOutput DowncastClone();
  }
  public class GetEncryptedDataKeyDescriptionOutput : _IGetEncryptedDataKeyDescriptionOutput {
    public readonly Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedDataKeyDescription> _EncryptedDataKeyDescriptionOutput;
    public GetEncryptedDataKeyDescriptionOutput(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedDataKeyDescription> EncryptedDataKeyDescriptionOutput) {
      this._EncryptedDataKeyDescriptionOutput = EncryptedDataKeyDescriptionOutput;
    }
    public _IGetEncryptedDataKeyDescriptionOutput DowncastClone() {
      if (this is _IGetEncryptedDataKeyDescriptionOutput dt) { return dt; }
      return new GetEncryptedDataKeyDescriptionOutput(_EncryptedDataKeyDescriptionOutput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.GetEncryptedDataKeyDescriptionOutput;
      return oth != null && object.Equals(this._EncryptedDataKeyDescriptionOutput, oth._EncryptedDataKeyDescriptionOutput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._EncryptedDataKeyDescriptionOutput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.GetEncryptedDataKeyDescriptionOutput.GetEncryptedDataKeyDescriptionOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._EncryptedDataKeyDescriptionOutput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionOutput theDefault = create(Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedDataKeyDescription>.Empty);
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionOutput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.GetEncryptedDataKeyDescriptionOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IGetEncryptedDataKeyDescriptionOutput create(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedDataKeyDescription> EncryptedDataKeyDescriptionOutput) {
      return new GetEncryptedDataKeyDescriptionOutput(EncryptedDataKeyDescriptionOutput);
    }
    public static _IGetEncryptedDataKeyDescriptionOutput create_GetEncryptedDataKeyDescriptionOutput(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedDataKeyDescription> EncryptedDataKeyDescriptionOutput) {
      return create(EncryptedDataKeyDescriptionOutput);
    }
    public bool is_GetEncryptedDataKeyDescriptionOutput { get { return true; } }
    public Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedDataKeyDescription> dtor_EncryptedDataKeyDescriptionOutput {
      get {
        return this._EncryptedDataKeyDescriptionOutput;
      }
    }
  }

  public interface _IGetEncryptedDataKeyDescriptionUnion {
    bool is_header { get; }
    bool is_item { get; }
    Dafny.ISequence<byte> dtor_header { get; }
    Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> dtor_item { get; }
    _IGetEncryptedDataKeyDescriptionUnion DowncastClone();
  }
  public abstract class GetEncryptedDataKeyDescriptionUnion : _IGetEncryptedDataKeyDescriptionUnion {
    public GetEncryptedDataKeyDescriptionUnion() {
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionUnion theDefault = create_header(Dafny.Sequence<byte>.Empty);
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionUnion Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionUnion> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionUnion>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.GetEncryptedDataKeyDescriptionUnion.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionUnion> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IGetEncryptedDataKeyDescriptionUnion create_header(Dafny.ISequence<byte> header) {
      return new GetEncryptedDataKeyDescriptionUnion_header(header);
    }
    public static _IGetEncryptedDataKeyDescriptionUnion create_item(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item) {
      return new GetEncryptedDataKeyDescriptionUnion_item(item);
    }
    public bool is_header { get { return this is GetEncryptedDataKeyDescriptionUnion_header; } }
    public bool is_item { get { return this is GetEncryptedDataKeyDescriptionUnion_item; } }
    public Dafny.ISequence<byte> dtor_header {
      get {
        var d = this;
        return ((GetEncryptedDataKeyDescriptionUnion_header)d)._header;
      }
    }
    public Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> dtor_item {
      get {
        var d = this;
        return ((GetEncryptedDataKeyDescriptionUnion_item)d)._item;
      }
    }
    public abstract _IGetEncryptedDataKeyDescriptionUnion DowncastClone();
  }
  public class GetEncryptedDataKeyDescriptionUnion_header : GetEncryptedDataKeyDescriptionUnion {
    public readonly Dafny.ISequence<byte> _header;
    public GetEncryptedDataKeyDescriptionUnion_header(Dafny.ISequence<byte> header) : base() {
      this._header = header;
    }
    public override _IGetEncryptedDataKeyDescriptionUnion DowncastClone() {
      if (this is _IGetEncryptedDataKeyDescriptionUnion dt) { return dt; }
      return new GetEncryptedDataKeyDescriptionUnion_header(_header);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.GetEncryptedDataKeyDescriptionUnion_header;
      return oth != null && object.Equals(this._header, oth._header);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._header));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.GetEncryptedDataKeyDescriptionUnion.header";
      s += "(";
      s += Dafny.Helpers.ToString(this._header);
      s += ")";
      return s;
    }
  }
  public class GetEncryptedDataKeyDescriptionUnion_item : GetEncryptedDataKeyDescriptionUnion {
    public readonly Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _item;
    public GetEncryptedDataKeyDescriptionUnion_item(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item) : base() {
      this._item = item;
    }
    public override _IGetEncryptedDataKeyDescriptionUnion DowncastClone() {
      if (this is _IGetEncryptedDataKeyDescriptionUnion dt) { return dt; }
      return new GetEncryptedDataKeyDescriptionUnion_item(_item);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.GetEncryptedDataKeyDescriptionUnion_item;
      return oth != null && object.Equals(this._item, oth._item);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._item));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.GetEncryptedDataKeyDescriptionUnion.item";
      s += "(";
      s += Dafny.Helpers.ToString(this._item);
      s += ")";
      return s;
    }
  }

  public interface _IGetPrefix {
    bool is_GetPrefix { get; }
    int dtor_length { get; }
    _IGetPrefix DowncastClone();
  }
  public class GetPrefix : _IGetPrefix {
    public readonly int _length;
    public GetPrefix(int length) {
      this._length = length;
    }
    public _IGetPrefix DowncastClone() {
      if (this is _IGetPrefix dt) { return dt; }
      return new GetPrefix(_length);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.GetPrefix;
      return oth != null && this._length == oth._length;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._length));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.GetPrefix.GetPrefix";
      s += "(";
      s += Dafny.Helpers.ToString(this._length);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetPrefix theDefault = create(0);
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetPrefix Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetPrefix> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetPrefix>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.GetPrefix.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetPrefix> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IGetPrefix create(int length) {
      return new GetPrefix(length);
    }
    public static _IGetPrefix create_GetPrefix(int length) {
      return create(length);
    }
    public bool is_GetPrefix { get { return true; } }
    public int dtor_length {
      get {
        return this._length;
      }
    }
  }

  public interface _IGetSegment {
    bool is_GetSegment { get; }
    Dafny.ISequence<char> dtor_split { get; }
    int dtor_index { get; }
    _IGetSegment DowncastClone();
  }
  public class GetSegment : _IGetSegment {
    public readonly Dafny.ISequence<char> _split;
    public readonly int _index;
    public GetSegment(Dafny.ISequence<char> split, int index) {
      this._split = split;
      this._index = index;
    }
    public _IGetSegment DowncastClone() {
      if (this is _IGetSegment dt) { return dt; }
      return new GetSegment(_split, _index);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.GetSegment;
      return oth != null && object.Equals(this._split, oth._split) && this._index == oth._index;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._split));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._index));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.GetSegment.GetSegment";
      s += "(";
      s += Dafny.Helpers.ToString(this._split);
      s += ", ";
      s += Dafny.Helpers.ToString(this._index);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSegment theDefault = create(Dafny.Sequence<char>.Empty, 0);
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSegment Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSegment> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSegment>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.GetSegment.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSegment> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IGetSegment create(Dafny.ISequence<char> split, int index) {
      return new GetSegment(split, index);
    }
    public static _IGetSegment create_GetSegment(Dafny.ISequence<char> split, int index) {
      return create(split, index);
    }
    public bool is_GetSegment { get { return true; } }
    public Dafny.ISequence<char> dtor_split {
      get {
        return this._split;
      }
    }
    public int dtor_index {
      get {
        return this._index;
      }
    }
  }

  public interface _IGetSegments {
    bool is_GetSegments { get; }
    Dafny.ISequence<char> dtor_split { get; }
    int dtor_low { get; }
    int dtor_high { get; }
    _IGetSegments DowncastClone();
  }
  public class GetSegments : _IGetSegments {
    public readonly Dafny.ISequence<char> _split;
    public readonly int _low;
    public readonly int _high;
    public GetSegments(Dafny.ISequence<char> split, int low, int high) {
      this._split = split;
      this._low = low;
      this._high = high;
    }
    public _IGetSegments DowncastClone() {
      if (this is _IGetSegments dt) { return dt; }
      return new GetSegments(_split, _low, _high);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.GetSegments;
      return oth != null && object.Equals(this._split, oth._split) && this._low == oth._low && this._high == oth._high;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._split));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._low));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._high));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.GetSegments.GetSegments";
      s += "(";
      s += Dafny.Helpers.ToString(this._split);
      s += ", ";
      s += Dafny.Helpers.ToString(this._low);
      s += ", ";
      s += Dafny.Helpers.ToString(this._high);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSegments theDefault = create(Dafny.Sequence<char>.Empty, 0, 0);
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSegments Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSegments> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSegments>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.GetSegments.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSegments> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IGetSegments create(Dafny.ISequence<char> split, int low, int high) {
      return new GetSegments(split, low, high);
    }
    public static _IGetSegments create_GetSegments(Dafny.ISequence<char> split, int low, int high) {
      return create(split, low, high);
    }
    public bool is_GetSegments { get { return true; } }
    public Dafny.ISequence<char> dtor_split {
      get {
        return this._split;
      }
    }
    public int dtor_low {
      get {
        return this._low;
      }
    }
    public int dtor_high {
      get {
        return this._high;
      }
    }
  }

  public interface _IGetSubstring {
    bool is_GetSubstring { get; }
    int dtor_low { get; }
    int dtor_high { get; }
    _IGetSubstring DowncastClone();
  }
  public class GetSubstring : _IGetSubstring {
    public readonly int _low;
    public readonly int _high;
    public GetSubstring(int low, int high) {
      this._low = low;
      this._high = high;
    }
    public _IGetSubstring DowncastClone() {
      if (this is _IGetSubstring dt) { return dt; }
      return new GetSubstring(_low, _high);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.GetSubstring;
      return oth != null && this._low == oth._low && this._high == oth._high;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._low));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._high));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.GetSubstring.GetSubstring";
      s += "(";
      s += Dafny.Helpers.ToString(this._low);
      s += ", ";
      s += Dafny.Helpers.ToString(this._high);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSubstring theDefault = create(0, 0);
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSubstring Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSubstring> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSubstring>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.GetSubstring.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSubstring> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IGetSubstring create(int low, int high) {
      return new GetSubstring(low, high);
    }
    public static _IGetSubstring create_GetSubstring(int low, int high) {
      return create(low, high);
    }
    public bool is_GetSubstring { get { return true; } }
    public int dtor_low {
      get {
        return this._low;
      }
    }
    public int dtor_high {
      get {
        return this._high;
      }
    }
  }

  public interface _IGetSuffix {
    bool is_GetSuffix { get; }
    int dtor_length { get; }
    _IGetSuffix DowncastClone();
  }
  public class GetSuffix : _IGetSuffix {
    public readonly int _length;
    public GetSuffix(int length) {
      this._length = length;
    }
    public _IGetSuffix DowncastClone() {
      if (this is _IGetSuffix dt) { return dt; }
      return new GetSuffix(_length);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.GetSuffix;
      return oth != null && this._length == oth._length;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._length));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.GetSuffix.GetSuffix";
      s += "(";
      s += Dafny.Helpers.ToString(this._length);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSuffix theDefault = create(0);
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSuffix Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSuffix> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSuffix>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.GetSuffix.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSuffix> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IGetSuffix create(int length) {
      return new GetSuffix(length);
    }
    public static _IGetSuffix create_GetSuffix(int length) {
      return create(length);
    }
    public bool is_GetSuffix { get { return true; } }
    public int dtor_length {
      get {
        return this._length;
      }
    }
  }

  public interface _IInsert {
    bool is_Insert { get; }
    Dafny.ISequence<char> dtor_literal { get; }
    _IInsert DowncastClone();
  }
  public class Insert : _IInsert {
    public readonly Dafny.ISequence<char> _literal;
    public Insert(Dafny.ISequence<char> literal) {
      this._literal = literal;
    }
    public _IInsert DowncastClone() {
      if (this is _IInsert dt) { return dt; }
      return new Insert(_literal);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Insert;
      return oth != null && object.Equals(this._literal, oth._literal);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._literal));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.Insert.Insert";
      s += "(";
      s += Dafny.Helpers.ToString(this._literal);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IInsert theDefault = create(Dafny.Sequence<char>.Empty);
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IInsert Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IInsert> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IInsert>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Insert.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IInsert> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IInsert create(Dafny.ISequence<char> literal) {
      return new Insert(literal);
    }
    public static _IInsert create_Insert(Dafny.ISequence<char> literal) {
      return create(literal);
    }
    public bool is_Insert { get { return true; } }
    public Dafny.ISequence<char> dtor_literal {
      get {
        return this._literal;
      }
    }
  }

  public partial class ILegacyDynamoDbEncryptorCallHistory {
    public ILegacyDynamoDbEncryptorCallHistory() {
    }
  }

  public interface ILegacyDynamoDbEncryptor {
  }
  public class _Companion_ILegacyDynamoDbEncryptor {
  }

  public interface _ILegacyOverride {
    bool is_LegacyOverride { get; }
    software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILegacyPolicy dtor_policy { get; }
    software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.ILegacyDynamoDbEncryptor dtor_encryptor { get; }
    Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> dtor_attributeActionsOnEncrypt { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> dtor_defaultAttributeFlag { get; }
    _ILegacyOverride DowncastClone();
  }
  public class LegacyOverride : _ILegacyOverride {
    public readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILegacyPolicy _policy;
    public readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.ILegacyDynamoDbEncryptor _encryptor;
    public readonly Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> _attributeActionsOnEncrypt;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> _defaultAttributeFlag;
    public LegacyOverride(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILegacyPolicy policy, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.ILegacyDynamoDbEncryptor encryptor, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> attributeActionsOnEncrypt, Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> defaultAttributeFlag) {
      this._policy = policy;
      this._encryptor = encryptor;
      this._attributeActionsOnEncrypt = attributeActionsOnEncrypt;
      this._defaultAttributeFlag = defaultAttributeFlag;
    }
    public _ILegacyOverride DowncastClone() {
      if (this is _ILegacyOverride dt) { return dt; }
      return new LegacyOverride(_policy, _encryptor, _attributeActionsOnEncrypt, _defaultAttributeFlag);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.LegacyOverride;
      return oth != null && object.Equals(this._policy, oth._policy) && this._encryptor == oth._encryptor && object.Equals(this._attributeActionsOnEncrypt, oth._attributeActionsOnEncrypt) && object.Equals(this._defaultAttributeFlag, oth._defaultAttributeFlag);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._policy));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptor));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._attributeActionsOnEncrypt));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._defaultAttributeFlag));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.LegacyOverride.LegacyOverride";
      s += "(";
      s += Dafny.Helpers.ToString(this._policy);
      s += ", ";
      s += Dafny.Helpers.ToString(this._encryptor);
      s += ", ";
      s += Dafny.Helpers.ToString(this._attributeActionsOnEncrypt);
      s += ", ";
      s += Dafny.Helpers.ToString(this._defaultAttributeFlag);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILegacyOverride theDefault = create(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.LegacyPolicy.Default(), default(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.ILegacyDynamoDbEncryptor), Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Empty, Wrappers_Compile.Option<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILegacyOverride Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILegacyOverride> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILegacyOverride>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.LegacyOverride.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILegacyOverride> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ILegacyOverride create(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILegacyPolicy policy, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.ILegacyDynamoDbEncryptor encryptor, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> attributeActionsOnEncrypt, Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> defaultAttributeFlag) {
      return new LegacyOverride(policy, encryptor, attributeActionsOnEncrypt, defaultAttributeFlag);
    }
    public static _ILegacyOverride create_LegacyOverride(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILegacyPolicy policy, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.ILegacyDynamoDbEncryptor encryptor, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> attributeActionsOnEncrypt, Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> defaultAttributeFlag) {
      return create(policy, encryptor, attributeActionsOnEncrypt, defaultAttributeFlag);
    }
    public bool is_LegacyOverride { get { return true; } }
    public software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILegacyPolicy dtor_policy {
      get {
        return this._policy;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.ILegacyDynamoDbEncryptor dtor_encryptor {
      get {
        return this._encryptor;
      }
    }
    public Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> dtor_attributeActionsOnEncrypt {
      get {
        return this._attributeActionsOnEncrypt;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> dtor_defaultAttributeFlag {
      get {
        return this._defaultAttributeFlag;
      }
    }
  }

  public interface _ILegacyPolicy {
    bool is_FORCE__LEGACY__ENCRYPT__ALLOW__LEGACY__DECRYPT { get; }
    bool is_FORBID__LEGACY__ENCRYPT__ALLOW__LEGACY__DECRYPT { get; }
    bool is_FORBID__LEGACY__ENCRYPT__FORBID__LEGACY__DECRYPT { get; }
    _ILegacyPolicy DowncastClone();
  }
  public abstract class LegacyPolicy : _ILegacyPolicy {
    public LegacyPolicy() {
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILegacyPolicy theDefault = create_FORCE__LEGACY__ENCRYPT__ALLOW__LEGACY__DECRYPT();
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILegacyPolicy Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILegacyPolicy> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILegacyPolicy>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.LegacyPolicy.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILegacyPolicy> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ILegacyPolicy create_FORCE__LEGACY__ENCRYPT__ALLOW__LEGACY__DECRYPT() {
      return new LegacyPolicy_FORCE__LEGACY__ENCRYPT__ALLOW__LEGACY__DECRYPT();
    }
    public static _ILegacyPolicy create_FORBID__LEGACY__ENCRYPT__ALLOW__LEGACY__DECRYPT() {
      return new LegacyPolicy_FORBID__LEGACY__ENCRYPT__ALLOW__LEGACY__DECRYPT();
    }
    public static _ILegacyPolicy create_FORBID__LEGACY__ENCRYPT__FORBID__LEGACY__DECRYPT() {
      return new LegacyPolicy_FORBID__LEGACY__ENCRYPT__FORBID__LEGACY__DECRYPT();
    }
    public bool is_FORCE__LEGACY__ENCRYPT__ALLOW__LEGACY__DECRYPT { get { return this is LegacyPolicy_FORCE__LEGACY__ENCRYPT__ALLOW__LEGACY__DECRYPT; } }
    public bool is_FORBID__LEGACY__ENCRYPT__ALLOW__LEGACY__DECRYPT { get { return this is LegacyPolicy_FORBID__LEGACY__ENCRYPT__ALLOW__LEGACY__DECRYPT; } }
    public bool is_FORBID__LEGACY__ENCRYPT__FORBID__LEGACY__DECRYPT { get { return this is LegacyPolicy_FORBID__LEGACY__ENCRYPT__FORBID__LEGACY__DECRYPT; } }
    public static System.Collections.Generic.IEnumerable<_ILegacyPolicy> AllSingletonConstructors {
      get {
        yield return LegacyPolicy.create_FORCE__LEGACY__ENCRYPT__ALLOW__LEGACY__DECRYPT();
        yield return LegacyPolicy.create_FORBID__LEGACY__ENCRYPT__ALLOW__LEGACY__DECRYPT();
        yield return LegacyPolicy.create_FORBID__LEGACY__ENCRYPT__FORBID__LEGACY__DECRYPT();
      }
    }
    public abstract _ILegacyPolicy DowncastClone();
  }
  public class LegacyPolicy_FORCE__LEGACY__ENCRYPT__ALLOW__LEGACY__DECRYPT : LegacyPolicy {
    public LegacyPolicy_FORCE__LEGACY__ENCRYPT__ALLOW__LEGACY__DECRYPT() : base() {
    }
    public override _ILegacyPolicy DowncastClone() {
      if (this is _ILegacyPolicy dt) { return dt; }
      return new LegacyPolicy_FORCE__LEGACY__ENCRYPT__ALLOW__LEGACY__DECRYPT();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.LegacyPolicy_FORCE__LEGACY__ENCRYPT__ALLOW__LEGACY__DECRYPT;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.LegacyPolicy.FORCE_LEGACY_ENCRYPT_ALLOW_LEGACY_DECRYPT";
      return s;
    }
  }
  public class LegacyPolicy_FORBID__LEGACY__ENCRYPT__ALLOW__LEGACY__DECRYPT : LegacyPolicy {
    public LegacyPolicy_FORBID__LEGACY__ENCRYPT__ALLOW__LEGACY__DECRYPT() : base() {
    }
    public override _ILegacyPolicy DowncastClone() {
      if (this is _ILegacyPolicy dt) { return dt; }
      return new LegacyPolicy_FORBID__LEGACY__ENCRYPT__ALLOW__LEGACY__DECRYPT();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.LegacyPolicy_FORBID__LEGACY__ENCRYPT__ALLOW__LEGACY__DECRYPT;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.LegacyPolicy.FORBID_LEGACY_ENCRYPT_ALLOW_LEGACY_DECRYPT";
      return s;
    }
  }
  public class LegacyPolicy_FORBID__LEGACY__ENCRYPT__FORBID__LEGACY__DECRYPT : LegacyPolicy {
    public LegacyPolicy_FORBID__LEGACY__ENCRYPT__FORBID__LEGACY__DECRYPT() : base() {
    }
    public override _ILegacyPolicy DowncastClone() {
      if (this is _ILegacyPolicy dt) { return dt; }
      return new LegacyPolicy_FORBID__LEGACY__ENCRYPT__FORBID__LEGACY__DECRYPT();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.LegacyPolicy_FORBID__LEGACY__ENCRYPT__FORBID__LEGACY__DECRYPT;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.LegacyPolicy.FORBID_LEGACY_ENCRYPT_FORBID_LEGACY_DECRYPT";
      return s;
    }
  }

  public interface _ILower {
    bool is_Lower { get; }
    _ILower DowncastClone();
  }
  public class Lower : _ILower {
    public Lower() {
    }
    public _ILower DowncastClone() {
      if (this is _ILower dt) { return dt; }
      return new Lower();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Lower;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.Lower.Lower";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILower theDefault = create();
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILower Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILower> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILower>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Lower.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILower> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ILower create() {
      return new Lower();
    }
    public static _ILower create_Lower() {
      return create();
    }
    public bool is_Lower { get { return true; } }
    public static System.Collections.Generic.IEnumerable<_ILower> AllSingletonConstructors {
      get {
        yield return Lower.create();
      }
    }
  }

  public interface _IMultiKeyStore {
    bool is_MultiKeyStore { get; }
    Dafny.ISequence<char> dtor_keyFieldName { get; }
    int dtor_cacheTTL { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._ICacheType> dtor_cache { get; }
    _IMultiKeyStore DowncastClone();
  }
  public class MultiKeyStore : _IMultiKeyStore {
    public readonly Dafny.ISequence<char> _keyFieldName;
    public readonly int _cacheTTL;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._ICacheType> _cache;
    public MultiKeyStore(Dafny.ISequence<char> keyFieldName, int cacheTTL, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._ICacheType> cache) {
      this._keyFieldName = keyFieldName;
      this._cacheTTL = cacheTTL;
      this._cache = cache;
    }
    public _IMultiKeyStore DowncastClone() {
      if (this is _IMultiKeyStore dt) { return dt; }
      return new MultiKeyStore(_keyFieldName, _cacheTTL, _cache);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.MultiKeyStore;
      return oth != null && object.Equals(this._keyFieldName, oth._keyFieldName) && this._cacheTTL == oth._cacheTTL && object.Equals(this._cache, oth._cache);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._keyFieldName));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._cacheTTL));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._cache));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.MultiKeyStore.MultiKeyStore";
      s += "(";
      s += Dafny.Helpers.ToString(this._keyFieldName);
      s += ", ";
      s += Dafny.Helpers.ToString(this._cacheTTL);
      s += ", ";
      s += Dafny.Helpers.ToString(this._cache);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IMultiKeyStore theDefault = create(Dafny.Sequence<char>.Empty, 0, Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types._ICacheType>.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IMultiKeyStore Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IMultiKeyStore> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IMultiKeyStore>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.MultiKeyStore.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IMultiKeyStore> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IMultiKeyStore create(Dafny.ISequence<char> keyFieldName, int cacheTTL, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._ICacheType> cache) {
      return new MultiKeyStore(keyFieldName, cacheTTL, cache);
    }
    public static _IMultiKeyStore create_MultiKeyStore(Dafny.ISequence<char> keyFieldName, int cacheTTL, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._ICacheType> cache) {
      return create(keyFieldName, cacheTTL, cache);
    }
    public bool is_MultiKeyStore { get { return true; } }
    public Dafny.ISequence<char> dtor_keyFieldName {
      get {
        return this._keyFieldName;
      }
    }
    public int dtor_cacheTTL {
      get {
        return this._cacheTTL;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._ICacheType> dtor_cache {
      get {
        return this._cache;
      }
    }
  }

  public interface _IPartOnly {
    bool is_PartOnly { get; }
    _IPartOnly DowncastClone();
  }
  public class PartOnly : _IPartOnly {
    public PartOnly() {
    }
    public _IPartOnly DowncastClone() {
      if (this is _IPartOnly dt) { return dt; }
      return new PartOnly();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.PartOnly;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.PartOnly.PartOnly";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPartOnly theDefault = create();
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPartOnly Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPartOnly> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPartOnly>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.PartOnly.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPartOnly> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IPartOnly create() {
      return new PartOnly();
    }
    public static _IPartOnly create_PartOnly() {
      return create();
    }
    public bool is_PartOnly { get { return true; } }
    public static System.Collections.Generic.IEnumerable<_IPartOnly> AllSingletonConstructors {
      get {
        yield return PartOnly.create();
      }
    }
  }

  public interface _IPlaintextOverride {
    bool is_FORCE__PLAINTEXT__WRITE__ALLOW__PLAINTEXT__READ { get; }
    bool is_FORBID__PLAINTEXT__WRITE__ALLOW__PLAINTEXT__READ { get; }
    bool is_FORBID__PLAINTEXT__WRITE__FORBID__PLAINTEXT__READ { get; }
    _IPlaintextOverride DowncastClone();
  }
  public abstract class PlaintextOverride : _IPlaintextOverride {
    public PlaintextOverride() {
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride theDefault = create_FORCE__PLAINTEXT__WRITE__ALLOW__PLAINTEXT__READ();
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.PlaintextOverride.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IPlaintextOverride create_FORCE__PLAINTEXT__WRITE__ALLOW__PLAINTEXT__READ() {
      return new PlaintextOverride_FORCE__PLAINTEXT__WRITE__ALLOW__PLAINTEXT__READ();
    }
    public static _IPlaintextOverride create_FORBID__PLAINTEXT__WRITE__ALLOW__PLAINTEXT__READ() {
      return new PlaintextOverride_FORBID__PLAINTEXT__WRITE__ALLOW__PLAINTEXT__READ();
    }
    public static _IPlaintextOverride create_FORBID__PLAINTEXT__WRITE__FORBID__PLAINTEXT__READ() {
      return new PlaintextOverride_FORBID__PLAINTEXT__WRITE__FORBID__PLAINTEXT__READ();
    }
    public bool is_FORCE__PLAINTEXT__WRITE__ALLOW__PLAINTEXT__READ { get { return this is PlaintextOverride_FORCE__PLAINTEXT__WRITE__ALLOW__PLAINTEXT__READ; } }
    public bool is_FORBID__PLAINTEXT__WRITE__ALLOW__PLAINTEXT__READ { get { return this is PlaintextOverride_FORBID__PLAINTEXT__WRITE__ALLOW__PLAINTEXT__READ; } }
    public bool is_FORBID__PLAINTEXT__WRITE__FORBID__PLAINTEXT__READ { get { return this is PlaintextOverride_FORBID__PLAINTEXT__WRITE__FORBID__PLAINTEXT__READ; } }
    public static System.Collections.Generic.IEnumerable<_IPlaintextOverride> AllSingletonConstructors {
      get {
        yield return PlaintextOverride.create_FORCE__PLAINTEXT__WRITE__ALLOW__PLAINTEXT__READ();
        yield return PlaintextOverride.create_FORBID__PLAINTEXT__WRITE__ALLOW__PLAINTEXT__READ();
        yield return PlaintextOverride.create_FORBID__PLAINTEXT__WRITE__FORBID__PLAINTEXT__READ();
      }
    }
    public abstract _IPlaintextOverride DowncastClone();
  }
  public class PlaintextOverride_FORCE__PLAINTEXT__WRITE__ALLOW__PLAINTEXT__READ : PlaintextOverride {
    public PlaintextOverride_FORCE__PLAINTEXT__WRITE__ALLOW__PLAINTEXT__READ() : base() {
    }
    public override _IPlaintextOverride DowncastClone() {
      if (this is _IPlaintextOverride dt) { return dt; }
      return new PlaintextOverride_FORCE__PLAINTEXT__WRITE__ALLOW__PLAINTEXT__READ();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.PlaintextOverride_FORCE__PLAINTEXT__WRITE__ALLOW__PLAINTEXT__READ;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.PlaintextOverride.FORCE_PLAINTEXT_WRITE_ALLOW_PLAINTEXT_READ";
      return s;
    }
  }
  public class PlaintextOverride_FORBID__PLAINTEXT__WRITE__ALLOW__PLAINTEXT__READ : PlaintextOverride {
    public PlaintextOverride_FORBID__PLAINTEXT__WRITE__ALLOW__PLAINTEXT__READ() : base() {
    }
    public override _IPlaintextOverride DowncastClone() {
      if (this is _IPlaintextOverride dt) { return dt; }
      return new PlaintextOverride_FORBID__PLAINTEXT__WRITE__ALLOW__PLAINTEXT__READ();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.PlaintextOverride_FORBID__PLAINTEXT__WRITE__ALLOW__PLAINTEXT__READ;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.PlaintextOverride.FORBID_PLAINTEXT_WRITE_ALLOW_PLAINTEXT_READ";
      return s;
    }
  }
  public class PlaintextOverride_FORBID__PLAINTEXT__WRITE__FORBID__PLAINTEXT__READ : PlaintextOverride {
    public PlaintextOverride_FORBID__PLAINTEXT__WRITE__FORBID__PLAINTEXT__READ() : base() {
    }
    public override _IPlaintextOverride DowncastClone() {
      if (this is _IPlaintextOverride dt) { return dt; }
      return new PlaintextOverride_FORBID__PLAINTEXT__WRITE__FORBID__PLAINTEXT__READ();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.PlaintextOverride_FORBID__PLAINTEXT__WRITE__FORBID__PLAINTEXT__READ;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.PlaintextOverride.FORBID_PLAINTEXT_WRITE_FORBID_PLAINTEXT_READ";
      return s;
    }
  }

  public partial class Prefix {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<char>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<char>>(Dafny.Sequence<char>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<char>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.ISequence<char> __source) {
      Dafny.ISequence<char> _0_x = __source;
      return software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.__default.IsValid__Prefix(_0_x);
    }
  }

  public interface _ISearchConfig {
    bool is_SearchConfig { get; }
    Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconVersion> dtor_versions { get; }
    int dtor_writeVersion { get; }
    _ISearchConfig DowncastClone();
  }
  public class SearchConfig : _ISearchConfig {
    public readonly Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconVersion> _versions;
    public readonly int _writeVersion;
    public SearchConfig(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconVersion> versions, int writeVersion) {
      this._versions = versions;
      this._writeVersion = writeVersion;
    }
    public _ISearchConfig DowncastClone() {
      if (this is _ISearchConfig dt) { return dt; }
      return new SearchConfig(_versions, _writeVersion);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.SearchConfig;
      return oth != null && object.Equals(this._versions, oth._versions) && this._writeVersion == oth._writeVersion;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._versions));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._writeVersion));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.SearchConfig.SearchConfig";
      s += "(";
      s += Dafny.Helpers.ToString(this._versions);
      s += ", ";
      s += Dafny.Helpers.ToString(this._writeVersion);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISearchConfig theDefault = create(Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconVersion>.Empty, 0);
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISearchConfig Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISearchConfig> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISearchConfig>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.SearchConfig.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISearchConfig> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ISearchConfig create(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconVersion> versions, int writeVersion) {
      return new SearchConfig(versions, writeVersion);
    }
    public static _ISearchConfig create_SearchConfig(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconVersion> versions, int writeVersion) {
      return create(versions, writeVersion);
    }
    public bool is_SearchConfig { get { return true; } }
    public Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconVersion> dtor_versions {
      get {
        return this._versions;
      }
    }
    public int dtor_writeVersion {
      get {
        return this._writeVersion;
      }
    }
  }

  public interface _IShared {
    bool is_Shared { get; }
    Dafny.ISequence<char> dtor_other { get; }
    _IShared DowncastClone();
  }
  public class Shared : _IShared {
    public readonly Dafny.ISequence<char> _other;
    public Shared(Dafny.ISequence<char> other) {
      this._other = other;
    }
    public _IShared DowncastClone() {
      if (this is _IShared dt) { return dt; }
      return new Shared(_other);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Shared;
      return oth != null && object.Equals(this._other, oth._other);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._other));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.Shared.Shared";
      s += "(";
      s += Dafny.Helpers.ToString(this._other);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IShared theDefault = create(Dafny.Sequence<char>.Empty);
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IShared Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IShared> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IShared>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Shared.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IShared> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IShared create(Dafny.ISequence<char> other) {
      return new Shared(other);
    }
    public static _IShared create_Shared(Dafny.ISequence<char> other) {
      return create(other);
    }
    public bool is_Shared { get { return true; } }
    public Dafny.ISequence<char> dtor_other {
      get {
        return this._other;
      }
    }
  }

  public interface _ISharedSet {
    bool is_SharedSet { get; }
    Dafny.ISequence<char> dtor_other { get; }
    _ISharedSet DowncastClone();
  }
  public class SharedSet : _ISharedSet {
    public readonly Dafny.ISequence<char> _other;
    public SharedSet(Dafny.ISequence<char> other) {
      this._other = other;
    }
    public _ISharedSet DowncastClone() {
      if (this is _ISharedSet dt) { return dt; }
      return new SharedSet(_other);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.SharedSet;
      return oth != null && object.Equals(this._other, oth._other);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._other));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.SharedSet.SharedSet";
      s += "(";
      s += Dafny.Helpers.ToString(this._other);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISharedSet theDefault = create(Dafny.Sequence<char>.Empty);
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISharedSet Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISharedSet> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISharedSet>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.SharedSet.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISharedSet> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ISharedSet create(Dafny.ISequence<char> other) {
      return new SharedSet(other);
    }
    public static _ISharedSet create_SharedSet(Dafny.ISequence<char> other) {
      return create(other);
    }
    public bool is_SharedSet { get { return true; } }
    public Dafny.ISequence<char> dtor_other {
      get {
        return this._other;
      }
    }
  }

  public interface _ISignedPart {
    bool is_SignedPart { get; }
    Dafny.ISequence<char> dtor_name { get; }
    Dafny.ISequence<char> dtor_prefix { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_loc { get; }
    _ISignedPart DowncastClone();
  }
  public class SignedPart : _ISignedPart {
    public readonly Dafny.ISequence<char> _name;
    public readonly Dafny.ISequence<char> _prefix;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<char>> _loc;
    public SignedPart(Dafny.ISequence<char> name, Dafny.ISequence<char> prefix, Wrappers_Compile._IOption<Dafny.ISequence<char>> loc) {
      this._name = name;
      this._prefix = prefix;
      this._loc = loc;
    }
    public _ISignedPart DowncastClone() {
      if (this is _ISignedPart dt) { return dt; }
      return new SignedPart(_name, _prefix, _loc);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.SignedPart;
      return oth != null && object.Equals(this._name, oth._name) && object.Equals(this._prefix, oth._prefix) && object.Equals(this._loc, oth._loc);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._name));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._prefix));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._loc));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.SignedPart.SignedPart";
      s += "(";
      s += Dafny.Helpers.ToString(this._name);
      s += ", ";
      s += Dafny.Helpers.ToString(this._prefix);
      s += ", ";
      s += Dafny.Helpers.ToString(this._loc);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart theDefault = create(Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty, Wrappers_Compile.Option<Dafny.ISequence<char>>.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.SignedPart.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ISignedPart create(Dafny.ISequence<char> name, Dafny.ISequence<char> prefix, Wrappers_Compile._IOption<Dafny.ISequence<char>> loc) {
      return new SignedPart(name, prefix, loc);
    }
    public static _ISignedPart create_SignedPart(Dafny.ISequence<char> name, Dafny.ISequence<char> prefix, Wrappers_Compile._IOption<Dafny.ISequence<char>> loc) {
      return create(name, prefix, loc);
    }
    public bool is_SignedPart { get { return true; } }
    public Dafny.ISequence<char> dtor_name {
      get {
        return this._name;
      }
    }
    public Dafny.ISequence<char> dtor_prefix {
      get {
        return this._prefix;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_loc {
      get {
        return this._loc;
      }
    }
  }

  public partial class SignedPartsList {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart>>(Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart> __source) {
      Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart> _1_x = __source;
      return software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.__default.IsValid__SignedPartsList(_1_x);
    }
  }

  public interface _ISingleKeyStore {
    bool is_SingleKeyStore { get; }
    Dafny.ISequence<char> dtor_keyId { get; }
    int dtor_cacheTTL { get; }
    _ISingleKeyStore DowncastClone();
  }
  public class SingleKeyStore : _ISingleKeyStore {
    public readonly Dafny.ISequence<char> _keyId;
    public readonly int _cacheTTL;
    public SingleKeyStore(Dafny.ISequence<char> keyId, int cacheTTL) {
      this._keyId = keyId;
      this._cacheTTL = cacheTTL;
    }
    public _ISingleKeyStore DowncastClone() {
      if (this is _ISingleKeyStore dt) { return dt; }
      return new SingleKeyStore(_keyId, _cacheTTL);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.SingleKeyStore;
      return oth != null && object.Equals(this._keyId, oth._keyId) && this._cacheTTL == oth._cacheTTL;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._keyId));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._cacheTTL));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.SingleKeyStore.SingleKeyStore";
      s += "(";
      s += Dafny.Helpers.ToString(this._keyId);
      s += ", ";
      s += Dafny.Helpers.ToString(this._cacheTTL);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISingleKeyStore theDefault = create(Dafny.Sequence<char>.Empty, 0);
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISingleKeyStore Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISingleKeyStore> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISingleKeyStore>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.SingleKeyStore.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISingleKeyStore> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ISingleKeyStore create(Dafny.ISequence<char> keyId, int cacheTTL) {
      return new SingleKeyStore(keyId, cacheTTL);
    }
    public static _ISingleKeyStore create_SingleKeyStore(Dafny.ISequence<char> keyId, int cacheTTL) {
      return create(keyId, cacheTTL);
    }
    public bool is_SingleKeyStore { get { return true; } }
    public Dafny.ISequence<char> dtor_keyId {
      get {
        return this._keyId;
      }
    }
    public int dtor_cacheTTL {
      get {
        return this._cacheTTL;
      }
    }
  }

  public interface _IStandardBeacon {
    bool is_StandardBeacon { get; }
    Dafny.ISequence<char> dtor_name { get; }
    int dtor_length { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_loc { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconStyle> dtor_style { get; }
    _IStandardBeacon DowncastClone();
  }
  public class StandardBeacon : _IStandardBeacon {
    public readonly Dafny.ISequence<char> _name;
    public readonly int _length;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<char>> _loc;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconStyle> _style;
    public StandardBeacon(Dafny.ISequence<char> name, int length, Wrappers_Compile._IOption<Dafny.ISequence<char>> loc, Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconStyle> style) {
      this._name = name;
      this._length = length;
      this._loc = loc;
      this._style = style;
    }
    public _IStandardBeacon DowncastClone() {
      if (this is _IStandardBeacon dt) { return dt; }
      return new StandardBeacon(_name, _length, _loc, _style);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.StandardBeacon;
      return oth != null && object.Equals(this._name, oth._name) && this._length == oth._length && object.Equals(this._loc, oth._loc) && object.Equals(this._style, oth._style);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._name));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._length));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._loc));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._style));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.StandardBeacon.StandardBeacon";
      s += "(";
      s += Dafny.Helpers.ToString(this._name);
      s += ", ";
      s += Dafny.Helpers.ToString(this._length);
      s += ", ";
      s += Dafny.Helpers.ToString(this._loc);
      s += ", ";
      s += Dafny.Helpers.ToString(this._style);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IStandardBeacon theDefault = create(Dafny.Sequence<char>.Empty, 0, Wrappers_Compile.Option<Dafny.ISequence<char>>.Default(), Wrappers_Compile.Option<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconStyle>.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IStandardBeacon Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IStandardBeacon> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IStandardBeacon>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.StandardBeacon.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IStandardBeacon> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IStandardBeacon create(Dafny.ISequence<char> name, int length, Wrappers_Compile._IOption<Dafny.ISequence<char>> loc, Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconStyle> style) {
      return new StandardBeacon(name, length, loc, style);
    }
    public static _IStandardBeacon create_StandardBeacon(Dafny.ISequence<char> name, int length, Wrappers_Compile._IOption<Dafny.ISequence<char>> loc, Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconStyle> style) {
      return create(name, length, loc, style);
    }
    public bool is_StandardBeacon { get { return true; } }
    public Dafny.ISequence<char> dtor_name {
      get {
        return this._name;
      }
    }
    public int dtor_length {
      get {
        return this._length;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_loc {
      get {
        return this._loc;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconStyle> dtor_style {
      get {
        return this._style;
      }
    }
  }

  public partial class StandardBeaconList {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IStandardBeacon>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IStandardBeacon>>(Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IStandardBeacon>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IStandardBeacon>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IStandardBeacon> __source) {
      Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IStandardBeacon> _2_x = __source;
      return software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.__default.IsValid__StandardBeaconList(_2_x);
    }
  }

  public partial class TerminalLocation {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<char>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<char>>(Dafny.Sequence<char>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<char>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.ISequence<char> __source) {
      Dafny.ISequence<char> _3_x = __source;
      return software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.__default.IsValid__TerminalLocation(_3_x);
    }
  }

  public interface _IUpper {
    bool is_Upper { get; }
    _IUpper DowncastClone();
  }
  public class Upper : _IUpper {
    public Upper() {
    }
    public _IUpper DowncastClone() {
      if (this is _IUpper dt) { return dt; }
      return new Upper();
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Upper;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.Upper.Upper";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IUpper theDefault = create();
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IUpper Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IUpper> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IUpper>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Upper.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IUpper> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IUpper create() {
      return new Upper();
    }
    public static _IUpper create_Upper() {
      return create();
    }
    public bool is_Upper { get { return true; } }
    public static System.Collections.Generic.IEnumerable<_IUpper> AllSingletonConstructors {
      get {
        yield return Upper.create();
      }
    }
  }

  public partial class VersionNumber {
    private static readonly Dafny.TypeDescriptor<int> _TYPE = new Dafny.TypeDescriptor<int>(0);
    public static Dafny.TypeDescriptor<int> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(int __source) {
      int _4_x = (int)(__source);
      if (true) {
        return software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.__default.IsValid__VersionNumber(_4_x);
      }
      return false;
    }
  }

  public interface _IVirtualField {
    bool is_VirtualField { get; }
    Dafny.ISequence<char> dtor_name { get; }
    Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualPart> dtor_parts { get; }
    _IVirtualField DowncastClone();
  }
  public class VirtualField : _IVirtualField {
    public readonly Dafny.ISequence<char> _name;
    public readonly Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualPart> _parts;
    public VirtualField(Dafny.ISequence<char> name, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualPart> parts) {
      this._name = name;
      this._parts = parts;
    }
    public _IVirtualField DowncastClone() {
      if (this is _IVirtualField dt) { return dt; }
      return new VirtualField(_name, _parts);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.VirtualField;
      return oth != null && object.Equals(this._name, oth._name) && object.Equals(this._parts, oth._parts);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._name));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._parts));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.VirtualField.VirtualField";
      s += "(";
      s += Dafny.Helpers.ToString(this._name);
      s += ", ";
      s += Dafny.Helpers.ToString(this._parts);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualField theDefault = create(Dafny.Sequence<char>.Empty, Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualPart>.Empty);
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualField Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualField> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualField>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.VirtualField.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualField> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IVirtualField create(Dafny.ISequence<char> name, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualPart> parts) {
      return new VirtualField(name, parts);
    }
    public static _IVirtualField create_VirtualField(Dafny.ISequence<char> name, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualPart> parts) {
      return create(name, parts);
    }
    public bool is_VirtualField { get { return true; } }
    public Dafny.ISequence<char> dtor_name {
      get {
        return this._name;
      }
    }
    public Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualPart> dtor_parts {
      get {
        return this._parts;
      }
    }
  }

  public partial class VirtualFieldList {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualField>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualField>>(Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualField>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualField>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualField> __source) {
      Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualField> _5_x = __source;
      return software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.__default.IsValid__VirtualFieldList(_5_x);
    }
  }

  public interface _IVirtualPart {
    bool is_VirtualPart { get; }
    Dafny.ISequence<char> dtor_loc { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualTransform>> dtor_trans { get; }
    _IVirtualPart DowncastClone();
  }
  public class VirtualPart : _IVirtualPart {
    public readonly Dafny.ISequence<char> _loc;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualTransform>> _trans;
    public VirtualPart(Dafny.ISequence<char> loc, Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualTransform>> trans) {
      this._loc = loc;
      this._trans = trans;
    }
    public _IVirtualPart DowncastClone() {
      if (this is _IVirtualPart dt) { return dt; }
      return new VirtualPart(_loc, _trans);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.VirtualPart;
      return oth != null && object.Equals(this._loc, oth._loc) && object.Equals(this._trans, oth._trans);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._loc));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._trans));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.VirtualPart.VirtualPart";
      s += "(";
      s += Dafny.Helpers.ToString(this._loc);
      s += ", ";
      s += Dafny.Helpers.ToString(this._trans);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualPart theDefault = create(Dafny.Sequence<char>.Empty, Wrappers_Compile.Option<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualTransform>>.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualPart Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualPart> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualPart>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.VirtualPart.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualPart> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IVirtualPart create(Dafny.ISequence<char> loc, Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualTransform>> trans) {
      return new VirtualPart(loc, trans);
    }
    public static _IVirtualPart create_VirtualPart(Dafny.ISequence<char> loc, Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualTransform>> trans) {
      return create(loc, trans);
    }
    public bool is_VirtualPart { get { return true; } }
    public Dafny.ISequence<char> dtor_loc {
      get {
        return this._loc;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualTransform>> dtor_trans {
      get {
        return this._trans;
      }
    }
  }

  public partial class VirtualPartList {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualPart>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualPart>>(Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualPart>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualPart>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualPart> __source) {
      Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualPart> _6_x = __source;
      return software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.__default.IsValid__VirtualPartList(_6_x);
    }
  }

  public interface _IVirtualTransform {
    bool is_upper { get; }
    bool is_lower { get; }
    bool is_insert { get; }
    bool is_prefix { get; }
    bool is_suffix { get; }
    bool is_substring { get; }
    bool is_segment { get; }
    bool is_segments { get; }
    software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IUpper dtor_upper { get; }
    software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILower dtor_lower { get; }
    software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IInsert dtor_insert { get; }
    software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetPrefix dtor_prefix { get; }
    software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSuffix dtor_suffix { get; }
    software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSubstring dtor_substring { get; }
    software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSegment dtor_segment { get; }
    software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSegments dtor_segments { get; }
    _IVirtualTransform DowncastClone();
  }
  public abstract class VirtualTransform : _IVirtualTransform {
    public VirtualTransform() {
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualTransform theDefault = create_upper(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Upper.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualTransform Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualTransform> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualTransform>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.VirtualTransform.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualTransform> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IVirtualTransform create_upper(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IUpper upper) {
      return new VirtualTransform_upper(upper);
    }
    public static _IVirtualTransform create_lower(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILower lower) {
      return new VirtualTransform_lower(lower);
    }
    public static _IVirtualTransform create_insert(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IInsert insert) {
      return new VirtualTransform_insert(insert);
    }
    public static _IVirtualTransform create_prefix(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetPrefix prefix) {
      return new VirtualTransform_prefix(prefix);
    }
    public static _IVirtualTransform create_suffix(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSuffix suffix) {
      return new VirtualTransform_suffix(suffix);
    }
    public static _IVirtualTransform create_substring(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSubstring substring) {
      return new VirtualTransform_substring(substring);
    }
    public static _IVirtualTransform create_segment(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSegment segment) {
      return new VirtualTransform_segment(segment);
    }
    public static _IVirtualTransform create_segments(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSegments segments) {
      return new VirtualTransform_segments(segments);
    }
    public bool is_upper { get { return this is VirtualTransform_upper; } }
    public bool is_lower { get { return this is VirtualTransform_lower; } }
    public bool is_insert { get { return this is VirtualTransform_insert; } }
    public bool is_prefix { get { return this is VirtualTransform_prefix; } }
    public bool is_suffix { get { return this is VirtualTransform_suffix; } }
    public bool is_substring { get { return this is VirtualTransform_substring; } }
    public bool is_segment { get { return this is VirtualTransform_segment; } }
    public bool is_segments { get { return this is VirtualTransform_segments; } }
    public software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IUpper dtor_upper {
      get {
        var d = this;
        return ((VirtualTransform_upper)d)._upper;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILower dtor_lower {
      get {
        var d = this;
        return ((VirtualTransform_lower)d)._lower;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IInsert dtor_insert {
      get {
        var d = this;
        return ((VirtualTransform_insert)d)._insert;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetPrefix dtor_prefix {
      get {
        var d = this;
        return ((VirtualTransform_prefix)d)._prefix;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSuffix dtor_suffix {
      get {
        var d = this;
        return ((VirtualTransform_suffix)d)._suffix;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSubstring dtor_substring {
      get {
        var d = this;
        return ((VirtualTransform_substring)d)._substring;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSegment dtor_segment {
      get {
        var d = this;
        return ((VirtualTransform_segment)d)._segment;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSegments dtor_segments {
      get {
        var d = this;
        return ((VirtualTransform_segments)d)._segments;
      }
    }
    public abstract _IVirtualTransform DowncastClone();
  }
  public class VirtualTransform_upper : VirtualTransform {
    public readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IUpper _upper;
    public VirtualTransform_upper(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IUpper upper) : base() {
      this._upper = upper;
    }
    public override _IVirtualTransform DowncastClone() {
      if (this is _IVirtualTransform dt) { return dt; }
      return new VirtualTransform_upper(_upper);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.VirtualTransform_upper;
      return oth != null && object.Equals(this._upper, oth._upper);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._upper));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.VirtualTransform.upper";
      s += "(";
      s += Dafny.Helpers.ToString(this._upper);
      s += ")";
      return s;
    }
  }
  public class VirtualTransform_lower : VirtualTransform {
    public readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILower _lower;
    public VirtualTransform_lower(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILower lower) : base() {
      this._lower = lower;
    }
    public override _IVirtualTransform DowncastClone() {
      if (this is _IVirtualTransform dt) { return dt; }
      return new VirtualTransform_lower(_lower);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.VirtualTransform_lower;
      return oth != null && object.Equals(this._lower, oth._lower);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._lower));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.VirtualTransform.lower";
      s += "(";
      s += Dafny.Helpers.ToString(this._lower);
      s += ")";
      return s;
    }
  }
  public class VirtualTransform_insert : VirtualTransform {
    public readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IInsert _insert;
    public VirtualTransform_insert(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IInsert insert) : base() {
      this._insert = insert;
    }
    public override _IVirtualTransform DowncastClone() {
      if (this is _IVirtualTransform dt) { return dt; }
      return new VirtualTransform_insert(_insert);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.VirtualTransform_insert;
      return oth != null && object.Equals(this._insert, oth._insert);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._insert));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.VirtualTransform.insert";
      s += "(";
      s += Dafny.Helpers.ToString(this._insert);
      s += ")";
      return s;
    }
  }
  public class VirtualTransform_prefix : VirtualTransform {
    public readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetPrefix _prefix;
    public VirtualTransform_prefix(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetPrefix prefix) : base() {
      this._prefix = prefix;
    }
    public override _IVirtualTransform DowncastClone() {
      if (this is _IVirtualTransform dt) { return dt; }
      return new VirtualTransform_prefix(_prefix);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.VirtualTransform_prefix;
      return oth != null && object.Equals(this._prefix, oth._prefix);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 3;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._prefix));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.VirtualTransform.prefix";
      s += "(";
      s += Dafny.Helpers.ToString(this._prefix);
      s += ")";
      return s;
    }
  }
  public class VirtualTransform_suffix : VirtualTransform {
    public readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSuffix _suffix;
    public VirtualTransform_suffix(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSuffix suffix) : base() {
      this._suffix = suffix;
    }
    public override _IVirtualTransform DowncastClone() {
      if (this is _IVirtualTransform dt) { return dt; }
      return new VirtualTransform_suffix(_suffix);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.VirtualTransform_suffix;
      return oth != null && object.Equals(this._suffix, oth._suffix);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 4;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._suffix));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.VirtualTransform.suffix";
      s += "(";
      s += Dafny.Helpers.ToString(this._suffix);
      s += ")";
      return s;
    }
  }
  public class VirtualTransform_substring : VirtualTransform {
    public readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSubstring _substring;
    public VirtualTransform_substring(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSubstring substring) : base() {
      this._substring = substring;
    }
    public override _IVirtualTransform DowncastClone() {
      if (this is _IVirtualTransform dt) { return dt; }
      return new VirtualTransform_substring(_substring);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.VirtualTransform_substring;
      return oth != null && object.Equals(this._substring, oth._substring);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 5;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._substring));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.VirtualTransform.substring";
      s += "(";
      s += Dafny.Helpers.ToString(this._substring);
      s += ")";
      return s;
    }
  }
  public class VirtualTransform_segment : VirtualTransform {
    public readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSegment _segment;
    public VirtualTransform_segment(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSegment segment) : base() {
      this._segment = segment;
    }
    public override _IVirtualTransform DowncastClone() {
      if (this is _IVirtualTransform dt) { return dt; }
      return new VirtualTransform_segment(_segment);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.VirtualTransform_segment;
      return oth != null && object.Equals(this._segment, oth._segment);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 6;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._segment));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.VirtualTransform.segment";
      s += "(";
      s += Dafny.Helpers.ToString(this._segment);
      s += ")";
      return s;
    }
  }
  public class VirtualTransform_segments : VirtualTransform {
    public readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSegments _segments;
    public VirtualTransform_segments(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSegments segments) : base() {
      this._segments = segments;
    }
    public override _IVirtualTransform DowncastClone() {
      if (this is _IVirtualTransform dt) { return dt; }
      return new VirtualTransform_segments(_segments);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.VirtualTransform_segments;
      return oth != null && object.Equals(this._segments, oth._segments);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 7;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._segments));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.VirtualTransform.segments";
      s += "(";
      s += Dafny.Helpers.ToString(this._segments);
      s += ")";
      return s;
    }
  }

  public partial class VirtualTransformList {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualTransform>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualTransform>>(Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualTransform>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualTransform>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualTransform> __source) {
      Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualTransform> _7_x = __source;
      return software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.__default.IsValid__VirtualTransformList(_7_x);
    }
  }

  public interface _IError {
    bool is_DynamoDbEncryptionException { get; }
    bool is_AwsCryptographyDbEncryptionSdkStructuredEncryption { get; }
    bool is_AwsCryptographyMaterialProviders { get; }
    bool is_AwsCryptographyKeyStore { get; }
    bool is_AwsCryptographyPrimitives { get; }
    bool is_ComAmazonawsDynamodb { get; }
    bool is_CollectionOfErrors { get; }
    bool is_Opaque { get; }
    bool is_OpaqueWithText { get; }
    Dafny.ISequence<char> dtor_message { get; }
    software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError dtor_AwsCryptographyDbEncryptionSdkStructuredEncryption { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IError dtor_AwsCryptographyMaterialProviders { get; }
    software.amazon.cryptography.keystore.internaldafny.types._IError dtor_AwsCryptographyKeyStore { get; }
    software.amazon.cryptography.primitives.internaldafny.types._IError dtor_AwsCryptographyPrimitives { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IError dtor_ComAmazonawsDynamodb { get; }
    Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> dtor_list { get; }
    object dtor_obj { get; }
    Dafny.ISequence<char> dtor_objMessage { get; }
    _IError DowncastClone();
  }
  public abstract class Error : _IError {
    public Error() {
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError theDefault = create_DynamoDbEncryptionException(Dafny.Sequence<char>.Empty);
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Error.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IError create_DynamoDbEncryptionException(Dafny.ISequence<char> message) {
      return new Error_DynamoDbEncryptionException(message);
    }
    public static _IError create_AwsCryptographyDbEncryptionSdkStructuredEncryption(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError AwsCryptographyDbEncryptionSdkStructuredEncryption) {
      return new Error_AwsCryptographyDbEncryptionSdkStructuredEncryption(AwsCryptographyDbEncryptionSdkStructuredEncryption);
    }
    public static _IError create_AwsCryptographyMaterialProviders(software.amazon.cryptography.materialproviders.internaldafny.types._IError AwsCryptographyMaterialProviders) {
      return new Error_AwsCryptographyMaterialProviders(AwsCryptographyMaterialProviders);
    }
    public static _IError create_AwsCryptographyKeyStore(software.amazon.cryptography.keystore.internaldafny.types._IError AwsCryptographyKeyStore) {
      return new Error_AwsCryptographyKeyStore(AwsCryptographyKeyStore);
    }
    public static _IError create_AwsCryptographyPrimitives(software.amazon.cryptography.primitives.internaldafny.types._IError AwsCryptographyPrimitives) {
      return new Error_AwsCryptographyPrimitives(AwsCryptographyPrimitives);
    }
    public static _IError create_ComAmazonawsDynamodb(software.amazon.cryptography.services.dynamodb.internaldafny.types._IError ComAmazonawsDynamodb) {
      return new Error_ComAmazonawsDynamodb(ComAmazonawsDynamodb);
    }
    public static _IError create_CollectionOfErrors(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> list, Dafny.ISequence<char> message) {
      return new Error_CollectionOfErrors(list, message);
    }
    public static _IError create_Opaque(object obj) {
      return new Error_Opaque(obj);
    }
    public static _IError create_OpaqueWithText(object obj, Dafny.ISequence<char> objMessage) {
      return new Error_OpaqueWithText(obj, objMessage);
    }
    public bool is_DynamoDbEncryptionException { get { return this is Error_DynamoDbEncryptionException; } }
    public bool is_AwsCryptographyDbEncryptionSdkStructuredEncryption { get { return this is Error_AwsCryptographyDbEncryptionSdkStructuredEncryption; } }
    public bool is_AwsCryptographyMaterialProviders { get { return this is Error_AwsCryptographyMaterialProviders; } }
    public bool is_AwsCryptographyKeyStore { get { return this is Error_AwsCryptographyKeyStore; } }
    public bool is_AwsCryptographyPrimitives { get { return this is Error_AwsCryptographyPrimitives; } }
    public bool is_ComAmazonawsDynamodb { get { return this is Error_ComAmazonawsDynamodb; } }
    public bool is_CollectionOfErrors { get { return this is Error_CollectionOfErrors; } }
    public bool is_Opaque { get { return this is Error_Opaque; } }
    public bool is_OpaqueWithText { get { return this is Error_OpaqueWithText; } }
    public Dafny.ISequence<char> dtor_message {
      get {
        var d = this;
        if (d is Error_DynamoDbEncryptionException) { return ((Error_DynamoDbEncryptionException)d)._message; }
        return ((Error_CollectionOfErrors)d)._message;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError dtor_AwsCryptographyDbEncryptionSdkStructuredEncryption {
      get {
        var d = this;
        return ((Error_AwsCryptographyDbEncryptionSdkStructuredEncryption)d)._AwsCryptographyDbEncryptionSdkStructuredEncryption;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IError dtor_AwsCryptographyMaterialProviders {
      get {
        var d = this;
        return ((Error_AwsCryptographyMaterialProviders)d)._AwsCryptographyMaterialProviders;
      }
    }
    public software.amazon.cryptography.keystore.internaldafny.types._IError dtor_AwsCryptographyKeyStore {
      get {
        var d = this;
        return ((Error_AwsCryptographyKeyStore)d)._AwsCryptographyKeyStore;
      }
    }
    public software.amazon.cryptography.primitives.internaldafny.types._IError dtor_AwsCryptographyPrimitives {
      get {
        var d = this;
        return ((Error_AwsCryptographyPrimitives)d)._AwsCryptographyPrimitives;
      }
    }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IError dtor_ComAmazonawsDynamodb {
      get {
        var d = this;
        return ((Error_ComAmazonawsDynamodb)d)._ComAmazonawsDynamodb;
      }
    }
    public Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> dtor_list {
      get {
        var d = this;
        return ((Error_CollectionOfErrors)d)._list;
      }
    }
    public object dtor_obj {
      get {
        var d = this;
        if (d is Error_Opaque) { return ((Error_Opaque)d)._obj; }
        return ((Error_OpaqueWithText)d)._obj;
      }
    }
    public Dafny.ISequence<char> dtor_objMessage {
      get {
        var d = this;
        return ((Error_OpaqueWithText)d)._objMessage;
      }
    }
    public abstract _IError DowncastClone();
  }
  public class Error_DynamoDbEncryptionException : Error {
    public readonly Dafny.ISequence<char> _message;
    public Error_DynamoDbEncryptionException(Dafny.ISequence<char> message) : base() {
      this._message = message;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_DynamoDbEncryptionException(_message);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Error_DynamoDbEncryptionException;
      return oth != null && object.Equals(this._message, oth._message);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._message));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.Error.DynamoDbEncryptionException";
      s += "(";
      s += Dafny.Helpers.ToString(this._message);
      s += ")";
      return s;
    }
  }
  public class Error_AwsCryptographyDbEncryptionSdkStructuredEncryption : Error {
    public readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError _AwsCryptographyDbEncryptionSdkStructuredEncryption;
    public Error_AwsCryptographyDbEncryptionSdkStructuredEncryption(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError AwsCryptographyDbEncryptionSdkStructuredEncryption) : base() {
      this._AwsCryptographyDbEncryptionSdkStructuredEncryption = AwsCryptographyDbEncryptionSdkStructuredEncryption;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_AwsCryptographyDbEncryptionSdkStructuredEncryption(_AwsCryptographyDbEncryptionSdkStructuredEncryption);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Error_AwsCryptographyDbEncryptionSdkStructuredEncryption;
      return oth != null && object.Equals(this._AwsCryptographyDbEncryptionSdkStructuredEncryption, oth._AwsCryptographyDbEncryptionSdkStructuredEncryption);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._AwsCryptographyDbEncryptionSdkStructuredEncryption));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.Error.AwsCryptographyDbEncryptionSdkStructuredEncryption";
      s += "(";
      s += Dafny.Helpers.ToString(this._AwsCryptographyDbEncryptionSdkStructuredEncryption);
      s += ")";
      return s;
    }
  }
  public class Error_AwsCryptographyMaterialProviders : Error {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IError _AwsCryptographyMaterialProviders;
    public Error_AwsCryptographyMaterialProviders(software.amazon.cryptography.materialproviders.internaldafny.types._IError AwsCryptographyMaterialProviders) : base() {
      this._AwsCryptographyMaterialProviders = AwsCryptographyMaterialProviders;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_AwsCryptographyMaterialProviders(_AwsCryptographyMaterialProviders);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Error_AwsCryptographyMaterialProviders;
      return oth != null && object.Equals(this._AwsCryptographyMaterialProviders, oth._AwsCryptographyMaterialProviders);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._AwsCryptographyMaterialProviders));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.Error.AwsCryptographyMaterialProviders";
      s += "(";
      s += Dafny.Helpers.ToString(this._AwsCryptographyMaterialProviders);
      s += ")";
      return s;
    }
  }
  public class Error_AwsCryptographyKeyStore : Error {
    public readonly software.amazon.cryptography.keystore.internaldafny.types._IError _AwsCryptographyKeyStore;
    public Error_AwsCryptographyKeyStore(software.amazon.cryptography.keystore.internaldafny.types._IError AwsCryptographyKeyStore) : base() {
      this._AwsCryptographyKeyStore = AwsCryptographyKeyStore;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_AwsCryptographyKeyStore(_AwsCryptographyKeyStore);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Error_AwsCryptographyKeyStore;
      return oth != null && object.Equals(this._AwsCryptographyKeyStore, oth._AwsCryptographyKeyStore);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 3;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._AwsCryptographyKeyStore));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.Error.AwsCryptographyKeyStore";
      s += "(";
      s += Dafny.Helpers.ToString(this._AwsCryptographyKeyStore);
      s += ")";
      return s;
    }
  }
  public class Error_AwsCryptographyPrimitives : Error {
    public readonly software.amazon.cryptography.primitives.internaldafny.types._IError _AwsCryptographyPrimitives;
    public Error_AwsCryptographyPrimitives(software.amazon.cryptography.primitives.internaldafny.types._IError AwsCryptographyPrimitives) : base() {
      this._AwsCryptographyPrimitives = AwsCryptographyPrimitives;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_AwsCryptographyPrimitives(_AwsCryptographyPrimitives);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Error_AwsCryptographyPrimitives;
      return oth != null && object.Equals(this._AwsCryptographyPrimitives, oth._AwsCryptographyPrimitives);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 4;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._AwsCryptographyPrimitives));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.Error.AwsCryptographyPrimitives";
      s += "(";
      s += Dafny.Helpers.ToString(this._AwsCryptographyPrimitives);
      s += ")";
      return s;
    }
  }
  public class Error_ComAmazonawsDynamodb : Error {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IError _ComAmazonawsDynamodb;
    public Error_ComAmazonawsDynamodb(software.amazon.cryptography.services.dynamodb.internaldafny.types._IError ComAmazonawsDynamodb) : base() {
      this._ComAmazonawsDynamodb = ComAmazonawsDynamodb;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_ComAmazonawsDynamodb(_ComAmazonawsDynamodb);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Error_ComAmazonawsDynamodb;
      return oth != null && object.Equals(this._ComAmazonawsDynamodb, oth._ComAmazonawsDynamodb);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 5;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._ComAmazonawsDynamodb));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.Error.ComAmazonawsDynamodb";
      s += "(";
      s += Dafny.Helpers.ToString(this._ComAmazonawsDynamodb);
      s += ")";
      return s;
    }
  }
  public class Error_CollectionOfErrors : Error {
    public readonly Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _list;
    public readonly Dafny.ISequence<char> _message;
    public Error_CollectionOfErrors(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> list, Dafny.ISequence<char> message) : base() {
      this._list = list;
      this._message = message;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_CollectionOfErrors(_list, _message);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Error_CollectionOfErrors;
      return oth != null && object.Equals(this._list, oth._list) && object.Equals(this._message, oth._message);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 6;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._list));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._message));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.Error.CollectionOfErrors";
      s += "(";
      s += Dafny.Helpers.ToString(this._list);
      s += ", ";
      s += Dafny.Helpers.ToString(this._message);
      s += ")";
      return s;
    }
  }
  public class Error_Opaque : Error {
    public readonly object _obj;
    public Error_Opaque(object obj) : base() {
      this._obj = obj;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_Opaque(_obj);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Error_Opaque;
      return oth != null && this._obj == oth._obj;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 7;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._obj));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.Error.Opaque";
      s += "(";
      s += Dafny.Helpers.ToString(this._obj);
      s += ")";
      return s;
    }
  }
  public class Error_OpaqueWithText : Error {
    public readonly object _obj;
    public readonly Dafny.ISequence<char> _objMessage;
    public Error_OpaqueWithText(object obj, Dafny.ISequence<char> objMessage) : base() {
      this._obj = obj;
      this._objMessage = objMessage;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_OpaqueWithText(_obj, _objMessage);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Error_OpaqueWithText;
      return oth != null && this._obj == oth._obj && object.Equals(this._objMessage, oth._objMessage);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 8;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._obj));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._objMessage));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTypes.Error.OpaqueWithText";
      s += "(";
      s += Dafny.Helpers.ToString(this._obj);
      s += ", ";
      s += Dafny.Helpers.ToString(this._objMessage);
      s += ")";
      return s;
    }
  }

  public partial class OpaqueError {
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Error.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError __source) {
      software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError _8_e = __source;
      return ((_8_e).is_Opaque) || ((_8_e).is_OpaqueWithText);
    }
  }

  public partial class DummySubsetType {
    private static readonly BigInteger Witness = BigInteger.One;
    public static BigInteger Default() {
      return Witness;
    }
    private static readonly Dafny.TypeDescriptor<BigInteger> _TYPE = new Dafny.TypeDescriptor<BigInteger>(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.DummySubsetType.Default());
    public static Dafny.TypeDescriptor<BigInteger> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(BigInteger __source) {
      BigInteger _9_x = __source;
      return software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.__default.IsDummySubsetType(_9_x);
    }
  }
} // end of namespace software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types
namespace software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types {

  public partial class __default {
    public static bool IsDummySubsetType(BigInteger x) {
      return (x).Sign == 1;
    }
  }

  public interface _IDafnyCallEvent<I, O> {
    bool is_DafnyCallEvent { get; }
    I dtor_input { get; }
    O dtor_output { get; }
    _IDafnyCallEvent<__I, __O> DowncastClone<__I, __O>(Func<I, __I> converter0, Func<O, __O> converter1);
  }
  public class DafnyCallEvent<I, O> : _IDafnyCallEvent<I, O> {
    public readonly I _input;
    public readonly O _output;
    public DafnyCallEvent(I input, O output) {
      this._input = input;
      this._output = output;
    }
    public _IDafnyCallEvent<__I, __O> DowncastClone<__I, __O>(Func<I, __I> converter0, Func<O, __O> converter1) {
      if (this is _IDafnyCallEvent<__I, __O> dt) { return dt; }
      return new DafnyCallEvent<__I, __O>(converter0(_input), converter1(_output));
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.DafnyCallEvent<I, O>;
      return oth != null && object.Equals(this._input, oth._input) && object.Equals(this._output, oth._output);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._input));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._output));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes.DafnyCallEvent.DafnyCallEvent";
      s += "(";
      s += Dafny.Helpers.ToString(this._input);
      s += ", ";
      s += Dafny.Helpers.ToString(this._output);
      s += ")";
      return s;
    }
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDafnyCallEvent<I, O> Default(I _default_I, O _default_O) {
      return create(_default_I, _default_O);
    }
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDafnyCallEvent<I, O>> _TypeDescriptor(Dafny.TypeDescriptor<I> _td_I, Dafny.TypeDescriptor<O> _td_O) {
      return new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDafnyCallEvent<I, O>>(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.DafnyCallEvent<I, O>.Default(_td_I.Default(), _td_O.Default()));
    }
    public static _IDafnyCallEvent<I, O> create(I input, O output) {
      return new DafnyCallEvent<I, O>(input, output);
    }
    public static _IDafnyCallEvent<I, O> create_DafnyCallEvent(I input, O output) {
      return create(input, output);
    }
    public bool is_DafnyCallEvent { get { return true; } }
    public I dtor_input {
      get {
        return this._input;
      }
    }
    public O dtor_output {
      get {
        return this._output;
      }
    }
  }

  public interface _IDecryptItemInput {
    bool is_DecryptItemInput { get; }
    Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> dtor_encryptedItem { get; }
    _IDecryptItemInput DowncastClone();
  }
  public class DecryptItemInput : _IDecryptItemInput {
    public readonly Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _encryptedItem;
    public DecryptItemInput(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> encryptedItem) {
      this._encryptedItem = encryptedItem;
    }
    public _IDecryptItemInput DowncastClone() {
      if (this is _IDecryptItemInput dt) { return dt; }
      return new DecryptItemInput(_encryptedItem);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.DecryptItemInput;
      return oth != null && object.Equals(this._encryptedItem, oth._encryptedItem);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptedItem));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes.DecryptItemInput.DecryptItemInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._encryptedItem);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemInput theDefault = create(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemInput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.DecryptItemInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IDecryptItemInput create(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> encryptedItem) {
      return new DecryptItemInput(encryptedItem);
    }
    public static _IDecryptItemInput create_DecryptItemInput(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> encryptedItem) {
      return create(encryptedItem);
    }
    public bool is_DecryptItemInput { get { return true; } }
    public Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> dtor_encryptedItem {
      get {
        return this._encryptedItem;
      }
    }
  }

  public interface _IDecryptItemOutput {
    bool is_DecryptItemOutput { get; }
    Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> dtor_plaintextItem { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IParsedHeader> dtor_parsedHeader { get; }
    _IDecryptItemOutput DowncastClone();
  }
  public class DecryptItemOutput : _IDecryptItemOutput {
    public readonly Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _plaintextItem;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IParsedHeader> _parsedHeader;
    public DecryptItemOutput(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> plaintextItem, Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IParsedHeader> parsedHeader) {
      this._plaintextItem = plaintextItem;
      this._parsedHeader = parsedHeader;
    }
    public _IDecryptItemOutput DowncastClone() {
      if (this is _IDecryptItemOutput dt) { return dt; }
      return new DecryptItemOutput(_plaintextItem, _parsedHeader);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.DecryptItemOutput;
      return oth != null && object.Equals(this._plaintextItem, oth._plaintextItem) && object.Equals(this._parsedHeader, oth._parsedHeader);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._plaintextItem));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._parsedHeader));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes.DecryptItemOutput.DecryptItemOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._plaintextItem);
      s += ", ";
      s += Dafny.Helpers.ToString(this._parsedHeader);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput theDefault = create(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty, Wrappers_Compile.Option<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IParsedHeader>.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.DecryptItemOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IDecryptItemOutput create(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> plaintextItem, Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IParsedHeader> parsedHeader) {
      return new DecryptItemOutput(plaintextItem, parsedHeader);
    }
    public static _IDecryptItemOutput create_DecryptItemOutput(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> plaintextItem, Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IParsedHeader> parsedHeader) {
      return create(plaintextItem, parsedHeader);
    }
    public bool is_DecryptItemOutput { get { return true; } }
    public Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> dtor_plaintextItem {
      get {
        return this._plaintextItem;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IParsedHeader> dtor_parsedHeader {
      get {
        return this._parsedHeader;
      }
    }
  }

  public partial class IDynamoDbItemEncryptorClientCallHistory {
    public IDynamoDbItemEncryptorClientCallHistory() {
    }
  }

  public interface IDynamoDbItemEncryptorClient {
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> EncryptItem(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> DecryptItem(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemInput input);
  }
  public class _Companion_IDynamoDbItemEncryptorClient {
  }

  public interface _IDynamoDbItemEncryptorConfig {
    bool is_DynamoDbItemEncryptorConfig { get; }
    Dafny.ISequence<char> dtor_logicalTableName { get; }
    Dafny.ISequence<char> dtor_partitionKeyName { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_sortKeyName { get; }
    Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> dtor_attributeActionsOnEncrypt { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> dtor_allowedUnsignedAttributes { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_allowedUnsignedAttributePrefix { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> dtor_algorithmSuiteId { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> dtor_keyring { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager> dtor_cmm { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILegacyOverride> dtor_legacyOverride { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride> dtor_plaintextOverride { get; }
    _IDynamoDbItemEncryptorConfig DowncastClone();
  }
  public class DynamoDbItemEncryptorConfig : _IDynamoDbItemEncryptorConfig {
    public readonly Dafny.ISequence<char> _logicalTableName;
    public readonly Dafny.ISequence<char> _partitionKeyName;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<char>> _sortKeyName;
    public readonly Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> _attributeActionsOnEncrypt;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> _allowedUnsignedAttributes;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<char>> _allowedUnsignedAttributePrefix;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> _algorithmSuiteId;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> _keyring;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager> _cmm;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILegacyOverride> _legacyOverride;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride> _plaintextOverride;
    public DynamoDbItemEncryptorConfig(Dafny.ISequence<char> logicalTableName, Dafny.ISequence<char> partitionKeyName, Wrappers_Compile._IOption<Dafny.ISequence<char>> sortKeyName, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> attributeActionsOnEncrypt, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> allowedUnsignedAttributes, Wrappers_Compile._IOption<Dafny.ISequence<char>> allowedUnsignedAttributePrefix, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> algorithmSuiteId, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> keyring, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager> cmm, Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILegacyOverride> legacyOverride, Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride> plaintextOverride) {
      this._logicalTableName = logicalTableName;
      this._partitionKeyName = partitionKeyName;
      this._sortKeyName = sortKeyName;
      this._attributeActionsOnEncrypt = attributeActionsOnEncrypt;
      this._allowedUnsignedAttributes = allowedUnsignedAttributes;
      this._allowedUnsignedAttributePrefix = allowedUnsignedAttributePrefix;
      this._algorithmSuiteId = algorithmSuiteId;
      this._keyring = keyring;
      this._cmm = cmm;
      this._legacyOverride = legacyOverride;
      this._plaintextOverride = plaintextOverride;
    }
    public _IDynamoDbItemEncryptorConfig DowncastClone() {
      if (this is _IDynamoDbItemEncryptorConfig dt) { return dt; }
      return new DynamoDbItemEncryptorConfig(_logicalTableName, _partitionKeyName, _sortKeyName, _attributeActionsOnEncrypt, _allowedUnsignedAttributes, _allowedUnsignedAttributePrefix, _algorithmSuiteId, _keyring, _cmm, _legacyOverride, _plaintextOverride);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.DynamoDbItemEncryptorConfig;
      return oth != null && object.Equals(this._logicalTableName, oth._logicalTableName) && object.Equals(this._partitionKeyName, oth._partitionKeyName) && object.Equals(this._sortKeyName, oth._sortKeyName) && object.Equals(this._attributeActionsOnEncrypt, oth._attributeActionsOnEncrypt) && object.Equals(this._allowedUnsignedAttributes, oth._allowedUnsignedAttributes) && object.Equals(this._allowedUnsignedAttributePrefix, oth._allowedUnsignedAttributePrefix) && object.Equals(this._algorithmSuiteId, oth._algorithmSuiteId) && object.Equals(this._keyring, oth._keyring) && object.Equals(this._cmm, oth._cmm) && object.Equals(this._legacyOverride, oth._legacyOverride) && object.Equals(this._plaintextOverride, oth._plaintextOverride);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._logicalTableName));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._partitionKeyName));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sortKeyName));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._attributeActionsOnEncrypt));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._allowedUnsignedAttributes));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._allowedUnsignedAttributePrefix));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._algorithmSuiteId));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._keyring));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._cmm));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._legacyOverride));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._plaintextOverride));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes.DynamoDbItemEncryptorConfig.DynamoDbItemEncryptorConfig";
      s += "(";
      s += Dafny.Helpers.ToString(this._logicalTableName);
      s += ", ";
      s += Dafny.Helpers.ToString(this._partitionKeyName);
      s += ", ";
      s += Dafny.Helpers.ToString(this._sortKeyName);
      s += ", ";
      s += Dafny.Helpers.ToString(this._attributeActionsOnEncrypt);
      s += ", ";
      s += Dafny.Helpers.ToString(this._allowedUnsignedAttributes);
      s += ", ";
      s += Dafny.Helpers.ToString(this._allowedUnsignedAttributePrefix);
      s += ", ";
      s += Dafny.Helpers.ToString(this._algorithmSuiteId);
      s += ", ";
      s += Dafny.Helpers.ToString(this._keyring);
      s += ", ";
      s += Dafny.Helpers.ToString(this._cmm);
      s += ", ";
      s += Dafny.Helpers.ToString(this._legacyOverride);
      s += ", ";
      s += Dafny.Helpers.ToString(this._plaintextOverride);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDynamoDbItemEncryptorConfig theDefault = create(Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty, Wrappers_Compile.Option<Dafny.ISequence<char>>.Default(), Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Empty, Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.Default(), Wrappers_Compile.Option<Dafny.ISequence<char>>.Default(), Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId>.Default(), Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>.Default(), Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager>.Default(), Wrappers_Compile.Option<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILegacyOverride>.Default(), Wrappers_Compile.Option<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride>.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDynamoDbItemEncryptorConfig Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDynamoDbItemEncryptorConfig> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDynamoDbItemEncryptorConfig>(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.DynamoDbItemEncryptorConfig.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDynamoDbItemEncryptorConfig> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IDynamoDbItemEncryptorConfig create(Dafny.ISequence<char> logicalTableName, Dafny.ISequence<char> partitionKeyName, Wrappers_Compile._IOption<Dafny.ISequence<char>> sortKeyName, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> attributeActionsOnEncrypt, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> allowedUnsignedAttributes, Wrappers_Compile._IOption<Dafny.ISequence<char>> allowedUnsignedAttributePrefix, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> algorithmSuiteId, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> keyring, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager> cmm, Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILegacyOverride> legacyOverride, Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride> plaintextOverride) {
      return new DynamoDbItemEncryptorConfig(logicalTableName, partitionKeyName, sortKeyName, attributeActionsOnEncrypt, allowedUnsignedAttributes, allowedUnsignedAttributePrefix, algorithmSuiteId, keyring, cmm, legacyOverride, plaintextOverride);
    }
    public static _IDynamoDbItemEncryptorConfig create_DynamoDbItemEncryptorConfig(Dafny.ISequence<char> logicalTableName, Dafny.ISequence<char> partitionKeyName, Wrappers_Compile._IOption<Dafny.ISequence<char>> sortKeyName, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> attributeActionsOnEncrypt, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> allowedUnsignedAttributes, Wrappers_Compile._IOption<Dafny.ISequence<char>> allowedUnsignedAttributePrefix, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> algorithmSuiteId, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> keyring, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager> cmm, Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILegacyOverride> legacyOverride, Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride> plaintextOverride) {
      return create(logicalTableName, partitionKeyName, sortKeyName, attributeActionsOnEncrypt, allowedUnsignedAttributes, allowedUnsignedAttributePrefix, algorithmSuiteId, keyring, cmm, legacyOverride, plaintextOverride);
    }
    public bool is_DynamoDbItemEncryptorConfig { get { return true; } }
    public Dafny.ISequence<char> dtor_logicalTableName {
      get {
        return this._logicalTableName;
      }
    }
    public Dafny.ISequence<char> dtor_partitionKeyName {
      get {
        return this._partitionKeyName;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_sortKeyName {
      get {
        return this._sortKeyName;
      }
    }
    public Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> dtor_attributeActionsOnEncrypt {
      get {
        return this._attributeActionsOnEncrypt;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> dtor_allowedUnsignedAttributes {
      get {
        return this._allowedUnsignedAttributes;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_allowedUnsignedAttributePrefix {
      get {
        return this._allowedUnsignedAttributePrefix;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> dtor_algorithmSuiteId {
      get {
        return this._algorithmSuiteId;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring> dtor_keyring {
      get {
        return this._keyring;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager> dtor_cmm {
      get {
        return this._cmm;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILegacyOverride> dtor_legacyOverride {
      get {
        return this._legacyOverride;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride> dtor_plaintextOverride {
      get {
        return this._plaintextOverride;
      }
    }
  }

  public interface _IEncryptItemInput {
    bool is_EncryptItemInput { get; }
    Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> dtor_plaintextItem { get; }
    _IEncryptItemInput DowncastClone();
  }
  public class EncryptItemInput : _IEncryptItemInput {
    public readonly Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _plaintextItem;
    public EncryptItemInput(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> plaintextItem) {
      this._plaintextItem = plaintextItem;
    }
    public _IEncryptItemInput DowncastClone() {
      if (this is _IEncryptItemInput dt) { return dt; }
      return new EncryptItemInput(_plaintextItem);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.EncryptItemInput;
      return oth != null && object.Equals(this._plaintextItem, oth._plaintextItem);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._plaintextItem));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes.EncryptItemInput.EncryptItemInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._plaintextItem);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemInput theDefault = create(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemInput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.EncryptItemInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IEncryptItemInput create(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> plaintextItem) {
      return new EncryptItemInput(plaintextItem);
    }
    public static _IEncryptItemInput create_EncryptItemInput(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> plaintextItem) {
      return create(plaintextItem);
    }
    public bool is_EncryptItemInput { get { return true; } }
    public Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> dtor_plaintextItem {
      get {
        return this._plaintextItem;
      }
    }
  }

  public interface _IEncryptItemOutput {
    bool is_EncryptItemOutput { get; }
    Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> dtor_encryptedItem { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IParsedHeader> dtor_parsedHeader { get; }
    _IEncryptItemOutput DowncastClone();
  }
  public class EncryptItemOutput : _IEncryptItemOutput {
    public readonly Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _encryptedItem;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IParsedHeader> _parsedHeader;
    public EncryptItemOutput(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> encryptedItem, Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IParsedHeader> parsedHeader) {
      this._encryptedItem = encryptedItem;
      this._parsedHeader = parsedHeader;
    }
    public _IEncryptItemOutput DowncastClone() {
      if (this is _IEncryptItemOutput dt) { return dt; }
      return new EncryptItemOutput(_encryptedItem, _parsedHeader);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.EncryptItemOutput;
      return oth != null && object.Equals(this._encryptedItem, oth._encryptedItem) && object.Equals(this._parsedHeader, oth._parsedHeader);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptedItem));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._parsedHeader));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes.EncryptItemOutput.EncryptItemOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._encryptedItem);
      s += ", ";
      s += Dafny.Helpers.ToString(this._parsedHeader);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput theDefault = create(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty, Wrappers_Compile.Option<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IParsedHeader>.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.EncryptItemOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IEncryptItemOutput create(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> encryptedItem, Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IParsedHeader> parsedHeader) {
      return new EncryptItemOutput(encryptedItem, parsedHeader);
    }
    public static _IEncryptItemOutput create_EncryptItemOutput(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> encryptedItem, Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IParsedHeader> parsedHeader) {
      return create(encryptedItem, parsedHeader);
    }
    public bool is_EncryptItemOutput { get { return true; } }
    public Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> dtor_encryptedItem {
      get {
        return this._encryptedItem;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IParsedHeader> dtor_parsedHeader {
      get {
        return this._parsedHeader;
      }
    }
  }

  public interface _IParsedHeader {
    bool is_ParsedHeader { get; }
    Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> dtor_attributeActionsOnEncrypt { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId dtor_algorithmSuiteId { get; }
    Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> dtor_encryptedDataKeys { get; }
    Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_storedEncryptionContext { get; }
    Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext { get; }
    Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> dtor_selectorContext { get; }
    _IParsedHeader DowncastClone();
  }
  public class ParsedHeader : _IParsedHeader {
    public readonly Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> _attributeActionsOnEncrypt;
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId _algorithmSuiteId;
    public readonly Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> _encryptedDataKeys;
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _storedEncryptionContext;
    public readonly Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _encryptionContext;
    public readonly Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _selectorContext;
    public ParsedHeader(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> attributeActionsOnEncrypt, software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId algorithmSuiteId, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> encryptedDataKeys, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> storedEncryptionContext, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> selectorContext) {
      this._attributeActionsOnEncrypt = attributeActionsOnEncrypt;
      this._algorithmSuiteId = algorithmSuiteId;
      this._encryptedDataKeys = encryptedDataKeys;
      this._storedEncryptionContext = storedEncryptionContext;
      this._encryptionContext = encryptionContext;
      this._selectorContext = selectorContext;
    }
    public _IParsedHeader DowncastClone() {
      if (this is _IParsedHeader dt) { return dt; }
      return new ParsedHeader(_attributeActionsOnEncrypt, _algorithmSuiteId, _encryptedDataKeys, _storedEncryptionContext, _encryptionContext, _selectorContext);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.ParsedHeader;
      return oth != null && object.Equals(this._attributeActionsOnEncrypt, oth._attributeActionsOnEncrypt) && object.Equals(this._algorithmSuiteId, oth._algorithmSuiteId) && object.Equals(this._encryptedDataKeys, oth._encryptedDataKeys) && object.Equals(this._storedEncryptionContext, oth._storedEncryptionContext) && object.Equals(this._encryptionContext, oth._encryptionContext) && object.Equals(this._selectorContext, oth._selectorContext);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._attributeActionsOnEncrypt));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._algorithmSuiteId));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptedDataKeys));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._storedEncryptionContext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptionContext));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._selectorContext));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes.ParsedHeader.ParsedHeader";
      s += "(";
      s += Dafny.Helpers.ToString(this._attributeActionsOnEncrypt);
      s += ", ";
      s += Dafny.Helpers.ToString(this._algorithmSuiteId);
      s += ", ";
      s += Dafny.Helpers.ToString(this._encryptedDataKeys);
      s += ", ";
      s += Dafny.Helpers.ToString(this._storedEncryptionContext);
      s += ", ";
      s += Dafny.Helpers.ToString(this._encryptionContext);
      s += ", ";
      s += Dafny.Helpers.ToString(this._selectorContext);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IParsedHeader theDefault = create(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Empty, software.amazon.cryptography.materialproviders.internaldafny.types.DBEAlgorithmSuiteId.Default(), Dafny.Sequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey>.Empty, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty, Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IParsedHeader Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IParsedHeader> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IParsedHeader>(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.ParsedHeader.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IParsedHeader> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IParsedHeader create(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> attributeActionsOnEncrypt, software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId algorithmSuiteId, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> encryptedDataKeys, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> storedEncryptionContext, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> selectorContext) {
      return new ParsedHeader(attributeActionsOnEncrypt, algorithmSuiteId, encryptedDataKeys, storedEncryptionContext, encryptionContext, selectorContext);
    }
    public static _IParsedHeader create_ParsedHeader(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> attributeActionsOnEncrypt, software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId algorithmSuiteId, Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> encryptedDataKeys, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> storedEncryptionContext, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> encryptionContext, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> selectorContext) {
      return create(attributeActionsOnEncrypt, algorithmSuiteId, encryptedDataKeys, storedEncryptionContext, encryptionContext, selectorContext);
    }
    public bool is_ParsedHeader { get { return true; } }
    public Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> dtor_attributeActionsOnEncrypt {
      get {
        return this._attributeActionsOnEncrypt;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId dtor_algorithmSuiteId {
      get {
        return this._algorithmSuiteId;
      }
    }
    public Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> dtor_encryptedDataKeys {
      get {
        return this._encryptedDataKeys;
      }
    }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_storedEncryptionContext {
      get {
        return this._storedEncryptionContext;
      }
    }
    public Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> dtor_encryptionContext {
      get {
        return this._encryptionContext;
      }
    }
    public Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> dtor_selectorContext {
      get {
        return this._selectorContext;
      }
    }
  }

  public interface _IError {
    bool is_DynamoDbItemEncryptorException { get; }
    bool is_AwsCryptographyDbEncryptionSdkDynamoDb { get; }
    bool is_AwsCryptographyDbEncryptionSdkStructuredEncryption { get; }
    bool is_AwsCryptographyMaterialProviders { get; }
    bool is_AwsCryptographyPrimitives { get; }
    bool is_ComAmazonawsDynamodb { get; }
    bool is_CollectionOfErrors { get; }
    bool is_Opaque { get; }
    bool is_OpaqueWithText { get; }
    Dafny.ISequence<char> dtor_message { get; }
    software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError dtor_AwsCryptographyDbEncryptionSdkDynamoDb { get; }
    software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError dtor_AwsCryptographyDbEncryptionSdkStructuredEncryption { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IError dtor_AwsCryptographyMaterialProviders { get; }
    software.amazon.cryptography.primitives.internaldafny.types._IError dtor_AwsCryptographyPrimitives { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IError dtor_ComAmazonawsDynamodb { get; }
    Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> dtor_list { get; }
    object dtor_obj { get; }
    Dafny.ISequence<char> dtor_objMessage { get; }
    _IError DowncastClone();
  }
  public abstract class Error : _IError {
    public Error() {
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError theDefault = create_DynamoDbItemEncryptorException(Dafny.Sequence<char>.Empty);
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IError create_DynamoDbItemEncryptorException(Dafny.ISequence<char> message) {
      return new Error_DynamoDbItemEncryptorException(message);
    }
    public static _IError create_AwsCryptographyDbEncryptionSdkDynamoDb(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError AwsCryptographyDbEncryptionSdkDynamoDb) {
      return new Error_AwsCryptographyDbEncryptionSdkDynamoDb(AwsCryptographyDbEncryptionSdkDynamoDb);
    }
    public static _IError create_AwsCryptographyDbEncryptionSdkStructuredEncryption(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError AwsCryptographyDbEncryptionSdkStructuredEncryption) {
      return new Error_AwsCryptographyDbEncryptionSdkStructuredEncryption(AwsCryptographyDbEncryptionSdkStructuredEncryption);
    }
    public static _IError create_AwsCryptographyMaterialProviders(software.amazon.cryptography.materialproviders.internaldafny.types._IError AwsCryptographyMaterialProviders) {
      return new Error_AwsCryptographyMaterialProviders(AwsCryptographyMaterialProviders);
    }
    public static _IError create_AwsCryptographyPrimitives(software.amazon.cryptography.primitives.internaldafny.types._IError AwsCryptographyPrimitives) {
      return new Error_AwsCryptographyPrimitives(AwsCryptographyPrimitives);
    }
    public static _IError create_ComAmazonawsDynamodb(software.amazon.cryptography.services.dynamodb.internaldafny.types._IError ComAmazonawsDynamodb) {
      return new Error_ComAmazonawsDynamodb(ComAmazonawsDynamodb);
    }
    public static _IError create_CollectionOfErrors(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> list, Dafny.ISequence<char> message) {
      return new Error_CollectionOfErrors(list, message);
    }
    public static _IError create_Opaque(object obj) {
      return new Error_Opaque(obj);
    }
    public static _IError create_OpaqueWithText(object obj, Dafny.ISequence<char> objMessage) {
      return new Error_OpaqueWithText(obj, objMessage);
    }
    public bool is_DynamoDbItemEncryptorException { get { return this is Error_DynamoDbItemEncryptorException; } }
    public bool is_AwsCryptographyDbEncryptionSdkDynamoDb { get { return this is Error_AwsCryptographyDbEncryptionSdkDynamoDb; } }
    public bool is_AwsCryptographyDbEncryptionSdkStructuredEncryption { get { return this is Error_AwsCryptographyDbEncryptionSdkStructuredEncryption; } }
    public bool is_AwsCryptographyMaterialProviders { get { return this is Error_AwsCryptographyMaterialProviders; } }
    public bool is_AwsCryptographyPrimitives { get { return this is Error_AwsCryptographyPrimitives; } }
    public bool is_ComAmazonawsDynamodb { get { return this is Error_ComAmazonawsDynamodb; } }
    public bool is_CollectionOfErrors { get { return this is Error_CollectionOfErrors; } }
    public bool is_Opaque { get { return this is Error_Opaque; } }
    public bool is_OpaqueWithText { get { return this is Error_OpaqueWithText; } }
    public Dafny.ISequence<char> dtor_message {
      get {
        var d = this;
        if (d is Error_DynamoDbItemEncryptorException) { return ((Error_DynamoDbItemEncryptorException)d)._message; }
        return ((Error_CollectionOfErrors)d)._message;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError dtor_AwsCryptographyDbEncryptionSdkDynamoDb {
      get {
        var d = this;
        return ((Error_AwsCryptographyDbEncryptionSdkDynamoDb)d)._AwsCryptographyDbEncryptionSdkDynamoDb;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError dtor_AwsCryptographyDbEncryptionSdkStructuredEncryption {
      get {
        var d = this;
        return ((Error_AwsCryptographyDbEncryptionSdkStructuredEncryption)d)._AwsCryptographyDbEncryptionSdkStructuredEncryption;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IError dtor_AwsCryptographyMaterialProviders {
      get {
        var d = this;
        return ((Error_AwsCryptographyMaterialProviders)d)._AwsCryptographyMaterialProviders;
      }
    }
    public software.amazon.cryptography.primitives.internaldafny.types._IError dtor_AwsCryptographyPrimitives {
      get {
        var d = this;
        return ((Error_AwsCryptographyPrimitives)d)._AwsCryptographyPrimitives;
      }
    }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IError dtor_ComAmazonawsDynamodb {
      get {
        var d = this;
        return ((Error_ComAmazonawsDynamodb)d)._ComAmazonawsDynamodb;
      }
    }
    public Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> dtor_list {
      get {
        var d = this;
        return ((Error_CollectionOfErrors)d)._list;
      }
    }
    public object dtor_obj {
      get {
        var d = this;
        if (d is Error_Opaque) { return ((Error_Opaque)d)._obj; }
        return ((Error_OpaqueWithText)d)._obj;
      }
    }
    public Dafny.ISequence<char> dtor_objMessage {
      get {
        var d = this;
        return ((Error_OpaqueWithText)d)._objMessage;
      }
    }
    public abstract _IError DowncastClone();
  }
  public class Error_DynamoDbItemEncryptorException : Error {
    public readonly Dafny.ISequence<char> _message;
    public Error_DynamoDbItemEncryptorException(Dafny.ISequence<char> message) : base() {
      this._message = message;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_DynamoDbItemEncryptorException(_message);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error_DynamoDbItemEncryptorException;
      return oth != null && object.Equals(this._message, oth._message);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._message));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes.Error.DynamoDbItemEncryptorException";
      s += "(";
      s += Dafny.Helpers.ToString(this._message);
      s += ")";
      return s;
    }
  }
  public class Error_AwsCryptographyDbEncryptionSdkDynamoDb : Error {
    public readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError _AwsCryptographyDbEncryptionSdkDynamoDb;
    public Error_AwsCryptographyDbEncryptionSdkDynamoDb(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError AwsCryptographyDbEncryptionSdkDynamoDb) : base() {
      this._AwsCryptographyDbEncryptionSdkDynamoDb = AwsCryptographyDbEncryptionSdkDynamoDb;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_AwsCryptographyDbEncryptionSdkDynamoDb(_AwsCryptographyDbEncryptionSdkDynamoDb);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error_AwsCryptographyDbEncryptionSdkDynamoDb;
      return oth != null && object.Equals(this._AwsCryptographyDbEncryptionSdkDynamoDb, oth._AwsCryptographyDbEncryptionSdkDynamoDb);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._AwsCryptographyDbEncryptionSdkDynamoDb));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes.Error.AwsCryptographyDbEncryptionSdkDynamoDb";
      s += "(";
      s += Dafny.Helpers.ToString(this._AwsCryptographyDbEncryptionSdkDynamoDb);
      s += ")";
      return s;
    }
  }
  public class Error_AwsCryptographyDbEncryptionSdkStructuredEncryption : Error {
    public readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError _AwsCryptographyDbEncryptionSdkStructuredEncryption;
    public Error_AwsCryptographyDbEncryptionSdkStructuredEncryption(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError AwsCryptographyDbEncryptionSdkStructuredEncryption) : base() {
      this._AwsCryptographyDbEncryptionSdkStructuredEncryption = AwsCryptographyDbEncryptionSdkStructuredEncryption;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_AwsCryptographyDbEncryptionSdkStructuredEncryption(_AwsCryptographyDbEncryptionSdkStructuredEncryption);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error_AwsCryptographyDbEncryptionSdkStructuredEncryption;
      return oth != null && object.Equals(this._AwsCryptographyDbEncryptionSdkStructuredEncryption, oth._AwsCryptographyDbEncryptionSdkStructuredEncryption);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._AwsCryptographyDbEncryptionSdkStructuredEncryption));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes.Error.AwsCryptographyDbEncryptionSdkStructuredEncryption";
      s += "(";
      s += Dafny.Helpers.ToString(this._AwsCryptographyDbEncryptionSdkStructuredEncryption);
      s += ")";
      return s;
    }
  }
  public class Error_AwsCryptographyMaterialProviders : Error {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IError _AwsCryptographyMaterialProviders;
    public Error_AwsCryptographyMaterialProviders(software.amazon.cryptography.materialproviders.internaldafny.types._IError AwsCryptographyMaterialProviders) : base() {
      this._AwsCryptographyMaterialProviders = AwsCryptographyMaterialProviders;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_AwsCryptographyMaterialProviders(_AwsCryptographyMaterialProviders);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error_AwsCryptographyMaterialProviders;
      return oth != null && object.Equals(this._AwsCryptographyMaterialProviders, oth._AwsCryptographyMaterialProviders);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 3;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._AwsCryptographyMaterialProviders));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes.Error.AwsCryptographyMaterialProviders";
      s += "(";
      s += Dafny.Helpers.ToString(this._AwsCryptographyMaterialProviders);
      s += ")";
      return s;
    }
  }
  public class Error_AwsCryptographyPrimitives : Error {
    public readonly software.amazon.cryptography.primitives.internaldafny.types._IError _AwsCryptographyPrimitives;
    public Error_AwsCryptographyPrimitives(software.amazon.cryptography.primitives.internaldafny.types._IError AwsCryptographyPrimitives) : base() {
      this._AwsCryptographyPrimitives = AwsCryptographyPrimitives;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_AwsCryptographyPrimitives(_AwsCryptographyPrimitives);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error_AwsCryptographyPrimitives;
      return oth != null && object.Equals(this._AwsCryptographyPrimitives, oth._AwsCryptographyPrimitives);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 4;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._AwsCryptographyPrimitives));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes.Error.AwsCryptographyPrimitives";
      s += "(";
      s += Dafny.Helpers.ToString(this._AwsCryptographyPrimitives);
      s += ")";
      return s;
    }
  }
  public class Error_ComAmazonawsDynamodb : Error {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IError _ComAmazonawsDynamodb;
    public Error_ComAmazonawsDynamodb(software.amazon.cryptography.services.dynamodb.internaldafny.types._IError ComAmazonawsDynamodb) : base() {
      this._ComAmazonawsDynamodb = ComAmazonawsDynamodb;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_ComAmazonawsDynamodb(_ComAmazonawsDynamodb);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error_ComAmazonawsDynamodb;
      return oth != null && object.Equals(this._ComAmazonawsDynamodb, oth._ComAmazonawsDynamodb);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 5;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._ComAmazonawsDynamodb));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes.Error.ComAmazonawsDynamodb";
      s += "(";
      s += Dafny.Helpers.ToString(this._ComAmazonawsDynamodb);
      s += ")";
      return s;
    }
  }
  public class Error_CollectionOfErrors : Error {
    public readonly Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _list;
    public readonly Dafny.ISequence<char> _message;
    public Error_CollectionOfErrors(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> list, Dafny.ISequence<char> message) : base() {
      this._list = list;
      this._message = message;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_CollectionOfErrors(_list, _message);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error_CollectionOfErrors;
      return oth != null && object.Equals(this._list, oth._list) && object.Equals(this._message, oth._message);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 6;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._list));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._message));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes.Error.CollectionOfErrors";
      s += "(";
      s += Dafny.Helpers.ToString(this._list);
      s += ", ";
      s += Dafny.Helpers.ToString(this._message);
      s += ")";
      return s;
    }
  }
  public class Error_Opaque : Error {
    public readonly object _obj;
    public Error_Opaque(object obj) : base() {
      this._obj = obj;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_Opaque(_obj);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error_Opaque;
      return oth != null && this._obj == oth._obj;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 7;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._obj));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes.Error.Opaque";
      s += "(";
      s += Dafny.Helpers.ToString(this._obj);
      s += ")";
      return s;
    }
  }
  public class Error_OpaqueWithText : Error {
    public readonly object _obj;
    public readonly Dafny.ISequence<char> _objMessage;
    public Error_OpaqueWithText(object obj, Dafny.ISequence<char> objMessage) : base() {
      this._obj = obj;
      this._objMessage = objMessage;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_OpaqueWithText(_obj, _objMessage);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error_OpaqueWithText;
      return oth != null && this._obj == oth._obj && object.Equals(this._objMessage, oth._objMessage);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 8;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._obj));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._objMessage));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes.Error.OpaqueWithText";
      s += "(";
      s += Dafny.Helpers.ToString(this._obj);
      s += ", ";
      s += Dafny.Helpers.ToString(this._objMessage);
      s += ")";
      return s;
    }
  }

  public partial class OpaqueError {
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError __source) {
      software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError _0_e = __source;
      return ((_0_e).is_Opaque) || ((_0_e).is_OpaqueWithText);
    }
  }

  public partial class DummySubsetType {
    private static readonly BigInteger Witness = BigInteger.One;
    public static BigInteger Default() {
      return Witness;
    }
    private static readonly Dafny.TypeDescriptor<BigInteger> _TYPE = new Dafny.TypeDescriptor<BigInteger>(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.DummySubsetType.Default());
    public static Dafny.TypeDescriptor<BigInteger> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(BigInteger __source) {
      BigInteger _1_x = __source;
      return software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.__default.IsDummySubsetType(_1_x);
    }
  }
} // end of namespace software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types
namespace DynamoDbEncryptionUtil_Compile {

  public partial class __default {
    public static DynamoDbEncryptionUtil_Compile._IMaybeKeyId MaybeFromOptionKeyId(Wrappers_Compile._IOption<Dafny.ISequence<char>> x) {
      if ((x).is_Some) {
        return DynamoDbEncryptionUtil_Compile.MaybeKeyId.create_KeyId((x).dtor_value);
      } else {
        return DynamoDbEncryptionUtil_Compile.MaybeKeyId.create_DontUseKeyId();
      }
    }
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError E(Dafny.ISequence<char> s) {
      return software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Error.create_DynamoDbEncryptionException(s);
    }
    public static bool CharLess(char x, char y)
    {
      return (x) < (y);
    }
    public static bool ByteLess(byte x, byte y)
    {
      return (x) < (y);
    }
    public static Dafny.ISequence<char> AttrTypeToStr(software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue attr) {
      software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue _source0 = attr;
      {
        if (_source0.is_S) {
          Dafny.ISequence<char> _0_s = _source0.dtor_S;
          return Dafny.Sequence<char>.FromString("S");
        }
      }
      {
        if (_source0.is_N) {
          Dafny.ISequence<char> _1_n = _source0.dtor_N;
          return Dafny.Sequence<char>.FromString("N");
        }
      }
      {
        if (_source0.is_B) {
          Dafny.ISequence<byte> _2_n = _source0.dtor_B;
          return Dafny.Sequence<char>.FromString("B");
        }
      }
      {
        if (_source0.is_SS) {
          Dafny.ISequence<Dafny.ISequence<char>> _3_n = _source0.dtor_SS;
          return Dafny.Sequence<char>.FromString("SS");
        }
      }
      {
        if (_source0.is_NS) {
          Dafny.ISequence<Dafny.ISequence<char>> _4_n = _source0.dtor_NS;
          return Dafny.Sequence<char>.FromString("NS");
        }
      }
      {
        if (_source0.is_BS) {
          Dafny.ISequence<Dafny.ISequence<byte>> _5_n = _source0.dtor_BS;
          return Dafny.Sequence<char>.FromString("BS");
        }
      }
      {
        if (_source0.is_M) {
          Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _6_n = _source0.dtor_M;
          return Dafny.Sequence<char>.FromString("M");
        }
      }
      {
        if (_source0.is_L) {
          Dafny.ISequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _7_n = _source0.dtor_L;
          return Dafny.Sequence<char>.FromString("L");
        }
      }
      {
        if (_source0.is_NULL) {
          bool _8_n = _source0.dtor_NULL;
          return Dafny.Sequence<char>.FromString("NULL");
        }
      }
      {
        bool _9_n = _source0.dtor_BOOL;
        return Dafny.Sequence<char>.FromString("BOOL");
      }
    }
    public static _System._ITuple0 printFromFunction<__T>(__T x)
    {
      _System._ITuple0 _hresult = _System.Tuple0.Default();
      Dafny.Helpers.Print((x));
      Dafny.Helpers.Print((Dafny.Sequence<char>.FromString("\n")));
      _hresult = _System.Tuple0.create();
      return _hresult;
      return _hresult;
    }
    public static Dafny.ISequence<char> ReservedPrefix { get {
      return Dafny.Sequence<char>.FromString("aws_dbe_");
    } }
    public static Dafny.ISequence<char> BeaconPrefix { get {
      return Dafny.Sequence<char>.FromString("aws_dbe_b_");
    } }
    public static Dafny.ISequence<char> VersionPrefix { get {
      return Dafny.Sequence<char>.FromString("aws_dbe_v_");
    } }
    public static BigInteger MAX__STRUCTURE__DEPTH { get {
      return new BigInteger(32);
    } }
    public static Dafny.ISequence<char> MAX__STRUCTURE__DEPTH__STR { get {
      return Dafny.Sequence<char>.FromString("32");
    } }
  }

  public interface _IMaybeKeyMap {
    bool is_DontUseKeys { get; }
    bool is_ShouldHaveKeys { get; }
    bool is_Keys { get; }
    Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>> dtor_value { get; }
    _IMaybeKeyMap DowncastClone();
  }
  public abstract class MaybeKeyMap : _IMaybeKeyMap {
    public MaybeKeyMap() {
    }
    private static readonly DynamoDbEncryptionUtil_Compile._IMaybeKeyMap theDefault = create_DontUseKeys();
    public static DynamoDbEncryptionUtil_Compile._IMaybeKeyMap Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<DynamoDbEncryptionUtil_Compile._IMaybeKeyMap> _TYPE = new Dafny.TypeDescriptor<DynamoDbEncryptionUtil_Compile._IMaybeKeyMap>(DynamoDbEncryptionUtil_Compile.MaybeKeyMap.Default());
    public static Dafny.TypeDescriptor<DynamoDbEncryptionUtil_Compile._IMaybeKeyMap> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IMaybeKeyMap create_DontUseKeys() {
      return new MaybeKeyMap_DontUseKeys();
    }
    public static _IMaybeKeyMap create_ShouldHaveKeys() {
      return new MaybeKeyMap_ShouldHaveKeys();
    }
    public static _IMaybeKeyMap create_Keys(Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>> @value) {
      return new MaybeKeyMap_Keys(@value);
    }
    public bool is_DontUseKeys { get { return this is MaybeKeyMap_DontUseKeys; } }
    public bool is_ShouldHaveKeys { get { return this is MaybeKeyMap_ShouldHaveKeys; } }
    public bool is_Keys { get { return this is MaybeKeyMap_Keys; } }
    public Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>> dtor_value {
      get {
        var d = this;
        return ((MaybeKeyMap_Keys)d)._value;
      }
    }
    public abstract _IMaybeKeyMap DowncastClone();
  }
  public class MaybeKeyMap_DontUseKeys : MaybeKeyMap {
    public MaybeKeyMap_DontUseKeys() : base() {
    }
    public override _IMaybeKeyMap DowncastClone() {
      if (this is _IMaybeKeyMap dt) { return dt; }
      return new MaybeKeyMap_DontUseKeys();
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDbEncryptionUtil_Compile.MaybeKeyMap_DontUseKeys;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "DynamoDbEncryptionUtil.MaybeKeyMap.DontUseKeys";
      return s;
    }
  }
  public class MaybeKeyMap_ShouldHaveKeys : MaybeKeyMap {
    public MaybeKeyMap_ShouldHaveKeys() : base() {
    }
    public override _IMaybeKeyMap DowncastClone() {
      if (this is _IMaybeKeyMap dt) { return dt; }
      return new MaybeKeyMap_ShouldHaveKeys();
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDbEncryptionUtil_Compile.MaybeKeyMap_ShouldHaveKeys;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "DynamoDbEncryptionUtil.MaybeKeyMap.ShouldHaveKeys";
      return s;
    }
  }
  public class MaybeKeyMap_Keys : MaybeKeyMap {
    public readonly Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>> _value;
    public MaybeKeyMap_Keys(Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>> @value) : base() {
      this._value = @value;
    }
    public override _IMaybeKeyMap DowncastClone() {
      if (this is _IMaybeKeyMap dt) { return dt; }
      return new MaybeKeyMap_Keys(_value);
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDbEncryptionUtil_Compile.MaybeKeyMap_Keys;
      return oth != null && object.Equals(this._value, oth._value);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._value));
      return (int) hash;
    }
    public override string ToString() {
      string s = "DynamoDbEncryptionUtil.MaybeKeyMap.Keys";
      s += "(";
      s += Dafny.Helpers.ToString(this._value);
      s += ")";
      return s;
    }
  }

  public interface _IMaybeKeyId {
    bool is_DontUseKeyId { get; }
    bool is_ShouldHaveKeyId { get; }
    bool is_KeyId { get; }
    Dafny.ISequence<char> dtor_value { get; }
    _IMaybeKeyId DowncastClone();
  }
  public abstract class MaybeKeyId : _IMaybeKeyId {
    public MaybeKeyId() {
    }
    private static readonly DynamoDbEncryptionUtil_Compile._IMaybeKeyId theDefault = create_DontUseKeyId();
    public static DynamoDbEncryptionUtil_Compile._IMaybeKeyId Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<DynamoDbEncryptionUtil_Compile._IMaybeKeyId> _TYPE = new Dafny.TypeDescriptor<DynamoDbEncryptionUtil_Compile._IMaybeKeyId>(DynamoDbEncryptionUtil_Compile.MaybeKeyId.Default());
    public static Dafny.TypeDescriptor<DynamoDbEncryptionUtil_Compile._IMaybeKeyId> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IMaybeKeyId create_DontUseKeyId() {
      return new MaybeKeyId_DontUseKeyId();
    }
    public static _IMaybeKeyId create_ShouldHaveKeyId() {
      return new MaybeKeyId_ShouldHaveKeyId();
    }
    public static _IMaybeKeyId create_KeyId(Dafny.ISequence<char> @value) {
      return new MaybeKeyId_KeyId(@value);
    }
    public bool is_DontUseKeyId { get { return this is MaybeKeyId_DontUseKeyId; } }
    public bool is_ShouldHaveKeyId { get { return this is MaybeKeyId_ShouldHaveKeyId; } }
    public bool is_KeyId { get { return this is MaybeKeyId_KeyId; } }
    public Dafny.ISequence<char> dtor_value {
      get {
        var d = this;
        return ((MaybeKeyId_KeyId)d)._value;
      }
    }
    public abstract _IMaybeKeyId DowncastClone();
  }
  public class MaybeKeyId_DontUseKeyId : MaybeKeyId {
    public MaybeKeyId_DontUseKeyId() : base() {
    }
    public override _IMaybeKeyId DowncastClone() {
      if (this is _IMaybeKeyId dt) { return dt; }
      return new MaybeKeyId_DontUseKeyId();
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDbEncryptionUtil_Compile.MaybeKeyId_DontUseKeyId;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "DynamoDbEncryptionUtil.MaybeKeyId.DontUseKeyId";
      return s;
    }
  }
  public class MaybeKeyId_ShouldHaveKeyId : MaybeKeyId {
    public MaybeKeyId_ShouldHaveKeyId() : base() {
    }
    public override _IMaybeKeyId DowncastClone() {
      if (this is _IMaybeKeyId dt) { return dt; }
      return new MaybeKeyId_ShouldHaveKeyId();
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDbEncryptionUtil_Compile.MaybeKeyId_ShouldHaveKeyId;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "DynamoDbEncryptionUtil.MaybeKeyId.ShouldHaveKeyId";
      return s;
    }
  }
  public class MaybeKeyId_KeyId : MaybeKeyId {
    public readonly Dafny.ISequence<char> _value;
    public MaybeKeyId_KeyId(Dafny.ISequence<char> @value) : base() {
      this._value = @value;
    }
    public override _IMaybeKeyId DowncastClone() {
      if (this is _IMaybeKeyId dt) { return dt; }
      return new MaybeKeyId_KeyId(_value);
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDbEncryptionUtil_Compile.MaybeKeyId_KeyId;
      return oth != null && object.Equals(this._value, oth._value);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._value));
      return (int) hash;
    }
    public override string ToString() {
      string s = "DynamoDbEncryptionUtil.MaybeKeyId.KeyId";
      s += "(";
      s += Dafny.Helpers.ToString(this._value);
      s += ")";
      return s;
    }
  }
} // end of namespace DynamoDbEncryptionUtil_Compile
namespace DynamoDbNormalizeNumber_Compile {

  public partial class __default {
    public static Dafny.ISequence<char> SkipLeadingZeros(Dafny.ISequence<char> val) {
    TAIL_CALL_START: ;
      if ((((BigInteger.One) < (new BigInteger((val).Count))) && (((val).Select(BigInteger.Zero)) == ('0'))) && (((val).Select(BigInteger.One)) != ('.'))) {
        Dafny.ISequence<char> _in0 = (val).Drop(BigInteger.One);
        val = _in0;
        goto TAIL_CALL_START;
      } else {
        return val;
      }
    }
    public static Dafny.ISequence<char> SkipTrailingZeros(Dafny.ISequence<char> val) {
    TAIL_CALL_START: ;
      if (((BigInteger.One) < (new BigInteger((val).Count))) && (((val).Select((new BigInteger((val).Count)) - (BigInteger.One))) == ('0'))) {
        if (((val).Select((new BigInteger((val).Count)) - (new BigInteger(2)))) == ('.')) {
          return (val).Take((new BigInteger((val).Count)) - (new BigInteger(2)));
        } else {
          Dafny.ISequence<char> _in0 = (val).Take((new BigInteger((val).Count)) - (BigInteger.One));
          val = _in0;
          goto TAIL_CALL_START;
        }
      } else {
        return val;
      }
    }
    public static Dafny.ISequence<char> SkipAllTrailingZeros(Dafny.ISequence<char> val) {
    TAIL_CALL_START: ;
      if (((new BigInteger((val).Count)).Sign == 1) && (((val).Select((new BigInteger((val).Count)) - (BigInteger.One))) == ('0'))) {
        Dafny.ISequence<char> _in0 = (val).Take((new BigInteger((val).Count)) - (BigInteger.One));
        val = _in0;
        goto TAIL_CALL_START;
      } else {
        return val;
      }
    }
    public static bool IsDecimalDigit(char ch) {
      return (('0') <= (ch)) && ((ch) <= ('9'));
    }
    public static Wrappers_Compile._IResult<BigInteger, Dafny.ISequence<char>> StrToIntInner(Dafny.ISequence<char> s, BigInteger acc)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((s).Count)).Sign == 0) {
        return Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.create_Success(acc);
      } else if (DynamoDbNormalizeNumber_Compile.__default.IsDecimalDigit((s).Select(BigInteger.Zero))) {
        Dafny.ISequence<char> _in0 = (s).Drop(BigInteger.One);
        BigInteger _in1 = (((acc) * (new BigInteger(10))) + (new BigInteger((s).Select(BigInteger.Zero)))) - (new BigInteger('0'));
        s = _in0;
        acc = _in1;
        goto TAIL_CALL_START;
      } else {
        return Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("The character '"), (s).Take(BigInteger.One)), Dafny.Sequence<char>.FromString("' is not a valid decimal digit.")));
      }
    }
    public static Wrappers_Compile._IResult<BigInteger, Dafny.ISequence<char>> StrToInt(Dafny.ISequence<char> s) {
      if ((new BigInteger((s).Count)).Sign == 0) {
        return Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("An empty string is not a valid number."));
      } else if (((s).Select(BigInteger.Zero)) == ('-')) {
        Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _0_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((BigInteger.One) < (new BigInteger((s).Count)), Dafny.Sequence<char>.FromString("An empty string is not a valid number."));
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<BigInteger>();
        } else {
          Wrappers_Compile._IResult<BigInteger, Dafny.ISequence<char>> _1_valueOrError1 = DynamoDbNormalizeNumber_Compile.__default.StrToIntInner((s).Drop(BigInteger.One), BigInteger.Zero);
          if ((_1_valueOrError1).IsFailure()) {
            return (_1_valueOrError1).PropagateFailure<BigInteger>();
          } else {
            BigInteger _2_x = (_1_valueOrError1).Extract();
            return Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.create_Success((BigInteger.Zero) - (_2_x));
          }
        }
      } else if (((s).Select(BigInteger.Zero)) == ('+')) {
        Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _3_valueOrError2 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((BigInteger.One) < (new BigInteger((s).Count)), Dafny.Sequence<char>.FromString("An empty string is not a valid number."));
        if ((_3_valueOrError2).IsFailure()) {
          return (_3_valueOrError2).PropagateFailure<BigInteger>();
        } else {
          return DynamoDbNormalizeNumber_Compile.__default.StrToIntInner((s).Drop(BigInteger.One), BigInteger.Zero);
        }
      } else {
        return DynamoDbNormalizeNumber_Compile.__default.StrToIntInner(s, BigInteger.Zero);
      }
    }
    public static Dafny.ISequence<char> Zeros(BigInteger n) {
      return ((System.Func<Dafny.ISequence<char>>) (() => {
        BigInteger dim0 = n;
        var arr0 = new char[Dafny.Helpers.ToIntChecked(dim0, "array size exceeds memory limit")];
        for (int i0 = 0; i0 < dim0; i0++) {
          var _0_i = (BigInteger) i0;
          arr0[(int)(_0_i)] = '0';
        }
        return Dafny.Sequence<char>.FromArray(arr0);
      }))();
    }
    public static BigInteger CountDigits(Dafny.ISequence<char> s) {
      BigInteger _0___accumulator = BigInteger.Zero;
    TAIL_CALL_START: ;
      if ((new BigInteger((s).Count)).Sign == 0) {
        return (BigInteger.Zero) + (_0___accumulator);
      } else if (DynamoDbNormalizeNumber_Compile.__default.IsDecimalDigit((s).Select(BigInteger.Zero))) {
        _0___accumulator = (_0___accumulator) + (BigInteger.One);
        Dafny.ISequence<char> _in0 = (s).Drop(BigInteger.One);
        s = _in0;
        goto TAIL_CALL_START;
      } else {
        return (BigInteger.Zero) + (_0___accumulator);
      }
    }
    public static bool IsE(char ch) {
      return ((ch) == ('e')) || ((ch) == ('E'));
    }
    public static Wrappers_Compile._IResult<_System._ITuple3<Dafny.ISequence<char>, BigInteger, BigInteger>, Dafny.ISequence<char>> ParseNumber(Dafny.ISequence<char> n) {
      BigInteger _0_preDot = DynamoDbNormalizeNumber_Compile.__default.CountDigits(n);
      if ((new BigInteger((n).Count)) == (_0_preDot)) {
        return Wrappers_Compile.Result<_System._ITuple3<Dafny.ISequence<char>, BigInteger, BigInteger>, Dafny.ISequence<char>>.create_Success(_System.Tuple3<Dafny.ISequence<char>, BigInteger, BigInteger>.create(n, new BigInteger((n).Count), BigInteger.Zero));
      } else if (((n).Select(_0_preDot)) == ('.')) {
        BigInteger _1_postDot = DynamoDbNormalizeNumber_Compile.__default.CountDigits((n).Drop((_0_preDot) + (BigInteger.One)));
        Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _2_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>(((_0_preDot) + (_1_postDot)).Sign == 1, Dafny.Sequence<char>.FromString("Number needs digits either before or after the decimal point."));
        if ((_2_valueOrError0).IsFailure()) {
          return (_2_valueOrError0).PropagateFailure<_System._ITuple3<Dafny.ISequence<char>, BigInteger, BigInteger>>();
        } else {
          BigInteger _3_len = ((_0_preDot) + (_1_postDot)) + (BigInteger.One);
          if ((_3_len) == (new BigInteger((n).Count))) {
            return Wrappers_Compile.Result<_System._ITuple3<Dafny.ISequence<char>, BigInteger, BigInteger>, Dafny.ISequence<char>>.create_Success(_System.Tuple3<Dafny.ISequence<char>, BigInteger, BigInteger>.create(Dafny.Sequence<char>.Concat((n).Subsequence(BigInteger.Zero, _0_preDot), (n).Drop((_0_preDot) + (BigInteger.One))), _0_preDot, BigInteger.Zero));
          } else if (DynamoDbNormalizeNumber_Compile.__default.IsE((n).Select(_3_len))) {
            Wrappers_Compile._IResult<BigInteger, Dafny.ISequence<char>> _4_valueOrError1 = DynamoDbNormalizeNumber_Compile.__default.StrToInt((n).Drop((_3_len) + (BigInteger.One)));
            if ((_4_valueOrError1).IsFailure()) {
              return (_4_valueOrError1).PropagateFailure<_System._ITuple3<Dafny.ISequence<char>, BigInteger, BigInteger>>();
            } else {
              BigInteger _5_exp = (_4_valueOrError1).Extract();
              return Wrappers_Compile.Result<_System._ITuple3<Dafny.ISequence<char>, BigInteger, BigInteger>, Dafny.ISequence<char>>.create_Success(_System.Tuple3<Dafny.ISequence<char>, BigInteger, BigInteger>.create(Dafny.Sequence<char>.Concat((n).Subsequence(BigInteger.Zero, _0_preDot), (n).Subsequence((_0_preDot) + (BigInteger.One), _3_len)), _0_preDot, _5_exp));
            }
          } else {
            return Wrappers_Compile.Result<_System._ITuple3<Dafny.ISequence<char>, BigInteger, BigInteger>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Invalid Character in number at '"), (n).Drop(_3_len)), Dafny.Sequence<char>.FromString("'.")));
          }
        }
      } else if ((_0_preDot).Sign == 0) {
        return Wrappers_Compile.Result<_System._ITuple3<Dafny.ISequence<char>, BigInteger, BigInteger>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Number needs digits either before or after the decimal point."));
      } else if (DynamoDbNormalizeNumber_Compile.__default.IsE((n).Select(_0_preDot))) {
        Wrappers_Compile._IResult<BigInteger, Dafny.ISequence<char>> _6_valueOrError2 = DynamoDbNormalizeNumber_Compile.__default.StrToInt((n).Drop((_0_preDot) + (BigInteger.One)));
        if ((_6_valueOrError2).IsFailure()) {
          return (_6_valueOrError2).PropagateFailure<_System._ITuple3<Dafny.ISequence<char>, BigInteger, BigInteger>>();
        } else {
          BigInteger _7_exp = (_6_valueOrError2).Extract();
          return Wrappers_Compile.Result<_System._ITuple3<Dafny.ISequence<char>, BigInteger, BigInteger>, Dafny.ISequence<char>>.create_Success(_System.Tuple3<Dafny.ISequence<char>, BigInteger, BigInteger>.create((n).Take(_0_preDot), _0_preDot, _7_exp));
        }
      } else {
        return Wrappers_Compile.Result<_System._ITuple3<Dafny.ISequence<char>, BigInteger, BigInteger>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Invalid Character in number at '"), (n).Drop(_0_preDot)), Dafny.Sequence<char>.FromString("'.")));
      }
    }
    public static BigInteger CountZeros(Dafny.ISequence<char> @value) {
      BigInteger _0___accumulator = BigInteger.Zero;
    TAIL_CALL_START: ;
      if (((new BigInteger((@value).Count)).Sign == 0) || (((@value).Select(BigInteger.Zero)) != ('0'))) {
        return (BigInteger.Zero) + (_0___accumulator);
      } else {
        _0___accumulator = (_0___accumulator) + (BigInteger.One);
        Dafny.ISequence<char> _in0 = (@value).Drop(BigInteger.One);
        @value = _in0;
        goto TAIL_CALL_START;
      }
    }
    public static _System._ITuple2<Dafny.ISequence<char>, BigInteger> NormalizeValue(Dafny.ISequence<char> @value, BigInteger pos)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((@value).Count)).Sign == 0) {
        return _System.Tuple2<Dafny.ISequence<char>, BigInteger>.create(@value, pos);
      } else if ((((@value).Select(BigInteger.Zero)) == ('0')) && ((pos).Sign == 1)) {
        Dafny.ISequence<char> _in0 = (@value).Drop(BigInteger.One);
        BigInteger _in1 = (pos) - (BigInteger.One);
        @value = _in0;
        pos = _in1;
        goto TAIL_CALL_START;
      } else if ((((@value).Select((new BigInteger((@value).Count)) - (BigInteger.One))) == ('0')) && ((pos) < (new BigInteger((@value).Count)))) {
        Dafny.ISequence<char> _in2 = (@value).Take((new BigInteger((@value).Count)) - (BigInteger.One));
        BigInteger _in3 = pos;
        @value = _in2;
        pos = _in3;
        goto TAIL_CALL_START;
      } else {
        return _System.Tuple2<Dafny.ISequence<char>, BigInteger>.create(@value, pos);
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> NormalizePositive(Dafny.ISequence<char> n) {
      Wrappers_Compile._IResult<_System._ITuple3<Dafny.ISequence<char>, BigInteger, BigInteger>, Dafny.ISequence<char>> _0_valueOrError0 = DynamoDbNormalizeNumber_Compile.__default.ParseNumber(n);
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<char>>();
      } else {
        _System._ITuple3<Dafny.ISequence<char>, BigInteger, BigInteger> _let_tmp_rhs0 = (_0_valueOrError0).Extract();
        Dafny.ISequence<char> _1_value = _let_tmp_rhs0.dtor__0;
        BigInteger _2_pos = _let_tmp_rhs0.dtor__1;
        BigInteger _3_exp = _let_tmp_rhs0.dtor__2;
        _System._ITuple2<Dafny.ISequence<char>, BigInteger> _let_tmp_rhs1 = DynamoDbNormalizeNumber_Compile.__default.NormalizeValue(_1_value, _2_pos);
        Dafny.ISequence<char> _4_value = _let_tmp_rhs1.dtor__0;
        BigInteger _5_pos = _let_tmp_rhs1.dtor__1;
        Dafny.ISequence<char> _6_digitsOfPrecision = DynamoDbNormalizeNumber_Compile.__default.SkipAllTrailingZeros(DynamoDbNormalizeNumber_Compile.__default.SkipLeadingZeros(_4_value));
        Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _7_valueOrError1 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((new BigInteger((_6_digitsOfPrecision).Count)) <= (new BigInteger(38)), Dafny.Sequence<char>.FromString("Attempting to store more than 38 significant digits in a Number."));
        if ((_7_valueOrError1).IsFailure()) {
          return (_7_valueOrError1).PropagateFailure<Dafny.ISequence<char>>();
        } else {
          BigInteger _8_newPos = (_5_pos) + (_3_exp);
          if ((new BigInteger((_6_digitsOfPrecision).Count)).Sign == 0) {
            return Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.create_Success(Dafny.Sequence<char>.FromString("0"));
          } else if ((_8_newPos).Sign != 1) {
            Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _9_valueOrError2 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>(((_8_newPos) - (DynamoDbNormalizeNumber_Compile.__default.CountZeros(_4_value))) >= (new BigInteger(-129)), Dafny.Sequence<char>.FromString("Attempting to store a number with magnitude smaller than supported range."));
            if ((_9_valueOrError2).IsFailure()) {
              return (_9_valueOrError2).PropagateFailure<Dafny.ISequence<char>>();
            } else {
              return Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.create_Success(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("0."), DynamoDbNormalizeNumber_Compile.__default.Zeros((BigInteger.Zero) - (_8_newPos))), _4_value));
            }
          } else if ((_8_newPos) >= (new BigInteger((_4_value).Count))) {
            Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _10_valueOrError3 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>(((_8_newPos) - (DynamoDbNormalizeNumber_Compile.__default.CountZeros(_4_value))) <= (new BigInteger(126)), Dafny.Sequence<char>.FromString("Attempting to store a number with magnitude larger than supported range."));
            if ((_10_valueOrError3).IsFailure()) {
              return (_10_valueOrError3).PropagateFailure<Dafny.ISequence<char>>();
            } else {
              return Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.create_Success(Dafny.Sequence<char>.Concat(_4_value, DynamoDbNormalizeNumber_Compile.__default.Zeros((_8_newPos) - (new BigInteger((_4_value).Count)))));
            }
          } else {
            return Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.create_Success(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat((_4_value).Take(_8_newPos), Dafny.Sequence<char>.FromString(".")), (_4_value).Drop(_8_newPos)));
          }
        }
      }
    }
    public static Dafny.ISequence<char> TrimZerosFromValidNumber(Dafny.ISequence<char> n) {
      Dafny.ISequence<char> _0_n = DynamoDbNormalizeNumber_Compile.__default.SkipLeadingZeros(n);
      if ((_0_n).Contains('.')) {
        return DynamoDbNormalizeNumber_Compile.__default.SkipTrailingZeros(_0_n);
      } else {
        return _0_n;
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> NormalizeNumber2(Dafny.ISequence<char> n) {
      Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _0_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((new BigInteger((n).Count)).Sign == 1, Dafny.Sequence<char>.FromString("An empty string is not a valid number."));
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<char>>();
      } else {
        _System._ITuple2<bool, Dafny.ISequence<char>> _let_tmp_rhs0 = ((((n).Select(BigInteger.Zero)) == ('-')) ? (_System.Tuple2<bool, Dafny.ISequence<char>>.create(true, (n).Drop(BigInteger.One))) : (((((n).Select(BigInteger.Zero)) == ('+')) ? (_System.Tuple2<bool, Dafny.ISequence<char>>.create(false, (n).Drop(BigInteger.One))) : (_System.Tuple2<bool, Dafny.ISequence<char>>.create(false, n)))));
        bool _1_neg = _let_tmp_rhs0.dtor__0;
        Dafny.ISequence<char> _2_n = _let_tmp_rhs0.dtor__1;
        Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _3_valueOrError1 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((new BigInteger((_2_n).Count)).Sign == 1, Dafny.Sequence<char>.FromString("An empty string is not a valid number."));
        if ((_3_valueOrError1).IsFailure()) {
          return (_3_valueOrError1).PropagateFailure<Dafny.ISequence<char>>();
        } else {
          Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _4_valueOrError2 = DynamoDbNormalizeNumber_Compile.__default.NormalizePositive(_2_n);
          if ((_4_valueOrError2).IsFailure()) {
            return (_4_valueOrError2).PropagateFailure<Dafny.ISequence<char>>();
          } else {
            Dafny.ISequence<char> _5_n = (_4_valueOrError2).Extract();
            Dafny.ISequence<char> _6_n = DynamoDbNormalizeNumber_Compile.__default.TrimZerosFromValidNumber(_5_n);
            if ((_1_neg) && (!(_6_n).Equals(Dafny.Sequence<char>.FromString("0")))) {
              return Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.create_Success(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromElements('-'), _6_n));
            } else {
              return Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.create_Success(_6_n);
            }
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> NormalizeNumber(Dafny.ISequence<char> n) {
      Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _0_ret = DynamoDbNormalizeNumber_Compile.__default.NormalizeNumber2(n);
      if ((_0_ret).is_Success) {
        return _0_ret;
      } else {
        return Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat((_0_ret).dtor_error, Dafny.Sequence<char>.FromString(" when parsing '")), n), Dafny.Sequence<char>.FromString("'.")));
      }
    }
  }
} // end of namespace DynamoDbNormalizeNumber_Compile
namespace DynamoToStruct_Compile {

  public partial class __default {
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> ItemToStructured(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item) {
      Dafny.IMap<Dafny.ISequence<char>,Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, Dafny.ISequence<char>>> _0_structuredMap = Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.IMap<Dafny.ISequence<char>,Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, Dafny.ISequence<char>>>>>((_1_item) => ((System.Func<Dafny.IMap<Dafny.ISequence<char>,Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, Dafny.ISequence<char>>>>)(() => {
        var _coll0 = new System.Collections.Generic.List<Dafny.Pair<Dafny.ISequence<char>,Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, Dafny.ISequence<char>>>>();
        foreach (Dafny.ISequence<char> _compr_0 in (_1_item).Keys.Elements) {
          Dafny.ISequence<char> _2_k = (Dafny.ISequence<char>)_compr_0;
          if (software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeName._Is(_2_k)) {
            if ((_1_item).Contains(_2_k)) {
              _coll0.Add(new Dafny.Pair<Dafny.ISequence<char>,Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, Dafny.ISequence<char>>>(_2_k, DynamoToStruct_Compile.__default.AttrToStructured(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(_1_item,_2_k))));
            }
          }
        }
        return Dafny.Map<Dafny.ISequence<char>,Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, Dafny.ISequence<char>>>.FromCollection(_coll0);
      }))())(item);
      return DynamoToStruct_Compile.__default.MapError<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>>(DynamoToStruct_Compile.__default.SimplifyMapValue<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>(_0_structuredMap));
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> StructuredToItem(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> s) {
      if (Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>, bool>>((_0_s) => Dafny.Helpers.Quantifier<Dafny.ISequence<char>>(((_0_s).Keys).Elements, true, (((_forall_var_0) => {
        Dafny.ISequence<char> _1_k = (Dafny.ISequence<char>)_forall_var_0;
        return !(((_0_s).Keys).Contains(_1_k)) || (software.amazon.cryptography.services.dynamodb.internaldafny.types.__default.IsValid__AttributeName(_1_k));
      }))))(s)) {
        Dafny.IMap<Dafny.ISequence<char>,Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, Dafny.ISequence<char>>> _2_structuredData = Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>, Dafny.IMap<Dafny.ISequence<char>,Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, Dafny.ISequence<char>>>>>((_3_s) => ((System.Func<Dafny.IMap<Dafny.ISequence<char>,Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, Dafny.ISequence<char>>>>)(() => {
          var _coll0 = new System.Collections.Generic.List<Dafny.Pair<Dafny.ISequence<char>,Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, Dafny.ISequence<char>>>>();
          foreach (Dafny.ISequence<char> _compr_0 in (_3_s).Keys.Elements) {
            Dafny.ISequence<char> _4_k = (Dafny.ISequence<char>)_compr_0;
            if (software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeName._Is(_4_k)) {
              if ((_3_s).Contains(_4_k)) {
                _coll0.Add(new Dafny.Pair<Dafny.ISequence<char>,Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, Dafny.ISequence<char>>>(_4_k, DynamoToStruct_Compile.__default.StructuredToAttr(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>.Select(_3_s,_4_k))));
              }
            }
          }
          return Dafny.Map<Dafny.ISequence<char>,Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, Dafny.ISequence<char>>>.FromCollection(_coll0);
        }))())(s);
        return DynamoToStruct_Compile.__default.MapError<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>(DynamoToStruct_Compile.__default.SimplifyMapValue<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>(_2_structuredData));
      } else {
        Dafny.ISet<Dafny.ISequence<char>> _5_badNames = Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>, Dafny.ISet<Dafny.ISequence<char>>>>((_6_s) => ((System.Func<Dafny.ISet<Dafny.ISequence<char>>>)(() => {
          var _coll1 = new System.Collections.Generic.List<Dafny.ISequence<char>>();
          foreach (Dafny.ISequence<char> _compr_1 in (_6_s).Keys.Elements) {
            Dafny.ISequence<char> _7_k = (Dafny.ISequence<char>)_compr_1;
            if (((_6_s).Contains(_7_k)) && (!(software.amazon.cryptography.services.dynamodb.internaldafny.types.__default.IsValid__AttributeName(_7_k)))) {
              _coll1.Add(_7_k);
            }
          }
          return Dafny.Set<Dafny.ISequence<char>>.FromCollection(_coll1);
        }))())(s);
        Dafny.ISequence<Dafny.ISequence<char>> _8_orderedAttrNames = StandardLibrary_Compile.__default.SetToOrderedSequence<char>(_5_badNames, DynamoToStruct_Compile.__default.CharLess);
        Dafny.ISequence<char> _9_attrNameList = StandardLibrary_Compile.__default.Join<char>(_8_orderedAttrNames, Dafny.Sequence<char>.FromString(","));
        return DynamoToStruct_Compile.__default.MakeError<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Not valid attribute names : "), _9_attrNameList));
      }
    }
    public static Wrappers_Compile._IResult<__T, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> MakeError<__T>(Dafny.ISequence<char> s) {
      return Wrappers_Compile.Result<__T, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Error.create_DynamoDbEncryptionException(s));
    }
    public static Wrappers_Compile._IResult<__T, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> MapError<__T>(Wrappers_Compile._IResult<__T, Dafny.ISequence<char>> r) {
      if ((r).is_Success) {
        return Wrappers_Compile.Result<__T, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success((r).dtor_value);
      } else {
        return DynamoToStruct_Compile.__default.MakeError<__T>((r).dtor_error);
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> TopLevelAttributeToBytes(software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue a) {
      return DynamoToStruct_Compile.__default.AttrToBytes(a, false, BigInteger.One);
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, Dafny.ISequence<char>> AttrToStructured(software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue item) {
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> _0_valueOrError0 = DynamoToStruct_Compile.__default.TopLevelAttributeToBytes(item);
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>();
      } else {
        Dafny.ISequence<byte> _1_body = (_0_valueOrError0).Extract();
        return Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, Dafny.ISequence<char>>.create_Success(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.StructuredDataTerminal.create(_1_body, DynamoToStruct_Compile.__default.AttrToTypeId(item)));
      }
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, Dafny.ISequence<char>> StructuredToAttr(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal s) {
      Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _0_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((new BigInteger(((s).dtor_typeId).Count)) == (new BigInteger(2)), Dafny.Sequence<char>.FromString("Type ID must be two bytes"));
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>();
      } else {
        Wrappers_Compile._IResult<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>> _1_valueOrError1 = DynamoToStruct_Compile.__default.BytesToAttr((s).dtor_value, (s).dtor_typeId, false, BigInteger.One);
        if ((_1_valueOrError1).IsFailure()) {
          return (_1_valueOrError1).PropagateFailure<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>();
        } else {
          DynamoToStruct_Compile._IAttrValueAndLength _2_attrValueAndLength = (_1_valueOrError1).Extract();
          Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _3_valueOrError2 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>(((_2_attrValueAndLength).dtor_len) == (new BigInteger(((s).dtor_value).Count)), Dafny.Sequence<char>.FromString("Mismatch between length of encoded data and length of data"));
          if ((_3_valueOrError2).IsFailure()) {
            return (_3_valueOrError2).PropagateFailure<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>();
          } else {
            return Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, Dafny.ISequence<char>>.create_Success((_2_attrValueAndLength).dtor_val);
          }
        }
      }
    }
    public static Dafny.ISequence<byte> AttrToTypeId(software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue a) {
      software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue _source0 = a;
      {
        if (_source0.is_S) {
          Dafny.ISequence<char> _0_s = _source0.dtor_S;
          return StructuredEncryptionUtil_Compile.__default.STRING;
        }
      }
      {
        if (_source0.is_N) {
          Dafny.ISequence<char> _1_n = _source0.dtor_N;
          return StructuredEncryptionUtil_Compile.__default.NUMBER;
        }
      }
      {
        if (_source0.is_B) {
          Dafny.ISequence<byte> _2_b = _source0.dtor_B;
          return StructuredEncryptionUtil_Compile.__default.BINARY;
        }
      }
      {
        if (_source0.is_SS) {
          Dafny.ISequence<Dafny.ISequence<char>> _3_ss = _source0.dtor_SS;
          return StructuredEncryptionUtil_Compile.__default.STRING__SET;
        }
      }
      {
        if (_source0.is_NS) {
          Dafny.ISequence<Dafny.ISequence<char>> _4_ns = _source0.dtor_NS;
          return StructuredEncryptionUtil_Compile.__default.NUMBER__SET;
        }
      }
      {
        if (_source0.is_BS) {
          Dafny.ISequence<Dafny.ISequence<byte>> _5_bs = _source0.dtor_BS;
          return StructuredEncryptionUtil_Compile.__default.BINARY__SET;
        }
      }
      {
        if (_source0.is_M) {
          Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _6_m = _source0.dtor_M;
          return StructuredEncryptionUtil_Compile.__default.MAP;
        }
      }
      {
        if (_source0.is_L) {
          Dafny.ISequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _7_l = _source0.dtor_L;
          return StructuredEncryptionUtil_Compile.__default.LIST;
        }
      }
      {
        if (_source0.is_NULL) {
          bool _8_n = _source0.dtor_NULL;
          return StructuredEncryptionUtil_Compile.__default.NULL;
        }
      }
      {
        bool _9_b = _source0.dtor_BOOL;
        return StructuredEncryptionUtil_Compile.__default.BOOLEAN;
      }
    }
    public static bool CharLess(char x, char y)
    {
      return (x) < (y);
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> AttrToBytes(software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue a, bool prefix, BigInteger depth)
    {
      Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _0_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((depth) <= (DynamoDbEncryptionUtil_Compile.__default.MAX__STRUCTURE__DEPTH), Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Depth of attribute structure to serialize exceeds limit of "), DynamoDbEncryptionUtil_Compile.__default.MAX__STRUCTURE__DEPTH__STR));
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
      } else {
        Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> _1_valueOrError1 = ((System.Func<Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>>)(() => {
          software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue _source0 = a;
          {
            if (_source0.is_S) {
              Dafny.ISequence<char> _2_s = _source0.dtor_S;
              return UTF8.__default.Encode(_2_s);
            }
          }
          {
            if (_source0.is_N) {
              Dafny.ISequence<char> _3_n = _source0.dtor_N;
              Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _4_valueOrError2 = DynamoDbNormalizeNumber_Compile.__default.NormalizeNumber(_3_n);
              if ((_4_valueOrError2).IsFailure()) {
                return (_4_valueOrError2).PropagateFailure<Dafny.ISequence<byte>>();
              } else {
                Dafny.ISequence<char> _5_nn = (_4_valueOrError2).Extract();
                return UTF8.__default.Encode(_5_nn);
              }
            }
          }
          {
            if (_source0.is_B) {
              Dafny.ISequence<byte> _6_b = _source0.dtor_B;
              return Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(_6_b);
            }
          }
          {
            if (_source0.is_SS) {
              Dafny.ISequence<Dafny.ISequence<char>> _7_ss = _source0.dtor_SS;
              return DynamoToStruct_Compile.__default.StringSetAttrToBytes(_7_ss);
            }
          }
          {
            if (_source0.is_NS) {
              Dafny.ISequence<Dafny.ISequence<char>> _8_ns = _source0.dtor_NS;
              return DynamoToStruct_Compile.__default.NumberSetAttrToBytes(_8_ns);
            }
          }
          {
            if (_source0.is_BS) {
              Dafny.ISequence<Dafny.ISequence<byte>> _9_bs = _source0.dtor_BS;
              return DynamoToStruct_Compile.__default.BinarySetAttrToBytes(_9_bs);
            }
          }
          {
            if (_source0.is_M) {
              Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _10_m = _source0.dtor_M;
              return DynamoToStruct_Compile.__default.MapAttrToBytes(_10_m, depth);
            }
          }
          {
            if (_source0.is_L) {
              Dafny.ISequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _11_l = _source0.dtor_L;
              return DynamoToStruct_Compile.__default.ListAttrToBytes(_11_l, depth);
            }
          }
          {
            if (_source0.is_NULL) {
              bool _12_n = _source0.dtor_NULL;
              return Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(Dafny.Sequence<byte>.FromElements());
            }
          }
          {
            bool _13_b = _source0.dtor_BOOL;
            return Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(Dafny.Sequence<byte>.FromElements(DynamoToStruct_Compile.__default.BoolToUint8(_13_b)));
          }
        }))();
        if ((_1_valueOrError1).IsFailure()) {
          return (_1_valueOrError1).PropagateFailure<Dafny.ISequence<byte>>();
        } else {
          Dafny.ISequence<byte> _14_baseBytes = (_1_valueOrError1).Extract();
          if (prefix) {
            Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> _15_valueOrError3 = DynamoToStruct_Compile.__default.U32ToBigEndian(new BigInteger((_14_baseBytes).Count));
            if ((_15_valueOrError3).IsFailure()) {
              return (_15_valueOrError3).PropagateFailure<Dafny.ISequence<byte>>();
            } else {
              Dafny.ISequence<byte> _16_len = (_15_valueOrError3).Extract();
              return Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(DynamoToStruct_Compile.__default.AttrToTypeId(a), _16_len), _14_baseBytes));
            }
          } else {
            return Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(_14_baseBytes);
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> StringSetAttrToBytes(Dafny.ISequence<Dafny.ISequence<char>> ss) {
      Dafny.ISet<Dafny.ISequence<char>> _0_asSet = Seq_Compile.__default.ToSet<Dafny.ISequence<char>>(ss);
      Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _1_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((new BigInteger((_0_asSet).Count)) == (new BigInteger((ss).Count)), Dafny.Sequence<char>.FromString("String Set had duplicate values"));
      if ((_1_valueOrError0).IsFailure()) {
        return (_1_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
      } else {
        Dafny.ISequence<Dafny.ISequence<char>> _2_sortedList = SortedSets.__default.SetToOrderedSequence2<char>(_0_asSet, DynamoToStruct_Compile.__default.CharLess);
        Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> _3_valueOrError1 = DynamoToStruct_Compile.__default.U32ToBigEndian(new BigInteger((_2_sortedList).Count));
        if ((_3_valueOrError1).IsFailure()) {
          return (_3_valueOrError1).PropagateFailure<Dafny.ISequence<byte>>();
        } else {
          Dafny.ISequence<byte> _4_count = (_3_valueOrError1).Extract();
          Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> _5_valueOrError2 = DynamoToStruct_Compile.__default.CollectString(_2_sortedList, Dafny.Sequence<byte>.FromElements());
          if ((_5_valueOrError2).IsFailure()) {
            return (_5_valueOrError2).PropagateFailure<Dafny.ISequence<byte>>();
          } else {
            Dafny.ISequence<byte> _6_body = (_5_valueOrError2).Extract();
            return Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(Dafny.Sequence<byte>.Concat(_4_count, _6_body));
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> NumberSetAttrToBytes(Dafny.ISequence<Dafny.ISequence<char>> ns) {
      Dafny.ISet<Dafny.ISequence<char>> _0_asSet = Seq_Compile.__default.ToSet<Dafny.ISequence<char>>(ns);
      Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _1_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((new BigInteger((_0_asSet).Count)) == (new BigInteger((ns).Count)), Dafny.Sequence<char>.FromString("Number Set had duplicate values"));
      if ((_1_valueOrError0).IsFailure()) {
        return (_1_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
      } else {
        Wrappers_Compile._IResult<Dafny.ISequence<Dafny.ISequence<char>>, Dafny.ISequence<char>> _2_valueOrError1 = Seq_Compile.__default.MapWithResult<Dafny.ISequence<char>, Dafny.ISequence<char>, Dafny.ISequence<char>>(((System.Func<Dafny.ISequence<char>, Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>>>)((_3_n) => {
          return DynamoDbNormalizeNumber_Compile.__default.NormalizeNumber(_3_n);
        })), ns);
        if ((_2_valueOrError1).IsFailure()) {
          return (_2_valueOrError1).PropagateFailure<Dafny.ISequence<byte>>();
        } else {
          Dafny.ISequence<Dafny.ISequence<char>> _4_normList = (_2_valueOrError1).Extract();
          Dafny.ISet<Dafny.ISequence<char>> _5_asSet = Seq_Compile.__default.ToSet<Dafny.ISequence<char>>(_4_normList);
          Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _6_valueOrError2 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((new BigInteger((_5_asSet).Count)) == (new BigInteger((_4_normList).Count)), Dafny.Sequence<char>.FromString("Number Set had duplicate values after normalization."));
          if ((_6_valueOrError2).IsFailure()) {
            return (_6_valueOrError2).PropagateFailure<Dafny.ISequence<byte>>();
          } else {
            Dafny.ISequence<Dafny.ISequence<char>> _7_sortedList = SortedSets.__default.SetToOrderedSequence2<char>(_5_asSet, DynamoToStruct_Compile.__default.CharLess);
            Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> _8_valueOrError3 = DynamoToStruct_Compile.__default.U32ToBigEndian(new BigInteger((_7_sortedList).Count));
            if ((_8_valueOrError3).IsFailure()) {
              return (_8_valueOrError3).PropagateFailure<Dafny.ISequence<byte>>();
            } else {
              Dafny.ISequence<byte> _9_count = (_8_valueOrError3).Extract();
              Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> _10_valueOrError4 = DynamoToStruct_Compile.__default.CollectString(_7_sortedList, Dafny.Sequence<byte>.FromElements());
              if ((_10_valueOrError4).IsFailure()) {
                return (_10_valueOrError4).PropagateFailure<Dafny.ISequence<byte>>();
              } else {
                Dafny.ISequence<byte> _11_body = (_10_valueOrError4).Extract();
                return Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(Dafny.Sequence<byte>.Concat(_9_count, _11_body));
              }
            }
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> BinarySetAttrToBytes(Dafny.ISequence<Dafny.ISequence<byte>> bs) {
      Dafny.ISet<Dafny.ISequence<byte>> _0_asSet = Seq_Compile.__default.ToSet<Dafny.ISequence<byte>>(bs);
      Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _1_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((new BigInteger((_0_asSet).Count)) == (new BigInteger((bs).Count)), Dafny.Sequence<char>.FromString("Binary Set had duplicate values"));
      if ((_1_valueOrError0).IsFailure()) {
        return (_1_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
      } else {
        Dafny.ISequence<Dafny.ISequence<byte>> _2_sortedList = SortedSets.__default.SetToOrderedSequence2<byte>(_0_asSet, DynamoDbEncryptionUtil_Compile.__default.ByteLess);
        Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> _3_valueOrError1 = DynamoToStruct_Compile.__default.U32ToBigEndian(new BigInteger((_2_sortedList).Count));
        if ((_3_valueOrError1).IsFailure()) {
          return (_3_valueOrError1).PropagateFailure<Dafny.ISequence<byte>>();
        } else {
          Dafny.ISequence<byte> _4_count = (_3_valueOrError1).Extract();
          Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> _5_valueOrError2 = DynamoToStruct_Compile.__default.CollectBinary(_2_sortedList, Dafny.Sequence<byte>.FromElements());
          if ((_5_valueOrError2).IsFailure()) {
            return (_5_valueOrError2).PropagateFailure<Dafny.ISequence<byte>>();
          } else {
            Dafny.ISequence<byte> _6_body = (_5_valueOrError2).Extract();
            return Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(Dafny.Sequence<byte>.Concat(_4_count, _6_body));
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> MapAttrToBytes(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> m, BigInteger depth)
    {
      Dafny.IMap<Dafny.ISequence<char>,Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>> _0_bytesResults = Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, BigInteger, Dafny.IMap<Dafny.ISequence<char>,Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>>>>((_1_m, _2_depth) => ((System.Func<Dafny.IMap<Dafny.ISequence<char>,Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>>>)(() => {
        var _coll0 = new System.Collections.Generic.List<Dafny.Pair<Dafny.ISequence<char>,Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>>>();
        foreach (_System._ITuple2<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _compr_0 in (Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Items((_1_m))).Elements) {
          _System._ITuple2<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _3_kv = (_System._ITuple2<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>)_compr_0;
          if ((Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Items((_1_m))).Contains(_3_kv)) {
            _coll0.Add(new Dafny.Pair<Dafny.ISequence<char>,Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>>((_3_kv).dtor__0, DynamoToStruct_Compile.__default.AttrToBytes((_3_kv).dtor__1, true, (_2_depth) + (BigInteger.One))));
          }
        }
        return Dafny.Map<Dafny.ISequence<char>,Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>>>.FromCollection(_coll0);
      }))())(m, depth);
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> _4_valueOrError0 = DynamoToStruct_Compile.__default.U32ToBigEndian(new BigInteger((m).Count));
      if ((_4_valueOrError0).IsFailure()) {
        return (_4_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
      } else {
        Dafny.ISequence<byte> _5_count = (_4_valueOrError0).Extract();
        Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, Dafny.ISequence<char>> _6_valueOrError1 = DynamoToStruct_Compile.__default.SimplifyMapValue<Dafny.ISequence<char>, Dafny.ISequence<byte>>(_0_bytesResults);
        if ((_6_valueOrError1).IsFailure()) {
          return (_6_valueOrError1).PropagateFailure<Dafny.ISequence<byte>>();
        } else {
          Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>> _7_bytes = (_6_valueOrError1).Extract();
          Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> _8_valueOrError2 = DynamoToStruct_Compile.__default.CollectMap(_7_bytes, Dafny.Sequence<byte>.FromElements());
          if ((_8_valueOrError2).IsFailure()) {
            return (_8_valueOrError2).PropagateFailure<Dafny.ISequence<byte>>();
          } else {
            Dafny.ISequence<byte> _9_body = (_8_valueOrError2).Extract();
            return Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(Dafny.Sequence<byte>.Concat(_5_count, _9_body));
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> ListAttrToBytes(Dafny.ISequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> l, BigInteger depth)
    {
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> _0_valueOrError0 = DynamoToStruct_Compile.__default.U32ToBigEndian(new BigInteger((l).Count));
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
      } else {
        Dafny.ISequence<byte> _1_count = (_0_valueOrError0).Extract();
        Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> _2_valueOrError1 = DynamoToStruct_Compile.__default.CollectList(l, depth, Dafny.Sequence<byte>.FromElements());
        if ((_2_valueOrError1).IsFailure()) {
          return (_2_valueOrError1).PropagateFailure<Dafny.ISequence<byte>>();
        } else {
          Dafny.ISequence<byte> _3_body = (_2_valueOrError1).Extract();
          return Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(Dafny.Sequence<byte>.Concat(_1_count, _3_body));
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> U32ToBigEndian(BigInteger x) {
      if ((x) > (new BigInteger(4294967295L))) {
        return Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Length was too big"));
      } else {
        return Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(StandardLibrary_mUInt_Compile.__default.UInt32ToSeq((uint)(x)));
      }
    }
    public static Wrappers_Compile._IResult<BigInteger, Dafny.ISequence<char>> BigEndianToU32(Dafny.ISequence<byte> x) {
      if ((new BigInteger((x).Count)) < (DynamoToStruct_Compile.__default.LENGTH__LEN)) {
        return Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Length of 4-byte integer was less than 4"));
      } else {
        return Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.create_Success(new BigInteger(StandardLibrary_mUInt_Compile.__default.SeqToUInt32((x).Take(DynamoToStruct_Compile.__default.LENGTH__LEN))));
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> EncodeString(Dafny.ISequence<char> s) {
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> _0_valueOrError0 = UTF8.__default.Encode(s);
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
      } else {
        Dafny.ISequence<byte> _1_val = (_0_valueOrError0).Extract();
        Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> _2_valueOrError1 = DynamoToStruct_Compile.__default.U32ToBigEndian(new BigInteger((_1_val).Count));
        if ((_2_valueOrError1).IsFailure()) {
          return (_2_valueOrError1).PropagateFailure<Dafny.ISequence<byte>>();
        } else {
          Dafny.ISequence<byte> _3_len = (_2_valueOrError1).Extract();
          return Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(Dafny.Sequence<byte>.Concat(_3_len, _1_val));
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> CollectString(Dafny.ISequence<Dafny.ISequence<char>> setToSerialize, Dafny.ISequence<byte> serialized)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((setToSerialize).Count)).Sign == 0) {
        return Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(serialized);
      } else {
        Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> _0_valueOrError0 = DynamoToStruct_Compile.__default.EncodeString((setToSerialize).Select(BigInteger.Zero));
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
        } else {
          Dafny.ISequence<byte> _1_entry = (_0_valueOrError0).Extract();
          Dafny.ISequence<Dafny.ISequence<char>> _in0 = (setToSerialize).Drop(BigInteger.One);
          Dafny.ISequence<byte> _in1 = Dafny.Sequence<byte>.Concat(serialized, _1_entry);
          setToSerialize = _in0;
          serialized = _in1;
          goto TAIL_CALL_START;
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> SerializeBinaryValue(Dafny.ISequence<byte> b) {
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> _0_valueOrError0 = DynamoToStruct_Compile.__default.U32ToBigEndian(new BigInteger((b).Count));
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
      } else {
        Dafny.ISequence<byte> _1_len = (_0_valueOrError0).Extract();
        return Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(Dafny.Sequence<byte>.Concat(_1_len, b));
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> CollectBinary(Dafny.ISequence<Dafny.ISequence<byte>> setToSerialize, Dafny.ISequence<byte> serialized)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((setToSerialize).Count)).Sign == 0) {
        return Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(serialized);
      } else {
        Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> _0_valueOrError0 = DynamoToStruct_Compile.__default.SerializeBinaryValue((setToSerialize).Select(BigInteger.Zero));
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
        } else {
          Dafny.ISequence<byte> _1_item = (_0_valueOrError0).Extract();
          Dafny.ISequence<Dafny.ISequence<byte>> _in0 = (setToSerialize).Drop(BigInteger.One);
          Dafny.ISequence<byte> _in1 = Dafny.Sequence<byte>.Concat(serialized, _1_item);
          setToSerialize = _in0;
          serialized = _in1;
          goto TAIL_CALL_START;
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> CollectList(Dafny.ISequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> listToSerialize, BigInteger depth, Dafny.ISequence<byte> serialized)
    {
      if ((new BigInteger((listToSerialize).Count)).Sign == 0) {
        return Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(serialized);
      } else {
        Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> _0_valueOrError0 = DynamoToStruct_Compile.__default.AttrToBytes((listToSerialize).Select(BigInteger.Zero), true, (depth) + (BigInteger.One));
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
        } else {
          Dafny.ISequence<byte> _1_val = (_0_valueOrError0).Extract();
          return DynamoToStruct_Compile.__default.CollectList((listToSerialize).Drop(BigInteger.One), depth, Dafny.Sequence<byte>.Concat(serialized, _1_val));
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> SerializeMapItem(Dafny.ISequence<char> key, Dafny.ISequence<byte> @value)
    {
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> _0_valueOrError0 = UTF8.__default.Encode(key);
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
      } else {
        Dafny.ISequence<byte> _1_name = (_0_valueOrError0).Extract();
        Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> _2_valueOrError1 = DynamoToStruct_Compile.__default.U32ToBigEndian(new BigInteger((_1_name).Count));
        if ((_2_valueOrError1).IsFailure()) {
          return (_2_valueOrError1).PropagateFailure<Dafny.ISequence<byte>>();
        } else {
          Dafny.ISequence<byte> _3_len = (_2_valueOrError1).Extract();
          Dafny.ISequence<byte> _4_serialized = Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(Dafny.Sequence<byte>.Concat(StructuredEncryptionUtil_Compile.__default.STRING, _3_len), _1_name), @value);
          return Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(_4_serialized);
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> CollectMap(Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>> mapToSerialize, Dafny.ISequence<byte> serialized)
    {
      Dafny.ISequence<Dafny.ISequence<char>> _0_keys = SortedSets.__default.SetToOrderedSequence2<char>((mapToSerialize).Keys, DynamoToStruct_Compile.__default.CharLess);
      return DynamoToStruct_Compile.__default.CollectOrderedMapSubset(_0_keys, mapToSerialize, serialized);
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> CollectOrderedMapSubset(Dafny.ISequence<Dafny.ISequence<char>> keys, Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>> mapToSerialize, Dafny.ISequence<byte> serialized)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((keys).Count)).Sign == 0) {
        return Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.create_Success(serialized);
      } else {
        Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> _0_valueOrError0 = DynamoToStruct_Compile.__default.SerializeMapItem((keys).Select(BigInteger.Zero), Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<byte>>.Select(mapToSerialize,(keys).Select(BigInteger.Zero)));
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
        } else {
          Dafny.ISequence<byte> _1_data = (_0_valueOrError0).Extract();
          Dafny.ISequence<Dafny.ISequence<char>> _in0 = (keys).Drop(BigInteger.One);
          Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>> _in1 = mapToSerialize;
          Dafny.ISequence<byte> _in2 = Dafny.Sequence<byte>.Concat(serialized, _1_data);
          keys = _in0;
          mapToSerialize = _in1;
          serialized = _in2;
          goto TAIL_CALL_START;
        }
      }
    }
    public static byte BoolToUint8(bool b) {
      if (b) {
        return (byte)(1);
      } else {
        return (byte)(0);
      }
    }
    public static bool IsUnique<__T>(Dafny.ISequence<__T> s) {
      return (new BigInteger((Dafny.Helpers.Id<Func<Dafny.ISequence<__T>, Dafny.ISet<__T>>>((_0_s) => ((System.Func<Dafny.ISet<__T>>)(() => {
        var _coll0 = new System.Collections.Generic.List<__T>();
        foreach (__T _compr_0 in (_0_s).CloneAsArray()) {
          __T _1_x = (__T)_compr_0;
          if ((_0_s).Contains(_1_x)) {
            _coll0.Add(_1_x);
          }
        }
        return Dafny.Set<__T>.FromCollection(_coll0);
      }))())(s)).Count)) == (new BigInteger((s).Count));
    }
    public static Wrappers_Compile._IResult<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>> DeserializeBinarySet(Dafny.ISequence<byte> serialized, BigInteger remainingCount, BigInteger origSerializedSize, DynamoToStruct_Compile._IAttrValueAndLength resultSet)
    {
    TAIL_CALL_START: ;
      if ((remainingCount).Sign == 0) {
        Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _0_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>(DynamoToStruct_Compile.__default.IsUnique<Dafny.ISequence<byte>>(((resultSet).dtor_val).dtor_BS), Dafny.Sequence<char>.FromString("Binary set values must not have duplicates"));
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<DynamoToStruct_Compile._IAttrValueAndLength>();
        } else {
          return Wrappers_Compile.Result<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>>.create_Success(resultSet);
        }
      } else if ((new BigInteger((serialized).Count)) < (DynamoToStruct_Compile.__default.LENGTH__LEN)) {
        return Wrappers_Compile.Result<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Out of bytes reading Binary Set"));
      } else {
        Wrappers_Compile._IResult<BigInteger, Dafny.ISequence<char>> _1_valueOrError1 = DynamoToStruct_Compile.__default.BigEndianToU32(serialized);
        if ((_1_valueOrError1).IsFailure()) {
          return (_1_valueOrError1).PropagateFailure<DynamoToStruct_Compile._IAttrValueAndLength>();
        } else {
          BigInteger _2_len = (_1_valueOrError1).Extract();
          Dafny.ISequence<byte> _3_serialized = (serialized).Drop(DynamoToStruct_Compile.__default.LENGTH__LEN);
          if ((new BigInteger((_3_serialized).Count)) < (_2_len)) {
            return Wrappers_Compile.Result<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Binary Set Structured Data has too few bytes"));
          } else {
            software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue _4_nattr = software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_BS(Dafny.Sequence<Dafny.ISequence<byte>>.Concat(((resultSet).dtor_val).dtor_BS, Dafny.Sequence<Dafny.ISequence<byte>>.FromElements((_3_serialized).Take(_2_len))));
            Dafny.ISequence<byte> _in0 = (_3_serialized).Drop(_2_len);
            BigInteger _in1 = (remainingCount) - (BigInteger.One);
            BigInteger _in2 = origSerializedSize;
            DynamoToStruct_Compile._IAttrValueAndLength _in3 = DynamoToStruct_Compile.AttrValueAndLength.create(_4_nattr, (((resultSet).dtor_len) + (_2_len)) + (DynamoToStruct_Compile.__default.LENGTH__LEN));
            serialized = _in0;
            remainingCount = _in1;
            origSerializedSize = _in2;
            resultSet = _in3;
            goto TAIL_CALL_START;
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>> DeserializeStringSet(Dafny.ISequence<byte> serialized, BigInteger remainingCount, BigInteger origSerializedSize, DynamoToStruct_Compile._IAttrValueAndLength resultSet)
    {
    TAIL_CALL_START: ;
      if ((remainingCount).Sign == 0) {
        Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _0_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>(DynamoToStruct_Compile.__default.IsUnique<Dafny.ISequence<char>>(((resultSet).dtor_val).dtor_SS), Dafny.Sequence<char>.FromString("String set values must not have duplicates"));
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<DynamoToStruct_Compile._IAttrValueAndLength>();
        } else {
          return Wrappers_Compile.Result<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>>.create_Success(resultSet);
        }
      } else if ((new BigInteger((serialized).Count)) < (DynamoToStruct_Compile.__default.LENGTH__LEN)) {
        return Wrappers_Compile.Result<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Out of bytes reading String Set"));
      } else {
        Wrappers_Compile._IResult<BigInteger, Dafny.ISequence<char>> _1_valueOrError1 = DynamoToStruct_Compile.__default.BigEndianToU32(serialized);
        if ((_1_valueOrError1).IsFailure()) {
          return (_1_valueOrError1).PropagateFailure<DynamoToStruct_Compile._IAttrValueAndLength>();
        } else {
          BigInteger _2_len = (_1_valueOrError1).Extract();
          Dafny.ISequence<byte> _3_serialized = (serialized).Drop(DynamoToStruct_Compile.__default.LENGTH__LEN);
          if ((new BigInteger((_3_serialized).Count)) < (_2_len)) {
            return Wrappers_Compile.Result<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("String Set Structured Data has too few bytes"));
          } else {
            Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _4_valueOrError2 = UTF8.__default.Decode((_3_serialized).Take(_2_len));
            if ((_4_valueOrError2).IsFailure()) {
              return (_4_valueOrError2).PropagateFailure<DynamoToStruct_Compile._IAttrValueAndLength>();
            } else {
              Dafny.ISequence<char> _5_nstring = (_4_valueOrError2).Extract();
              software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue _6_nattr = software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_SS(Dafny.Sequence<Dafny.ISequence<char>>.Concat(((resultSet).dtor_val).dtor_SS, Dafny.Sequence<Dafny.ISequence<char>>.FromElements(_5_nstring)));
              Dafny.ISequence<byte> _in0 = (_3_serialized).Drop(_2_len);
              BigInteger _in1 = (remainingCount) - (BigInteger.One);
              BigInteger _in2 = origSerializedSize;
              DynamoToStruct_Compile._IAttrValueAndLength _in3 = DynamoToStruct_Compile.AttrValueAndLength.create(_6_nattr, (((resultSet).dtor_len) + (_2_len)) + (DynamoToStruct_Compile.__default.LENGTH__LEN));
              serialized = _in0;
              remainingCount = _in1;
              origSerializedSize = _in2;
              resultSet = _in3;
              goto TAIL_CALL_START;
            }
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>> DeserializeNumberSet(Dafny.ISequence<byte> serialized, BigInteger remainingCount, BigInteger origSerializedSize, DynamoToStruct_Compile._IAttrValueAndLength resultSet)
    {
    TAIL_CALL_START: ;
      if ((remainingCount).Sign == 0) {
        Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _0_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>(DynamoToStruct_Compile.__default.IsUnique<Dafny.ISequence<char>>(((resultSet).dtor_val).dtor_NS), Dafny.Sequence<char>.FromString("Number set values must not have duplicates"));
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<DynamoToStruct_Compile._IAttrValueAndLength>();
        } else {
          return Wrappers_Compile.Result<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>>.create_Success(resultSet);
        }
      } else if ((new BigInteger((serialized).Count)) < (DynamoToStruct_Compile.__default.LENGTH__LEN)) {
        return Wrappers_Compile.Result<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Out of bytes reading String Set"));
      } else {
        Wrappers_Compile._IResult<BigInteger, Dafny.ISequence<char>> _1_valueOrError1 = DynamoToStruct_Compile.__default.BigEndianToU32(serialized);
        if ((_1_valueOrError1).IsFailure()) {
          return (_1_valueOrError1).PropagateFailure<DynamoToStruct_Compile._IAttrValueAndLength>();
        } else {
          BigInteger _2_len = (_1_valueOrError1).Extract();
          Dafny.ISequence<byte> _3_serialized = (serialized).Drop(DynamoToStruct_Compile.__default.LENGTH__LEN);
          if ((new BigInteger((_3_serialized).Count)) < (_2_len)) {
            return Wrappers_Compile.Result<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Number Set Structured Data has too few bytes"));
          } else {
            Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _4_valueOrError2 = UTF8.__default.Decode((_3_serialized).Take(_2_len));
            if ((_4_valueOrError2).IsFailure()) {
              return (_4_valueOrError2).PropagateFailure<DynamoToStruct_Compile._IAttrValueAndLength>();
            } else {
              Dafny.ISequence<char> _5_nstring = (_4_valueOrError2).Extract();
              software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue _6_nattr = software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_NS(Dafny.Sequence<Dafny.ISequence<char>>.Concat(((resultSet).dtor_val).dtor_NS, Dafny.Sequence<Dafny.ISequence<char>>.FromElements(_5_nstring)));
              Dafny.ISequence<byte> _in0 = (_3_serialized).Drop(_2_len);
              BigInteger _in1 = (remainingCount) - (BigInteger.One);
              BigInteger _in2 = origSerializedSize;
              DynamoToStruct_Compile._IAttrValueAndLength _in3 = DynamoToStruct_Compile.AttrValueAndLength.create(_6_nattr, (((resultSet).dtor_len) + (_2_len)) + (DynamoToStruct_Compile.__default.LENGTH__LEN));
              serialized = _in0;
              remainingCount = _in1;
              origSerializedSize = _in2;
              resultSet = _in3;
              goto TAIL_CALL_START;
            }
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>> DeserializeList(Dafny.ISequence<byte> serialized, BigInteger remainingCount, BigInteger depth, DynamoToStruct_Compile._IAttrValueAndLength resultList)
    {
      if ((remainingCount).Sign == 0) {
        return Wrappers_Compile.Result<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>>.create_Success(resultList);
      } else if ((new BigInteger((serialized).Count)) < (new BigInteger(6))) {
        return Wrappers_Compile.Result<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Out of bytes reading Type of List element"));
      } else {
        Dafny.ISequence<byte> _0_TerminalTypeId = (serialized).Subsequence(BigInteger.Zero, new BigInteger(2));
        Dafny.ISequence<byte> _1_serialized = (serialized).Drop(new BigInteger(2));
        Wrappers_Compile._IResult<BigInteger, Dafny.ISequence<char>> _2_valueOrError0 = DynamoToStruct_Compile.__default.BigEndianToU32(_1_serialized);
        if ((_2_valueOrError0).IsFailure()) {
          return (_2_valueOrError0).PropagateFailure<DynamoToStruct_Compile._IAttrValueAndLength>();
        } else {
          BigInteger _3_len = (_2_valueOrError0).Extract();
          Dafny.ISequence<byte> _4_serialized = (_1_serialized).Drop(DynamoToStruct_Compile.__default.LENGTH__LEN);
          if ((new BigInteger((_4_serialized).Count)) < (_3_len)) {
            return Wrappers_Compile.Result<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Out of bytes reading Content of List element"));
          } else {
            Wrappers_Compile._IResult<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>> _5_valueOrError1 = DynamoToStruct_Compile.__default.BytesToAttr((_4_serialized).Take(_3_len), _0_TerminalTypeId, false, (depth) + (BigInteger.One));
            if ((_5_valueOrError1).IsFailure()) {
              return (_5_valueOrError1).PropagateFailure<DynamoToStruct_Compile._IAttrValueAndLength>();
            } else {
              DynamoToStruct_Compile._IAttrValueAndLength _6_nval = (_5_valueOrError1).Extract();
              software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue _7_nattr = software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_L(Dafny.Sequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Concat(((resultList).dtor_val).dtor_L, Dafny.Sequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.FromElements((_6_nval).dtor_val)));
              return DynamoToStruct_Compile.__default.DeserializeList((_4_serialized).Drop(_3_len), (remainingCount) - (BigInteger.One), depth, DynamoToStruct_Compile.AttrValueAndLength.create(_7_nattr, (((resultList).dtor_len) + (_3_len)) + (new BigInteger(6))));
            }
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>> DeserializeMap(Dafny.ISequence<byte> serialized, BigInteger remainingCount, BigInteger depth, DynamoToStruct_Compile._IAttrValueAndLength resultMap)
    {
      if ((remainingCount).Sign == 0) {
        return Wrappers_Compile.Result<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>>.create_Success(resultMap);
      } else {
        Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _0_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((new BigInteger(6)) <= (new BigInteger((serialized).Count)), Dafny.Sequence<char>.FromString("Out of bytes reading Map Key"));
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<DynamoToStruct_Compile._IAttrValueAndLength>();
        } else {
          Dafny.ISequence<byte> _1_TerminalTypeId__key = (serialized).Subsequence(BigInteger.Zero, new BigInteger(2));
          Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _2_valueOrError1 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((_1_TerminalTypeId__key).Equals(StructuredEncryptionUtil_Compile.__default.STRING), Dafny.Sequence<char>.FromString("Key of Map is not String"));
          if ((_2_valueOrError1).IsFailure()) {
            return (_2_valueOrError1).PropagateFailure<DynamoToStruct_Compile._IAttrValueAndLength>();
          } else {
            Dafny.ISequence<byte> _3_serialized = (serialized).Drop(new BigInteger(2));
            Wrappers_Compile._IResult<BigInteger, Dafny.ISequence<char>> _4_valueOrError2 = DynamoToStruct_Compile.__default.BigEndianToU32(_3_serialized);
            if ((_4_valueOrError2).IsFailure()) {
              return (_4_valueOrError2).PropagateFailure<DynamoToStruct_Compile._IAttrValueAndLength>();
            } else {
              BigInteger _5_len = (_4_valueOrError2).Extract();
              Dafny.ISequence<byte> _6_serialized = (_3_serialized).Drop(DynamoToStruct_Compile.__default.LENGTH__LEN);
              Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _7_valueOrError3 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((_5_len) <= (new BigInteger((_6_serialized).Count)), Dafny.Sequence<char>.FromString("Key of Map of Structured Data has too few bytes"));
              if ((_7_valueOrError3).IsFailure()) {
                return (_7_valueOrError3).PropagateFailure<DynamoToStruct_Compile._IAttrValueAndLength>();
              } else {
                Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _8_valueOrError4 = UTF8.__default.Decode((_6_serialized).Take(_5_len));
                if ((_8_valueOrError4).IsFailure()) {
                  return (_8_valueOrError4).PropagateFailure<DynamoToStruct_Compile._IAttrValueAndLength>();
                } else {
                  Dafny.ISequence<char> _9_key = (_8_valueOrError4).Extract();
                  Dafny.ISequence<byte> _10_serialized = (_6_serialized).Drop(_5_len);
                  Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _11_valueOrError5 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((new BigInteger(2)) <= (new BigInteger((_10_serialized).Count)), Dafny.Sequence<char>.FromString("Out of bytes reading Map Value"));
                  if ((_11_valueOrError5).IsFailure()) {
                    return (_11_valueOrError5).PropagateFailure<DynamoToStruct_Compile._IAttrValueAndLength>();
                  } else {
                    Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _12_valueOrError6 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>(software.amazon.cryptography.services.dynamodb.internaldafny.types.__default.IsValid__AttributeName(_9_key), Dafny.Sequence<char>.FromString("Key is not valid AttributeName"));
                    if ((_12_valueOrError6).IsFailure()) {
                      return (_12_valueOrError6).PropagateFailure<DynamoToStruct_Compile._IAttrValueAndLength>();
                    } else {
                      Dafny.ISequence<byte> _13_TerminalTypeId__value = (_10_serialized).Subsequence(BigInteger.Zero, new BigInteger(2));
                      Dafny.ISequence<byte> _14_serialized = (_10_serialized).Drop(new BigInteger(2));
                      Wrappers_Compile._IResult<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>> _15_valueOrError7 = DynamoToStruct_Compile.__default.BytesToAttr(_14_serialized, _13_TerminalTypeId__value, true, (depth) + (BigInteger.One));
                      if ((_15_valueOrError7).IsFailure()) {
                        return (_15_valueOrError7).PropagateFailure<DynamoToStruct_Compile._IAttrValueAndLength>();
                      } else {
                        DynamoToStruct_Compile._IAttrValueAndLength _16_nval = (_15_valueOrError7).Extract();
                        Dafny.ISequence<byte> _17_serialized = (_14_serialized).Drop((_16_nval).dtor_len);
                        Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _18_valueOrError8 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>(!(((resultMap).dtor_val).dtor_M).Contains(_9_key), Dafny.Sequence<char>.FromString("Duplicate key in map."));
                        if ((_18_valueOrError8).IsFailure()) {
                          return (_18_valueOrError8).PropagateFailure<DynamoToStruct_Compile._IAttrValueAndLength>();
                        } else {
                          software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue _19_nattr = software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_M(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Update(((resultMap).dtor_val).dtor_M, _9_key, (_16_nval).dtor_val));
                          DynamoToStruct_Compile._IAttrValueAndLength _20_newResultMap = DynamoToStruct_Compile.AttrValueAndLength.create(_19_nattr, ((((resultMap).dtor_len) + ((_16_nval).dtor_len)) + (new BigInteger(8))) + (_5_len));
                          return DynamoToStruct_Compile.__default.DeserializeMap(_17_serialized, (remainingCount) - (BigInteger.One), depth, _20_newResultMap);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>> BytesToAttr(Dafny.ISequence<byte> @value, Dafny.ISequence<byte> typeId, bool hasLen, BigInteger depth)
    {
      Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _0_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((depth) <= (DynamoDbEncryptionUtil_Compile.__default.MAX__STRUCTURE__DEPTH), Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Depth of attribute structure to deserialize exceeds limit of "), DynamoDbEncryptionUtil_Compile.__default.MAX__STRUCTURE__DEPTH__STR));
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<DynamoToStruct_Compile._IAttrValueAndLength>();
      } else {
        Wrappers_Compile._IResult<BigInteger, Dafny.ISequence<char>> _1_valueOrError1 = ((hasLen) ? ((((new BigInteger((@value).Count)) < (DynamoToStruct_Compile.__default.LENGTH__LEN)) ? (Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Out of bytes reading length"))) : (DynamoToStruct_Compile.__default.BigEndianToU32(@value)))) : (Wrappers_Compile.Result<BigInteger, Dafny.ISequence<char>>.create_Success(new BigInteger((@value).Count))));
        if ((_1_valueOrError1).IsFailure()) {
          return (_1_valueOrError1).PropagateFailure<DynamoToStruct_Compile._IAttrValueAndLength>();
        } else {
          BigInteger _2_len = (_1_valueOrError1).Extract();
          Dafny.ISequence<byte> _3_value = ((hasLen) ? ((@value).Drop(DynamoToStruct_Compile.__default.LENGTH__LEN)) : (@value));
          BigInteger _4_lengthBytes = ((hasLen) ? (DynamoToStruct_Compile.__default.LENGTH__LEN) : (BigInteger.Zero));
          if ((new BigInteger((_3_value).Count)) < (_2_len)) {
            return Wrappers_Compile.Result<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Structured Data has too few bytes"));
          } else if ((typeId).Equals(StructuredEncryptionUtil_Compile.__default.NULL)) {
            if ((_2_len).Sign != 0) {
              return Wrappers_Compile.Result<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("NULL type did not have length zero"));
            } else {
              return Wrappers_Compile.Result<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>>.create_Success(DynamoToStruct_Compile.AttrValueAndLength.create(software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_NULL(true), _4_lengthBytes));
            }
          } else if ((typeId).Equals(StructuredEncryptionUtil_Compile.__default.STRING)) {
            Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _5_valueOrError2 = UTF8.__default.Decode((_3_value).Take(_2_len));
            if ((_5_valueOrError2).IsFailure()) {
              return (_5_valueOrError2).PropagateFailure<DynamoToStruct_Compile._IAttrValueAndLength>();
            } else {
              Dafny.ISequence<char> _6_str = (_5_valueOrError2).Extract();
              return Wrappers_Compile.Result<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>>.create_Success(DynamoToStruct_Compile.AttrValueAndLength.create(software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_S(_6_str), (_2_len) + (_4_lengthBytes)));
            }
          } else if ((typeId).Equals(StructuredEncryptionUtil_Compile.__default.NUMBER)) {
            Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _7_valueOrError3 = UTF8.__default.Decode((_3_value).Take(_2_len));
            if ((_7_valueOrError3).IsFailure()) {
              return (_7_valueOrError3).PropagateFailure<DynamoToStruct_Compile._IAttrValueAndLength>();
            } else {
              Dafny.ISequence<char> _8_str = (_7_valueOrError3).Extract();
              return Wrappers_Compile.Result<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>>.create_Success(DynamoToStruct_Compile.AttrValueAndLength.create(software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_N(_8_str), (_2_len) + (_4_lengthBytes)));
            }
          } else if ((typeId).Equals(StructuredEncryptionUtil_Compile.__default.BINARY)) {
            return Wrappers_Compile.Result<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>>.create_Success(DynamoToStruct_Compile.AttrValueAndLength.create(software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_B((_3_value).Take(_2_len)), (_2_len) + (_4_lengthBytes)));
          } else if ((typeId).Equals(StructuredEncryptionUtil_Compile.__default.BOOLEAN)) {
            if ((_2_len) != (DynamoToStruct_Compile.__default.BOOL__LEN)) {
              return Wrappers_Compile.Result<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Boolean Structured Data has more than one byte"));
            } else if (((_3_value).Select(BigInteger.Zero)) == ((byte)(0))) {
              return Wrappers_Compile.Result<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>>.create_Success(DynamoToStruct_Compile.AttrValueAndLength.create(software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_BOOL(false), (DynamoToStruct_Compile.__default.BOOL__LEN) + (_4_lengthBytes)));
            } else if (((_3_value).Select(BigInteger.Zero)) == ((byte)(1))) {
              return Wrappers_Compile.Result<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>>.create_Success(DynamoToStruct_Compile.AttrValueAndLength.create(software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_BOOL(true), (DynamoToStruct_Compile.__default.BOOL__LEN) + (_4_lengthBytes)));
            } else {
              return Wrappers_Compile.Result<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Boolean Structured Data had inappropriate value"));
            }
          } else if ((typeId).Equals(StructuredEncryptionUtil_Compile.__default.STRING__SET)) {
            if ((new BigInteger((_3_value).Count)) < (DynamoToStruct_Compile.__default.LENGTH__LEN)) {
              return Wrappers_Compile.Result<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("String Set Structured Data has less than LENGTH_LEN bytes"));
            } else {
              Wrappers_Compile._IResult<BigInteger, Dafny.ISequence<char>> _9_valueOrError4 = DynamoToStruct_Compile.__default.BigEndianToU32(_3_value);
              if ((_9_valueOrError4).IsFailure()) {
                return (_9_valueOrError4).PropagateFailure<DynamoToStruct_Compile._IAttrValueAndLength>();
              } else {
                BigInteger _10_len = (_9_valueOrError4).Extract();
                Dafny.ISequence<byte> _11_value = (_3_value).Drop(DynamoToStruct_Compile.__default.LENGTH__LEN);
                return DynamoToStruct_Compile.__default.DeserializeStringSet(_11_value, _10_len, ((new BigInteger((_11_value).Count)) + (DynamoToStruct_Compile.__default.LENGTH__LEN)) + (_4_lengthBytes), DynamoToStruct_Compile.AttrValueAndLength.create(software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_SS(Dafny.Sequence<Dafny.ISequence<char>>.FromElements()), (DynamoToStruct_Compile.__default.LENGTH__LEN) + (_4_lengthBytes)));
              }
            }
          } else if ((typeId).Equals(StructuredEncryptionUtil_Compile.__default.NUMBER__SET)) {
            if ((new BigInteger((_3_value).Count)) < (DynamoToStruct_Compile.__default.LENGTH__LEN)) {
              return Wrappers_Compile.Result<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Number Set Structured Data has less than 4 bytes"));
            } else {
              Wrappers_Compile._IResult<BigInteger, Dafny.ISequence<char>> _12_valueOrError5 = DynamoToStruct_Compile.__default.BigEndianToU32(_3_value);
              if ((_12_valueOrError5).IsFailure()) {
                return (_12_valueOrError5).PropagateFailure<DynamoToStruct_Compile._IAttrValueAndLength>();
              } else {
                BigInteger _13_len = (_12_valueOrError5).Extract();
                Dafny.ISequence<byte> _14_value = (_3_value).Drop(DynamoToStruct_Compile.__default.LENGTH__LEN);
                return DynamoToStruct_Compile.__default.DeserializeNumberSet(_14_value, _13_len, ((new BigInteger((_14_value).Count)) + (DynamoToStruct_Compile.__default.LENGTH__LEN)) + (_4_lengthBytes), DynamoToStruct_Compile.AttrValueAndLength.create(software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_NS(Dafny.Sequence<Dafny.ISequence<char>>.FromElements()), (DynamoToStruct_Compile.__default.LENGTH__LEN) + (_4_lengthBytes)));
              }
            }
          } else if ((typeId).Equals(StructuredEncryptionUtil_Compile.__default.BINARY__SET)) {
            if ((new BigInteger((_3_value).Count)) < (DynamoToStruct_Compile.__default.LENGTH__LEN)) {
              return Wrappers_Compile.Result<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Binary Set Structured Data has less than LENGTH_LEN bytes"));
            } else {
              Wrappers_Compile._IResult<BigInteger, Dafny.ISequence<char>> _15_valueOrError6 = DynamoToStruct_Compile.__default.BigEndianToU32(_3_value);
              if ((_15_valueOrError6).IsFailure()) {
                return (_15_valueOrError6).PropagateFailure<DynamoToStruct_Compile._IAttrValueAndLength>();
              } else {
                BigInteger _16_len = (_15_valueOrError6).Extract();
                Dafny.ISequence<byte> _17_value = (_3_value).Drop(DynamoToStruct_Compile.__default.LENGTH__LEN);
                return DynamoToStruct_Compile.__default.DeserializeBinarySet(_17_value, _16_len, ((new BigInteger((_17_value).Count)) + (DynamoToStruct_Compile.__default.LENGTH__LEN)) + (_4_lengthBytes), DynamoToStruct_Compile.AttrValueAndLength.create(software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_BS(Dafny.Sequence<Dafny.ISequence<byte>>.FromElements()), (DynamoToStruct_Compile.__default.LENGTH__LEN) + (_4_lengthBytes)));
              }
            }
          } else if ((typeId).Equals(StructuredEncryptionUtil_Compile.__default.MAP)) {
            if ((new BigInteger((_3_value).Count)) < (DynamoToStruct_Compile.__default.LENGTH__LEN)) {
              return Wrappers_Compile.Result<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("List Structured Data has less than 4 bytes"));
            } else {
              Wrappers_Compile._IResult<BigInteger, Dafny.ISequence<char>> _18_valueOrError7 = DynamoToStruct_Compile.__default.BigEndianToU32(_3_value);
              if ((_18_valueOrError7).IsFailure()) {
                return (_18_valueOrError7).PropagateFailure<DynamoToStruct_Compile._IAttrValueAndLength>();
              } else {
                BigInteger _19_len = (_18_valueOrError7).Extract();
                Dafny.ISequence<byte> _20_value = (_3_value).Drop(DynamoToStruct_Compile.__default.LENGTH__LEN);
                return DynamoToStruct_Compile.__default.DeserializeMap(_20_value, _19_len, depth, DynamoToStruct_Compile.AttrValueAndLength.create(software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_M(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.FromElements()), (DynamoToStruct_Compile.__default.LENGTH__LEN) + (_4_lengthBytes)));
              }
            }
          } else if ((typeId).Equals(StructuredEncryptionUtil_Compile.__default.LIST)) {
            if ((new BigInteger((_3_value).Count)) < (DynamoToStruct_Compile.__default.LENGTH__LEN)) {
              return Wrappers_Compile.Result<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("List Structured Data has less than 4 bytes"));
            } else {
              Wrappers_Compile._IResult<BigInteger, Dafny.ISequence<char>> _21_valueOrError8 = DynamoToStruct_Compile.__default.BigEndianToU32(_3_value);
              if ((_21_valueOrError8).IsFailure()) {
                return (_21_valueOrError8).PropagateFailure<DynamoToStruct_Compile._IAttrValueAndLength>();
              } else {
                BigInteger _22_len = (_21_valueOrError8).Extract();
                Dafny.ISequence<byte> _23_value = (_3_value).Drop(DynamoToStruct_Compile.__default.LENGTH__LEN);
                return DynamoToStruct_Compile.__default.DeserializeList(_23_value, _22_len, depth, DynamoToStruct_Compile.AttrValueAndLength.create(software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_L(Dafny.Sequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.FromElements()), (DynamoToStruct_Compile.__default.LENGTH__LEN) + (_4_lengthBytes)));
              }
            }
          } else {
            return Wrappers_Compile.Result<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Unsupported TerminalTypeId"));
          }
        }
      }
    }
    public static Dafny.IMap<__X,__Y> FlattenValueMap<__X, __Y>(Dafny.IMap<__X,Wrappers_Compile._IResult<__Y, Dafny.ISequence<char>>> m) {
      return Dafny.Helpers.Id<Func<Dafny.IMap<__X,Wrappers_Compile._IResult<__Y, Dafny.ISequence<char>>>, Dafny.IMap<__X,__Y>>>((_0_m) => ((System.Func<Dafny.IMap<__X,__Y>>)(() => {
        var _coll0 = new System.Collections.Generic.List<Dafny.Pair<__X,__Y>>();
        foreach (__X _compr_0 in (_0_m).Keys.Elements) {
          __X _1_k = (__X)_compr_0;
          if (((_0_m).Contains(_1_k)) && ((Dafny.Map<__X, Wrappers_Compile._IResult<__Y, Dafny.ISequence<char>>>.Select(_0_m,_1_k)).is_Success)) {
            _coll0.Add(new Dafny.Pair<__X,__Y>(_1_k, (Dafny.Map<__X, Wrappers_Compile._IResult<__Y, Dafny.ISequence<char>>>.Select(_0_m,_1_k)).dtor_value));
          }
        }
        return Dafny.Map<__X,__Y>.FromCollection(_coll0);
      }))())(m);
    }
    public static Dafny.ISet<Dafny.ISequence<char>> FlattenErrors<__X, __Y>(Dafny.IMap<__X,Wrappers_Compile._IResult<__Y, Dafny.ISequence<char>>> m) {
      return Dafny.Helpers.Id<Func<Dafny.IMap<__X,Wrappers_Compile._IResult<__Y, Dafny.ISequence<char>>>, Dafny.ISet<Dafny.ISequence<char>>>>((_0_m) => ((System.Func<Dafny.ISet<Dafny.ISequence<char>>>)(() => {
        var _coll0 = new System.Collections.Generic.List<Dafny.ISequence<char>>();
        foreach (__X _compr_0 in (_0_m).Keys.Elements) {
          __X _1_k = (__X)_compr_0;
          if (((_0_m).Contains(_1_k)) && ((Dafny.Map<__X, Wrappers_Compile._IResult<__Y, Dafny.ISequence<char>>>.Select(_0_m,_1_k)).is_Failure)) {
            _coll0.Add((Dafny.Map<__X, Wrappers_Compile._IResult<__Y, Dafny.ISequence<char>>>.Select(_0_m,_1_k)).dtor_error);
          }
        }
        return Dafny.Set<Dafny.ISequence<char>>.FromCollection(_coll0);
      }))())(m);
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<__X,__Y>, Dafny.ISequence<char>> SimplifyMapValue<__X, __Y>(Dafny.IMap<__X,Wrappers_Compile._IResult<__Y, Dafny.ISequence<char>>> m) {
      if (Dafny.Helpers.Id<Func<Dafny.IMap<__X,Wrappers_Compile._IResult<__Y, Dafny.ISequence<char>>>, bool>>((_0_m) => Dafny.Helpers.Quantifier<__X>((_0_m).Keys.Elements, true, (((_forall_var_0) => {
        __X _1_k = (__X)_forall_var_0;
        return !((_0_m).Contains(_1_k)) || ((Dafny.Map<__X, Wrappers_Compile._IResult<__Y, Dafny.ISequence<char>>>.Select(_0_m,_1_k)).is_Success);
      }))))(m)) {
        Dafny.IMap<__X,__Y> _2_result = DynamoToStruct_Compile.__default.FlattenValueMap<__X, __Y>(m);
        return Wrappers_Compile.Result<Dafny.IMap<__X,__Y>, Dafny.ISequence<char>>.create_Success(_2_result);
      } else {
        Dafny.ISet<Dafny.ISequence<char>> _3_badValues = DynamoToStruct_Compile.__default.FlattenErrors<__X, __Y>(m);
        Dafny.ISequence<Dafny.ISequence<char>> _4_badValueSeq = StandardLibrary_Compile.__default.SetToOrderedSequence<char>(_3_badValues, DynamoToStruct_Compile.__default.CharLess);
        return Wrappers_Compile.Result<Dafny.IMap<__X,__Y>, Dafny.ISequence<char>>.create_Failure(StandardLibrary_Compile.__default.Join<char>(_4_badValueSeq, Dafny.Sequence<char>.FromString("\n")));
      }
    }
    public static BigInteger BOOL__LEN { get {
      return BigInteger.One;
    } }
    public static BigInteger PREFIX__LEN { get {
      return new BigInteger(6);
    } }
    public static BigInteger TYPEID__LEN { get {
      return new BigInteger(2);
    } }
    public static BigInteger LENGTH__LEN { get {
      return new BigInteger(4);
    } }
  }

  public interface _IAttrValueAndLength {
    bool is_AttrValueAndLength { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue dtor_val { get; }
    BigInteger dtor_len { get; }
    _IAttrValueAndLength DowncastClone();
  }
  public class AttrValueAndLength : _IAttrValueAndLength {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue _val;
    public readonly BigInteger _len;
    public AttrValueAndLength(software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue val, BigInteger len) {
      this._val = val;
      this._len = len;
    }
    public _IAttrValueAndLength DowncastClone() {
      if (this is _IAttrValueAndLength dt) { return dt; }
      return new AttrValueAndLength(_val, _len);
    }
    public override bool Equals(object other) {
      var oth = other as DynamoToStruct_Compile.AttrValueAndLength;
      return oth != null && object.Equals(this._val, oth._val) && this._len == oth._len;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._val));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._len));
      return (int) hash;
    }
    public override string ToString() {
      string s = "DynamoToStruct.AttrValueAndLength.AttrValueAndLength";
      s += "(";
      s += Dafny.Helpers.ToString(this._val);
      s += ", ";
      s += Dafny.Helpers.ToString(this._len);
      s += ")";
      return s;
    }
    private static readonly DynamoToStruct_Compile._IAttrValueAndLength theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.Default(), BigInteger.Zero);
    public static DynamoToStruct_Compile._IAttrValueAndLength Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<DynamoToStruct_Compile._IAttrValueAndLength> _TYPE = new Dafny.TypeDescriptor<DynamoToStruct_Compile._IAttrValueAndLength>(DynamoToStruct_Compile.AttrValueAndLength.Default());
    public static Dafny.TypeDescriptor<DynamoToStruct_Compile._IAttrValueAndLength> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IAttrValueAndLength create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue val, BigInteger len) {
      return new AttrValueAndLength(val, len);
    }
    public static _IAttrValueAndLength create_AttrValueAndLength(software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue val, BigInteger len) {
      return create(val, len);
    }
    public bool is_AttrValueAndLength { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue dtor_val {
      get {
        return this._val;
      }
    }
    public BigInteger dtor_len {
      get {
        return this._len;
      }
    }
  }
} // end of namespace DynamoToStruct_Compile
namespace DynamoDbItemEncryptorUtil_Compile {

  public partial class __default {
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError E(Dafny.ISequence<char> msg) {
      return software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error.create_DynamoDbItemEncryptorException(msg);
    }
    public static bool ByteLess(byte x, byte y)
    {
      return (x) < (y);
    }
    public static bool CharLess(char x, char y)
    {
      return (x) < (y);
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, Dafny.ISequence<char>> GetLiteralValue(Dafny.ISequence<byte> x) {
      Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _0_valueOrError0 = UTF8.__default.Decode(x);
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>();
      } else {
        Dafny.ISequence<char> _1_str = (_0_valueOrError0).Extract();
        if ((_1_str).Equals(StructuredEncryptionUtil_Compile.__default.TRUE__STR)) {
          return Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, Dafny.ISequence<char>>.create_Success(software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_BOOL(true));
        } else if ((_1_str).Equals(StructuredEncryptionUtil_Compile.__default.FALSE__STR)) {
          return Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, Dafny.ISequence<char>>.create_Success(software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_BOOL(false));
        } else if ((_1_str).Equals(StructuredEncryptionUtil_Compile.__default.NULL__STR)) {
          return Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, Dafny.ISequence<char>>.create_Success(software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_NULL(true));
        } else {
          return Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Encryption Context literal value has unexpected value : '"), _1_str), Dafny.Sequence<char>.FromString("'.")));
        }
      }
    }
    public static Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<byte>>, Dafny.ISequence<char>> GetSortKey(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> context) {
      if (((context).Keys).Contains(DynamoDbItemEncryptorUtil_Compile.__default.SORT__NAME)) {
        Dafny.ISequence<byte> _0_sortName = Dafny.Sequence<byte>.Concat(StructuredEncryptionUtil_Compile.__default.EC__ATTR__PREFIX, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(context,DynamoDbItemEncryptorUtil_Compile.__default.SORT__NAME));
        Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _1_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>(UTF8.__default.ValidUTF8Seq(_0_sortName), Dafny.Sequence<char>.FromString("Internal Error : bad utf8 in sortName"));
        if ((_1_valueOrError0).IsFailure()) {
          return (_1_valueOrError0).PropagateFailure<Wrappers_Compile._IOption<Dafny.ISequence<byte>>>();
        } else {
          return Wrappers_Compile.Result<Wrappers_Compile._IOption<Dafny.ISequence<byte>>, Dafny.ISequence<char>>.create_Success(Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_0_sortName));
        }
      } else {
        return Wrappers_Compile.Result<Wrappers_Compile._IOption<Dafny.ISequence<byte>>, Dafny.ISequence<char>>.create_Success(Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None());
      }
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.ISequence<char>> ConvertContextForSelector(Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> context) {
      Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _0_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>(((context).Keys).Contains(DynamoDbItemEncryptorUtil_Compile.__default.PARTITION__NAME), Dafny.Sequence<char>.FromString("Invalid encryption context: Missing partition name"));
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
      } else {
        Dafny.ISequence<byte> _1_partitionName = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(context,DynamoDbItemEncryptorUtil_Compile.__default.PARTITION__NAME);
        Dafny.ISequence<byte> _2_partitionValueKey = Dafny.Sequence<byte>.Concat(StructuredEncryptionUtil_Compile.__default.EC__ATTR__PREFIX, _1_partitionName);
        Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _3_valueOrError1 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>(((context).Keys).Contains(_2_partitionValueKey), Dafny.Sequence<char>.FromString("Invalid encryption context: Missing partition value"));
        if ((_3_valueOrError1).IsFailure()) {
          return (_3_valueOrError1).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
        } else {
          Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<byte>>, Dafny.ISequence<char>> _4_valueOrError2 = DynamoDbItemEncryptorUtil_Compile.__default.GetSortKey(context);
          if ((_4_valueOrError2).IsFailure()) {
            return (_4_valueOrError2).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
          } else {
            Wrappers_Compile._IOption<Dafny.ISequence<byte>> _5_sortValueKey = (_4_valueOrError2).Extract();
            Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _6_valueOrError3 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>(((_5_sortValueKey).is_None) || ((context).Contains((_5_sortValueKey).dtor_value)), Dafny.Sequence<char>.FromString("Invalid encryption context: Missing sort value"));
            if ((_6_valueOrError3).IsFailure()) {
              return (_6_valueOrError3).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
            } else {
              Dafny.ISequence<Dafny.ISequence<byte>> _7_keys = SortedSets.__default.SetToOrderedSequence2<byte>((context).Keys, StructuredEncryptionUtil_Compile.__default.ByteLess);
              if ((context).Contains(StructuredEncryptionUtil_Compile.__default.LEGEND__UTF8)) {
                Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _8_valueOrError4 = UTF8.__default.Decode(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(context,StructuredEncryptionUtil_Compile.__default.LEGEND__UTF8));
                if ((_8_valueOrError4).IsFailure()) {
                  return (_8_valueOrError4).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
                } else {
                  Dafny.ISequence<char> _9_legend = (_8_valueOrError4).Extract();
                  Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.ISequence<char>> _10_valueOrError5 = DynamoDbItemEncryptorUtil_Compile.__default.GetV2AttrMap(_7_keys, context, _9_legend, Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.FromElements());
                  if ((_10_valueOrError5).IsFailure()) {
                    return (_10_valueOrError5).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
                  } else {
                    Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _11_attrMap = (_10_valueOrError5).Extract();
                    Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _12_valueOrError6 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((context).Contains(DynamoDbItemEncryptorUtil_Compile.__default.TABLE__NAME), Dafny.Sequence<char>.FromString("Internal error, table name not in encryption context."));
                    if ((_12_valueOrError6).IsFailure()) {
                      return (_12_valueOrError6).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
                    } else {
                      Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _13_valueOrError7 = UTF8.__default.Decode(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(context,DynamoDbItemEncryptorUtil_Compile.__default.TABLE__NAME));
                      if ((_13_valueOrError7).IsFailure()) {
                        return (_13_valueOrError7).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
                      } else {
                        Dafny.ISequence<char> _14_tableName = (_13_valueOrError7).Extract();
                        Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _15_attrMap2 = Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Update(_11_attrMap, DynamoDbItemEncryptorUtil_Compile.__default.SELECTOR__TABLE__NAME, software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_S(_14_tableName));
                        Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _16_valueOrError8 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((context).Contains(DynamoDbItemEncryptorUtil_Compile.__default.PARTITION__NAME), Dafny.Sequence<char>.FromString("Internal error, table name not in encryption context."));
                        if ((_16_valueOrError8).IsFailure()) {
                          return (_16_valueOrError8).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
                        } else {
                          Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _17_valueOrError9 = UTF8.__default.Decode(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(context,DynamoDbItemEncryptorUtil_Compile.__default.PARTITION__NAME));
                          if ((_17_valueOrError9).IsFailure()) {
                            return (_17_valueOrError9).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
                          } else {
                            Dafny.ISequence<char> _18_partitionName = (_17_valueOrError9).Extract();
                            Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _19_attrMap3 = Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Update(_15_attrMap2, DynamoDbItemEncryptorUtil_Compile.__default.SELECTOR__PARTITION__NAME, software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_S(_18_partitionName));
                            if ((context).Contains(DynamoDbItemEncryptorUtil_Compile.__default.SORT__NAME)) {
                              Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _20_valueOrError10 = UTF8.__default.Decode(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(context,DynamoDbItemEncryptorUtil_Compile.__default.SORT__NAME));
                              if ((_20_valueOrError10).IsFailure()) {
                                return (_20_valueOrError10).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
                              } else {
                                Dafny.ISequence<char> _21_sortName = (_20_valueOrError10).Extract();
                                return Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.ISequence<char>>.create_Success(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Update(_19_attrMap3, DynamoDbItemEncryptorUtil_Compile.__default.SELECTOR__SORT__NAME, software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_S(_21_sortName)));
                              }
                            } else {
                              return Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.ISequence<char>>.create_Success(_19_attrMap3);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else if ((_5_sortValueKey).is_None) {
                return DynamoDbItemEncryptorUtil_Compile.__default.AddAttributeToMap(_2_partitionValueKey, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(context,_2_partitionValueKey), Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.FromElements());
              } else {
                Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.ISequence<char>> _22_valueOrError11 = DynamoDbItemEncryptorUtil_Compile.__default.AddAttributeToMap(_2_partitionValueKey, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(context,_2_partitionValueKey), Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.FromElements());
                if ((_22_valueOrError11).IsFailure()) {
                  return (_22_valueOrError11).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
                } else {
                  Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _23_attrMap = (_22_valueOrError11).Extract();
                  return DynamoDbItemEncryptorUtil_Compile.__default.AddAttributeToMap((_5_sortValueKey).dtor_value, Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(context,(_5_sortValueKey).dtor_value), _23_attrMap);
                }
              }
            }
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, Dafny.ISequence<char>> GetAttrValue(Dafny.ISequence<byte> ecValue, char legend)
    {
      if ((legend) == (StructuredEncryptionUtil_Compile.__default.LEGEND__STRING)) {
        Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _0_valueOrError0 = UTF8.__default.Decode(ecValue);
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>();
        } else {
          Dafny.ISequence<char> _1_value = (_0_valueOrError0).Extract();
          return Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, Dafny.ISequence<char>>.create_Success(software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_S(_1_value));
        }
      } else if ((legend) == (StructuredEncryptionUtil_Compile.__default.LEGEND__NUMBER)) {
        Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _2_valueOrError1 = UTF8.__default.Decode(ecValue);
        if ((_2_valueOrError1).IsFailure()) {
          return (_2_valueOrError1).PropagateFailure<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>();
        } else {
          Dafny.ISequence<char> _3_value = (_2_valueOrError1).Extract();
          return Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, Dafny.ISequence<char>>.create_Success(software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_N(_3_value));
        }
      } else if ((legend) == (StructuredEncryptionUtil_Compile.__default.LEGEND__LITERAL)) {
        Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, Dafny.ISequence<char>> _4_valueOrError2 = DynamoDbItemEncryptorUtil_Compile.__default.GetLiteralValue(ecValue);
        if ((_4_valueOrError2).IsFailure()) {
          return (_4_valueOrError2).PropagateFailure<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>();
        } else {
          software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue _5_value = (_4_valueOrError2).Extract();
          return Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, Dafny.ISequence<char>>.create_Success(_5_value);
        }
      } else if ((legend) == (StructuredEncryptionUtil_Compile.__default.LEGEND__BINARY)) {
        Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, Dafny.ISequence<char>> _6_valueOrError3 = StructuredEncryptionUtil_Compile.__default.DecodeTerminal(ecValue);
        if ((_6_valueOrError3).IsFailure()) {
          return (_6_valueOrError3).PropagateFailure<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>();
        } else {
          software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal _7_terminal = (_6_valueOrError3).Extract();
          Wrappers_Compile._IResult<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>> _8_valueOrError4 = DynamoToStruct_Compile.__default.BytesToAttr((_7_terminal).dtor_value, (_7_terminal).dtor_typeId, false, BigInteger.One);
          if ((_8_valueOrError4).IsFailure()) {
            return (_8_valueOrError4).PropagateFailure<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>();
          } else {
            DynamoToStruct_Compile._IAttrValueAndLength _9_ddbAttrValue = (_8_valueOrError4).Extract();
            return Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, Dafny.ISequence<char>>.create_Success((_9_ddbAttrValue).dtor_val);
          }
        }
      } else {
        return Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Encryption Context Legend has unexpected character : '"), Dafny.Sequence<char>.FromElements(legend)), Dafny.Sequence<char>.FromString("'.")));
      }
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.ISequence<char>> GetV2AttrMap(Dafny.ISequence<Dafny.ISequence<byte>> keys, Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> context, Dafny.ISequence<char> legend, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> attrMap)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((keys).Count)).Sign == 0) {
        if ((new BigInteger((legend).Count)).Sign == 0) {
          return Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.ISequence<char>>.create_Success(attrMap);
        } else {
          return Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Encryption Context Legend is too long."));
        }
      } else {
        Dafny.ISequence<byte> _0_key = (keys).Select(BigInteger.Zero);
        if (Dafny.Sequence<byte>.IsProperPrefixOf(StructuredEncryptionUtil_Compile.__default.EC__ATTR__PREFIX, _0_key)) {
          Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _1_valueOrError0 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>((new BigInteger((legend).Count)).Sign == 1, Dafny.Sequence<char>.FromString("Encryption Context Legend is too short."));
          if ((_1_valueOrError0).IsFailure()) {
            return (_1_valueOrError0).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
          } else {
            Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _2_valueOrError1 = DynamoDbItemEncryptorUtil_Compile.__default.GetAttributeName(_0_key);
            if ((_2_valueOrError1).IsFailure()) {
              return (_2_valueOrError1).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
            } else {
              Dafny.ISequence<char> _3_attrName = (_2_valueOrError1).Extract();
              Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, Dafny.ISequence<char>> _4_valueOrError2 = DynamoDbItemEncryptorUtil_Compile.__default.GetAttrValue(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Select(context,_0_key), (legend).Select(BigInteger.Zero));
              if ((_4_valueOrError2).IsFailure()) {
                return (_4_valueOrError2).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
              } else {
                software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue _5_attrValue = (_4_valueOrError2).Extract();
                Dafny.ISequence<Dafny.ISequence<byte>> _in0 = (keys).Drop(BigInteger.One);
                Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _in1 = context;
                Dafny.ISequence<char> _in2 = (legend).Drop(BigInteger.One);
                Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in3 = Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Update(attrMap, _3_attrName, _5_attrValue);
                keys = _in0;
                context = _in1;
                legend = _in2;
                attrMap = _in3;
                goto TAIL_CALL_START;
              }
            }
          }
        } else {
          Dafny.ISequence<Dafny.ISequence<byte>> _in4 = (keys).Drop(BigInteger.One);
          Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _in5 = context;
          Dafny.ISequence<char> _in6 = legend;
          Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in7 = attrMap;
          keys = _in4;
          context = _in5;
          legend = _in6;
          attrMap = _in7;
          goto TAIL_CALL_START;
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> GetAttributeName(Dafny.ISequence<byte> ddbAttrKey) {
      Dafny.ISequence<byte> _0_ddbAttrNameBytes = (ddbAttrKey).Drop(new BigInteger((StructuredEncryptionUtil_Compile.__default.EC__ATTR__PREFIX).Count));
      Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _1_valueOrError0 = UTF8.__default.Decode(_0_ddbAttrNameBytes);
      if ((_1_valueOrError0).IsFailure()) {
        return (_1_valueOrError0).PropagateFailure<Dafny.ISequence<char>>();
      } else {
        Dafny.ISequence<char> _2_ddbAttrName = (_1_valueOrError0).Extract();
        Wrappers_Compile._IOutcome<Dafny.ISequence<char>> _3_valueOrError1 = Wrappers_Compile.__default.Need<Dafny.ISequence<char>>(software.amazon.cryptography.services.dynamodb.internaldafny.types.__default.IsValid__AttributeName(_2_ddbAttrName), Dafny.Sequence<char>.FromString("Invalid serialization of DDB Attribute in encryption context."));
        if ((_3_valueOrError1).IsFailure()) {
          return (_3_valueOrError1).PropagateFailure<Dafny.ISequence<char>>();
        } else {
          return Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.create_Success(_2_ddbAttrName);
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.ISequence<char>> AddAttributeToMap(Dafny.ISequence<byte> ddbAttrKey, Dafny.ISequence<byte> encodedAttrValue, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> attrMap)
    {
      Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _0_valueOrError0 = DynamoDbItemEncryptorUtil_Compile.__default.GetAttributeName(ddbAttrKey);
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
      } else {
        Dafny.ISequence<char> _1_ddbAttrName = (_0_valueOrError0).Extract();
        Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal, Dafny.ISequence<char>> _2_valueOrError1 = StructuredEncryptionUtil_Compile.__default.DecodeTerminal(encodedAttrValue);
        if ((_2_valueOrError1).IsFailure()) {
          return (_2_valueOrError1).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
        } else {
          software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal _3_terminal = (_2_valueOrError1).Extract();
          Wrappers_Compile._IResult<DynamoToStruct_Compile._IAttrValueAndLength, Dafny.ISequence<char>> _4_valueOrError2 = DynamoToStruct_Compile.__default.BytesToAttr((_3_terminal).dtor_value, (_3_terminal).dtor_typeId, false, BigInteger.One);
          if ((_4_valueOrError2).IsFailure()) {
            return (_4_valueOrError2).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
          } else {
            DynamoToStruct_Compile._IAttrValueAndLength _5_ddbAttrValue = (_4_valueOrError2).Extract();
            return Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.ISequence<char>>.create_Success(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Update(attrMap, _1_ddbAttrName, (_5_ddbAttrValue).dtor_val));
          }
        }
      }
    }
    public static Dafny.ISequence<char> ReservedPrefix { get {
      return Dafny.Sequence<char>.FromString("aws_dbe_");
    } }
    public static Dafny.ISequence<char> BeaconPrefix { get {
      return Dafny.Sequence<char>.Concat(DynamoDbItemEncryptorUtil_Compile.__default.ReservedPrefix, Dafny.Sequence<char>.FromString("b_"));
    } }
    public static Dafny.ISequence<char> VersionPrefix { get {
      return Dafny.Sequence<char>.Concat(DynamoDbItemEncryptorUtil_Compile.__default.ReservedPrefix, Dafny.Sequence<char>.FromString("v_"));
    } }
    public static Dafny.ISequence<byte> SORT__NAME { get {
      return UTF8.__default.EncodeAscii(Dafny.Sequence<char>.FromString("aws-crypto-sort-name"));
    } }
    public static Dafny.ISequence<byte> PARTITION__NAME { get {
      return UTF8.__default.EncodeAscii(Dafny.Sequence<char>.FromString("aws-crypto-partition-name"));
    } }
    public static Dafny.ISequence<byte> TABLE__NAME { get {
      return UTF8.__default.EncodeAscii(Dafny.Sequence<char>.FromString("aws-crypto-table-name"));
    } }
    public static Dafny.ISequence<char> SELECTOR__TABLE__NAME { get {
      return Dafny.Sequence<char>.FromString("aws_dbe_table_name");
    } }
    public static Dafny.ISequence<char> SELECTOR__PARTITION__NAME { get {
      return Dafny.Sequence<char>.FromString("aws_dbe_partition_name");
    } }
    public static Dafny.ISequence<char> SELECTOR__SORT__NAME { get {
      return Dafny.Sequence<char>.FromString("aws_dbe_sort_name");
    } }
    public static BigInteger MAX__ATTRIBUTE__COUNT { get {
      return new BigInteger(100);
    } }
  }
} // end of namespace DynamoDbItemEncryptorUtil_Compile
namespace software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.legacy {


  public partial class InternalLegacyOverride {
    public InternalLegacyOverride() {
    }
    public static Wrappers_Compile._IResult<Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.legacy.InternalLegacyOverride>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> CreateBuildSuccess(Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.legacy.InternalLegacyOverride> @value) {
      return Wrappers_Compile.Result<Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.legacy.InternalLegacyOverride>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.create_Success(@value);
    }
    public static Wrappers_Compile._IResult<Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.legacy.InternalLegacyOverride>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> CreateBuildFailure(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError error) {
      return Wrappers_Compile.Result<Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.legacy.InternalLegacyOverride>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.create_Failure(error);
    }
    public static Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.legacy.InternalLegacyOverride> CreateInternalLegacyOverrideSome(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.legacy.InternalLegacyOverride @value) {
      return Wrappers_Compile.Option<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.legacy.InternalLegacyOverride>.create_Some(@value);
    }
    public static Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.legacy.InternalLegacyOverride> CreateInternalLegacyOverrideNone() {
      return Wrappers_Compile.Option<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.legacy.InternalLegacyOverride>.create_None();
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> CreateEncryptItemSuccess(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput @value) {
      return Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.create_Success(@value);
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> CreateEncryptItemFailure(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError error) {
      return Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.create_Failure(error);
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> CreateDecryptItemSuccess(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput @value) {
      return Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.create_Success(@value);
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> CreateDecryptItemFailure(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError error) {
      return Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.create_Failure(error);
    }
  }
} // end of namespace software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.legacy
namespace AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile {

  public partial class __default {
    public static bool AllowedUnsigned(Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> unauthenticatedAttributes, Wrappers_Compile._IOption<Dafny.ISequence<char>> unauthenticatedPrefix, Dafny.ISequence<char> attr)
    {
      return ((((unauthenticatedAttributes).is_Some) && (((unauthenticatedAttributes).dtor_value).Contains(attr))) || (((unauthenticatedPrefix).is_Some) && (Dafny.Sequence<char>.IsPrefixOf((unauthenticatedPrefix).dtor_value, attr)))) || (Dafny.Sequence<char>.IsPrefixOf(DynamoDbItemEncryptorUtil_Compile.__default.ReservedPrefix, attr));
    }
    public static bool ForwardCompatibleAttributeAction(Dafny.ISequence<char> attribute, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction action, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> unauthenticatedAttributes, Wrappers_Compile._IOption<Dafny.ISequence<char>> unauthenticatedPrefix)
    {
      if (object.Equals(action, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_DO__NOTHING())) {
        return AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.AllowedUnsigned(unauthenticatedAttributes, unauthenticatedPrefix, attribute);
      } else {
        return !(AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.AllowedUnsigned(unauthenticatedAttributes, unauthenticatedPrefix, attribute));
      }
    }
    public static Dafny.ISequence<char> CryptoActionString(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction action) {
      if (object.Equals(action, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_DO__NOTHING())) {
        return Dafny.Sequence<char>.FromString("DO_NOTHING");
      } else if (object.Equals(action, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_SIGN__ONLY())) {
        return Dafny.Sequence<char>.FromString("SIGN_ONLY");
      } else if (object.Equals(action, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_SIGN__AND__INCLUDE__IN__ENCRYPTION__CONTEXT())) {
        return Dafny.Sequence<char>.FromString("SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT");
      } else if (object.Equals(action, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_ENCRYPT__AND__SIGN())) {
        return Dafny.Sequence<char>.FromString("ENCRYPT_AND_SIGN");
      } else {
        return Dafny.Sequence<char>.FromString("internal error");
      }
    }
    public static Dafny.ISequence<char> ExplainNotForwardCompatible(Dafny.ISequence<char> attr, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction action, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> unauthenticatedAttributes, Wrappers_Compile._IOption<Dafny.ISequence<char>> unauthenticatedPrefix)
    {
      return Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Attribute "), attr), Dafny.Sequence<char>.FromString(" is configured as ")), AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.CryptoActionString(action)), Dafny.Sequence<char>.FromString(" but ")), ((object.Equals(action, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_DO__NOTHING())) ? (Dafny.Sequence<char>.FromString("it must also be in unauthenticatedAttributes or begin with the unauthenticatedPrefix.")) : (((((unauthenticatedAttributes).is_Some) && (((unauthenticatedAttributes).dtor_value).Contains(attr))) ? (Dafny.Sequence<char>.FromString("it is also in unauthenticatedAttributes.")) : (((((unauthenticatedPrefix).is_Some) && (Dafny.Sequence<char>.IsPrefixOf((unauthenticatedPrefix).dtor_value, attr))) ? (Dafny.Sequence<char>.FromString("it also begins with the unauthenticatedPrefix.")) : (Dafny.Sequence<char>.FromString("it also begins with the reserved prefix."))))))));
    }
    public static bool UnknownAttribute(AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile._IConfig config, Dafny.ISequence<char> attr)
    {
      return (AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.InSignatureScope(config, attr)) && (!((config).dtor_attributeActionsOnEncrypt).Contains(attr));
    }
    public static bool InSignatureScope(AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile._IConfig config, Dafny.ISequence<char> attr)
    {
      return !(AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.AllowedUnsigned((config).dtor_allowedUnsignedAttributes, (config).dtor_allowedUnsignedAttributePrefix, attr));
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> EncodeName(Dafny.ISequence<char> k) {
      return AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.DDBEncode(Dafny.Sequence<char>.Concat(StructuredEncryptionUtil_Compile.__default.ATTR__PREFIX, k));
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> MakeEncryptionContextForEncrypt(AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile._IConfig config, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> item)
    {
      if (((config).dtor_version) == ((byte)(2))) {
        return AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.MakeEncryptionContextV2(config, item);
      } else {
        return AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.MakeEncryptionContextV1(config, item);
      }
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> MakeEncryptionContextForDecrypt(AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile._IConfig config, Dafny.ISequence<byte> header, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> item)
    {
      if (((header).Select(BigInteger.Zero)) == ((byte)(2))) {
        return AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.MakeEncryptionContextV2(config, item);
      } else if (((header).Select(BigInteger.Zero)) == ((byte)(1))) {
        return AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.MakeEncryptionContextV1(config, item);
      } else {
        return Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.create_Failure(DynamoDbItemEncryptorUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Header attribute has unexpected version number")));
      }
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> MakeEncryptionContextV1(AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile._IConfig config, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> item)
    {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>((item).Contains((config).dtor_partitionKeyName), AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.DDBError(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Partition key "), (config).dtor_partitionKeyName), Dafny.Sequence<char>.FromString(" not found in Item to be encrypted or decrypted"))));
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
      } else {
        Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _1_valueOrError1 = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.DDBEncode((config).dtor_logicalTableName);
        if ((_1_valueOrError1).IsFailure()) {
          return (_1_valueOrError1).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
        } else {
          Dafny.ISequence<byte> _2_logicalTableName = (_1_valueOrError1).Extract();
          Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _3_valueOrError2 = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.DDBEncode((config).dtor_partitionKeyName);
          if ((_3_valueOrError2).IsFailure()) {
            return (_3_valueOrError2).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
          } else {
            Dafny.ISequence<byte> _4_partitionName = (_3_valueOrError2).Extract();
            Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _5_valueOrError3 = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.EncodeName((config).dtor_partitionKeyName);
            if ((_5_valueOrError3).IsFailure()) {
              return (_5_valueOrError3).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
            } else {
              Dafny.ISequence<byte> _6_partitionKeyName = (_5_valueOrError3).Extract();
              Dafny.ISequence<byte> _7_partitionKeyValue = StructuredEncryptionUtil_Compile.__default.EncodeTerminal(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>.Select(item,(config).dtor_partitionKeyName));
              if (((config).dtor_sortKeyName).is_None) {
                Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _8_valueOrError4 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>((new BigInteger((Dafny.Set<Dafny.ISequence<byte>>.FromElements(DynamoDbItemEncryptorUtil_Compile.__default.TABLE__NAME, DynamoDbItemEncryptorUtil_Compile.__default.PARTITION__NAME, DynamoDbItemEncryptorUtil_Compile.__default.SORT__NAME, _6_partitionKeyName)).Count)) == (new BigInteger(4)), DynamoDbItemEncryptorUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Internal Error")));
                if ((_8_valueOrError4).IsFailure()) {
                  return (_8_valueOrError4).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
                } else {
                  Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _9_ec = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(new Dafny.Pair<Dafny.ISequence<byte>, Dafny.ISequence<byte>>(DynamoDbItemEncryptorUtil_Compile.__default.TABLE__NAME, _2_logicalTableName), new Dafny.Pair<Dafny.ISequence<byte>, Dafny.ISequence<byte>>(DynamoDbItemEncryptorUtil_Compile.__default.PARTITION__NAME, _4_partitionName), new Dafny.Pair<Dafny.ISequence<byte>, Dafny.ISequence<byte>>(_6_partitionKeyName, _7_partitionKeyValue));
                  return Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.create_Success(_9_ec);
                }
              } else {
                Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _10_valueOrError5 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>((item).Contains(((config).dtor_sortKeyName).dtor_value), AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.DDBError(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Sort key "), ((config).dtor_sortKeyName).dtor_value), Dafny.Sequence<char>.FromString(" not found in Item to be encrypted or decrypted"))));
                if ((_10_valueOrError5).IsFailure()) {
                  return (_10_valueOrError5).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
                } else {
                  Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _11_valueOrError6 = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.DDBEncode(((config).dtor_sortKeyName).dtor_value);
                  if ((_11_valueOrError6).IsFailure()) {
                    return (_11_valueOrError6).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
                  } else {
                    Dafny.ISequence<byte> _12_sortName = (_11_valueOrError6).Extract();
                    Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _13_valueOrError7 = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.EncodeName(((config).dtor_sortKeyName).dtor_value);
                    if ((_13_valueOrError7).IsFailure()) {
                      return (_13_valueOrError7).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
                    } else {
                      Dafny.ISequence<byte> _14_sortKeyName = (_13_valueOrError7).Extract();
                      Dafny.ISequence<byte> _15_sortKeyValue = StructuredEncryptionUtil_Compile.__default.EncodeTerminal(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>.Select(item,((config).dtor_sortKeyName).dtor_value));
                      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _16_valueOrError8 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>((new BigInteger((Dafny.Set<Dafny.ISequence<byte>>.FromElements(DynamoDbItemEncryptorUtil_Compile.__default.TABLE__NAME, DynamoDbItemEncryptorUtil_Compile.__default.PARTITION__NAME, _6_partitionKeyName, DynamoDbItemEncryptorUtil_Compile.__default.SORT__NAME, _14_sortKeyName)).Count)) == (new BigInteger(5)), DynamoDbItemEncryptorUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Internal Error")));
                      if ((_16_valueOrError8).IsFailure()) {
                        return (_16_valueOrError8).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
                      } else {
                        Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _17_ec = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(new Dafny.Pair<Dafny.ISequence<byte>, Dafny.ISequence<byte>>(DynamoDbItemEncryptorUtil_Compile.__default.TABLE__NAME, _2_logicalTableName), new Dafny.Pair<Dafny.ISequence<byte>, Dafny.ISequence<byte>>(DynamoDbItemEncryptorUtil_Compile.__default.PARTITION__NAME, _4_partitionName), new Dafny.Pair<Dafny.ISequence<byte>, Dafny.ISequence<byte>>(_6_partitionKeyName, _7_partitionKeyValue), new Dafny.Pair<Dafny.ISequence<byte>, Dafny.ISequence<byte>>(DynamoDbItemEncryptorUtil_Compile.__default.SORT__NAME, _12_sortName), new Dafny.Pair<Dafny.ISequence<byte>, Dafny.ISequence<byte>>(_14_sortKeyName, _15_sortKeyValue));
                        return Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.create_Success(_17_ec);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> MakeEncryptionContextV2(AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile._IConfig config, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> item)
    {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>((item).Contains((config).dtor_partitionKeyName), AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.DDBError(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Partition key "), (config).dtor_partitionKeyName), Dafny.Sequence<char>.FromString(" not found in Item to be encrypted or decrypted"))));
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
      } else {
        Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _1_valueOrError1 = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.DDBEncode((config).dtor_logicalTableName);
        if ((_1_valueOrError1).IsFailure()) {
          return (_1_valueOrError1).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
        } else {
          Dafny.ISequence<byte> _2_logicalTableName = (_1_valueOrError1).Extract();
          Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _3_valueOrError2 = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.DDBEncode((config).dtor_partitionKeyName);
          if ((_3_valueOrError2).IsFailure()) {
            return (_3_valueOrError2).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
          } else {
            Dafny.ISequence<byte> _4_partitionName = (_3_valueOrError2).Extract();
            Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _5_valueOrError3 = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.EncodeName((config).dtor_partitionKeyName);
            if ((_5_valueOrError3).IsFailure()) {
              return (_5_valueOrError3).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
            } else {
              Dafny.ISequence<byte> _6_partitionKeyName = (_5_valueOrError3).Extract();
              if (((config).dtor_sortKeyName).is_None) {
                Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _7_ec = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(new Dafny.Pair<Dafny.ISequence<byte>, Dafny.ISequence<byte>>(DynamoDbItemEncryptorUtil_Compile.__default.TABLE__NAME, _2_logicalTableName), new Dafny.Pair<Dafny.ISequence<byte>, Dafny.ISequence<byte>>(DynamoDbItemEncryptorUtil_Compile.__default.PARTITION__NAME, _4_partitionName));
                return Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.create_Success(_7_ec);
              } else {
                Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _8_valueOrError4 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>((item).Contains(((config).dtor_sortKeyName).dtor_value), AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.DDBError(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Sort key "), ((config).dtor_sortKeyName).dtor_value), Dafny.Sequence<char>.FromString(" not found in Item to be encrypted or decrypted"))));
                if ((_8_valueOrError4).IsFailure()) {
                  return (_8_valueOrError4).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
                } else {
                  Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _9_valueOrError5 = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.DDBEncode(((config).dtor_sortKeyName).dtor_value);
                  if ((_9_valueOrError5).IsFailure()) {
                    return (_9_valueOrError5).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
                  } else {
                    Dafny.ISequence<byte> _10_sortName = (_9_valueOrError5).Extract();
                    Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _11_valueOrError6 = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.EncodeName(((config).dtor_sortKeyName).dtor_value);
                    if ((_11_valueOrError6).IsFailure()) {
                      return (_11_valueOrError6).PropagateFailure<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>();
                    } else {
                      Dafny.ISequence<byte> _12_sortKeyName = (_11_valueOrError6).Extract();
                      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _13_ec = Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.FromElements(new Dafny.Pair<Dafny.ISequence<byte>, Dafny.ISequence<byte>>(DynamoDbItemEncryptorUtil_Compile.__default.TABLE__NAME, _2_logicalTableName), new Dafny.Pair<Dafny.ISequence<byte>, Dafny.ISequence<byte>>(DynamoDbItemEncryptorUtil_Compile.__default.PARTITION__NAME, _4_partitionName), new Dafny.Pair<Dafny.ISequence<byte>, Dafny.ISequence<byte>>(DynamoDbItemEncryptorUtil_Compile.__default.SORT__NAME, _10_sortName));
                      return Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.create_Success(_13_ec);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError DDBError(Dafny.ISequence<char> s) {
      return software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error.create_DynamoDbItemEncryptorException(s);
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> DDBEncode(Dafny.ISequence<char> s) {
      return Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>(UTF8.__default.Encode(s), ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>)((_0_e) => {
        return AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.DDBError(_0_e);
      })));
    }
    public static bool IsVersion2Schema(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> actions) {
      return Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>, bool>>((_0_actions) => Dafny.Helpers.Quantifier<Dafny.ISequence<char>>((_0_actions).Keys.Elements, false, (((_exists_var_0) => {
        Dafny.ISequence<char> _1_x = (Dafny.ISequence<char>)_exists_var_0;
        return ((_0_actions).Contains(_1_x)) && (object.Equals(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Select(_0_actions,_1_x), software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_SIGN__AND__INCLUDE__IN__ENCRYPTION__CONTEXT()));
      }))))(actions);
    }
    public static byte VersionFromActions(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> actions) {
      if (AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.IsVersion2Schema(actions)) {
        return (byte)(2);
      } else {
        return (byte)(1);
      }
    }
    public static software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction KeyActionFromVersion(byte version) {
      if ((version) == ((byte)(2))) {
        return software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_SIGN__AND__INCLUDE__IN__ENCRYPTION__CONTEXT();
      } else {
        return software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_SIGN__ONLY();
      }
    }
    public static Dafny.ISequence<char> KeyActionStringFromVersion(byte version) {
      if ((version) == ((byte)(2))) {
        return Dafny.Sequence<char>.FromString("SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT");
      } else {
        return Dafny.Sequence<char>.FromString("SIGN_ONLY");
      }
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction, Dafny.ISequence<char>> GetCryptoSchemaActionInner(AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile._IConfig config, Dafny.ISequence<char> attr)
    {
      if (((config).dtor_attributeActionsOnEncrypt).Contains(attr)) {
        return Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction, Dafny.ISequence<char>>.create_Success(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Select((config).dtor_attributeActionsOnEncrypt,attr));
      } else if (!(AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.InSignatureScope(config, attr))) {
        return Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction, Dafny.ISequence<char>>.create_Success(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_DO__NOTHING());
      } else {
        return Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("No Crypto Action configured for attribute "), attr));
      }
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction, Dafny.ISequence<char>> GetCryptoSchemaAction(AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile._IConfig config, Dafny.ISequence<char> attr)
    {
      return AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.GetCryptoSchemaActionInner(config, attr);
    }
    public static software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction GetAuthenticateSchemaAction(AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile._IConfig config, Dafny.ISequence<char> attr)
    {
      if (AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.InSignatureScope(config, attr)) {
        return software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.AuthenticateAction.create_SIGN();
      } else {
        return software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.AuthenticateAction.create_DO__NOT__SIGN();
      }
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> ConfigToCryptoSchema(AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile._IConfig config, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item)
    {
      Dafny.IMap<Dafny.ISequence<char>,Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction, Dafny.ISequence<char>>> _0_schema = Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile._IConfig, Dafny.IMap<Dafny.ISequence<char>,Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction, Dafny.ISequence<char>>>>>((_1_item, _2_config) => ((System.Func<Dafny.IMap<Dafny.ISequence<char>,Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction, Dafny.ISequence<char>>>>)(() => {
        var _coll0 = new System.Collections.Generic.List<Dafny.Pair<Dafny.ISequence<char>,Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction, Dafny.ISequence<char>>>>();
        foreach (Dafny.ISequence<char> _compr_0 in (_1_item).Keys.Elements) {
          Dafny.ISequence<char> _3_k = (Dafny.ISequence<char>)_compr_0;
          if ((_1_item).Contains(_3_k)) {
            _coll0.Add(new Dafny.Pair<Dafny.ISequence<char>,Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction, Dafny.ISequence<char>>>(_3_k, AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.GetCryptoSchemaAction(_2_config, _3_k)));
          }
        }
        return Dafny.Map<Dafny.ISequence<char>,Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction, Dafny.ISequence<char>>>.FromCollection(_coll0);
      }))())(item, config);
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>, Dafny.ISequence<char>> _4_actionMapRes = DynamoToStruct_Compile.__default.SimplifyMapValue<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>(_0_schema);
      return DynamoToStruct_Compile.__default.MapError<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>>(_4_actionMapRes);
    }
    public static Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction> ConfigToAuthenticateSchema(AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile._IConfig config, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item)
    {
      return Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile._IConfig, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction>>>((_0_item, _1_config) => ((System.Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction>>)(() => {
        var _coll0 = new System.Collections.Generic.List<Dafny.Pair<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction>>();
        foreach (Dafny.ISequence<char> _compr_0 in (_0_item).Keys.Elements) {
          Dafny.ISequence<char> _2_k = (Dafny.ISequence<char>)_compr_0;
          if (software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeName._Is(_2_k)) {
            if ((_0_item).Contains(_2_k)) {
              _coll0.Add(new Dafny.Pair<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction>(_2_k, AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.GetAuthenticateSchemaAction(_1_config, _2_k)));
            }
          }
        }
        return Dafny.Map<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction>.FromCollection(_coll0);
      }))())(item, config);
    }
    public static bool IsPlaintextItem(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> ddbItem) {
      return (!(ddbItem).Contains(StructuredEncryptionUtil_Compile.__default.HeaderField)) && (!(ddbItem).Contains(StructuredEncryptionUtil_Compile.__default.FooterField));
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> ConvertCryptoSchemaToAttributeActions(AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile._IConfig config, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> schema)
    {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>(Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>, AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile._IConfig, bool>>((_1_schema, _2_config) => Dafny.Helpers.Quantifier<Dafny.ISequence<char>>((_1_schema).Keys.Elements, true, (((_forall_var_0) => {
        Dafny.ISequence<char> _3_k = (Dafny.ISequence<char>)_forall_var_0;
        if (software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeName._Is(_3_k)) {
          return !((_1_schema).Contains(_3_k)) || (AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.InSignatureScope(_2_config, _3_k));
        } else {
          return true;
        }
      }))))(schema, config), software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error.create_DynamoDbItemEncryptorException(Dafny.Sequence<char>.FromString("Received unexpected Crypto Schema: mismatch with signature scope")));
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>>();
      } else {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _4_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>(Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>, bool>>((_5_schema) => Dafny.Helpers.Quantifier<Dafny.ISequence<char>>((_5_schema).Keys.Elements, true, (((_forall_var_1) => {
          Dafny.ISequence<char> _6_k = (Dafny.ISequence<char>)_forall_var_1;
          return !((_5_schema).Contains(_6_k)) || (software.amazon.cryptography.services.dynamodb.internaldafny.types.__default.IsValid__AttributeName(_6_k));
        }))))(schema), software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error.create_DynamoDbItemEncryptorException(Dafny.Sequence<char>.FromString("Received unexpected Crypto Schema: Invalid attribute names")));
        if ((_4_valueOrError1).IsFailure()) {
          return (_4_valueOrError1).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>>();
        } else {
          return Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.create_Success(schema);
        }
      }
    }
    public static Dafny.ISequence<char> GetItemNames(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item) {
      Dafny.ISequence<Dafny.ISequence<char>> _0_keys = SortedSets.__default.SetToOrderedSequence2<char>((item).Keys, DynamoDbItemEncryptorUtil_Compile.__default.CharLess);
      if ((new BigInteger((_0_keys).Count)).Sign == 0) {
        return Dafny.Sequence<char>.FromString("item is empty");
      } else {
        return StandardLibrary_Compile.__default.Join<char>(_0_keys, Dafny.Sequence<char>.FromString(" "));
      }
    }
    public static Dafny.ISequence<char> KeyMissingMsg(AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile._IConfig config, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Dafny.ISequence<char> tag)
    {
      return Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("On "), tag), Dafny.Sequence<char>.FromString(" : ")), ((!(item).Contains((config).dtor_partitionKeyName)) ? (Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Partition key '"), (config).dtor_partitionKeyName), Dafny.Sequence<char>.FromString("' does not exist in item. "))) : (Dafny.Sequence<char>.FromString("")))), (((((config).dtor_sortKeyName).is_Some) && (!(item).Contains(((config).dtor_sortKeyName).dtor_value))) ? (Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Sort key '"), ((config).dtor_sortKeyName).dtor_value), Dafny.Sequence<char>.FromString("' does not exist in item. "))) : (Dafny.Sequence<char>.FromString("")))), Dafny.Sequence<char>.FromString("Item contains these attributes : ")), AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.GetItemNames(item)), Dafny.Sequence<char>.FromString("."));
    }
    public static bool ContextAttrsExist(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> actions, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item)
    {
      return Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, bool>>((_0_actions, _1_item) => Dafny.Helpers.Quantifier<Dafny.ISequence<char>>((_0_actions).Keys.Elements, true, (((_forall_var_0) => {
        Dafny.ISequence<char> _2_k = (Dafny.ISequence<char>)_forall_var_0;
        return !((_0_actions).Contains(_2_k)) || (!(object.Equals(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Select(_0_actions,_2_k), software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_SIGN__AND__INCLUDE__IN__ENCRYPTION__CONTEXT())) || ((_1_item).Contains(_2_k)));
      }))))(actions, item);
    }
    public static Dafny.ISequence<char> ContextMissingMsg(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> actions, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item)
    {
      Dafny.ISet<Dafny.ISequence<char>> _0_s = Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.ISet<Dafny.ISequence<char>>>>((_1_actions, _2_item) => ((System.Func<Dafny.ISet<Dafny.ISequence<char>>>)(() => {
        var _coll0 = new System.Collections.Generic.List<Dafny.ISequence<char>>();
        foreach (Dafny.ISequence<char> _compr_0 in (_1_actions).Keys.Elements) {
          Dafny.ISequence<char> _3_k = (Dafny.ISequence<char>)_compr_0;
          if ((((_1_actions).Contains(_3_k)) && (object.Equals(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Select(_1_actions,_3_k), software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_SIGN__AND__INCLUDE__IN__ENCRYPTION__CONTEXT()))) && (!(_2_item).Contains(_3_k))) {
            _coll0.Add(_3_k);
          }
        }
        return Dafny.Set<Dafny.ISequence<char>>.FromCollection(_coll0);
      }))())(actions, item);
      Dafny.ISequence<Dafny.ISequence<char>> _4_missing = SortedSets.__default.SetToOrderedSequence2<char>(_0_s, DynamoDbItemEncryptorUtil_Compile.__default.CharLess);
      if ((new BigInteger((_4_missing).Count)).Sign == 0) {
        return Dafny.Sequence<char>.FromString("No missing SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT attributes.");
      } else if ((new BigInteger((_4_missing).Count)) == (BigInteger.One)) {
        return Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Attribute "), (_4_missing).Select(BigInteger.Zero)), Dafny.Sequence<char>.FromString(" was configured with SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT but was not present in item to be encrypted."));
      } else {
        return Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("These attributes were configured with SIGN_AND_INCLUDE_IN_ENCRYPTION_CONTEXT but were not present in item to be encrypted."), StandardLibrary_Compile.__default.Join<char>(_4_missing, Dafny.Sequence<char>.FromString(",")));
      }
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> EncryptItem(AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.EncryptItemOutput.Default());
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.Default();
      _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>((((input).dtor_plaintextItem).Contains((config).dtor_partitionKeyName)) && ((((config).dtor_sortKeyName).is_None) || (((input).dtor_plaintextItem).Contains(((config).dtor_sortKeyName).dtor_value))), DynamoDbItemEncryptorUtil_Compile.__default.E(AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.KeyMissingMsg(config, (input).dtor_plaintextItem, Dafny.Sequence<char>.FromString("Encrypt"))));
      if ((_0_valueOrError0).IsFailure()) {
        output = (_0_valueOrError0).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput>();
        return output;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _1_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.Default();
      _1_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>(AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.ContextAttrsExist((config).dtor_attributeActionsOnEncrypt, (input).dtor_plaintextItem), DynamoDbItemEncryptorUtil_Compile.__default.E(AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.ContextMissingMsg((config).dtor_attributeActionsOnEncrypt, (input).dtor_plaintextItem)));
      if ((_1_valueOrError1).IsFailure()) {
        output = (_1_valueOrError1).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput>();
        return output;
      }
      if ((new BigInteger(((input).dtor_plaintextItem).Count)) > (DynamoDbItemEncryptorUtil_Compile.__default.MAX__ATTRIBUTE__COUNT)) {
        Dafny.ISequence<char> _2_actCount;
        _2_actCount = StandardLibrary_mString_Compile.__default.Base10Int2String(new BigInteger(((input).dtor_plaintextItem).Count));
        Dafny.ISequence<char> _3_maxCount;
        _3_maxCount = StandardLibrary_mString_Compile.__default.Base10Int2String(DynamoDbItemEncryptorUtil_Compile.__default.MAX__ATTRIBUTE__COUNT);
        output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.create_Failure(DynamoDbItemEncryptorUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Item to encrypt had "), _2_actCount), Dafny.Sequence<char>.FromString(" attributes, but maximum allowed is ")), _3_maxCount)));
        return output;
      }
      if ((((config).dtor_internalLegacyOverride).is_Some) && (((((config).dtor_internalLegacyOverride).dtor_value).policy).is_FORCE__LEGACY__ENCRYPT__ALLOW__LEGACY__DECRYPT)) {
        Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _4_valueOrError2 = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.EncryptItemOutput.Default());
        Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _out0;
        _out0 = (((config).dtor_internalLegacyOverride).dtor_value).EncryptItem(input);
        _4_valueOrError2 = _out0;
        if ((_4_valueOrError2).IsFailure()) {
          output = (_4_valueOrError2).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput>();
          return output;
        }
        software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput _5_encryptItemOutput;
        _5_encryptItemOutput = (_4_valueOrError2).Extract();
        output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.create_Success(_5_encryptItemOutput);
        return output;
      }
      if (((config).dtor_plaintextOverride).is_FORCE__PLAINTEXT__WRITE__ALLOW__PLAINTEXT__READ) {
        software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput _6_passthroughOutput;
        _6_passthroughOutput = software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.EncryptItemOutput.create((input).dtor_plaintextItem, Wrappers_Compile.Option<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IParsedHeader>.create_None());
        output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.create_Success(_6_passthroughOutput);
        return output;
      }
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _7_valueOrError3 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>.Empty);
      _7_valueOrError3 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>(DynamoToStruct_Compile.__default.ItemToStructured((input).dtor_plaintextItem), ((System.Func<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>)((_8_e) => {
        return software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error.create_AwsCryptographyDbEncryptionSdkDynamoDb(_8_e);
      })));
      if ((_7_valueOrError3).IsFailure()) {
        output = (_7_valueOrError3).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput>();
        return output;
      }
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> _9_plaintextStructure;
      _9_plaintextStructure = (_7_valueOrError3).Extract();
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _10_valueOrError4 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty);
      _10_valueOrError4 = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.MakeEncryptionContextForEncrypt(config, _9_plaintextStructure);
      if ((_10_valueOrError4).IsFailure()) {
        output = (_10_valueOrError4).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput>();
        return output;
      }
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _11_context;
      _11_context = (_10_valueOrError4).Extract();
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _12_valueOrError5 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Empty);
      _12_valueOrError5 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>(AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.ConfigToCryptoSchema(config, (input).dtor_plaintextItem), ((System.Func<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>)((_13_e) => {
        return software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error.create_AwsCryptographyDbEncryptionSdkDynamoDb(_13_e);
      })));
      if ((_12_valueOrError5).IsFailure()) {
        output = (_12_valueOrError5).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput>();
        return output;
      }
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> _14_cryptoSchema;
      _14_cryptoSchema = (_12_valueOrError5).Extract();
      Dafny.ISequence<Dafny.ISequence<byte>> _15_contextKeysX;
      _15_contextKeysX = SortedSets.__default.SetToOrderedSequence2<byte>((_11_context).Keys, DynamoDbItemEncryptorUtil_Compile.__default.ByteLess);
      Dafny.ISequence<Dafny.ISequence<byte>> _16_contextKeys;
      _16_contextKeys = _15_contextKeysX;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _17_reqCMMR;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out1;
      _out1 = ((config).dtor_cmpClient).CreateRequiredEncryptionContextCMM(software.amazon.cryptography.materialproviders.internaldafny.types.CreateRequiredEncryptionContextCMMInput.create(Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager>.create_Some((config).dtor_cmm), Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>.create_None(), _16_contextKeys));
      _17_reqCMMR = _out1;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _18_valueOrError6 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>);
      _18_valueOrError6 = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>(_17_reqCMMR, ((System.Func<software.amazon.cryptography.materialproviders.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>)((_19_e) => {
        return software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error.create_AwsCryptographyMaterialProviders(_19_e);
      })));
      if ((_18_valueOrError6).IsFailure()) {
        output = (_18_valueOrError6).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput>();
        return output;
      }
      software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager _20_reqCMM;
      _20_reqCMM = (_18_valueOrError6).Extract();
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _21_encryptRes;
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _out2;
      _out2 = ((config).dtor_structuredEncryption).EncryptStructure(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.EncryptStructureInput.create((config).dtor_logicalTableName, _9_plaintextStructure, _14_cryptoSchema, _20_reqCMM, (config).dtor_algorithmSuiteId, Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>.create_Some(_11_context)));
      _21_encryptRes = _out2;
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _22_valueOrError7 = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.EncryptStructureOutput.Default());
      _22_valueOrError7 = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>(_21_encryptRes, ((System.Func<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>)((_23_e) => {
        return software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error.create_AwsCryptographyDbEncryptionSdkDynamoDb(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Error.create_AwsCryptographyDbEncryptionSdkStructuredEncryption(_23_e));
      })));
      if ((_22_valueOrError7).IsFailure()) {
        output = (_22_valueOrError7).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput>();
        return output;
      }
      software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IEncryptStructureOutput _24_encryptVal;
      _24_encryptVal = (_22_valueOrError7).Extract();
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> _25_encryptedData;
      _25_encryptedData = (_24_encryptVal).dtor_encryptedStructure;
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _26_valueOrError8 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.Default();
      _26_valueOrError8 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>(Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>, bool>>((_27_encryptedData) => Dafny.Helpers.Quantifier<Dafny.ISequence<char>>((_27_encryptedData).Keys.Elements, true, (((_forall_var_0) => {
        Dafny.ISequence<char> _28_k = (Dafny.ISequence<char>)_forall_var_0;
        return !((_27_encryptedData).Contains(_28_k)) || (software.amazon.cryptography.services.dynamodb.internaldafny.types.__default.IsValid__AttributeName(_28_k));
      }))))(_25_encryptedData), DynamoDbItemEncryptorUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("")));
      if ((_26_valueOrError8).IsFailure()) {
        output = (_26_valueOrError8).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput>();
        return output;
      }
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _29_valueOrError9 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
      _29_valueOrError9 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>(DynamoToStruct_Compile.__default.StructuredToItem(_25_encryptedData), ((System.Func<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>)((_30_e) => {
        return software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error.create_AwsCryptographyDbEncryptionSdkDynamoDb(_30_e);
      })));
      if ((_29_valueOrError9).IsFailure()) {
        output = (_29_valueOrError9).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput>();
        return output;
      }
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _31_ddbKey;
      _31_ddbKey = (_29_valueOrError9).Extract();
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _32_valueOrError10 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Empty);
      _32_valueOrError10 = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.ConvertCryptoSchemaToAttributeActions(config, (_24_encryptVal).dtor_cryptoSchema);
      if ((_32_valueOrError10).IsFailure()) {
        output = (_32_valueOrError10).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput>();
        return output;
      }
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> _33_parsedActions;
      _33_parsedActions = (_32_valueOrError10).Extract();
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.ISequence<char>> _34_selectorContextR;
      _34_selectorContextR = DynamoDbItemEncryptorUtil_Compile.__default.ConvertContextForSelector(((_24_encryptVal).dtor_parsedHeader).dtor_encryptionContext);
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _35_valueOrError11 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
      _35_valueOrError11 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>(_34_selectorContextR, ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>)((_36_e) => {
        return DynamoDbItemEncryptorUtil_Compile.__default.E(_36_e);
      })));
      if ((_35_valueOrError11).IsFailure()) {
        output = (_35_valueOrError11).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput>();
        return output;
      }
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _37_selectorContext;
      _37_selectorContext = (_35_valueOrError11).Extract();
      software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IParsedHeader _38_parsedHeader;
      _38_parsedHeader = software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.ParsedHeader.create(_33_parsedActions, ((_24_encryptVal).dtor_parsedHeader).dtor_algorithmSuiteId, ((_24_encryptVal).dtor_parsedHeader).dtor_encryptedDataKeys, ((_24_encryptVal).dtor_parsedHeader).dtor_storedEncryptionContext, ((_24_encryptVal).dtor_parsedHeader).dtor_encryptionContext, _37_selectorContext);
      output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.EncryptItemOutput.create(_31_ddbKey, Wrappers_Compile.Option<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IParsedHeader>.create_Some(_38_parsedHeader)));
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> DecryptItem(AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.DecryptItemOutput.Default());
      BigInteger _0_realCount;
      _0_realCount = new BigInteger((Dafny.Helpers.Id<Func<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemInput, Dafny.ISet<Dafny.ISequence<char>>>>((_1_input) => ((System.Func<Dafny.ISet<Dafny.ISequence<char>>>)(() => {
        var _coll0 = new System.Collections.Generic.List<Dafny.ISequence<char>>();
        foreach (Dafny.ISequence<char> _compr_0 in ((_1_input).dtor_encryptedItem).Keys.Elements) {
          Dafny.ISequence<char> _2_k = (Dafny.ISequence<char>)_compr_0;
          if ((((_1_input).dtor_encryptedItem).Contains(_2_k)) && (!(Dafny.Sequence<char>.IsPrefixOf(DynamoDbItemEncryptorUtil_Compile.__default.ReservedPrefix, _2_k)))) {
            _coll0.Add(_2_k);
          }
        }
        return Dafny.Set<Dafny.ISequence<char>>.FromCollection(_coll0);
      }))())(input)).Count);
      if ((_0_realCount) > (DynamoDbItemEncryptorUtil_Compile.__default.MAX__ATTRIBUTE__COUNT)) {
        Dafny.ISequence<char> _3_actCount;
        _3_actCount = StandardLibrary_mString_Compile.__default.Base10Int2String(_0_realCount);
        Dafny.ISequence<char> _4_maxCount;
        _4_maxCount = StandardLibrary_mString_Compile.__default.Base10Int2String(DynamoDbItemEncryptorUtil_Compile.__default.MAX__ATTRIBUTE__COUNT);
        output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.create_Failure(DynamoDbItemEncryptorUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Item to decrypt had "), _3_actCount), Dafny.Sequence<char>.FromString(" attributes, but maximum allowed is ")), _4_maxCount)));
        return output;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _5_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.Default();
      _5_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>((((input).dtor_encryptedItem).Contains((config).dtor_partitionKeyName)) && ((((config).dtor_sortKeyName).is_None) || (((input).dtor_encryptedItem).Contains(((config).dtor_sortKeyName).dtor_value))), software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error.create_DynamoDbItemEncryptorException(AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.KeyMissingMsg(config, (input).dtor_encryptedItem, Dafny.Sequence<char>.FromString("Decrypt"))));
      if ((_5_valueOrError0).IsFailure()) {
        output = (_5_valueOrError0).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput>();
        return output;
      }
      if ((((config).dtor_internalLegacyOverride).is_Some) && ((((config).dtor_internalLegacyOverride).dtor_value).IsLegacyInput(input))) {
        Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _6_valueOrError1 = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.DecryptItemOutput.Default());
        Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _out0;
        _out0 = (((config).dtor_internalLegacyOverride).dtor_value).DecryptItem(input);
        _6_valueOrError1 = _out0;
        if ((_6_valueOrError1).IsFailure()) {
          output = (_6_valueOrError1).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput>();
          return output;
        }
        software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput _7_decryptItemOutput;
        _7_decryptItemOutput = (_6_valueOrError1).Extract();
        output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.create_Success(_7_decryptItemOutput);
        return output;
      }
      if (((((config).dtor_plaintextOverride).is_FORCE__PLAINTEXT__WRITE__ALLOW__PLAINTEXT__READ) || (((config).dtor_plaintextOverride).is_FORBID__PLAINTEXT__WRITE__ALLOW__PLAINTEXT__READ)) && (AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.IsPlaintextItem((input).dtor_encryptedItem))) {
        software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput _8_passthroughOutput;
        _8_passthroughOutput = software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.DecryptItemOutput.create((input).dtor_encryptedItem, Wrappers_Compile.Option<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IParsedHeader>.create_None());
        output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.create_Success(_8_passthroughOutput);
        return output;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _9_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.Default();
      _9_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>(!(AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.IsPlaintextItem((input).dtor_encryptedItem)), software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error.create_DynamoDbItemEncryptorException(Dafny.Sequence<char>.FromString("Encrypted item missing expected header and footer attributes")));
      if ((_9_valueOrError2).IsFailure()) {
        output = (_9_valueOrError2).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput>();
        return output;
      }
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _10_valueOrError3 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>.Empty);
      _10_valueOrError3 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>(DynamoToStruct_Compile.__default.ItemToStructured((input).dtor_encryptedItem), ((System.Func<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>)((_11_e) => {
        return software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error.create_AwsCryptographyDbEncryptionSdkDynamoDb(_11_e);
      })));
      if ((_10_valueOrError3).IsFailure()) {
        output = (_10_valueOrError3).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput>();
        return output;
      }
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> _12_encryptedStructure;
      _12_encryptedStructure = (_10_valueOrError3).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _13_valueOrError4 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.Default();
      _13_valueOrError4 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>(((input).dtor_encryptedItem).Contains(StructuredEncryptionUtil_Compile.__default.HeaderField), DynamoDbItemEncryptorUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Header field, \"aws_dbe_head\", not in item.")));
      if ((_13_valueOrError4).IsFailure()) {
        output = (_13_valueOrError4).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput>();
        return output;
      }
      software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue _14_header;
      _14_header = Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select((input).dtor_encryptedItem,StructuredEncryptionUtil_Compile.__default.HeaderField);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _15_valueOrError5 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.Default();
      _15_valueOrError5 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>((_14_header).is_B, DynamoDbItemEncryptorUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Header field, \"aws_dbe_head\", not binary")));
      if ((_15_valueOrError5).IsFailure()) {
        output = (_15_valueOrError5).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput>();
        return output;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _16_valueOrError6 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.Default();
      _16_valueOrError6 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>((new BigInteger(((_14_header).dtor_B).Count)).Sign == 1, DynamoDbItemEncryptorUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Unexpected empty header field.")));
      if ((_16_valueOrError6).IsFailure()) {
        output = (_16_valueOrError6).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput>();
        return output;
      }
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _17_valueOrError7 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<byte>, Dafny.ISequence<byte>>.Empty);
      _17_valueOrError7 = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.MakeEncryptionContextForDecrypt(config, (_14_header).dtor_B, _12_encryptedStructure);
      if ((_17_valueOrError7).IsFailure()) {
        output = (_17_valueOrError7).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput>();
        return output;
      }
      Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>> _18_context;
      _18_context = (_17_valueOrError7).Extract();
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IAuthenticateAction> _19_authenticateSchema;
      _19_authenticateSchema = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.ConfigToAuthenticateSchema(config, (input).dtor_encryptedItem);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _20_reqCMMR;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out1;
      _out1 = ((config).dtor_cmpClient).CreateRequiredEncryptionContextCMM(software.amazon.cryptography.materialproviders.internaldafny.types.CreateRequiredEncryptionContextCMMInput.create(Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager>.create_Some((config).dtor_cmm), Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>.create_None(), SortedSets.__default.SetToOrderedSequence2<byte>((_18_context).Keys, DynamoDbItemEncryptorUtil_Compile.__default.ByteLess)));
      _20_reqCMMR = _out1;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _21_valueOrError8 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>);
      _21_valueOrError8 = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>(_20_reqCMMR, ((System.Func<software.amazon.cryptography.materialproviders.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>)((_22_e) => {
        return software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error.create_AwsCryptographyMaterialProviders(_22_e);
      })));
      if ((_21_valueOrError8).IsFailure()) {
        output = (_21_valueOrError8).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput>();
        return output;
      }
      software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager _23_reqCMM;
      _23_reqCMM = (_21_valueOrError8).Extract();
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _24_decryptRes;
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _out2;
      _out2 = ((config).dtor_structuredEncryption).DecryptStructure(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.DecryptStructureInput.create((config).dtor_logicalTableName, _12_encryptedStructure, _19_authenticateSchema, _23_reqCMM, Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<byte>,Dafny.ISequence<byte>>>.create_Some(_18_context)));
      _24_decryptRes = _out2;
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptStructureOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _25_valueOrError9 = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptStructureOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.DecryptStructureOutput.Default());
      _25_valueOrError9 = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptStructureOutput, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>(_24_decryptRes, ((System.Func<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>)((_26_e) => {
        return software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error.create_AwsCryptographyDbEncryptionSdkDynamoDb(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Error.create_AwsCryptographyDbEncryptionSdkStructuredEncryption(_26_e));
      })));
      if ((_25_valueOrError9).IsFailure()) {
        output = (_25_valueOrError9).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput>();
        return output;
      }
      software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IDecryptStructureOutput _27_decryptVal;
      _27_decryptVal = (_25_valueOrError9).Extract();
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal> _28_decryptedData;
      _28_decryptedData = (_27_decryptVal).dtor_plaintextStructure;
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _29_valueOrError10 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.Default();
      _29_valueOrError10 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>(Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IStructuredDataTerminal>, bool>>((_30_decryptedData) => Dafny.Helpers.Quantifier<Dafny.ISequence<char>>((_30_decryptedData).Keys.Elements, true, (((_forall_var_0) => {
        Dafny.ISequence<char> _31_k = (Dafny.ISequence<char>)_forall_var_0;
        return !((_30_decryptedData).Contains(_31_k)) || (software.amazon.cryptography.services.dynamodb.internaldafny.types.__default.IsValid__AttributeName(_31_k));
      }))))(_28_decryptedData), DynamoDbItemEncryptorUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("")));
      if ((_29_valueOrError10).IsFailure()) {
        output = (_29_valueOrError10).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput>();
        return output;
      }
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _32_valueOrError11 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
      _32_valueOrError11 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>(DynamoToStruct_Compile.__default.StructuredToItem(_28_decryptedData), ((System.Func<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>)((_33_e) => {
        return software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error.create_AwsCryptographyDbEncryptionSdkDynamoDb(_33_e);
      })));
      if ((_32_valueOrError11).IsFailure()) {
        output = (_32_valueOrError11).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput>();
        return output;
      }
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _34_ddbItem;
      _34_ddbItem = (_32_valueOrError11).Extract();
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> _35_schemaToConvert;
      _35_schemaToConvert = (_27_decryptVal).dtor_cryptoSchema;
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _36_valueOrError12 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Empty);
      _36_valueOrError12 = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.ConvertCryptoSchemaToAttributeActions(config, _35_schemaToConvert);
      if ((_36_valueOrError12).IsFailure()) {
        output = (_36_valueOrError12).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput>();
        return output;
      }
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> _37_parsedAuthActions;
      _37_parsedAuthActions = (_36_valueOrError12).Extract();
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.ISequence<char>> _38_selectorContextR;
      _38_selectorContextR = DynamoDbItemEncryptorUtil_Compile.__default.ConvertContextForSelector(((_27_decryptVal).dtor_parsedHeader).dtor_encryptionContext);
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _39_valueOrError13 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
      _39_valueOrError13 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>(_38_selectorContextR, ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>)((_40_e) => {
        return DynamoDbItemEncryptorUtil_Compile.__default.E(_40_e);
      })));
      if ((_39_valueOrError13).IsFailure()) {
        output = (_39_valueOrError13).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput>();
        return output;
      }
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _41_selectorContext;
      _41_selectorContext = (_39_valueOrError13).Extract();
      software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IParsedHeader _42_parsedHeader;
      _42_parsedHeader = software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.ParsedHeader.create(_37_parsedAuthActions, ((_27_decryptVal).dtor_parsedHeader).dtor_algorithmSuiteId, ((_27_decryptVal).dtor_parsedHeader).dtor_encryptedDataKeys, ((_27_decryptVal).dtor_parsedHeader).dtor_storedEncryptionContext, ((_27_decryptVal).dtor_parsedHeader).dtor_encryptionContext, _41_selectorContext);
      output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.DecryptItemOutput.create(_34_ddbItem, Wrappers_Compile.Option<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IParsedHeader>.create_Some(_42_parsedHeader)));
      return output;
    }
  }

  public interface _IConfig {
    bool is_Config { get; }
    byte dtor_version { get; }
    software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient dtor_cmpClient { get; }
    Dafny.ISequence<char> dtor_logicalTableName { get; }
    Dafny.ISequence<char> dtor_partitionKeyName { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_sortKeyName { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager dtor_cmm { get; }
    Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> dtor_attributeActionsOnEncrypt { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> dtor_allowedUnsignedAttributes { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_allowedUnsignedAttributePrefix { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> dtor_algorithmSuiteId { get; }
    software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.StructuredEncryptionClient dtor_structuredEncryption { get; }
    software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride dtor_plaintextOverride { get; }
    Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.legacy.InternalLegacyOverride> dtor_internalLegacyOverride { get; }
    _IConfig DowncastClone();
  }
  public class Config : _IConfig {
    public readonly byte _version;
    public readonly software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient _cmpClient;
    public readonly Dafny.ISequence<char> _logicalTableName;
    public readonly Dafny.ISequence<char> _partitionKeyName;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<char>> _sortKeyName;
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager _cmm;
    public readonly Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> _attributeActionsOnEncrypt;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> _allowedUnsignedAttributes;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<char>> _allowedUnsignedAttributePrefix;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> _algorithmSuiteId;
    public readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.StructuredEncryptionClient _structuredEncryption;
    public readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride _plaintextOverride;
    public readonly Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.legacy.InternalLegacyOverride> _internalLegacyOverride;
    public Config(byte version, software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient cmpClient, Dafny.ISequence<char> logicalTableName, Dafny.ISequence<char> partitionKeyName, Wrappers_Compile._IOption<Dafny.ISequence<char>> sortKeyName, software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager cmm, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> attributeActionsOnEncrypt, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> allowedUnsignedAttributes, Wrappers_Compile._IOption<Dafny.ISequence<char>> allowedUnsignedAttributePrefix, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> algorithmSuiteId, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.StructuredEncryptionClient structuredEncryption, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride plaintextOverride, Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.legacy.InternalLegacyOverride> internalLegacyOverride) {
      this._version = version;
      this._cmpClient = cmpClient;
      this._logicalTableName = logicalTableName;
      this._partitionKeyName = partitionKeyName;
      this._sortKeyName = sortKeyName;
      this._cmm = cmm;
      this._attributeActionsOnEncrypt = attributeActionsOnEncrypt;
      this._allowedUnsignedAttributes = allowedUnsignedAttributes;
      this._allowedUnsignedAttributePrefix = allowedUnsignedAttributePrefix;
      this._algorithmSuiteId = algorithmSuiteId;
      this._structuredEncryption = structuredEncryption;
      this._plaintextOverride = plaintextOverride;
      this._internalLegacyOverride = internalLegacyOverride;
    }
    public _IConfig DowncastClone() {
      if (this is _IConfig dt) { return dt; }
      return new Config(_version, _cmpClient, _logicalTableName, _partitionKeyName, _sortKeyName, _cmm, _attributeActionsOnEncrypt, _allowedUnsignedAttributes, _allowedUnsignedAttributePrefix, _algorithmSuiteId, _structuredEncryption, _plaintextOverride, _internalLegacyOverride);
    }
    public override bool Equals(object other) {
      var oth = other as AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.Config;
      return oth != null && this._version == oth._version && this._cmpClient == oth._cmpClient && object.Equals(this._logicalTableName, oth._logicalTableName) && object.Equals(this._partitionKeyName, oth._partitionKeyName) && object.Equals(this._sortKeyName, oth._sortKeyName) && this._cmm == oth._cmm && object.Equals(this._attributeActionsOnEncrypt, oth._attributeActionsOnEncrypt) && object.Equals(this._allowedUnsignedAttributes, oth._allowedUnsignedAttributes) && object.Equals(this._allowedUnsignedAttributePrefix, oth._allowedUnsignedAttributePrefix) && object.Equals(this._algorithmSuiteId, oth._algorithmSuiteId) && this._structuredEncryption == oth._structuredEncryption && object.Equals(this._plaintextOverride, oth._plaintextOverride) && object.Equals(this._internalLegacyOverride, oth._internalLegacyOverride);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._version));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._cmpClient));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._logicalTableName));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._partitionKeyName));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sortKeyName));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._cmm));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._attributeActionsOnEncrypt));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._allowedUnsignedAttributes));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._allowedUnsignedAttributePrefix));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._algorithmSuiteId));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._structuredEncryption));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._plaintextOverride));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._internalLegacyOverride));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations.Config.Config";
      s += "(";
      s += Dafny.Helpers.ToString(this._version);
      s += ", ";
      s += Dafny.Helpers.ToString(this._cmpClient);
      s += ", ";
      s += Dafny.Helpers.ToString(this._logicalTableName);
      s += ", ";
      s += Dafny.Helpers.ToString(this._partitionKeyName);
      s += ", ";
      s += Dafny.Helpers.ToString(this._sortKeyName);
      s += ", ";
      s += Dafny.Helpers.ToString(this._cmm);
      s += ", ";
      s += Dafny.Helpers.ToString(this._attributeActionsOnEncrypt);
      s += ", ";
      s += Dafny.Helpers.ToString(this._allowedUnsignedAttributes);
      s += ", ";
      s += Dafny.Helpers.ToString(this._allowedUnsignedAttributePrefix);
      s += ", ";
      s += Dafny.Helpers.ToString(this._algorithmSuiteId);
      s += ", ";
      s += Dafny.Helpers.ToString(this._structuredEncryption);
      s += ", ";
      s += Dafny.Helpers.ToString(this._plaintextOverride);
      s += ", ";
      s += Dafny.Helpers.ToString(this._internalLegacyOverride);
      s += ")";
      return s;
    }
    private static readonly AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile._IConfig theDefault = create(StructuredEncryptionHeader_Compile.Version.Default(), default(software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient), Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty, Wrappers_Compile.Option<Dafny.ISequence<char>>.Default(), default(software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager), Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Empty, Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.Default(), Wrappers_Compile.Option<Dafny.ISequence<char>>.Default(), Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId>.Default(), default(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.StructuredEncryptionClient), software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.PlaintextOverride.Default(), Wrappers_Compile.Option<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.legacy.InternalLegacyOverride>.Default());
    public static AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile._IConfig Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile._IConfig> _TYPE = new Dafny.TypeDescriptor<AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile._IConfig>(AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.Config.Default());
    public static Dafny.TypeDescriptor<AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile._IConfig> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IConfig create(byte version, software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient cmpClient, Dafny.ISequence<char> logicalTableName, Dafny.ISequence<char> partitionKeyName, Wrappers_Compile._IOption<Dafny.ISequence<char>> sortKeyName, software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager cmm, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> attributeActionsOnEncrypt, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> allowedUnsignedAttributes, Wrappers_Compile._IOption<Dafny.ISequence<char>> allowedUnsignedAttributePrefix, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> algorithmSuiteId, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.StructuredEncryptionClient structuredEncryption, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride plaintextOverride, Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.legacy.InternalLegacyOverride> internalLegacyOverride) {
      return new Config(version, cmpClient, logicalTableName, partitionKeyName, sortKeyName, cmm, attributeActionsOnEncrypt, allowedUnsignedAttributes, allowedUnsignedAttributePrefix, algorithmSuiteId, structuredEncryption, plaintextOverride, internalLegacyOverride);
    }
    public static _IConfig create_Config(byte version, software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient cmpClient, Dafny.ISequence<char> logicalTableName, Dafny.ISequence<char> partitionKeyName, Wrappers_Compile._IOption<Dafny.ISequence<char>> sortKeyName, software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager cmm, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> attributeActionsOnEncrypt, Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> allowedUnsignedAttributes, Wrappers_Compile._IOption<Dafny.ISequence<char>> allowedUnsignedAttributePrefix, Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> algorithmSuiteId, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.StructuredEncryptionClient structuredEncryption, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride plaintextOverride, Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.legacy.InternalLegacyOverride> internalLegacyOverride) {
      return create(version, cmpClient, logicalTableName, partitionKeyName, sortKeyName, cmm, attributeActionsOnEncrypt, allowedUnsignedAttributes, allowedUnsignedAttributePrefix, algorithmSuiteId, structuredEncryption, plaintextOverride, internalLegacyOverride);
    }
    public bool is_Config { get { return true; } }
    public byte dtor_version {
      get {
        return this._version;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient dtor_cmpClient {
      get {
        return this._cmpClient;
      }
    }
    public Dafny.ISequence<char> dtor_logicalTableName {
      get {
        return this._logicalTableName;
      }
    }
    public Dafny.ISequence<char> dtor_partitionKeyName {
      get {
        return this._partitionKeyName;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_sortKeyName {
      get {
        return this._sortKeyName;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager dtor_cmm {
      get {
        return this._cmm;
      }
    }
    public Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> dtor_attributeActionsOnEncrypt {
      get {
        return this._attributeActionsOnEncrypt;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<Dafny.ISequence<char>>> dtor_allowedUnsignedAttributes {
      get {
        return this._allowedUnsignedAttributes;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_allowedUnsignedAttributePrefix {
      get {
        return this._allowedUnsignedAttributePrefix;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId> dtor_algorithmSuiteId {
      get {
        return this._algorithmSuiteId;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.StructuredEncryptionClient dtor_structuredEncryption {
      get {
        return this._structuredEncryption;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride dtor_plaintextOverride {
      get {
        return this._plaintextOverride;
      }
    }
    public Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.legacy.InternalLegacyOverride> dtor_internalLegacyOverride {
      get {
        return this._internalLegacyOverride;
      }
    }
  }

  public partial class ValidConfig {
    private static readonly Dafny.TypeDescriptor<AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile._IConfig> _TYPE = new Dafny.TypeDescriptor<AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile._IConfig>(AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.Config.Default());
    public static Dafny.TypeDescriptor<AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile._IConfig> _TypeDescriptor() {
      return _TYPE;
    }
  }
} // end of namespace AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile
namespace software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny {

  public partial class __default {
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDynamoDbItemEncryptorConfig DefaultDynamoDbItemEncryptorConfig() {
      return software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.DynamoDbItemEncryptorConfig.create(Dafny.Sequence<char>.FromString("foo"), Dafny.Sequence<char>.FromString("bar"), Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None(), Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.FromElements(), Wrappers_Compile.Option<Dafny.ISequence<Dafny.ISequence<char>>>.create_None(), Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None(), Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types._IDBEAlgorithmSuiteId>.create_None(), Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring>.create_None(), Wrappers_Compile.Option<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager>.create_None(), Wrappers_Compile.Option<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILegacyOverride>.create_None(), Wrappers_Compile.Option<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride>.create_None());
    }
    public static bool UnreservedPrefix(Dafny.ISequence<char> attr) {
      return (!(Dafny.Sequence<char>.IsPrefixOf(DynamoDbItemEncryptorUtil_Compile.__default.ReservedPrefix, attr))) && (!(Dafny.Sequence<char>.IsPrefixOf(StructuredEncryptionUtil_Compile.__default.ReservedCryptoContextPrefixString, attr)));
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.DynamoDbItemEncryptorClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> DynamoDbItemEncryptor(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDynamoDbItemEncryptorConfig config)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.DynamoDbItemEncryptorClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> res = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.DynamoDbItemEncryptorClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.Default();
      _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>((((config).dtor_keyring).is_None) || (((config).dtor_cmm).is_None), software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error.create_DynamoDbItemEncryptorException(Dafny.Sequence<char>.FromString("Cannot provide both a keyring and a CMM")));
      if ((_0_valueOrError0).IsFailure()) {
        res = (_0_valueOrError0).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.DynamoDbItemEncryptorClient>();
        return res;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _1_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.Default();
      _1_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>((((config).dtor_keyring).is_Some) || (((config).dtor_cmm).is_Some), software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error.create_DynamoDbItemEncryptorException(Dafny.Sequence<char>.FromString("Must provide either a keyring or a CMM")));
      if ((_1_valueOrError1).IsFailure()) {
        res = (_1_valueOrError1).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.DynamoDbItemEncryptorClient>();
        return res;
      }
      byte _2_version;
      _2_version = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.VersionFromActions((config).dtor_attributeActionsOnEncrypt);
      software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction _3_keyAction;
      _3_keyAction = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.KeyActionFromVersion(_2_version);
      Dafny.ISequence<char> _4_keyActionStr;
      _4_keyActionStr = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.KeyActionStringFromVersion(_2_version);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _5_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.Default();
      _5_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>((((config).dtor_attributeActionsOnEncrypt).Contains((config).dtor_partitionKeyName)) && (object.Equals(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Select((config).dtor_attributeActionsOnEncrypt,(config).dtor_partitionKeyName), _3_keyAction)), software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error.create_DynamoDbItemEncryptorException(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Partition key attribute action MUST be "), _4_keyActionStr)));
      if ((_5_valueOrError2).IsFailure()) {
        res = (_5_valueOrError2).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.DynamoDbItemEncryptorClient>();
        return res;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _6_valueOrError3 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.Default();
      _6_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>(!(((config).dtor_sortKeyName).is_Some) || ((((config).dtor_attributeActionsOnEncrypt).Contains(((config).dtor_sortKeyName).dtor_value)) && (object.Equals(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Select((config).dtor_attributeActionsOnEncrypt,((config).dtor_sortKeyName).dtor_value), _3_keyAction))), software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error.create_DynamoDbItemEncryptorException(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Sort key attribute action MUST be "), _4_keyActionStr)));
      if ((_6_valueOrError3).IsFailure()) {
        res = (_6_valueOrError3).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.DynamoDbItemEncryptorClient>();
        return res;
      }
      Dafny.ISequence<Dafny.ISequence<char>> _7_attributeNames;
      _7_attributeNames = SortedSets.__default.SetToOrderedSequence2<char>(((config).dtor_attributeActionsOnEncrypt).Keys, DynamoDbItemEncryptorUtil_Compile.__default.CharLess);
      BigInteger _hi0 = new BigInteger((_7_attributeNames).Count);
      for (BigInteger _8_i = BigInteger.Zero; _8_i < _hi0; _8_i++) {
        Dafny.ISequence<char> _9_attributeName;
        _9_attributeName = (_7_attributeNames).Select(_8_i);
        software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction _10_action;
        _10_action = Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Select((config).dtor_attributeActionsOnEncrypt,_9_attributeName);
        if (!(AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.ForwardCompatibleAttributeAction(_9_attributeName, _10_action, (config).dtor_allowedUnsignedAttributes, (config).dtor_allowedUnsignedAttributePrefix))) {
          res = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.DynamoDbItemEncryptorClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.create_Failure(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error.create_DynamoDbItemEncryptorException(AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.ExplainNotForwardCompatible(_9_attributeName, _10_action, (config).dtor_allowedUnsignedAttributes, (config).dtor_allowedUnsignedAttributePrefix)));
          return res;
        }
        if (!(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.__default.UnreservedPrefix(_9_attributeName))) {
          res = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.DynamoDbItemEncryptorClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.create_Failure(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error.create_DynamoDbItemEncryptorException(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Attribute: "), _9_attributeName), Dafny.Sequence<char>.FromString(" is reserved, and may not be configured."))));
          return res;
        }
      }
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.StructuredEncryptionClient, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _11_structuredEncryptionRes;
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.StructuredEncryptionClient, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError> _out0;
      _out0 = software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.__default.StructuredEncryption(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.__default.DefaultStructuredEncryptionConfig());
      _11_structuredEncryptionRes = _out0;
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.StructuredEncryptionClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _12_valueOrError4 = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.StructuredEncryptionClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>);
      _12_valueOrError4 = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.StructuredEncryptionClient, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>(_11_structuredEncryptionRes, ((System.Func<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>)((_13_e) => {
        return software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error.create_AwsCryptographyDbEncryptionSdkDynamoDb(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Error.create_AwsCryptographyDbEncryptionSdkStructuredEncryption(_13_e));
      })));
      if ((_12_valueOrError4).IsFailure()) {
        res = (_12_valueOrError4).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.DynamoDbItemEncryptorClient>();
        return res;
      }
      software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.IStructuredEncryptionClient _14_structuredEncryptionX;
      _14_structuredEncryptionX = (_12_valueOrError4).Extract();
      software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.StructuredEncryptionClient _15_structuredEncryption;
      _15_structuredEncryption = ((software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.StructuredEncryptionClient)(_14_structuredEncryptionX));
      software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager _16_cmm = default(software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager);
      if (((config).dtor_cmm).is_Some) {
        _16_cmm = ((config).dtor_cmm).dtor_value;
      } else {
        software.amazon.cryptography.materialproviders.internaldafny.types.IKeyring _17_keyring;
        _17_keyring = ((config).dtor_keyring).dtor_value;
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _18_valueOrError5 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError>);
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out1;
        _out1 = software.amazon.cryptography.materialproviders.internaldafny.__default.MaterialProviders(software.amazon.cryptography.materialproviders.internaldafny.__default.DefaultMaterialProvidersConfig());
        _18_valueOrError5 = _out1;
        if (!(!((_18_valueOrError5).IsFailure()))) {
          throw new Dafny.HaltException("dafny/DynamoDbItemEncryptor/src/Index.dfy(159,21): " + _18_valueOrError5);}
        software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient _19_matProv;
        _19_matProv = (_18_valueOrError5).Extract();
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _20_maybeCmm;
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out2;
        _out2 = (_19_matProv).CreateDefaultCryptographicMaterialsManager(software.amazon.cryptography.materialproviders.internaldafny.types.CreateDefaultCryptographicMaterialsManagerInput.create(_17_keyring));
        _20_maybeCmm = _out2;
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _21_valueOrError6 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>);
        _21_valueOrError6 = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsManager, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>(_20_maybeCmm, ((System.Func<software.amazon.cryptography.materialproviders.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>)((_22_e) => {
          return software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error.create_AwsCryptographyMaterialProviders(_22_e);
        })));
        if ((_21_valueOrError6).IsFailure()) {
          res = (_21_valueOrError6).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.DynamoDbItemEncryptorClient>();
          return res;
        }
        _16_cmm = (_21_valueOrError6).Extract();
      }
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _23_maybeCmpClient;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out3;
      _out3 = software.amazon.cryptography.materialproviders.internaldafny.__default.MaterialProviders(software.amazon.cryptography.materialproviders.internaldafny.__default.DefaultMaterialProvidersConfig());
      _23_maybeCmpClient = _out3;
      Wrappers_Compile._IResult<Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.legacy.InternalLegacyOverride>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _24_valueOrError7 = Wrappers_Compile.Result<Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.legacy.InternalLegacyOverride>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.Default(Wrappers_Compile.Option<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.legacy.InternalLegacyOverride>.Default());
      Wrappers_Compile._IResult<Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.legacy.InternalLegacyOverride>, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _out4;
      _out4 = software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.legacy.InternalLegacyOverride.Build(config);
      _24_valueOrError7 = _out4;
      if ((_24_valueOrError7).IsFailure()) {
        res = (_24_valueOrError7).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.DynamoDbItemEncryptorClient>();
        return res;
      }
      Wrappers_Compile._IOption<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.legacy.InternalLegacyOverride> _25_internalLegacyOverride;
      _25_internalLegacyOverride = (_24_valueOrError7).Extract();
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _26_valueOrError8 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>);
      _26_valueOrError8 = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>(_23_maybeCmpClient, ((System.Func<software.amazon.cryptography.materialproviders.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>)((_27_e) => {
        return software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error.create_AwsCryptographyMaterialProviders(_27_e);
      })));
      if ((_26_valueOrError8).IsFailure()) {
        res = (_26_valueOrError8).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.DynamoDbItemEncryptorClient>();
        return res;
      }
      software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient _28_cmpClient;
      _28_cmpClient = (_26_valueOrError8).Extract();
      if (!(((_25_internalLegacyOverride).is_None) || (((config).dtor_plaintextOverride).is_None))) {
        res = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.DynamoDbItemEncryptorClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.create_Failure(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.Error.create_DynamoDbItemEncryptorException(Dafny.Sequence<char>.FromString("Cannot configure both a plaintext policy and a legacy config.")));
        return res;
      }
      software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride _29_plaintextOverride;
      if (((config).dtor_plaintextOverride).is_Some) {
        _29_plaintextOverride = ((config).dtor_plaintextOverride).dtor_value;
      } else {
        _29_plaintextOverride = software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.PlaintextOverride.create_FORBID__PLAINTEXT__WRITE__FORBID__PLAINTEXT__READ();
      }
      AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile._IConfig _30_internalConfig;
      _30_internalConfig = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.Config.create(_2_version, _28_cmpClient, (config).dtor_logicalTableName, (config).dtor_partitionKeyName, (config).dtor_sortKeyName, _16_cmm, (config).dtor_attributeActionsOnEncrypt, (config).dtor_allowedUnsignedAttributes, (config).dtor_allowedUnsignedAttributePrefix, (config).dtor_algorithmSuiteId, _15_structuredEncryption, _29_plaintextOverride, _25_internalLegacyOverride);
      software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.DynamoDbItemEncryptorClient _31_client;
      software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.DynamoDbItemEncryptorClient _nw0 = new software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.DynamoDbItemEncryptorClient();
      _nw0.__ctor(_30_internalConfig);
      _31_client = _nw0;
      res = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.DynamoDbItemEncryptorClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.create_Success(_31_client);
      return res;
      return res;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.IDynamoDbItemEncryptorClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> CreateSuccessOfClient(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.IDynamoDbItemEncryptorClient client) {
      return Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.IDynamoDbItemEncryptorClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.create_Success(client);
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.IDynamoDbItemEncryptorClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> CreateFailureOfError(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError error) {
      return Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.IDynamoDbItemEncryptorClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.create_Failure(error);
    }
  }

  public partial class DynamoDbItemEncryptorClient : software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.IDynamoDbItemEncryptorClient {
    public DynamoDbItemEncryptorClient() {
      this._config = default(AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile._IConfig);
    }
    public void __ctor(AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile._IConfig config)
    {
      (this)._config = config;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> EncryptItem(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.EncryptItemOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.EncryptItem((this).config, input);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> DecryptItem(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.DecryptItemOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile.__default.DecryptItem((this).config, input);
      output = _out0;
      return output;
    }
    public AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile._IConfig _config {get; set;}
    public AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile._IConfig config { get {
      return this._config;
    } }
  }
} // end of namespace software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny
namespace DynamoDbEncryptionBranchKeyIdSupplier_Compile {

  public partial class __default {
    public static software.amazon.cryptography.materialproviders.internaldafny.types._IError ConvertToMplError(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError err) {
      if ((err).is_Opaque) {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_Opaque((err).dtor_obj);
      } else {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(Dafny.Sequence<char>.FromString("Unexpected error while getting Branch Key ID."));
      }
    }
  }

  public partial class DynamoDbEncryptionBranchKeyIdSupplier : software.amazon.cryptography.materialproviders.internaldafny.types.IBranchKeyIdSupplier {
    public DynamoDbEncryptionBranchKeyIdSupplier() {
      this._ddbKeyBranchKeyIdSupplier = default(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.IDynamoDbKeyBranchKeyIdSupplier);
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetBranchKeyIdOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetBranchKeyId(software.amazon.cryptography.materialproviders.internaldafny.types._IGetBranchKeyIdInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetBranchKeyIdOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out0;
      _out0 = software.amazon.cryptography.materialproviders.internaldafny.types._Companion_IBranchKeyIdSupplier.GetBranchKeyId(this, input);
      return _out0;
    }
    public void __ctor(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.IDynamoDbKeyBranchKeyIdSupplier ddbKeyBranchKeyIdSupplier)
    {
      (this)._ddbKeyBranchKeyIdSupplier = ddbKeyBranchKeyIdSupplier;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetBranchKeyIdOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> GetBranchKeyId_k(software.amazon.cryptography.materialproviders.internaldafny.types._IGetBranchKeyIdInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetBranchKeyIdOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IGetBranchKeyIdOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(software.amazon.cryptography.materialproviders.internaldafny.types.GetBranchKeyIdOutput.Default());
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.ISequence<char>> _0_attrMapR;
      _0_attrMapR = DynamoDbItemEncryptorUtil_Compile.__default.ConvertContextForSelector((input).dtor_encryptionContext);
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _1_valueOrError0 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
      _1_valueOrError0 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_0_attrMapR, ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>)((_2_e) => {
        return software.amazon.cryptography.materialproviders.internaldafny.types.Error.create_AwsCryptographicMaterialProvidersException(_2_e);
      })));
      if ((_1_valueOrError0).IsFailure()) {
        output = (_1_valueOrError0).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IGetBranchKeyIdOutput>();
        return output;
      }
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _3_attrMap;
      _3_attrMap = (_1_valueOrError0).Extract();
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetBranchKeyIdFromDdbKeyOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _4_branchKeyIdR;
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetBranchKeyIdFromDdbKeyOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
      _out0 = ((this).ddbKeyBranchKeyIdSupplier).GetBranchKeyIdFromDdbKey(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.GetBranchKeyIdFromDdbKeyInput.create(_3_attrMap));
      _4_branchKeyIdR = _out0;
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetBranchKeyIdFromDdbKeyOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _5_valueOrError1 = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetBranchKeyIdFromDdbKeyOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.GetBranchKeyIdFromDdbKeyOutput.Default());
      _5_valueOrError1 = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetBranchKeyIdFromDdbKeyOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IError>(_4_branchKeyIdR, DynamoDbEncryptionBranchKeyIdSupplier_Compile.__default.ConvertToMplError);
      if ((_5_valueOrError1).IsFailure()) {
        output = (_5_valueOrError1).PropagateFailure<software.amazon.cryptography.materialproviders.internaldafny.types._IGetBranchKeyIdOutput>();
        return output;
      }
      software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetBranchKeyIdFromDdbKeyOutput _6_branchKeyIdOut;
      _6_branchKeyIdOut = (_5_valueOrError1).Extract();
      output = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types._IGetBranchKeyIdOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.create_Success(software.amazon.cryptography.materialproviders.internaldafny.types.GetBranchKeyIdOutput.create((_6_branchKeyIdOut).dtor_branchKeyId));
      return output;
      return output;
    }
    public software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.IDynamoDbKeyBranchKeyIdSupplier _ddbKeyBranchKeyIdSupplier {get; set;}
    public software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.IDynamoDbKeyBranchKeyIdSupplier ddbKeyBranchKeyIdSupplier { get {
      return this._ddbKeyBranchKeyIdSupplier;
    } }
  }
} // end of namespace DynamoDbEncryptionBranchKeyIdSupplier_Compile
namespace AwsCryptographyDbEncryptionSdkDynamoDbOperations_Compile {

  public partial class __default {
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICreateDynamoDbEncryptionBranchKeyIdSupplierOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> CreateDynamoDbEncryptionBranchKeyIdSupplier(AwsCryptographyDbEncryptionSdkDynamoDbOperations_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICreateDynamoDbEncryptionBranchKeyIdSupplierInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICreateDynamoDbEncryptionBranchKeyIdSupplierOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICreateDynamoDbEncryptionBranchKeyIdSupplierOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>);
      DynamoDbEncryptionBranchKeyIdSupplier_Compile.DynamoDbEncryptionBranchKeyIdSupplier _0_supplier;
      DynamoDbEncryptionBranchKeyIdSupplier_Compile.DynamoDbEncryptionBranchKeyIdSupplier _nw0 = new DynamoDbEncryptionBranchKeyIdSupplier_Compile.DynamoDbEncryptionBranchKeyIdSupplier();
      _nw0.__ctor((input).dtor_ddbKeyBranchKeyIdSupplier);
      _0_supplier = _nw0;
      output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICreateDynamoDbEncryptionBranchKeyIdSupplierOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.CreateDynamoDbEncryptionBranchKeyIdSupplierOutput.create(_0_supplier));
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetEncryptedDataKeyDescription(AwsCryptographyDbEncryptionSdkDynamoDbOperations_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.GetEncryptedDataKeyDescriptionOutput.Default());
      Dafny.ISequence<byte> _0_header = Dafny.Sequence<byte>.Empty;
      software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionUnion _source0 = (input).dtor_input;
      {
        if (_source0.is_item) {
          Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _1_item = _source0.dtor_item;
          {
            Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _2_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default();
            _2_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(((_1_item).Contains(Dafny.Sequence<char>.FromString("aws_dbe_head"))) && ((Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(_1_item,Dafny.Sequence<char>.FromString("aws_dbe_head"))).is_B), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Header not found in the DynamoDB item.")));
            if ((_2_valueOrError0).IsFailure()) {
              output = (_2_valueOrError0).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionOutput>();
              return output;
            }
            _0_header = (Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(_1_item,Dafny.Sequence<char>.FromString("aws_dbe_head"))).dtor_B;
          }
          goto after_match0;
        }
      }
      {
        Dafny.ISequence<byte> _3_headerItem = _source0.dtor_header;
        _0_header = _3_headerItem;
      }
    after_match0: ;
      Wrappers_Compile._IResult<StructuredEncryptionHeader_Compile._IPartialHeader, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _4_valueOrError1 = default(Wrappers_Compile._IResult<StructuredEncryptionHeader_Compile._IPartialHeader, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>);
      _4_valueOrError1 = Wrappers_Compile.Result<StructuredEncryptionHeader_Compile._IPartialHeader, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(StructuredEncryptionHeader_Compile.__default.PartialDeserialize(_0_header), ((System.Func<software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>)((_5_e) => {
        return software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Error.create_AwsCryptographyDbEncryptionSdkStructuredEncryption(_5_e);
      })));
      if ((_4_valueOrError1).IsFailure()) {
        output = (_4_valueOrError1).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionOutput>();
        return output;
      }
      StructuredEncryptionHeader_Compile._IPartialHeader _6_deserializedHeader;
      _6_deserializedHeader = (_4_valueOrError1).Extract();
      Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> _7_datakeys;
      _7_datakeys = (_6_deserializedHeader).dtor_dataKeys;
      Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedDataKeyDescription> _8_list;
      _8_list = Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedDataKeyDescription>.FromElements();
      BigInteger _hi0 = new BigInteger((_7_datakeys).Count);
      for (BigInteger _9_i = BigInteger.Zero; _9_i < _hi0; _9_i++) {
        Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _10_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Sequence<char>.Empty);
        _10_valueOrError2 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(UTF8.__default.Decode(((_7_datakeys).Select(_9_i)).dtor_keyProviderId), ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>)((_11_e) => {
          return DynamoDbEncryptionUtil_Compile.__default.E(_11_e);
        })));
        if ((_10_valueOrError2).IsFailure()) {
          output = (_10_valueOrError2).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionOutput>();
          return output;
        }
        Dafny.ISequence<char> _12_extractedKeyProviderId;
        _12_extractedKeyProviderId = (_10_valueOrError2).Extract();
        Wrappers_Compile._IOption<Dafny.ISequence<char>> _13_extractedKeyProviderIdInfo;
        _13_extractedKeyProviderIdInfo = Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None();
        Wrappers_Compile._IOption<Dafny.ISequence<char>> _14_expectedBranchKeyVersion;
        _14_expectedBranchKeyVersion = Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None();
        if (Dafny.Sequence<char>.IsPrefixOf(Dafny.Sequence<char>.FromString("aws-kms"), _12_extractedKeyProviderId)) {
          Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _15_valueOrError3 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default();
          _15_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>((((_6_deserializedHeader).dtor_flavor) == ((byte)(0))) || (((_6_deserializedHeader).dtor_flavor) == ((byte)(1))), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Invalid format flavor.")));
          if ((_15_valueOrError3).IsFailure()) {
            output = (_15_valueOrError3).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionOutput>();
            return output;
          }
          software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo _16_algorithmSuite = default(software.amazon.cryptography.materialproviders.internaldafny.types._IAlgorithmSuiteInfo);
          if (((_6_deserializedHeader).dtor_flavor) == ((byte)(0))) {
            _16_algorithmSuite = AlgorithmSuites_Compile.__default.DBE__ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__SYMSIG__HMAC__SHA384;
          } else {
            _16_algorithmSuite = AlgorithmSuites_Compile.__default.DBE__ALG__AES__256__GCM__HKDF__SHA512__COMMIT__KEY__ECDSA__P384__SYMSIG__HMAC__SHA384;
          }
          Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _17_valueOrError4 = Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Sequence<char>.Empty);
          _17_valueOrError4 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(UTF8.__default.Decode(((_7_datakeys).Select(_9_i)).dtor_keyProviderInfo), ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>)((_18_e) => {
            return DynamoDbEncryptionUtil_Compile.__default.E(_18_e);
          })));
          if ((_17_valueOrError4).IsFailure()) {
            output = (_17_valueOrError4).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionOutput>();
            return output;
          }
          Dafny.ISequence<char> _19_maybeKeyProviderIdInfo;
          _19_maybeKeyProviderIdInfo = (_17_valueOrError4).Extract();
          _13_extractedKeyProviderIdInfo = Wrappers_Compile.Option<Dafny.ISequence<char>>.create_Some(_19_maybeKeyProviderIdInfo);
          if ((_12_extractedKeyProviderId).Equals(Dafny.Sequence<char>.FromString("aws-kms-hierarchy"))) {
            Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _20_valueOrError5 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
            _20_valueOrError5 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(EdkWrapping_Compile.__default.GetProviderWrappedMaterial(((_7_datakeys).Select(_9_i)).dtor_ciphertext, _16_algorithmSuite), ((System.Func<software.amazon.cryptography.materialproviders.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>)((_21_e) => {
              return software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Error.create_AwsCryptographyMaterialProviders(_21_e);
            })));
            if ((_20_valueOrError5).IsFailure()) {
              output = (_20_valueOrError5).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionOutput>();
              return output;
            }
            Dafny.ISequence<byte> _22_providerWrappedMaterial;
            _22_providerWrappedMaterial = (_20_valueOrError5).Extract();
            BigInteger _23_EDK__CIPHERTEXT__BRANCH__KEY__VERSION__INDEX;
            _23_EDK__CIPHERTEXT__BRANCH__KEY__VERSION__INDEX = (AwsCryptographyDbEncryptionSdkDynamoDbOperations_Compile.__default.SALT__LENGTH) + (AwsCryptographyDbEncryptionSdkDynamoDbOperations_Compile.__default.IV__LENGTH);
            BigInteger _24_EDK__CIPHERTEXT__VERSION__INDEX;
            _24_EDK__CIPHERTEXT__VERSION__INDEX = (_23_EDK__CIPHERTEXT__BRANCH__KEY__VERSION__INDEX) + (AwsCryptographyDbEncryptionSdkDynamoDbOperations_Compile.__default.VERSION__LENGTH);
            Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _25_valueOrError6 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default();
            _25_valueOrError6 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>((_23_EDK__CIPHERTEXT__BRANCH__KEY__VERSION__INDEX) < (_24_EDK__CIPHERTEXT__VERSION__INDEX), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Wrong branch key version index.")));
            if ((_25_valueOrError6).IsFailure()) {
              output = (_25_valueOrError6).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionOutput>();
              return output;
            }
            Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _26_valueOrError7 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default();
            _26_valueOrError7 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>((new BigInteger((_22_providerWrappedMaterial).Count)) >= (_24_EDK__CIPHERTEXT__VERSION__INDEX), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Incorrect ciphertext structure length.")));
            if ((_26_valueOrError7).IsFailure()) {
              output = (_26_valueOrError7).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionOutput>();
              return output;
            }
            Dafny.ISequence<byte> _27_branchKeyVersionUuid;
            _27_branchKeyVersionUuid = (_22_providerWrappedMaterial).Subsequence(_23_EDK__CIPHERTEXT__BRANCH__KEY__VERSION__INDEX, _24_EDK__CIPHERTEXT__VERSION__INDEX);
            Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _28_valueOrError8 = Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Sequence<char>.Empty);
            _28_valueOrError8 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(UUID.__default.FromByteArray(_27_branchKeyVersionUuid), ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>)((_29_e) => {
              return DynamoDbEncryptionUtil_Compile.__default.E(_29_e);
            })));
            if ((_28_valueOrError8).IsFailure()) {
              output = (_28_valueOrError8).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionOutput>();
              return output;
            }
            Dafny.ISequence<char> _30_maybeBranchKeyVersion;
            _30_maybeBranchKeyVersion = (_28_valueOrError8).Extract();
            _14_expectedBranchKeyVersion = Wrappers_Compile.Option<Dafny.ISequence<char>>.create_Some(_30_maybeBranchKeyVersion);
          }
        }
        software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedDataKeyDescription _31_singleDataKeyOutput;
        _31_singleDataKeyOutput = software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.EncryptedDataKeyDescription.create(_12_extractedKeyProviderId, _13_extractedKeyProviderIdInfo, _13_extractedKeyProviderIdInfo, _14_expectedBranchKeyVersion);
        _8_list = Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedDataKeyDescription>.Concat(_8_list, Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedDataKeyDescription>.FromElements(_31_singleDataKeyOutput));
      }
      output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.GetEncryptedDataKeyDescriptionOutput.create(_8_list));
      return output;
    }
    public static BigInteger SALT__LENGTH { get {
      return new BigInteger(16);
    } }
    public static BigInteger IV__LENGTH { get {
      return new BigInteger(12);
    } }
    public static BigInteger VERSION__LENGTH { get {
      return new BigInteger(16);
    } }
  }

  public interface _IConfig {
    bool is_Config { get; }
    _IConfig DowncastClone();
  }
  public class Config : _IConfig {
    public Config() {
    }
    public _IConfig DowncastClone() {
      if (this is _IConfig dt) { return dt; }
      return new Config();
    }
    public override bool Equals(object other) {
      var oth = other as AwsCryptographyDbEncryptionSdkDynamoDbOperations_Compile.Config;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbOperations.Config.Config";
      return s;
    }
    private static readonly AwsCryptographyDbEncryptionSdkDynamoDbOperations_Compile._IConfig theDefault = create();
    public static AwsCryptographyDbEncryptionSdkDynamoDbOperations_Compile._IConfig Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<AwsCryptographyDbEncryptionSdkDynamoDbOperations_Compile._IConfig> _TYPE = new Dafny.TypeDescriptor<AwsCryptographyDbEncryptionSdkDynamoDbOperations_Compile._IConfig>(AwsCryptographyDbEncryptionSdkDynamoDbOperations_Compile.Config.Default());
    public static Dafny.TypeDescriptor<AwsCryptographyDbEncryptionSdkDynamoDbOperations_Compile._IConfig> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IConfig create() {
      return new Config();
    }
    public static _IConfig create_Config() {
      return create();
    }
    public bool is_Config { get { return true; } }
    public static System.Collections.Generic.IEnumerable<_IConfig> AllSingletonConstructors {
      get {
        yield return Config.create();
      }
    }
  }
} // end of namespace AwsCryptographyDbEncryptionSdkDynamoDbOperations_Compile
namespace software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny {

  public partial class __default {
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbEncryptionConfig DefaultDynamoDbEncryptionConfig() {
      return software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.DynamoDbEncryptionConfig.create();
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.DynamoDbEncryptionClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> DynamoDbEncryption(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbEncryptionConfig config)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.DynamoDbEncryptionClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> res = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.DynamoDbEncryptionClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>);
      AwsCryptographyDbEncryptionSdkDynamoDbOperations_Compile._IConfig _0_internalConfig;
      _0_internalConfig = AwsCryptographyDbEncryptionSdkDynamoDbOperations_Compile.Config.create();
      software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.DynamoDbEncryptionClient _1_client;
      software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.DynamoDbEncryptionClient _nw0 = new software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.DynamoDbEncryptionClient();
      _nw0.__ctor(_0_internalConfig);
      _1_client = _nw0;
      res = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.DynamoDbEncryptionClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(_1_client);
      return res;
      return res;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.IDynamoDbEncryptionClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> CreateSuccessOfClient(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.IDynamoDbEncryptionClient client) {
      return Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.IDynamoDbEncryptionClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(client);
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.IDynamoDbEncryptionClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> CreateFailureOfError(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError error) {
      return Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.IDynamoDbEncryptionClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(error);
    }
  }

  public partial class DynamoDbEncryptionClient : software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.IDynamoDbEncryptionClient {
    public DynamoDbEncryptionClient() {
      this._config = AwsCryptographyDbEncryptionSdkDynamoDbOperations_Compile.Config.Default();
    }
    public void __ctor(AwsCryptographyDbEncryptionSdkDynamoDbOperations_Compile._IConfig config)
    {
      (this)._config = config;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICreateDynamoDbEncryptionBranchKeyIdSupplierOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> CreateDynamoDbEncryptionBranchKeyIdSupplier(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICreateDynamoDbEncryptionBranchKeyIdSupplierInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICreateDynamoDbEncryptionBranchKeyIdSupplierOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICreateDynamoDbEncryptionBranchKeyIdSupplierOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICreateDynamoDbEncryptionBranchKeyIdSupplierOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkDynamoDbOperations_Compile.__default.CreateDynamoDbEncryptionBranchKeyIdSupplier((this).config, input);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetEncryptedDataKeyDescription(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.GetEncryptedDataKeyDescriptionOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetEncryptedDataKeyDescriptionOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkDynamoDbOperations_Compile.__default.GetEncryptedDataKeyDescription((this).config, input);
      output = _out0;
      return output;
    }
    public AwsCryptographyDbEncryptionSdkDynamoDbOperations_Compile._IConfig _config {get; set;}
    public AwsCryptographyDbEncryptionSdkDynamoDbOperations_Compile._IConfig config { get {
      return this._config;
    } }
  }
} // end of namespace software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny
namespace TermLoc_Compile {

  public partial class __default {
    public static bool ValidTermLoc(Dafny.ISequence<TermLoc_Compile._ISelector> s) {
      return (((new BigInteger((s).Count)).Sign == 1) && ((new BigInteger((s).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT64__LIMIT))) && (((s).Select(BigInteger.Zero)).is_Map);
    }
    public static Dafny.ISequence<char> TermLocToString(Dafny.ISequence<TermLoc_Compile._ISelector> t) {
      return Dafny.Sequence<char>.Concat(((t).Select(BigInteger.Zero)).dtor_key, TermLoc_Compile.__default.SelectorListToString((t).Drop(BigInteger.One)));
    }
    public static Dafny.ISequence<char> SelectorListToString(Dafny.ISequence<TermLoc_Compile._ISelector> s) {
      Dafny.ISequence<char> _0___accumulator = Dafny.Sequence<char>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((s).Count)).Sign == 0) {
        return Dafny.Sequence<char>.Concat(_0___accumulator, Dafny.Sequence<char>.FromString(""));
      } else if (((s).Select(BigInteger.Zero)).is_Map) {
        _0___accumulator = Dafny.Sequence<char>.Concat(_0___accumulator, Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("."), ((s).Select(BigInteger.Zero)).dtor_key));
        Dafny.ISequence<TermLoc_Compile._ISelector> _in0 = (s).Drop(BigInteger.One);
        s = _in0;
        goto TAIL_CALL_START;
      } else {
        _0___accumulator = Dafny.Sequence<char>.Concat(_0___accumulator, Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("["), StandardLibrary_mString_Compile.__default.Base10Int2String(new BigInteger(((s).Select(BigInteger.Zero)).dtor_pos))), Dafny.Sequence<char>.FromString("]")));
        Dafny.ISequence<TermLoc_Compile._ISelector> _in1 = (s).Drop(BigInteger.One);
        s = _in1;
        goto TAIL_CALL_START;
      }
    }
    public static bool LacksAttribute(Dafny.ISequence<TermLoc_Compile._ISelector> t, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item)
    {
      return !(item).Contains(((t).Select(BigInteger.Zero)).dtor_key);
    }
    public static Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> TermToAttr(Dafny.ISequence<TermLoc_Compile._ISelector> t, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> names)
    {
      if (!(item).Contains(((t).Select(BigInteger.Zero)).dtor_key)) {
        return Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.create_None();
      } else {
        Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_res = TermLoc_Compile.__default.GetTerminal(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(item,((t).Select(BigInteger.Zero)).dtor_key), (t).Drop(BigInteger.One), names);
        if ((_0_res).is_Success) {
          return Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.create_Some((_0_res).dtor_value);
        } else {
          return Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.create_None();
        }
      }
    }
    public static Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> TermToString(Dafny.ISequence<TermLoc_Compile._ISelector> t, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item)
    {
      Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _0_part = TermLoc_Compile.__default.TermToAttr(t, item, Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>.create_None());
      if ((_0_part).is_None) {
        return Wrappers_Compile.Result<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None());
      } else {
        Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _1_valueOrError0 = TermLoc_Compile.__default.AttrValueToString((_0_part).dtor_value);
        if ((_1_valueOrError0).IsFailure()) {
          return (_1_valueOrError0).PropagateFailure<Wrappers_Compile._IOption<Dafny.ISequence<char>>>();
        } else {
          Dafny.ISequence<char> _2_res = (_1_valueOrError0).Extract();
          return Wrappers_Compile.Result<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Wrappers_Compile.Option<Dafny.ISequence<char>>.create_Some(_2_res));
        }
      }
    }
    public static Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> TermToBytes(Dafny.ISequence<TermLoc_Compile._ISelector> t, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item)
    {
      Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _0_part = TermLoc_Compile.__default.TermToAttr(t, item, Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>.create_None());
      if ((_0_part).is_None) {
        return Wrappers_Compile.Result<Wrappers_Compile._IOption<Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None());
      } else {
        Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _1_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(DynamoToStruct_Compile.__default.TopLevelAttributeToBytes((_0_part).dtor_value), ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>)((_2_e) => {
          return DynamoDbEncryptionUtil_Compile.__default.E(_2_e);
        })));
        if ((_1_valueOrError0).IsFailure()) {
          return (_1_valueOrError0).PropagateFailure<Wrappers_Compile._IOption<Dafny.ISequence<byte>>>();
        } else {
          Dafny.ISequence<byte> _3_res = (_1_valueOrError0).Extract();
          return Wrappers_Compile.Result<Wrappers_Compile._IOption<Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_3_res));
        }
      }
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetTerminal(software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue v, Dafny.ISequence<TermLoc_Compile._ISelector> parts, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> names)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((parts).Count)).Sign == 0) {
        return Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(v);
      } else {
        software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue _source0 = v;
        {
          if (_source0.is_S) {
            Dafny.ISequence<char> _0_s = _source0.dtor_S;
            return Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Found string with parts left over.")));
          }
        }
        {
          if (_source0.is_N) {
            Dafny.ISequence<char> _1_s = _source0.dtor_N;
            return Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Found number with parts left over.")));
          }
        }
        {
          if (_source0.is_B) {
            Dafny.ISequence<byte> _2_b = _source0.dtor_B;
            return Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Found binary with parts left over.")));
          }
        }
        {
          if (_source0.is_SS) {
            Dafny.ISequence<Dafny.ISequence<char>> _3_s = _source0.dtor_SS;
            return Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Found string set with parts left over.")));
          }
        }
        {
          if (_source0.is_NS) {
            Dafny.ISequence<Dafny.ISequence<char>> _4_s = _source0.dtor_NS;
            return Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Found number set with parts left over.")));
          }
        }
        {
          if (_source0.is_BS) {
            Dafny.ISequence<Dafny.ISequence<byte>> _5_s = _source0.dtor_BS;
            return Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Found binary set with parts left over.")));
          }
        }
        {
          if (_source0.is_BOOL) {
            bool _6_b = _source0.dtor_BOOL;
            return Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Found boolean with parts left over.")));
          }
        }
        {
          if (_source0.is_NULL) {
            bool _7_n = _source0.dtor_NULL;
            return Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Found null with parts left over.")));
          }
        }
        {
          if (_source0.is_L) {
            Dafny.ISequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _8_l = _source0.dtor_L;
            if (!(((parts).Select(BigInteger.Zero)).is_List)) {
              return Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Tried to access list with key")));
            } else if ((new BigInteger((_8_l).Count)) <= (new BigInteger(((parts).Select(BigInteger.Zero)).dtor_pos))) {
              return Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Tried to access beyond the end of the list")));
            } else {
              software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue _in0 = (_8_l).Select(((parts).Select(BigInteger.Zero)).dtor_pos);
              Dafny.ISequence<TermLoc_Compile._ISelector> _in1 = (parts).Drop(BigInteger.One);
              Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> _in2 = names;
              v = _in0;
              parts = _in1;
              names = _in2;
              goto TAIL_CALL_START;
            }
          }
        }
        {
          Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _9_m = _source0.dtor_M;
          if (!(((parts).Select(BigInteger.Zero)).is_Map)) {
            return Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Tried to access map with index")));
          } else if (!(_9_m).Contains(((parts).Select(BigInteger.Zero)).dtor_key)) {
            if ((((names).is_Some) && (((names).dtor_value).Contains(((parts).Select(BigInteger.Zero)).dtor_key))) && ((_9_m).Contains(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Select((names).dtor_value,((parts).Select(BigInteger.Zero)).dtor_key)))) {
              software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue _in3 = Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(_9_m,Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Select((names).dtor_value,((parts).Select(BigInteger.Zero)).dtor_key));
              Dafny.ISequence<TermLoc_Compile._ISelector> _in4 = (parts).Drop(BigInteger.One);
              Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> _in5 = names;
              v = _in3;
              parts = _in4;
              names = _in5;
              goto TAIL_CALL_START;
            } else {
              return Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Tried to access "), ((parts).Select(BigInteger.Zero)).dtor_key), Dafny.Sequence<char>.FromString(" which is not in the map."))));
            }
          } else {
            software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue _in6 = Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(_9_m,((parts).Select(BigInteger.Zero)).dtor_key);
            Dafny.ISequence<TermLoc_Compile._ISelector> _in7 = (parts).Drop(BigInteger.One);
            Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> _in8 = names;
            v = _in6;
            parts = _in7;
            names = _in8;
            goto TAIL_CALL_START;
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> AttrValueToString(software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue v) {
      software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue _source0 = v;
      {
        if (_source0.is_S) {
          Dafny.ISequence<char> _0_s = _source0.dtor_S;
          return Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(_0_s);
        }
      }
      {
        if (_source0.is_N) {
          Dafny.ISequence<char> _1_s = _source0.dtor_N;
          return Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(_1_s);
        }
      }
      {
        if (_source0.is_B) {
          Dafny.ISequence<byte> _2_b = _source0.dtor_B;
          return Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Can't convert Binary to string")));
        }
      }
      {
        if (_source0.is_SS) {
          Dafny.ISequence<Dafny.ISequence<char>> _3_s = _source0.dtor_SS;
          return Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Can't convert String Set to string.")));
        }
      }
      {
        if (_source0.is_NS) {
          Dafny.ISequence<Dafny.ISequence<char>> _4_s = _source0.dtor_NS;
          return Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Can't convert Number Set to string.")));
        }
      }
      {
        if (_source0.is_BS) {
          Dafny.ISequence<Dafny.ISequence<byte>> _5_s = _source0.dtor_BS;
          return Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Can't convert Binary Set to string.")));
        }
      }
      {
        if (_source0.is_BOOL) {
          bool _6_b = _source0.dtor_BOOL;
          return Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(((_6_b) ? (Dafny.Sequence<char>.FromString("true")) : (Dafny.Sequence<char>.FromString("false"))));
        }
      }
      {
        if (_source0.is_NULL) {
          bool _7_n = _source0.dtor_NULL;
          return Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Dafny.Sequence<char>.FromString("null"));
        }
      }
      {
        if (_source0.is_L) {
          Dafny.ISequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _8_l = _source0.dtor_L;
          return Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Can't convert List to string.")));
        }
      }
      {
        Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _9_m = _source0.dtor_M;
        return Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Can't convert Map to string.")));
      }
    }
    public static Wrappers_Compile._IOption<BigInteger> FindStartOfNext(Dafny.ISequence<char> s) {
      Wrappers_Compile._IOption<BigInteger> _0_dot = StandardLibrary_Compile.__default.FindIndexMatching<char>(s, '.', BigInteger.Zero);
      Wrappers_Compile._IOption<BigInteger> _1_bracket = StandardLibrary_Compile.__default.FindIndexMatching<char>(s, '[', BigInteger.Zero);
      if (((_0_dot).is_None) && ((_1_bracket).is_None)) {
        return Wrappers_Compile.Option<BigInteger>.create_None();
      } else if (((_0_dot).is_Some) && ((_1_bracket).is_Some)) {
        if (((_0_dot).dtor_value) < ((_1_bracket).dtor_value)) {
          return _0_dot;
        } else {
          return _1_bracket;
        }
      } else if ((_0_dot).is_Some) {
        return _0_dot;
      } else {
        return _1_bracket;
      }
    }
    public static Wrappers_Compile._IResult<BigInteger, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetNumber(Dafny.ISequence<char> s, BigInteger acc)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((s).Count)).Sign == 0) {
        return Wrappers_Compile.Result<BigInteger, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(acc);
      } else if ((('0') <= ((s).Select(BigInteger.Zero))) && (((s).Select(BigInteger.Zero)) <= ('9'))) {
        Dafny.ISequence<char> _in0 = (s).Drop(BigInteger.One);
        BigInteger _in1 = (((acc) * (new BigInteger(10))) + (new BigInteger((s).Select(BigInteger.Zero)))) - (new BigInteger('0'));
        s = _in0;
        acc = _in1;
        goto TAIL_CALL_START;
      } else {
        return Wrappers_Compile.Result<BigInteger, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Unexpected character in number : "), Dafny.Sequence<char>.FromElements((s).Select(BigInteger.Zero)))));
      }
    }
    public static Wrappers_Compile._IResult<TermLoc_Compile._ISelector, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetSelector(Dafny.ISequence<char> s) {
      if (((s).Select(BigInteger.Zero)) == ('.')) {
        return Wrappers_Compile.Result<TermLoc_Compile._ISelector, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(TermLoc_Compile.Selector.create_Map((s).Drop(BigInteger.One)));
      } else if (((s).Select((new BigInteger((s).Count)) - (BigInteger.One))) != (']')) {
        return Wrappers_Compile.Result<TermLoc_Compile._ISelector, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("List index must end with ]")));
      } else {
        Wrappers_Compile._IResult<BigInteger, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = TermLoc_Compile.__default.GetNumber((s).Subsequence(BigInteger.One, (new BigInteger((s).Count)) - (BigInteger.One)), BigInteger.Zero);
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<TermLoc_Compile._ISelector>();
        } else {
          BigInteger _1_num = (_0_valueOrError0).Extract();
          Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _2_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>((_1_num) < (StandardLibrary_mUInt_Compile.__default.UINT64__LIMIT), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Array selector exceeds maximum.")));
          if ((_2_valueOrError1).IsFailure()) {
            return (_2_valueOrError1).PropagateFailure<TermLoc_Compile._ISelector>();
          } else {
            return Wrappers_Compile.Result<TermLoc_Compile._ISelector, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(TermLoc_Compile.Selector.create_List((ulong)(_1_num)));
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<TermLoc_Compile._ISelector>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetSelectors(Dafny.ISequence<char> s, Dafny.ISequence<TermLoc_Compile._ISelector> acc)
    {
    TAIL_CALL_START: ;
      Wrappers_Compile._IOption<BigInteger> _0_pos = TermLoc_Compile.__default.FindStartOfNext((s).Drop(BigInteger.One));
      BigInteger _1_end = (((_0_pos).is_None) ? (new BigInteger((s).Count)) : (((_0_pos).dtor_value) + (BigInteger.One)));
      Wrappers_Compile._IResult<TermLoc_Compile._ISelector, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _2_valueOrError0 = TermLoc_Compile.__default.GetSelector((s).Take(_1_end));
      if ((_2_valueOrError0).IsFailure()) {
        return (_2_valueOrError0).PropagateFailure<Dafny.ISequence<TermLoc_Compile._ISelector>>();
      } else {
        TermLoc_Compile._ISelector _3_sel = (_2_valueOrError0).Extract();
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _4_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(((new BigInteger((acc).Count)) + (BigInteger.One)) < (StandardLibrary_mUInt_Compile.__default.UINT64__LIMIT), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Selector Overflow")));
        if ((_4_valueOrError1).IsFailure()) {
          return (_4_valueOrError1).PropagateFailure<Dafny.ISequence<TermLoc_Compile._ISelector>>();
        } else if ((_0_pos).is_None) {
          return Wrappers_Compile.Result<Dafny.ISequence<TermLoc_Compile._ISelector>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Dafny.Sequence<TermLoc_Compile._ISelector>.Concat(acc, Dafny.Sequence<TermLoc_Compile._ISelector>.FromElements(_3_sel)));
        } else {
          Dafny.ISequence<char> _in0 = (s).Drop(_1_end);
          Dafny.ISequence<TermLoc_Compile._ISelector> _in1 = Dafny.Sequence<TermLoc_Compile._ISelector>.Concat(acc, Dafny.Sequence<TermLoc_Compile._ISelector>.FromElements(_3_sel));
          s = _in0;
          acc = _in1;
          goto TAIL_CALL_START;
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<TermLoc_Compile._ISelector>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> MakeTermLoc(Dafny.ISequence<char> s) {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>((new BigInteger((s).Count)).Sign == 1, DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Path specification must not be empty.")));
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<TermLoc_Compile._ISelector>>();
      } else {
        Wrappers_Compile._IOption<BigInteger> _1_pos = TermLoc_Compile.__default.FindStartOfNext(s);
        if ((_1_pos).is_None) {
          TermLoc_Compile._ISelector _2_m = TermLoc_Compile.Selector.create_Map(s);
          return Wrappers_Compile.Result<Dafny.ISequence<TermLoc_Compile._ISelector>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Dafny.Sequence<TermLoc_Compile._ISelector>.FromElements(TermLoc_Compile.Selector.create_Map(s)));
        } else {
          Dafny.ISequence<char> _3_name = (s).Take((_1_pos).dtor_value);
          Wrappers_Compile._IResult<Dafny.ISequence<TermLoc_Compile._ISelector>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _4_valueOrError1 = TermLoc_Compile.__default.GetSelectors((s).Drop((_1_pos).dtor_value), Dafny.Sequence<TermLoc_Compile._ISelector>.FromElements());
          if ((_4_valueOrError1).IsFailure()) {
            return (_4_valueOrError1).PropagateFailure<Dafny.ISequence<TermLoc_Compile._ISelector>>();
          } else {
            Dafny.ISequence<TermLoc_Compile._ISelector> _5_selectors = (_4_valueOrError1).Extract();
            Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _6_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(((new BigInteger((_5_selectors).Count)) + (BigInteger.One)) < (StandardLibrary_mUInt_Compile.__default.UINT64__LIMIT), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Selector Overflow")));
            if ((_6_valueOrError2).IsFailure()) {
              return (_6_valueOrError2).PropagateFailure<Dafny.ISequence<TermLoc_Compile._ISelector>>();
            } else {
              return Wrappers_Compile.Result<Dafny.ISequence<TermLoc_Compile._ISelector>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Dafny.Sequence<TermLoc_Compile._ISelector>.Concat(Dafny.Sequence<TermLoc_Compile._ISelector>.FromElements(TermLoc_Compile.Selector.create_Map(_3_name)), _5_selectors));
            }
          }
        }
      }
    }
    public static Dafny.ISequence<TermLoc_Compile._ISelector> TermLocMap(Dafny.ISequence<char> attr) {
      return Dafny.Sequence<TermLoc_Compile._ISelector>.FromElements(TermLoc_Compile.Selector.create_Map(attr));
    }
  }

  public interface _ISelector {
    bool is_List { get; }
    bool is_Map { get; }
    ulong dtor_pos { get; }
    Dafny.ISequence<char> dtor_key { get; }
    _ISelector DowncastClone();
  }
  public abstract class Selector : _ISelector {
    public Selector() {
    }
    private static readonly TermLoc_Compile._ISelector theDefault = create_List(0);
    public static TermLoc_Compile._ISelector Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<TermLoc_Compile._ISelector> _TYPE = new Dafny.TypeDescriptor<TermLoc_Compile._ISelector>(TermLoc_Compile.Selector.Default());
    public static Dafny.TypeDescriptor<TermLoc_Compile._ISelector> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ISelector create_List(ulong pos) {
      return new Selector_List(pos);
    }
    public static _ISelector create_Map(Dafny.ISequence<char> key) {
      return new Selector_Map(key);
    }
    public bool is_List { get { return this is Selector_List; } }
    public bool is_Map { get { return this is Selector_Map; } }
    public ulong dtor_pos {
      get {
        var d = this;
        return ((Selector_List)d)._pos;
      }
    }
    public Dafny.ISequence<char> dtor_key {
      get {
        var d = this;
        return ((Selector_Map)d)._key;
      }
    }
    public abstract _ISelector DowncastClone();
  }
  public class Selector_List : Selector {
    public readonly ulong _pos;
    public Selector_List(ulong pos) : base() {
      this._pos = pos;
    }
    public override _ISelector DowncastClone() {
      if (this is _ISelector dt) { return dt; }
      return new Selector_List(_pos);
    }
    public override bool Equals(object other) {
      var oth = other as TermLoc_Compile.Selector_List;
      return oth != null && this._pos == oth._pos;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._pos));
      return (int) hash;
    }
    public override string ToString() {
      string s = "TermLoc.Selector.List";
      s += "(";
      s += Dafny.Helpers.ToString(this._pos);
      s += ")";
      return s;
    }
  }
  public class Selector_Map : Selector {
    public readonly Dafny.ISequence<char> _key;
    public Selector_Map(Dafny.ISequence<char> key) : base() {
      this._key = key;
    }
    public override _ISelector DowncastClone() {
      if (this is _ISelector dt) { return dt; }
      return new Selector_Map(_key);
    }
    public override bool Equals(object other) {
      var oth = other as TermLoc_Compile.Selector_Map;
      return oth != null && object.Equals(this._key, oth._key);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._key));
      return (int) hash;
    }
    public override string ToString() {
      string s = "TermLoc.Selector.Map";
      s += "(";
      s += Dafny.Helpers.ToString(this._key);
      s += ")";
      return s;
    }
  }

  public partial class SelectorList {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<TermLoc_Compile._ISelector>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<TermLoc_Compile._ISelector>>(Dafny.Sequence<TermLoc_Compile._ISelector>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<TermLoc_Compile._ISelector>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.ISequence<TermLoc_Compile._ISelector> __source) {
      Dafny.ISequence<TermLoc_Compile._ISelector> _0_x = __source;
      return (new BigInteger((_0_x).Count)) < (StandardLibrary_mUInt_Compile.__default.UINT64__LIMIT);
    }
  }

  public partial class TermLoc {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<TermLoc_Compile._ISelector>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<TermLoc_Compile._ISelector>>(Dafny.Sequence<TermLoc_Compile._ISelector>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<TermLoc_Compile._ISelector>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.ISequence<TermLoc_Compile._ISelector> __source) {
      Dafny.ISequence<TermLoc_Compile._ISelector> _1_x = __source;
      return TermLoc_Compile.__default.ValidTermLoc(_1_x);
    }
  }
} // end of namespace TermLoc_Compile
namespace DdbVirtualFields_Compile {

  public partial class __default {
    public static Wrappers_Compile._IResult<DdbVirtualFields_Compile._IVirtField, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> ParseVirtualFieldConfig(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualField vf) {
      Wrappers_Compile._IResult<Dafny.ISequence<DdbVirtualFields_Compile._IVirtPart>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = Seq_Compile.__default.MapWithResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualPart, DdbVirtualFields_Compile._IVirtPart, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(((System.Func<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualPart, Wrappers_Compile._IResult<DdbVirtualFields_Compile._IVirtPart, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>>)((_1_p) => {
        return DdbVirtualFields_Compile.__default.ParseVirtualPartConfig(_1_p);
      })), (vf).dtor_parts);
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<DdbVirtualFields_Compile._IVirtField>();
      } else {
        Dafny.ISequence<DdbVirtualFields_Compile._IVirtPart> _2_parts = (_0_valueOrError0).Extract();
        return Wrappers_Compile.Result<DdbVirtualFields_Compile._IVirtField, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(DdbVirtualFields_Compile.VirtField.create((vf).dtor_name, _2_parts));
      }
    }
    public static Wrappers_Compile._IResult<DdbVirtualFields_Compile._IVirtPart, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> ParseVirtualPartConfig(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualPart part) {
      Wrappers_Compile._IResult<Dafny.ISequence<TermLoc_Compile._ISelector>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = TermLoc_Compile.__default.MakeTermLoc((part).dtor_loc);
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<DdbVirtualFields_Compile._IVirtPart>();
      } else {
        Dafny.ISequence<TermLoc_Compile._ISelector> _1_loc = (_0_valueOrError0).Extract();
        if (((part).dtor_trans).is_None) {
          return Wrappers_Compile.Result<DdbVirtualFields_Compile._IVirtPart, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(DdbVirtualFields_Compile.VirtPart.create(_1_loc, Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualTransform>.FromElements()));
        } else {
          return Wrappers_Compile.Result<DdbVirtualFields_Compile._IVirtPart, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(DdbVirtualFields_Compile.VirtPart.create(_1_loc, ((part).dtor_trans).dtor_value));
        }
      }
    }
    public static bool Examine(Dafny.ISequence<DdbVirtualFields_Compile._IVirtPart> parts, Func<Dafny.ISequence<TermLoc_Compile._ISelector>, bool> exam)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((parts).Count)).Sign == 0) {
        return false;
      } else if (Dafny.Helpers.Id<Func<Dafny.ISequence<TermLoc_Compile._ISelector>, bool>>(exam)(((parts).Select(BigInteger.Zero)).dtor_loc)) {
        return true;
      } else {
        Dafny.ISequence<DdbVirtualFields_Compile._IVirtPart> _in0 = (parts).Drop(BigInteger.One);
        Func<Dafny.ISequence<TermLoc_Compile._ISelector>, bool> _in1 = exam;
        parts = _in0;
        exam = _in1;
        goto TAIL_CALL_START;
      }
    }
    public static BigInteger Min(BigInteger x, BigInteger y)
    {
      if ((y) < (x)) {
        return y;
      } else {
        return x;
      }
    }
    public static Dafny.ISequence<char> GetPrefix(Dafny.ISequence<char> s, BigInteger length)
    {
      if ((length).Sign != -1) {
        return (s).Take(DdbVirtualFields_Compile.__default.Min(length, new BigInteger((s).Count)));
      } else {
        return (s).Take((new BigInteger((s).Count)) - (DdbVirtualFields_Compile.__default.Min((BigInteger.Zero) - (length), new BigInteger((s).Count))));
      }
    }
    public static Dafny.ISequence<char> GetSuffix(Dafny.ISequence<char> s, BigInteger length)
    {
      if ((length).Sign != -1) {
        return (s).Drop((new BigInteger((s).Count)) - (DdbVirtualFields_Compile.__default.Min(length, new BigInteger((s).Count))));
      } else {
        return (s).Drop(DdbVirtualFields_Compile.__default.Min((BigInteger.Zero) - (length), new BigInteger((s).Count)));
      }
    }
    public static BigInteger GetPos(BigInteger pos, BigInteger limit)
    {
      if ((limit).Sign == 0) {
        return BigInteger.Zero;
      } else if ((pos).Sign != -1) {
        return DdbVirtualFields_Compile.__default.Min(pos, (limit) - (BigInteger.One));
      } else if (((limit) + (pos)).Sign == -1) {
        return BigInteger.Zero;
      } else {
        return (limit) + (pos);
      }
    }
    public static Dafny.ISequence<char> GetSubstring(Dafny.ISequence<char> s, BigInteger low, BigInteger high)
    {
      BigInteger _0_lo = DdbVirtualFields_Compile.__default.GetPos(low, new BigInteger((s).Count));
      BigInteger _1_hi = DdbVirtualFields_Compile.__default.GetPos(high, new BigInteger((s).Count));
      if ((_0_lo) < (_1_hi)) {
        return (s).Subsequence(_0_lo, _1_hi);
      } else {
        return Dafny.Sequence<char>.FromString("");
      }
    }
    public static char UpperChar(char ch) {
      if ((('a') <= (ch)) && ((ch) <= ('z'))) {
        return (char)(((char)((ch) - ('a'))) + ('A'));
      } else {
        return ch;
      }
    }
    public static Dafny.ISequence<char> UpperCase(Dafny.ISequence<char> s) {
      return Seq_Compile.__default.Map<char, char>(((System.Func<char, char>)((_0_c) => {
        return DdbVirtualFields_Compile.__default.UpperChar(_0_c);
      })), s);
    }
    public static char LowerChar(char ch) {
      if ((('A') <= (ch)) && ((ch) <= ('Z'))) {
        return (char)(((char)((ch) - ('A'))) + ('a'));
      } else {
        return ch;
      }
    }
    public static Dafny.ISequence<char> LowerCase(Dafny.ISequence<char> s) {
      return Seq_Compile.__default.Map<char, char>(((System.Func<char, char>)((_0_c) => {
        return DdbVirtualFields_Compile.__default.LowerChar(_0_c);
      })), s);
    }
    public static Dafny.ISequence<char> GetSegment(Dafny.ISequence<char> s, char split, BigInteger index)
    {
      Dafny.ISequence<Dafny.ISequence<char>> _0_parts = StandardLibrary_Compile.__default.Split<char>(s, split);
      if (((index) >= (new BigInteger((_0_parts).Count))) || (((BigInteger.Zero) - (index)) > (new BigInteger((_0_parts).Count)))) {
        return Dafny.Sequence<char>.FromString("");
      } else {
        return (_0_parts).Select(DdbVirtualFields_Compile.__default.GetPos(index, new BigInteger((_0_parts).Count)));
      }
    }
    public static Dafny.ISequence<char> GetSegments(Dafny.ISequence<char> s, char split, BigInteger low, BigInteger high)
    {
      Dafny.ISequence<Dafny.ISequence<char>> _0_parts = StandardLibrary_Compile.__default.Split<char>(s, split);
      BigInteger _1_lo = DdbVirtualFields_Compile.__default.GetPos(low, new BigInteger((_0_parts).Count));
      BigInteger _2_hi = DdbVirtualFields_Compile.__default.GetPos(high, new BigInteger((_0_parts).Count));
      if ((_1_lo) < (_2_hi)) {
        return StandardLibrary_Compile.__default.Join<char>((_0_parts).Subsequence(_1_lo, _2_hi), Dafny.Sequence<char>.FromElements(split));
      } else {
        return Dafny.Sequence<char>.FromString("");
      }
    }
    public static Dafny.ISequence<char> DoTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualTransform t, Dafny.ISequence<char> s)
    {
      software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualTransform _source0 = t;
      {
        if (_source0.is_upper) {
          software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IUpper _0_up = _source0.dtor_upper;
          return DdbVirtualFields_Compile.__default.UpperCase(s);
        }
      }
      {
        if (_source0.is_lower) {
          software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ILower _1_lo = _source0.dtor_lower;
          return DdbVirtualFields_Compile.__default.LowerCase(s);
        }
      }
      {
        if (_source0.is_insert) {
          software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IInsert _2_ins = _source0.dtor_insert;
          return Dafny.Sequence<char>.Concat(s, (_2_ins).dtor_literal);
        }
      }
      {
        if (_source0.is_prefix) {
          software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetPrefix _3_pre = _source0.dtor_prefix;
          return DdbVirtualFields_Compile.__default.GetPrefix(s, new BigInteger((_3_pre).dtor_length));
        }
      }
      {
        if (_source0.is_suffix) {
          software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSuffix _4_suf = _source0.dtor_suffix;
          return DdbVirtualFields_Compile.__default.GetSuffix(s, new BigInteger((_4_suf).dtor_length));
        }
      }
      {
        if (_source0.is_substring) {
          software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSubstring _5_sub = _source0.dtor_substring;
          return DdbVirtualFields_Compile.__default.GetSubstring(s, new BigInteger((_5_sub).dtor_low), new BigInteger((_5_sub).dtor_high));
        }
      }
      {
        if (_source0.is_segment) {
          software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSegment _6_seg = _source0.dtor_segment;
          return DdbVirtualFields_Compile.__default.GetSegment(s, ((_6_seg).dtor_split).Select(BigInteger.Zero), new BigInteger((_6_seg).dtor_index));
        }
      }
      {
        software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IGetSegments _7_seg = _source0.dtor_segments;
        return DdbVirtualFields_Compile.__default.GetSegments(s, ((_7_seg).dtor_split).Select(BigInteger.Zero), new BigInteger((_7_seg).dtor_low), new BigInteger((_7_seg).dtor_high));
      }
    }
    public static Dafny.ISequence<char> FullTransform(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualTransform> t, Dafny.ISequence<char> s)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((t).Count)).Sign == 0) {
        return s;
      } else {
        Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualTransform> _in0 = (t).Drop(BigInteger.One);
        Dafny.ISequence<char> _in1 = DdbVirtualFields_Compile.__default.DoTransform((t).Select(BigInteger.Zero), s);
        t = _in0;
        s = _in1;
        goto TAIL_CALL_START;
      }
    }
    public static Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetVirtField(DdbVirtualFields_Compile._IVirtField vf, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item)
    {
      return DdbVirtualFields_Compile.__default.GetVirtField2((vf).dtor_parts, item, Dafny.Sequence<char>.FromString(""));
    }
    public static Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetVirtField2(Dafny.ISequence<DdbVirtualFields_Compile._IVirtPart> parts, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Dafny.ISequence<char> acc)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((parts).Count)).Sign == 0) {
        return Wrappers_Compile.Result<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Wrappers_Compile.Option<Dafny.ISequence<char>>.create_Some(acc));
      } else {
        Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = TermLoc_Compile.__default.TermToString(((parts).Select(BigInteger.Zero)).dtor_loc, item);
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<Wrappers_Compile._IOption<Dafny.ISequence<char>>>();
        } else {
          Wrappers_Compile._IOption<Dafny.ISequence<char>> _1_value = (_0_valueOrError0).Extract();
          if ((_1_value).is_None) {
            return Wrappers_Compile.Result<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None());
          } else {
            Dafny.ISequence<char> _2_trans = DdbVirtualFields_Compile.__default.FullTransform(((parts).Select(BigInteger.Zero)).dtor_trans, (_1_value).dtor_value);
            Dafny.ISequence<DdbVirtualFields_Compile._IVirtPart> _in0 = (parts).Drop(BigInteger.One);
            Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in1 = item;
            Dafny.ISequence<char> _in2 = Dafny.Sequence<char>.Concat(acc, _2_trans);
            parts = _in0;
            item = _in1;
            acc = _in2;
            goto TAIL_CALL_START;
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> VirtToAttr(Dafny.ISequence<TermLoc_Compile._ISelector> loc, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> vf)
    {
      if (((new BigInteger((loc).Count)) == (BigInteger.One)) && ((vf).Contains(((loc).Select(BigInteger.Zero)).dtor_key))) {
        Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = DdbVirtualFields_Compile.__default.GetVirtField(Dafny.Map<Dafny.ISequence<char>, DdbVirtualFields_Compile._IVirtField>.Select(vf,((loc).Select(BigInteger.Zero)).dtor_key), item);
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
        } else {
          Wrappers_Compile._IOption<Dafny.ISequence<char>> _1_str = (_0_valueOrError0).Extract();
          if ((_1_str).is_None) {
            return Wrappers_Compile.Result<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.create_None());
          } else {
            return Wrappers_Compile.Result<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.create_Some(DdbVirtualFields_Compile.__default.DS((_1_str).dtor_value)));
          }
        }
      } else {
        return Wrappers_Compile.Result<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(TermLoc_Compile.__default.TermToAttr(loc, item, Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>.create_None()));
      }
    }
    public static Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> VirtToBytes(Dafny.ISequence<TermLoc_Compile._ISelector> loc, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> vf)
    {
      if (((new BigInteger((loc).Count)) == (BigInteger.One)) && ((vf).Contains(((loc).Select(BigInteger.Zero)).dtor_key))) {
        Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = DdbVirtualFields_Compile.__default.GetVirtField(Dafny.Map<Dafny.ISequence<char>, DdbVirtualFields_Compile._IVirtField>.Select(vf,((loc).Select(BigInteger.Zero)).dtor_key), item);
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<Wrappers_Compile._IOption<Dafny.ISequence<byte>>>();
        } else {
          Wrappers_Compile._IOption<Dafny.ISequence<char>> _1_str = (_0_valueOrError0).Extract();
          if ((_1_str).is_None) {
            return Wrappers_Compile.Result<Wrappers_Compile._IOption<Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None());
          } else {
            Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _2_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(UTF8.__default.Encode((_1_str).dtor_value), ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>)((_3_e) => {
              return DynamoDbEncryptionUtil_Compile.__default.E(_3_e);
            })));
            if ((_2_valueOrError1).IsFailure()) {
              return (_2_valueOrError1).PropagateFailure<Wrappers_Compile._IOption<Dafny.ISequence<byte>>>();
            } else {
              Dafny.ISequence<byte> _4_ustr = (_2_valueOrError1).Extract();
              return Wrappers_Compile.Result<Wrappers_Compile._IOption<Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_Some(_4_ustr));
            }
          }
        }
      } else {
        return TermLoc_Compile.__default.TermToBytes(loc, item);
      }
    }
    public static Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> VirtToString(Dafny.ISequence<TermLoc_Compile._ISelector> loc, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> vf)
    {
      if (((new BigInteger((loc).Count)) == (BigInteger.One)) && ((vf).Contains(((loc).Select(BigInteger.Zero)).dtor_key))) {
        return DdbVirtualFields_Compile.__default.GetVirtField(Dafny.Map<Dafny.ISequence<char>, DdbVirtualFields_Compile._IVirtField>.Select(vf,((loc).Select(BigInteger.Zero)).dtor_key), item);
      } else {
        return TermLoc_Compile.__default.TermToString(loc, item);
      }
    }
    public static software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue DS(Dafny.ISequence<char> s) {
      return software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_S(s);
    }
  }

  public partial class VirtualFieldMap {
    private static readonly Dafny.TypeDescriptor<Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField>> _TYPE = new Dafny.TypeDescriptor<Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField>>(Dafny.Map<Dafny.ISequence<char>, DdbVirtualFields_Compile._IVirtField>.Empty);
    public static Dafny.TypeDescriptor<Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField>> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class ValidVirtualField {
    private static readonly Dafny.TypeDescriptor<DdbVirtualFields_Compile._IVirtField> _TYPE = new Dafny.TypeDescriptor<DdbVirtualFields_Compile._IVirtField>(DdbVirtualFields_Compile.VirtField.Default());
    public static Dafny.TypeDescriptor<DdbVirtualFields_Compile._IVirtField> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public interface _IVirtField {
    bool is_VirtField { get; }
    Dafny.ISequence<char> dtor_name { get; }
    Dafny.ISequence<DdbVirtualFields_Compile._IVirtPart> dtor_parts { get; }
    _IVirtField DowncastClone();
    bool examine(Func<Dafny.ISequence<TermLoc_Compile._ISelector>, bool> exam);
    Dafny.ISequence<Dafny.ISequence<char>> GetFields();
    Dafny.ISet<Dafny.ISequence<TermLoc_Compile._ISelector>> GetLocs();
    bool HasSingleLoc(Dafny.ISequence<TermLoc_Compile._ISelector> loc);
  }
  public class VirtField : _IVirtField {
    public readonly Dafny.ISequence<char> _name;
    public readonly Dafny.ISequence<DdbVirtualFields_Compile._IVirtPart> _parts;
    public VirtField(Dafny.ISequence<char> name, Dafny.ISequence<DdbVirtualFields_Compile._IVirtPart> parts) {
      this._name = name;
      this._parts = parts;
    }
    public _IVirtField DowncastClone() {
      if (this is _IVirtField dt) { return dt; }
      return new VirtField(_name, _parts);
    }
    public override bool Equals(object other) {
      var oth = other as DdbVirtualFields_Compile.VirtField;
      return oth != null && object.Equals(this._name, oth._name) && object.Equals(this._parts, oth._parts);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._name));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._parts));
      return (int) hash;
    }
    public override string ToString() {
      string s = "DdbVirtualFields.VirtField.VirtField";
      s += "(";
      s += Dafny.Helpers.ToString(this._name);
      s += ", ";
      s += Dafny.Helpers.ToString(this._parts);
      s += ")";
      return s;
    }
    private static readonly DdbVirtualFields_Compile._IVirtField theDefault = create(Dafny.Sequence<char>.Empty, Dafny.Sequence<DdbVirtualFields_Compile._IVirtPart>.Empty);
    public static DdbVirtualFields_Compile._IVirtField Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<DdbVirtualFields_Compile._IVirtField> _TYPE = new Dafny.TypeDescriptor<DdbVirtualFields_Compile._IVirtField>(DdbVirtualFields_Compile.VirtField.Default());
    public static Dafny.TypeDescriptor<DdbVirtualFields_Compile._IVirtField> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IVirtField create(Dafny.ISequence<char> name, Dafny.ISequence<DdbVirtualFields_Compile._IVirtPart> parts) {
      return new VirtField(name, parts);
    }
    public static _IVirtField create_VirtField(Dafny.ISequence<char> name, Dafny.ISequence<DdbVirtualFields_Compile._IVirtPart> parts) {
      return create(name, parts);
    }
    public bool is_VirtField { get { return true; } }
    public Dafny.ISequence<char> dtor_name {
      get {
        return this._name;
      }
    }
    public Dafny.ISequence<DdbVirtualFields_Compile._IVirtPart> dtor_parts {
      get {
        return this._parts;
      }
    }
    public bool examine(Func<Dafny.ISequence<TermLoc_Compile._ISelector>, bool> exam) {
      return DdbVirtualFields_Compile.__default.Examine((this).dtor_parts, exam);
    }
    public Dafny.ISequence<Dafny.ISequence<char>> GetFields() {
      return Seq_Compile.__default.Map<DdbVirtualFields_Compile._IVirtPart, Dafny.ISequence<char>>(((System.Func<DdbVirtualFields_Compile._IVirtPart, Dafny.ISequence<char>>)((_0_p) => {
        return (((_0_p).dtor_loc).Select(BigInteger.Zero)).dtor_key;
      })), (this).dtor_parts);
    }
    public Dafny.ISet<Dafny.ISequence<TermLoc_Compile._ISelector>> GetLocs() {
      return ((System.Func<Dafny.ISet<Dafny.ISequence<TermLoc_Compile._ISelector>>>)(() => {
        var _coll0 = new System.Collections.Generic.List<Dafny.ISequence<TermLoc_Compile._ISelector>>();
        foreach (DdbVirtualFields_Compile._IVirtPart _compr_0 in ((this).dtor_parts).CloneAsArray()) {
          DdbVirtualFields_Compile._IVirtPart _0_p = (DdbVirtualFields_Compile._IVirtPart)_compr_0;
          if (((this).dtor_parts).Contains(_0_p)) {
            _coll0.Add((_0_p).dtor_loc);
          }
        }
        return Dafny.Set<Dafny.ISequence<TermLoc_Compile._ISelector>>.FromCollection(_coll0);
      }))();
    }
    public bool HasSingleLoc(Dafny.ISequence<TermLoc_Compile._ISelector> loc) {
      return ((new BigInteger(((this).dtor_parts).Count)) == (BigInteger.One)) && (((((this).dtor_parts).Select(BigInteger.Zero)).dtor_loc).Equals(loc));
    }
  }

  public interface _IVirtPart {
    bool is_VirtPart { get; }
    Dafny.ISequence<TermLoc_Compile._ISelector> dtor_loc { get; }
    Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualTransform> dtor_trans { get; }
    _IVirtPart DowncastClone();
  }
  public class VirtPart : _IVirtPart {
    public readonly Dafny.ISequence<TermLoc_Compile._ISelector> _loc;
    public readonly Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualTransform> _trans;
    public VirtPart(Dafny.ISequence<TermLoc_Compile._ISelector> loc, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualTransform> trans) {
      this._loc = loc;
      this._trans = trans;
    }
    public _IVirtPart DowncastClone() {
      if (this is _IVirtPart dt) { return dt; }
      return new VirtPart(_loc, _trans);
    }
    public override bool Equals(object other) {
      var oth = other as DdbVirtualFields_Compile.VirtPart;
      return oth != null && object.Equals(this._loc, oth._loc) && object.Equals(this._trans, oth._trans);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._loc));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._trans));
      return (int) hash;
    }
    public override string ToString() {
      string s = "DdbVirtualFields.VirtPart.VirtPart";
      s += "(";
      s += Dafny.Helpers.ToString(this._loc);
      s += ", ";
      s += Dafny.Helpers.ToString(this._trans);
      s += ")";
      return s;
    }
    private static readonly DdbVirtualFields_Compile._IVirtPart theDefault = create(Dafny.Sequence<TermLoc_Compile._ISelector>.Empty, Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualTransform>.Empty);
    public static DdbVirtualFields_Compile._IVirtPart Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<DdbVirtualFields_Compile._IVirtPart> _TYPE = new Dafny.TypeDescriptor<DdbVirtualFields_Compile._IVirtPart>(DdbVirtualFields_Compile.VirtPart.Default());
    public static Dafny.TypeDescriptor<DdbVirtualFields_Compile._IVirtPart> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IVirtPart create(Dafny.ISequence<TermLoc_Compile._ISelector> loc, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualTransform> trans) {
      return new VirtPart(loc, trans);
    }
    public static _IVirtPart create_VirtPart(Dafny.ISequence<TermLoc_Compile._ISelector> loc, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualTransform> trans) {
      return create(loc, trans);
    }
    public bool is_VirtPart { get { return true; } }
    public Dafny.ISequence<TermLoc_Compile._ISelector> dtor_loc {
      get {
        return this._loc;
      }
    }
    public Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualTransform> dtor_trans {
      get {
        return this._trans;
      }
    }
  }
} // end of namespace DdbVirtualFields_Compile
namespace DynamoDbUpdateExpr_Compile {

  public partial class __default {
    public static Dafny.ISequence<Dafny.ISequence<char>> ExtractAttributes(Dafny.ISequence<char> s, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> ex)
    {
      Dafny.ISequence<Dafny.ISequence<char>> _0_x = DynamoDbUpdateExpr_Compile.__default.ExtractAttrs(s);
      if ((ex).is_None) {
        return _0_x;
      } else {
        return DynamoDbUpdateExpr_Compile.__default.Resolve(_0_x, (ex).dtor_value);
      }
    }
    public static bool IgnoreAttr(Dafny.ISequence<char> s) {
      return (Dafny.Sequence<Dafny.ISequence<char>>.FromElements(Dafny.Sequence<char>.FromString("SET"), Dafny.Sequence<char>.FromString("REMOVE"), Dafny.Sequence<char>.FromString("ADD"), Dafny.Sequence<char>.FromString("DELETE"), Dafny.Sequence<char>.FromString("list_append"), Dafny.Sequence<char>.FromString("if_not_exists"))).Contains(s);
    }
    public static Dafny.ISequence<Dafny.ISequence<char>> Resolve(Dafny.ISequence<Dafny.ISequence<char>> names, Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> ex)
    {
      Dafny.ISequence<Dafny.ISequence<char>> _0___accumulator = Dafny.Sequence<Dafny.ISequence<char>>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((names).Count)).Sign == 0) {
        return Dafny.Sequence<Dafny.ISequence<char>>.Concat(_0___accumulator, Dafny.Sequence<Dafny.ISequence<char>>.FromElements());
      } else if ((ex).Contains((names).Select(BigInteger.Zero))) {
        _0___accumulator = Dafny.Sequence<Dafny.ISequence<char>>.Concat(_0___accumulator, Dafny.Sequence<Dafny.ISequence<char>>.FromElements(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Select(ex,(names).Select(BigInteger.Zero))));
        Dafny.ISequence<Dafny.ISequence<char>> _in0 = (names).Drop(BigInteger.One);
        Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> _in1 = ex;
        names = _in0;
        ex = _in1;
        goto TAIL_CALL_START;
      } else {
        _0___accumulator = Dafny.Sequence<Dafny.ISequence<char>>.Concat(_0___accumulator, Dafny.Sequence<Dafny.ISequence<char>>.FromElements((names).Select(BigInteger.Zero)));
        Dafny.ISequence<Dafny.ISequence<char>> _in2 = (names).Drop(BigInteger.One);
        Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> _in3 = ex;
        names = _in2;
        ex = _in3;
        goto TAIL_CALL_START;
      }
    }
    public static Dafny.ISequence<char> ChopOne(Dafny.ISequence<char> s, char ch)
    {
      if ((s).Contains(ch)) {
        return (StandardLibrary_Compile.__default.SplitOnce<char>(s, ch)).dtor__0;
      } else {
        return s;
      }
    }
    public static Dafny.ISequence<char> Chop(Dafny.ISequence<char> s) {
      Dafny.ISequence<char> _0_s = DynamoDbUpdateExpr_Compile.__default.ChopOne(s, '.');
      return DynamoDbUpdateExpr_Compile.__default.ChopOne(_0_s, '[');
    }
    public static Dafny.ISequence<Dafny.ISequence<char>> ExtractAttrs(Dafny.ISequence<char> s) {
      Dafny.ISequence<Dafny.ISequence<char>> _0___accumulator = Dafny.Sequence<Dafny.ISequence<char>>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((s).Count)).Sign == 0) {
        return Dafny.Sequence<Dafny.ISequence<char>>.Concat(_0___accumulator, Dafny.Sequence<Dafny.ISequence<char>>.FromElements());
      } else {
        _System._ITuple2<BigInteger, Wrappers_Compile._IOption<Dafny.ISequence<char>>> _1_ret = DynamoDbUpdateExpr_Compile.__default.FindToken(s);
        if (((_1_ret).dtor__0).Sign == 0) {
          return Dafny.Sequence<Dafny.ISequence<char>>.Concat(_0___accumulator, Dafny.Sequence<Dafny.ISequence<char>>.FromElements());
        } else if (((_1_ret).dtor__1).is_None) {
          Dafny.ISequence<char> _in0 = (s).Drop((_1_ret).dtor__0);
          s = _in0;
          goto TAIL_CALL_START;
        } else if (DynamoDbUpdateExpr_Compile.__default.IgnoreAttr(((_1_ret).dtor__1).dtor_value)) {
          Dafny.ISequence<char> _in1 = (s).Drop((_1_ret).dtor__0);
          s = _in1;
          goto TAIL_CALL_START;
        } else {
          _0___accumulator = Dafny.Sequence<Dafny.ISequence<char>>.Concat(_0___accumulator, Dafny.Sequence<Dafny.ISequence<char>>.FromElements(DynamoDbUpdateExpr_Compile.__default.Chop(((_1_ret).dtor__1).dtor_value)));
          Dafny.ISequence<char> _in2 = (s).Drop((_1_ret).dtor__0);
          s = _in2;
          goto TAIL_CALL_START;
        }
      }
    }
    public static bool BadStart(char ch) {
      return ((ch) == (':')) || ((('0') <= (ch)) && ((ch) <= ('9')));
    }
    public static bool AttrStart(char ch) {
      if ((('a') <= (ch)) && ((ch) <= ('z'))) {
        return true;
      } else if ((('A') <= (ch)) && ((ch) <= ('Z'))) {
        return true;
      } else if (((ch) == ('#')) || ((ch) == ('_'))) {
        return true;
      } else {
        return false;
      }
    }
    public static bool AttrChar(char ch) {
      if (DynamoDbUpdateExpr_Compile.__default.AttrStart(ch)) {
        return true;
      } else if ((('0') <= (ch)) && ((ch) <= ('9'))) {
        return true;
      } else if ((Dafny.Sequence<char>.FromElements('[', ']', '.')).Contains(ch)) {
        return true;
      } else {
        return false;
      }
    }
    public static BigInteger AttrLen(Dafny.ISequence<char> s) {
      BigInteger _0___accumulator = BigInteger.Zero;
    TAIL_CALL_START: ;
      if ((new BigInteger((s).Count)).Sign == 0) {
        return (BigInteger.Zero) + (_0___accumulator);
      } else if (DynamoDbUpdateExpr_Compile.__default.AttrChar((s).Select(BigInteger.Zero))) {
        _0___accumulator = (BigInteger.One) + (_0___accumulator);
        Dafny.ISequence<char> _in0 = (s).Drop(BigInteger.One);
        s = _in0;
        goto TAIL_CALL_START;
      } else {
        return (BigInteger.Zero) + (_0___accumulator);
      }
    }
    public static _System._ITuple2<BigInteger, Wrappers_Compile._IOption<Dafny.ISequence<char>>> FindToken(Dafny.ISequence<char> s) {
      if ((new BigInteger((s).Count)).Sign == 0) {
        return _System.Tuple2<BigInteger, Wrappers_Compile._IOption<Dafny.ISequence<char>>>.create(BigInteger.Zero, Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None());
      } else {
        char _0_ch = (s).Select(BigInteger.Zero);
        if ((_0_ch) == ('#')) {
          BigInteger _1_x = (DynamoDbUpdateExpr_Compile.__default.AttrLen((s).Drop(BigInteger.One))) + (BigInteger.One);
          return _System.Tuple2<BigInteger, Wrappers_Compile._IOption<Dafny.ISequence<char>>>.create(_1_x, Wrappers_Compile.Option<Dafny.ISequence<char>>.create_Some((s).Subsequence(BigInteger.Zero, _1_x)));
        } else if (DynamoDbUpdateExpr_Compile.__default.BadStart(_0_ch)) {
          BigInteger _2_x = (DynamoDbUpdateExpr_Compile.__default.AttrLen((s).Drop(BigInteger.One))) + (BigInteger.One);
          return _System.Tuple2<BigInteger, Wrappers_Compile._IOption<Dafny.ISequence<char>>>.create(_2_x, Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None());
        } else if (DynamoDbUpdateExpr_Compile.__default.AttrStart(_0_ch)) {
          BigInteger _3_x = (DynamoDbUpdateExpr_Compile.__default.AttrLen((s).Drop(BigInteger.One))) + (BigInteger.One);
          return _System.Tuple2<BigInteger, Wrappers_Compile._IOption<Dafny.ISequence<char>>>.create(_3_x, Wrappers_Compile.Option<Dafny.ISequence<char>>.create_Some((s).Subsequence(BigInteger.Zero, _3_x)));
        } else {
          return _System.Tuple2<BigInteger, Wrappers_Compile._IOption<Dafny.ISequence<char>>>.create(BigInteger.One, Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None());
        }
      }
    }
  }
} // end of namespace DynamoDbUpdateExpr_Compile
namespace BaseBeacon_Compile {

  public partial class __default {
    public static Wrappers_Compile._IResult<BaseBeacon_Compile._IStandardBeacon, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> MakeStandardBeacon(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient client, Dafny.ISequence<char> name, byte length, Dafny.ISequence<char> loc, bool partOnly, bool asSet, Wrappers_Compile._IOption<Dafny.ISequence<char>> share)
    {
      Wrappers_Compile._IResult<Dafny.ISequence<TermLoc_Compile._ISelector>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = TermLoc_Compile.__default.MakeTermLoc(loc);
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<BaseBeacon_Compile._IStandardBeacon>();
      } else {
        Dafny.ISequence<TermLoc_Compile._ISelector> _1_termLoc = (_0_valueOrError0).Extract();
        Dafny.ISequence<char> _2_beaconName = Dafny.Sequence<char>.Concat(DynamoDbEncryptionUtil_Compile.__default.BeaconPrefix, name);
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _3_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(software.amazon.cryptography.services.dynamodb.internaldafny.types.__default.IsValid__AttributeName(_2_beaconName), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(_2_beaconName, Dafny.Sequence<char>.FromString(" is not a valid attribute name."))));
        if ((_3_valueOrError1).IsFailure()) {
          return (_3_valueOrError1).PropagateFailure<BaseBeacon_Compile._IStandardBeacon>();
        } else {
          return Wrappers_Compile.Result<BaseBeacon_Compile._IStandardBeacon, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(BaseBeacon_Compile.StandardBeacon.create(BaseBeacon_Compile.BeaconBase.create(client, name, _2_beaconName), length, _1_termLoc, partOnly, asSet, share));
        }
      }
    }
    public static BigInteger CharsFromBeaconLength(byte bits) {
      return new BigInteger((byte)(((byte)(((byte)(bits)) + ((byte)(3)))) / ((byte)(4))));
    }
    public static byte TopBits(byte bits) {
      byte _0_x = (byte)(((byte)(bits)) % ((byte)(4)));
      if ((_0_x) == ((byte)(0))) {
        return (byte)(4);
      } else {
        return _0_x;
      }
    }
    public static BigInteger BytesFromBeaconLength(byte bits) {
      return new BigInteger((byte)(((byte)(((byte)(bits)) + ((byte)(7)))) / ((byte)(8))));
    }
    public static byte TruncateNibble(byte nibble, byte length)
    {
      if ((length) == ((byte)(4))) {
        return nibble;
      } else if ((length) == ((byte)(3))) {
        return (byte)((nibble) % ((byte)(8)));
      } else if ((length) == ((byte)(2))) {
        return (byte)((nibble) % ((byte)(4)));
      } else {
        return (byte)((nibble) % ((byte)(2)));
      }
    }
    public static Dafny.ISequence<char> BytesToHex(Dafny.ISequence<byte> bytes, byte bits)
    {
      BigInteger _0_numBytes = BaseBeacon_Compile.__default.BytesFromBeaconLength(bits);
      BigInteger _1_numChars = BaseBeacon_Compile.__default.CharsFromBeaconLength(bits);
      byte _2_topBits = BaseBeacon_Compile.__default.TopBits(bits);
      Dafny.ISequence<byte> _3_bytes = (bytes).Drop((new BigInteger(8)) - (_0_numBytes));
      if ((_1_numChars) == ((new BigInteger(2)) * (_0_numBytes))) {
        byte _4_topNibble = (byte)(((_3_bytes).Select(BigInteger.Zero)) / ((byte)(16)));
        byte _5_bottomNibble = (byte)(((_3_bytes).Select(BigInteger.Zero)) % ((byte)(16)));
        return Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromElements(HexStrings_Compile.__default.HexChar(BaseBeacon_Compile.__default.TruncateNibble(_4_topNibble, _2_topBits)), HexStrings_Compile.__default.HexChar(_5_bottomNibble)), HexStrings_Compile.__default.ToHexString((_3_bytes).Drop(BigInteger.One)));
      } else {
        return Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromElements(HexStrings_Compile.__default.HexChar(BaseBeacon_Compile.__default.TruncateNibble((byte)(((_3_bytes).Select(BigInteger.Zero)) % ((byte)(16))), _2_topBits))), HexStrings_Compile.__default.ToHexString((_3_bytes).Drop(BigInteger.One)));
      }
    }
  }

  public partial class BeaconLength {
    public static System.Collections.Generic.IEnumerable<byte> IntegerRange(BigInteger lo, BigInteger hi) {
      for (var j = lo; j < hi; j++) { yield return (byte)j; }
    }
    public static readonly byte Witness = (byte)(BigInteger.One);
    private static readonly Dafny.TypeDescriptor<byte> _TYPE = new Dafny.TypeDescriptor<byte>(BaseBeacon_Compile.BeaconLength.Witness);
    public static Dafny.TypeDescriptor<byte> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(byte __source) {
      BigInteger _6_x = new BigInteger(__source);
      return ((BigInteger.One) <= (_6_x)) && ((_6_x) <= (new BigInteger(63)));
    }
  }

  public partial class Nibble {
    private static readonly Dafny.TypeDescriptor<byte> _TYPE = new Dafny.TypeDescriptor<byte>(0);
    public static Dafny.TypeDescriptor<byte> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(byte __source) {
      byte _7_x = (byte)(__source);
      if (true) {
        return (((byte)(0)) <= (_7_x)) && ((_7_x) < ((byte)(16)));
      }
      return false;
    }
  }

  public interface _IBeaconBase {
    bool is_BeaconBase { get; }
    software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient dtor_client { get; }
    Dafny.ISequence<char> dtor_name { get; }
    Dafny.ISequence<char> dtor_beaconName { get; }
    _IBeaconBase DowncastClone();
    Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> hash(Dafny.ISequence<byte> val, Dafny.ISequence<byte> key, byte length);
    Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> hashStr(Dafny.ISequence<char> val, Dafny.ISequence<byte> key, byte length);
    Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> getHmac(Dafny.ISequence<byte> data, Dafny.ISequence<byte> key);
  }
  public class BeaconBase : _IBeaconBase {
    public readonly software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient _client;
    public readonly Dafny.ISequence<char> _name;
    public readonly Dafny.ISequence<char> _beaconName;
    public BeaconBase(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient client, Dafny.ISequence<char> name, Dafny.ISequence<char> beaconName) {
      this._client = client;
      this._name = name;
      this._beaconName = beaconName;
    }
    public _IBeaconBase DowncastClone() {
      if (this is _IBeaconBase dt) { return dt; }
      return new BeaconBase(_client, _name, _beaconName);
    }
    public override bool Equals(object other) {
      var oth = other as BaseBeacon_Compile.BeaconBase;
      return oth != null && this._client == oth._client && object.Equals(this._name, oth._name) && object.Equals(this._beaconName, oth._beaconName);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._client));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._name));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._beaconName));
      return (int) hash;
    }
    public override string ToString() {
      string s = "BaseBeacon.BeaconBase.BeaconBase";
      s += "(";
      s += Dafny.Helpers.ToString(this._client);
      s += ", ";
      s += Dafny.Helpers.ToString(this._name);
      s += ", ";
      s += Dafny.Helpers.ToString(this._beaconName);
      s += ")";
      return s;
    }
    private static readonly BaseBeacon_Compile._IBeaconBase theDefault = create(default(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient), Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty);
    public static BaseBeacon_Compile._IBeaconBase Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<BaseBeacon_Compile._IBeaconBase> _TYPE = new Dafny.TypeDescriptor<BaseBeacon_Compile._IBeaconBase>(BaseBeacon_Compile.BeaconBase.Default());
    public static Dafny.TypeDescriptor<BaseBeacon_Compile._IBeaconBase> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IBeaconBase create(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient client, Dafny.ISequence<char> name, Dafny.ISequence<char> beaconName) {
      return new BeaconBase(client, name, beaconName);
    }
    public static _IBeaconBase create_BeaconBase(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient client, Dafny.ISequence<char> name, Dafny.ISequence<char> beaconName) {
      return create(client, name, beaconName);
    }
    public bool is_BeaconBase { get { return true; } }
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient dtor_client {
      get {
        return this._client;
      }
    }
    public Dafny.ISequence<char> dtor_name {
      get {
        return this._name;
      }
    }
    public Dafny.ISequence<char> dtor_beaconName {
      get {
        return this._beaconName;
      }
    }
    public Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> hash(Dafny.ISequence<byte> val, Dafny.ISequence<byte> key, byte length)
    {
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = (this).getHmac(val, key);
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<char>>();
      } else {
        Dafny.ISequence<byte> _1_hash = (_0_valueOrError0).Extract();
        return Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(BaseBeacon_Compile.__default.BytesToHex(_1_hash, length));
      }
    }
    public Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> hashStr(Dafny.ISequence<char> val, Dafny.ISequence<byte> key, byte length)
    {
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> _0_str = UTF8.__default.Encode(val);
      if ((_0_str).is_Failure) {
        return Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E((_0_str).dtor_error));
      } else {
        return (this).hash((_0_str).dtor_value, key, length);
      }
    }
    public Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> getHmac(Dafny.ISequence<byte> data, Dafny.ISequence<byte> key)
    {
      software.amazon.cryptography.primitives.internaldafny.types._IHMacInput _0_input = software.amazon.cryptography.primitives.internaldafny.types.HMacInput.create(software.amazon.cryptography.primitives.internaldafny.types.DigestAlgorithm.create_SHA__384(), key, data);
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _1_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(((this).dtor_client).HMac(_0_input), ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>)((_2_e) => {
        return software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Error.create_AwsCryptographyPrimitives(_2_e);
      })));
      if ((_1_valueOrError0).IsFailure()) {
        return (_1_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
      } else {
        Dafny.ISequence<byte> _3_output = (_1_valueOrError0).Extract();
        return Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success((_3_output).Take(new BigInteger(8)));
      }
    }
  }

  public partial class ValidStandardBeacon {
    private static readonly Dafny.TypeDescriptor<BaseBeacon_Compile._IStandardBeacon> _TYPE = new Dafny.TypeDescriptor<BaseBeacon_Compile._IStandardBeacon>(BaseBeacon_Compile.StandardBeacon.Default());
    public static Dafny.TypeDescriptor<BaseBeacon_Compile._IStandardBeacon> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public interface _IStandardBeacon {
    bool is_StandardBeacon { get; }
    BaseBeacon_Compile._IBeaconBase dtor_base { get; }
    byte dtor_length { get; }
    Dafny.ISequence<TermLoc_Compile._ISelector> dtor_loc { get; }
    bool dtor_partOnly { get; }
    bool dtor_asSet { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_share { get; }
    _IStandardBeacon DowncastClone();
    Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> hash(Dafny.ISequence<byte> val, Dafny.ISequence<byte> key);
    Dafny.ISequence<char> keyName();
    Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> hashStr(Dafny.ISequence<char> val, Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>> keys);
    Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> ValueToSet(software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue @value, Dafny.ISequence<byte> key);
    Wrappers_Compile._IResult<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> getHash(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> vf, Dafny.ISequence<byte> key);
    Wrappers_Compile._IResult<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> getHashSet(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Dafny.ISequence<byte> key);
    Wrappers_Compile._IResult<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> getHashNonSet(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> vf, Dafny.ISequence<byte> key);
    Wrappers_Compile._IResult<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> getNaked(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> vf);
    Dafny.ISequence<Dafny.ISequence<char>> GetFields(Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> virtualFields);
    Wrappers_Compile._IResult<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> BeaconizeStringSet(Dafny.ISequence<Dafny.ISequence<char>> @value, Dafny.ISequence<byte> key, Dafny.ISequence<Dafny.ISequence<char>> converted);
    Wrappers_Compile._IResult<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> BeaconizeNumberSet(Dafny.ISequence<Dafny.ISequence<char>> @value, Dafny.ISequence<byte> key, Dafny.ISequence<Dafny.ISequence<char>> converted);
    Wrappers_Compile._IResult<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> BeaconizeBinarySet(Dafny.ISequence<Dafny.ISequence<byte>> @value, Dafny.ISequence<byte> key, Dafny.ISequence<Dafny.ISequence<char>> converted);
    Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetBeaconValue(software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue @value, Dafny.ISequence<byte> key, bool forContains);
    Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> getPart(Dafny.ISequence<byte> val, Dafny.ISequence<byte> key);
  }
  public class StandardBeacon : _IStandardBeacon {
    public readonly BaseBeacon_Compile._IBeaconBase _base;
    public readonly byte _length;
    public readonly Dafny.ISequence<TermLoc_Compile._ISelector> _loc;
    public readonly bool _partOnly;
    public readonly bool _asSet;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<char>> _share;
    public StandardBeacon(BaseBeacon_Compile._IBeaconBase @base, byte length, Dafny.ISequence<TermLoc_Compile._ISelector> loc, bool partOnly, bool asSet, Wrappers_Compile._IOption<Dafny.ISequence<char>> share) {
      this._base = @base;
      this._length = length;
      this._loc = loc;
      this._partOnly = partOnly;
      this._asSet = asSet;
      this._share = share;
    }
    public _IStandardBeacon DowncastClone() {
      if (this is _IStandardBeacon dt) { return dt; }
      return new StandardBeacon(_base, _length, _loc, _partOnly, _asSet, _share);
    }
    public override bool Equals(object other) {
      var oth = other as BaseBeacon_Compile.StandardBeacon;
      return oth != null && object.Equals(this._base, oth._base) && this._length == oth._length && object.Equals(this._loc, oth._loc) && this._partOnly == oth._partOnly && this._asSet == oth._asSet && object.Equals(this._share, oth._share);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._base));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._length));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._loc));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._partOnly));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._asSet));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._share));
      return (int) hash;
    }
    public override string ToString() {
      string s = "BaseBeacon.StandardBeacon.StandardBeacon";
      s += "(";
      s += Dafny.Helpers.ToString(this._base);
      s += ", ";
      s += Dafny.Helpers.ToString(this._length);
      s += ", ";
      s += Dafny.Helpers.ToString(this._loc);
      s += ", ";
      s += Dafny.Helpers.ToString(this._partOnly);
      s += ", ";
      s += Dafny.Helpers.ToString(this._asSet);
      s += ", ";
      s += Dafny.Helpers.ToString(this._share);
      s += ")";
      return s;
    }
    private static readonly BaseBeacon_Compile._IStandardBeacon theDefault = create(BaseBeacon_Compile.BeaconBase.Default(), BaseBeacon_Compile.BeaconLength.Witness, Dafny.Sequence<TermLoc_Compile._ISelector>.Empty, false, false, Wrappers_Compile.Option<Dafny.ISequence<char>>.Default());
    public static BaseBeacon_Compile._IStandardBeacon Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<BaseBeacon_Compile._IStandardBeacon> _TYPE = new Dafny.TypeDescriptor<BaseBeacon_Compile._IStandardBeacon>(BaseBeacon_Compile.StandardBeacon.Default());
    public static Dafny.TypeDescriptor<BaseBeacon_Compile._IStandardBeacon> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IStandardBeacon create(BaseBeacon_Compile._IBeaconBase @base, byte length, Dafny.ISequence<TermLoc_Compile._ISelector> loc, bool partOnly, bool asSet, Wrappers_Compile._IOption<Dafny.ISequence<char>> share) {
      return new StandardBeacon(@base, length, loc, partOnly, asSet, share);
    }
    public static _IStandardBeacon create_StandardBeacon(BaseBeacon_Compile._IBeaconBase @base, byte length, Dafny.ISequence<TermLoc_Compile._ISelector> loc, bool partOnly, bool asSet, Wrappers_Compile._IOption<Dafny.ISequence<char>> share) {
      return create(@base, length, loc, partOnly, asSet, share);
    }
    public bool is_StandardBeacon { get { return true; } }
    public BaseBeacon_Compile._IBeaconBase dtor_base {
      get {
        return this._base;
      }
    }
    public byte dtor_length {
      get {
        return this._length;
      }
    }
    public Dafny.ISequence<TermLoc_Compile._ISelector> dtor_loc {
      get {
        return this._loc;
      }
    }
    public bool dtor_partOnly {
      get {
        return this._partOnly;
      }
    }
    public bool dtor_asSet {
      get {
        return this._asSet;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_share {
      get {
        return this._share;
      }
    }
    public Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> hash(Dafny.ISequence<byte> val, Dafny.ISequence<byte> key)
    {
      return ((this).dtor_base).hash(val, key, (this).dtor_length);
    }
    public Dafny.ISequence<char> keyName() {
      if (((this).dtor_share).is_Some) {
        return ((this).dtor_share).dtor_value;
      } else {
        return ((this).dtor_base).dtor_name;
      }
    }
    public Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> hashStr(Dafny.ISequence<char> val, Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>> keys)
    {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>((keys).Contains((this).keyName()), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Internal Error, no key for "), (this).keyName())));
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<char>>();
      } else {
        Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> _1_str = UTF8.__default.Encode(val);
        if ((_1_str).is_Failure) {
          return Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E((_1_str).dtor_error));
        } else {
          return (this).hash((_1_str).dtor_value, Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<byte>>.Select(keys,(this).keyName()));
        }
      }
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> ValueToSet(software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue @value, Dafny.ISequence<byte> key)
    {
      Wrappers_Compile._IResult<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = ((System.Func<Wrappers_Compile._IResult<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>>)(() => {
        software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue _source0 = @value;
        {
          if (_source0.is_SS) {
            Dafny.ISequence<Dafny.ISequence<char>> _1_n = _source0.dtor_SS;
            return (this).BeaconizeStringSet(_1_n, key, Dafny.Sequence<Dafny.ISequence<char>>.FromElements());
          }
        }
        {
          if (_source0.is_NS) {
            Dafny.ISequence<Dafny.ISequence<char>> _2_n = _source0.dtor_NS;
            return (this).BeaconizeNumberSet(_2_n, key, Dafny.Sequence<Dafny.ISequence<char>>.FromElements());
          }
        }
        {
          if (_source0.is_BS) {
            Dafny.ISequence<Dafny.ISequence<byte>> _3_n = _source0.dtor_BS;
            return (this).BeaconizeBinarySet(_3_n, key, Dafny.Sequence<Dafny.ISequence<char>>.FromElements());
          }
        }
        {
          return Wrappers_Compile.Result<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Beacon "), ((this).dtor_base).dtor_name), Dafny.Sequence<char>.FromString(" has style AsSet, but attribute has type ")), DynamoDbEncryptionUtil_Compile.__default.AttrTypeToStr(@value)), Dafny.Sequence<char>.FromString("."))));
        }
      }))();
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>();
      } else {
        Dafny.ISequence<Dafny.ISequence<char>> _4_beaconSeq = (_0_valueOrError0).Extract();
        return Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_SS(_4_beaconSeq));
      }
    }
    public Wrappers_Compile._IResult<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> getHash(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> vf, Dafny.ISequence<byte> key)
    {
      if ((this).dtor_asSet) {
        return (this).getHashSet(item, key);
      } else {
        return (this).getHashNonSet(item, vf, key);
      }
    }
    public Wrappers_Compile._IResult<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> getHashSet(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Dafny.ISequence<byte> key)
    {
      Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _0_value = TermLoc_Compile.__default.TermToAttr((this).dtor_loc, item, Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>.create_None());
      if ((_0_value).is_None) {
        return Wrappers_Compile.Result<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.create_None());
      } else {
        Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _1_valueOrError0 = (this).ValueToSet((_0_value).dtor_value, key);
        if ((_1_valueOrError0).IsFailure()) {
          return (_1_valueOrError0).PropagateFailure<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
        } else {
          software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue _2_setValue = (_1_valueOrError0).Extract();
          return Wrappers_Compile.Result<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.create_Some(_2_setValue));
        }
      }
    }
    public Wrappers_Compile._IResult<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> getHashNonSet(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> vf, Dafny.ISequence<byte> key)
    {
      Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = DdbVirtualFields_Compile.__default.VirtToBytes((this).dtor_loc, item, vf);
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
      } else {
        Wrappers_Compile._IOption<Dafny.ISequence<byte>> _1_bytes = (_0_valueOrError0).Extract();
        if ((_1_bytes).is_None) {
          return Wrappers_Compile.Result<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.create_None());
        } else {
          Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _2_valueOrError1 = (this).hash((_1_bytes).dtor_value, key);
          if ((_2_valueOrError1).IsFailure()) {
            return (_2_valueOrError1).PropagateFailure<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
          } else {
            Dafny.ISequence<char> _3_res = (_2_valueOrError1).Extract();
            return Wrappers_Compile.Result<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.create_Some(software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_S(_3_res)));
          }
        }
      }
    }
    public Wrappers_Compile._IResult<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> getNaked(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> vf)
    {
      return DdbVirtualFields_Compile.__default.VirtToAttr((this).dtor_loc, item, vf);
    }
    public Dafny.ISequence<Dafny.ISequence<char>> GetFields(Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> virtualFields) {
      if ((virtualFields).Contains((((this).dtor_loc).Select(BigInteger.Zero)).dtor_key)) {
        return (Dafny.Map<Dafny.ISequence<char>, DdbVirtualFields_Compile._IVirtField>.Select(virtualFields,(((this).dtor_loc).Select(BigInteger.Zero)).dtor_key)).GetFields();
      } else {
        return Dafny.Sequence<Dafny.ISequence<char>>.FromElements((((this).dtor_loc).Select(BigInteger.Zero)).dtor_key);
      }
    }
    public Wrappers_Compile._IResult<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> BeaconizeStringSet(Dafny.ISequence<Dafny.ISequence<char>> @value, Dafny.ISequence<byte> key, Dafny.ISequence<Dafny.ISequence<char>> converted)
    {
      _IStandardBeacon _this = this;
    TAIL_CALL_START: ;
      if ((new BigInteger((@value).Count)).Sign == 0) {
        return Wrappers_Compile.Result<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(converted);
      } else {
        Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(DynamoToStruct_Compile.__default.TopLevelAttributeToBytes(software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_S((@value).Select(BigInteger.Zero))), Dafny.Helpers.Id<Func<BaseBeacon_Compile._IStandardBeacon, Func<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>>>((_1___this0) => ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>)((_2_e) => {
          return DynamoDbEncryptionUtil_Compile.__default.E(_2_e);
        })))(_this));
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<Dafny.ISequence<char>>>();
        } else {
          Dafny.ISequence<byte> _3_bytes = (_0_valueOrError0).Extract();
          Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _4_valueOrError1 = (_this).hash(_3_bytes, key);
          if ((_4_valueOrError1).IsFailure()) {
            return (_4_valueOrError1).PropagateFailure<Dafny.ISequence<Dafny.ISequence<char>>>();
          } else {
            Dafny.ISequence<char> _5_h = (_4_valueOrError1).Extract();
            if ((converted).Contains(_5_h)) {
              BaseBeacon_Compile._IStandardBeacon _in0 = _this;
              Dafny.ISequence<Dafny.ISequence<char>> _in1 = (@value).Drop(BigInteger.One);
              Dafny.ISequence<byte> _in2 = key;
              Dafny.ISequence<Dafny.ISequence<char>> _in3 = converted;
              _this = _in0;
              ;
              @value = _in1;
              key = _in2;
              converted = _in3;
              goto TAIL_CALL_START;
            } else {
              BaseBeacon_Compile._IStandardBeacon _in4 = _this;
              Dafny.ISequence<Dafny.ISequence<char>> _in5 = (@value).Drop(BigInteger.One);
              Dafny.ISequence<byte> _in6 = key;
              Dafny.ISequence<Dafny.ISequence<char>> _in7 = Dafny.Sequence<Dafny.ISequence<char>>.Concat(converted, Dafny.Sequence<Dafny.ISequence<char>>.FromElements(_5_h));
              _this = _in4;
              ;
              @value = _in5;
              key = _in6;
              converted = _in7;
              goto TAIL_CALL_START;
            }
          }
        }
      }
    }
    public Wrappers_Compile._IResult<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> BeaconizeNumberSet(Dafny.ISequence<Dafny.ISequence<char>> @value, Dafny.ISequence<byte> key, Dafny.ISequence<Dafny.ISequence<char>> converted)
    {
      _IStandardBeacon _this = this;
    TAIL_CALL_START: ;
      if ((new BigInteger((@value).Count)).Sign == 0) {
        return Wrappers_Compile.Result<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(converted);
      } else {
        Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(DynamoToStruct_Compile.__default.TopLevelAttributeToBytes(software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_N((@value).Select(BigInteger.Zero))), Dafny.Helpers.Id<Func<BaseBeacon_Compile._IStandardBeacon, Func<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>>>((_1___this0) => ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>)((_2_e) => {
          return DynamoDbEncryptionUtil_Compile.__default.E(_2_e);
        })))(_this));
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<Dafny.ISequence<char>>>();
        } else {
          Dafny.ISequence<byte> _3_bytes = (_0_valueOrError0).Extract();
          Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _4_valueOrError1 = (_this).hash(_3_bytes, key);
          if ((_4_valueOrError1).IsFailure()) {
            return (_4_valueOrError1).PropagateFailure<Dafny.ISequence<Dafny.ISequence<char>>>();
          } else {
            Dafny.ISequence<char> _5_h = (_4_valueOrError1).Extract();
            if ((converted).Contains(_5_h)) {
              BaseBeacon_Compile._IStandardBeacon _in0 = _this;
              Dafny.ISequence<Dafny.ISequence<char>> _in1 = (@value).Drop(BigInteger.One);
              Dafny.ISequence<byte> _in2 = key;
              Dafny.ISequence<Dafny.ISequence<char>> _in3 = converted;
              _this = _in0;
              ;
              @value = _in1;
              key = _in2;
              converted = _in3;
              goto TAIL_CALL_START;
            } else {
              BaseBeacon_Compile._IStandardBeacon _in4 = _this;
              Dafny.ISequence<Dafny.ISequence<char>> _in5 = (@value).Drop(BigInteger.One);
              Dafny.ISequence<byte> _in6 = key;
              Dafny.ISequence<Dafny.ISequence<char>> _in7 = Dafny.Sequence<Dafny.ISequence<char>>.Concat(converted, Dafny.Sequence<Dafny.ISequence<char>>.FromElements(_5_h));
              _this = _in4;
              ;
              @value = _in5;
              key = _in6;
              converted = _in7;
              goto TAIL_CALL_START;
            }
          }
        }
      }
    }
    public Wrappers_Compile._IResult<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> BeaconizeBinarySet(Dafny.ISequence<Dafny.ISequence<byte>> @value, Dafny.ISequence<byte> key, Dafny.ISequence<Dafny.ISequence<char>> converted)
    {
      _IStandardBeacon _this = this;
    TAIL_CALL_START: ;
      if ((new BigInteger((@value).Count)).Sign == 0) {
        return Wrappers_Compile.Result<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(converted);
      } else {
        Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(DynamoToStruct_Compile.__default.TopLevelAttributeToBytes(software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_B((@value).Select(BigInteger.Zero))), Dafny.Helpers.Id<Func<BaseBeacon_Compile._IStandardBeacon, Func<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>>>((_1___this0) => ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>)((_2_e) => {
          return DynamoDbEncryptionUtil_Compile.__default.E(_2_e);
        })))(_this));
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<Dafny.ISequence<char>>>();
        } else {
          Dafny.ISequence<byte> _3_bytes = (_0_valueOrError0).Extract();
          Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _4_valueOrError1 = (_this).hash(_3_bytes, key);
          if ((_4_valueOrError1).IsFailure()) {
            return (_4_valueOrError1).PropagateFailure<Dafny.ISequence<Dafny.ISequence<char>>>();
          } else {
            Dafny.ISequence<char> _5_h = (_4_valueOrError1).Extract();
            if ((converted).Contains(_5_h)) {
              BaseBeacon_Compile._IStandardBeacon _in0 = _this;
              Dafny.ISequence<Dafny.ISequence<byte>> _in1 = (@value).Drop(BigInteger.One);
              Dafny.ISequence<byte> _in2 = key;
              Dafny.ISequence<Dafny.ISequence<char>> _in3 = converted;
              _this = _in0;
              ;
              @value = _in1;
              key = _in2;
              converted = _in3;
              goto TAIL_CALL_START;
            } else {
              BaseBeacon_Compile._IStandardBeacon _in4 = _this;
              Dafny.ISequence<Dafny.ISequence<byte>> _in5 = (@value).Drop(BigInteger.One);
              Dafny.ISequence<byte> _in6 = key;
              Dafny.ISequence<Dafny.ISequence<char>> _in7 = Dafny.Sequence<Dafny.ISequence<char>>.Concat(converted, Dafny.Sequence<Dafny.ISequence<char>>.FromElements(_5_h));
              _this = _in4;
              ;
              @value = _in5;
              key = _in6;
              converted = _in7;
              goto TAIL_CALL_START;
            }
          }
        }
      }
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetBeaconValue(software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue @value, Dafny.ISequence<byte> key, bool forContains)
    {
      if (((((this).dtor_asSet) && (!((@value).is_S))) && (!((@value).is_N))) && (!((@value).is_B))) {
        return (this).ValueToSet(@value, key);
      } else if ((forContains) && ((((@value).is_SS) || ((@value).is_NS)) || ((@value).is_BS))) {
        return (this).ValueToSet(@value, key);
      } else {
        Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(DynamoToStruct_Compile.__default.TopLevelAttributeToBytes(@value), ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>)((_1_e) => {
          return DynamoDbEncryptionUtil_Compile.__default.E(_1_e);
        })));
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>();
        } else {
          Dafny.ISequence<byte> _2_bytes = (_0_valueOrError0).Extract();
          Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _3_valueOrError1 = (this).hash(_2_bytes, key);
          if ((_3_valueOrError1).IsFailure()) {
            return (_3_valueOrError1).PropagateFailure<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>();
          } else {
            Dafny.ISequence<char> _4_h = (_3_valueOrError1).Extract();
            return Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_S(_4_h));
          }
        }
      }
    }
    public Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> getPart(Dafny.ISequence<byte> val, Dafny.ISequence<byte> key)
    {
      return ((this).dtor_base).hash(val, key, (this).dtor_length);
    }
  }
} // end of namespace BaseBeacon_Compile
namespace CompoundBeacon_Compile {

  public partial class __default {
    public static Wrappers_Compile._IResult<CompoundBeacon_Compile._ICompoundBeacon, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> MakeCompoundBeacon(BaseBeacon_Compile._IBeaconBase @base, char split, Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> parts, BigInteger numSigned, Dafny.ISequence<CompoundBeacon_Compile._IConstructor> construct)
    {
      CompoundBeacon_Compile._ICompoundBeacon _0_x = CompoundBeacon_Compile.CompoundBeacon.create(@base, split, parts, numSigned, construct);
      Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _1_valueOrError0 = (_0_x).ValidPrefixSetResult();
      if ((_1_valueOrError0).IsFailure()) {
        return (_1_valueOrError0).PropagateFailure<CompoundBeacon_Compile._ICompoundBeacon>();
      } else {
        bool _2___v0 = (_1_valueOrError0).Extract();
        return Wrappers_Compile.Result<CompoundBeacon_Compile._ICompoundBeacon, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(_0_x);
      }
    }
    public static CompoundBeacon_Compile._IConstructor MakeDefaultConstructor(Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> parts) {
      Dafny.ISequence<CompoundBeacon_Compile._IConstructorPart> _0_cons = Seq_Compile.__default.Map<CompoundBeacon_Compile._IBeaconPart, CompoundBeacon_Compile._IConstructorPart>(((System.Func<CompoundBeacon_Compile._IBeaconPart, CompoundBeacon_Compile._IConstructorPart>)((_1_x) => {
        return CompoundBeacon_Compile.ConstructorPart.create(_1_x, true);
      })), parts);
      return CompoundBeacon_Compile.Constructor.create(_0_cons);
    }
  }

  public partial class Prefix {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<char>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<char>>(Dafny.Sequence<char>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<char>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.ISequence<char> __source) {
      Dafny.ISequence<char> _2_x = __source;
      return (new BigInteger((_2_x).Count)).Sign == 1;
    }
  }

  public interface _IBeaconPart {
    bool is_Encrypted { get; }
    bool is_Signed { get; }
    Dafny.ISequence<char> dtor_prefix { get; }
    BaseBeacon_Compile._IStandardBeacon dtor_beacon { get; }
    Dafny.ISequence<char> dtor_name { get; }
    Dafny.ISequence<TermLoc_Compile._ISelector> dtor_loc { get; }
    _IBeaconPart DowncastClone();
    Dafny.ISequence<char> getPrefix();
    Dafny.ISequence<char> getName();
    Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> getString(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> vf);
    Dafny.ISequence<Dafny.ISequence<char>> GetFields(Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> virtualFields);
  }
  public abstract class BeaconPart : _IBeaconPart {
    public BeaconPart() {
    }
    private static readonly CompoundBeacon_Compile._IBeaconPart theDefault = create_Encrypted(Dafny.Sequence<char>.Empty, BaseBeacon_Compile.StandardBeacon.Default());
    public static CompoundBeacon_Compile._IBeaconPart Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<CompoundBeacon_Compile._IBeaconPart> _TYPE = new Dafny.TypeDescriptor<CompoundBeacon_Compile._IBeaconPart>(CompoundBeacon_Compile.BeaconPart.Default());
    public static Dafny.TypeDescriptor<CompoundBeacon_Compile._IBeaconPart> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IBeaconPart create_Encrypted(Dafny.ISequence<char> prefix, BaseBeacon_Compile._IStandardBeacon beacon) {
      return new BeaconPart_Encrypted(prefix, beacon);
    }
    public static _IBeaconPart create_Signed(Dafny.ISequence<char> prefix, Dafny.ISequence<char> name, Dafny.ISequence<TermLoc_Compile._ISelector> loc) {
      return new BeaconPart_Signed(prefix, name, loc);
    }
    public bool is_Encrypted { get { return this is BeaconPart_Encrypted; } }
    public bool is_Signed { get { return this is BeaconPart_Signed; } }
    public Dafny.ISequence<char> dtor_prefix {
      get {
        var d = this;
        if (d is BeaconPart_Encrypted) { return ((BeaconPart_Encrypted)d)._prefix; }
        return ((BeaconPart_Signed)d)._prefix;
      }
    }
    public BaseBeacon_Compile._IStandardBeacon dtor_beacon {
      get {
        var d = this;
        return ((BeaconPart_Encrypted)d)._beacon;
      }
    }
    public Dafny.ISequence<char> dtor_name {
      get {
        var d = this;
        return ((BeaconPart_Signed)d)._name;
      }
    }
    public Dafny.ISequence<TermLoc_Compile._ISelector> dtor_loc {
      get {
        var d = this;
        return ((BeaconPart_Signed)d)._loc;
      }
    }
    public abstract _IBeaconPart DowncastClone();
    public Dafny.ISequence<char> getPrefix() {
      CompoundBeacon_Compile._IBeaconPart _source0 = this;
      {
        if (_source0.is_Encrypted) {
          Dafny.ISequence<char> _0_p = _source0.dtor_prefix;
          BaseBeacon_Compile._IStandardBeacon _1_b = _source0.dtor_beacon;
          return _0_p;
        }
      }
      {
        Dafny.ISequence<char> _2_p = _source0.dtor_prefix;
        Dafny.ISequence<char> _3_n = _source0.dtor_name;
        Dafny.ISequence<TermLoc_Compile._ISelector> _4_l = _source0.dtor_loc;
        return _2_p;
      }
    }
    public Dafny.ISequence<char> getName() {
      CompoundBeacon_Compile._IBeaconPart _source0 = this;
      {
        if (_source0.is_Encrypted) {
          Dafny.ISequence<char> _0_p = _source0.dtor_prefix;
          BaseBeacon_Compile._IStandardBeacon _1_b = _source0.dtor_beacon;
          return ((_1_b).dtor_base).dtor_name;
        }
      }
      {
        Dafny.ISequence<char> _2_p = _source0.dtor_prefix;
        Dafny.ISequence<char> _3_n = _source0.dtor_name;
        Dafny.ISequence<TermLoc_Compile._ISelector> _4_l = _source0.dtor_loc;
        return _3_n;
      }
    }
    public Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> getString(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> vf)
    {
      CompoundBeacon_Compile._IBeaconPart _source0 = this;
      {
        if (_source0.is_Encrypted) {
          Dafny.ISequence<char> _0_p = _source0.dtor_prefix;
          BaseBeacon_Compile._IStandardBeacon _1_b = _source0.dtor_beacon;
          return DdbVirtualFields_Compile.__default.VirtToString((_1_b).dtor_loc, item, vf);
        }
      }
      {
        Dafny.ISequence<char> _2_p = _source0.dtor_prefix;
        Dafny.ISequence<char> _3_n = _source0.dtor_name;
        Dafny.ISequence<TermLoc_Compile._ISelector> _4_l = _source0.dtor_loc;
        return DdbVirtualFields_Compile.__default.VirtToString(_4_l, item, vf);
      }
    }
    public Dafny.ISequence<Dafny.ISequence<char>> GetFields(Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> virtualFields) {
      CompoundBeacon_Compile._IBeaconPart _source0 = this;
      {
        if (_source0.is_Encrypted) {
          Dafny.ISequence<char> _0_p = _source0.dtor_prefix;
          BaseBeacon_Compile._IStandardBeacon _1_b = _source0.dtor_beacon;
          return (_1_b).GetFields(virtualFields);
        }
      }
      {
        Dafny.ISequence<char> _2_p = _source0.dtor_prefix;
        Dafny.ISequence<char> _3_n = _source0.dtor_name;
        Dafny.ISequence<TermLoc_Compile._ISelector> _4_l = _source0.dtor_loc;
        if ((virtualFields).Contains((((this).dtor_loc).Select(BigInteger.Zero)).dtor_key)) {
          return (Dafny.Map<Dafny.ISequence<char>, DdbVirtualFields_Compile._IVirtField>.Select(virtualFields,(((this).dtor_loc).Select(BigInteger.Zero)).dtor_key)).GetFields();
        } else {
          return Dafny.Sequence<Dafny.ISequence<char>>.FromElements((((this).dtor_loc).Select(BigInteger.Zero)).dtor_key);
        }
      }
    }
  }
  public class BeaconPart_Encrypted : BeaconPart {
    public readonly Dafny.ISequence<char> _prefix;
    public readonly BaseBeacon_Compile._IStandardBeacon _beacon;
    public BeaconPart_Encrypted(Dafny.ISequence<char> prefix, BaseBeacon_Compile._IStandardBeacon beacon) : base() {
      this._prefix = prefix;
      this._beacon = beacon;
    }
    public override _IBeaconPart DowncastClone() {
      if (this is _IBeaconPart dt) { return dt; }
      return new BeaconPart_Encrypted(_prefix, _beacon);
    }
    public override bool Equals(object other) {
      var oth = other as CompoundBeacon_Compile.BeaconPart_Encrypted;
      return oth != null && object.Equals(this._prefix, oth._prefix) && object.Equals(this._beacon, oth._beacon);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._prefix));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._beacon));
      return (int) hash;
    }
    public override string ToString() {
      string s = "CompoundBeacon.BeaconPart.Encrypted";
      s += "(";
      s += Dafny.Helpers.ToString(this._prefix);
      s += ", ";
      s += Dafny.Helpers.ToString(this._beacon);
      s += ")";
      return s;
    }
  }
  public class BeaconPart_Signed : BeaconPart {
    public readonly Dafny.ISequence<char> _prefix;
    public readonly Dafny.ISequence<char> _name;
    public readonly Dafny.ISequence<TermLoc_Compile._ISelector> _loc;
    public BeaconPart_Signed(Dafny.ISequence<char> prefix, Dafny.ISequence<char> name, Dafny.ISequence<TermLoc_Compile._ISelector> loc) : base() {
      this._prefix = prefix;
      this._name = name;
      this._loc = loc;
    }
    public override _IBeaconPart DowncastClone() {
      if (this is _IBeaconPart dt) { return dt; }
      return new BeaconPart_Signed(_prefix, _name, _loc);
    }
    public override bool Equals(object other) {
      var oth = other as CompoundBeacon_Compile.BeaconPart_Signed;
      return oth != null && object.Equals(this._prefix, oth._prefix) && object.Equals(this._name, oth._name) && object.Equals(this._loc, oth._loc);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._prefix));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._name));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._loc));
      return (int) hash;
    }
    public override string ToString() {
      string s = "CompoundBeacon.BeaconPart.Signed";
      s += "(";
      s += Dafny.Helpers.ToString(this._prefix);
      s += ", ";
      s += Dafny.Helpers.ToString(this._name);
      s += ", ";
      s += Dafny.Helpers.ToString(this._loc);
      s += ")";
      return s;
    }
  }

  public interface _IConstructorPart {
    bool is_ConstructorPart { get; }
    CompoundBeacon_Compile._IBeaconPart dtor_part { get; }
    bool dtor_required { get; }
    _IConstructorPart DowncastClone();
  }
  public class ConstructorPart : _IConstructorPart {
    public readonly CompoundBeacon_Compile._IBeaconPart _part;
    public readonly bool _required;
    public ConstructorPart(CompoundBeacon_Compile._IBeaconPart part, bool required) {
      this._part = part;
      this._required = required;
    }
    public _IConstructorPart DowncastClone() {
      if (this is _IConstructorPart dt) { return dt; }
      return new ConstructorPart(_part, _required);
    }
    public override bool Equals(object other) {
      var oth = other as CompoundBeacon_Compile.ConstructorPart;
      return oth != null && object.Equals(this._part, oth._part) && this._required == oth._required;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._part));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._required));
      return (int) hash;
    }
    public override string ToString() {
      string s = "CompoundBeacon.ConstructorPart.ConstructorPart";
      s += "(";
      s += Dafny.Helpers.ToString(this._part);
      s += ", ";
      s += Dafny.Helpers.ToString(this._required);
      s += ")";
      return s;
    }
    private static readonly CompoundBeacon_Compile._IConstructorPart theDefault = create(CompoundBeacon_Compile.BeaconPart.Default(), false);
    public static CompoundBeacon_Compile._IConstructorPart Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<CompoundBeacon_Compile._IConstructorPart> _TYPE = new Dafny.TypeDescriptor<CompoundBeacon_Compile._IConstructorPart>(CompoundBeacon_Compile.ConstructorPart.Default());
    public static Dafny.TypeDescriptor<CompoundBeacon_Compile._IConstructorPart> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IConstructorPart create(CompoundBeacon_Compile._IBeaconPart part, bool required) {
      return new ConstructorPart(part, required);
    }
    public static _IConstructorPart create_ConstructorPart(CompoundBeacon_Compile._IBeaconPart part, bool required) {
      return create(part, required);
    }
    public bool is_ConstructorPart { get { return true; } }
    public CompoundBeacon_Compile._IBeaconPart dtor_part {
      get {
        return this._part;
      }
    }
    public bool dtor_required {
      get {
        return this._required;
      }
    }
  }

  public partial class ConstructorPartList {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<CompoundBeacon_Compile._IConstructorPart>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<CompoundBeacon_Compile._IConstructorPart>>(Dafny.Sequence<CompoundBeacon_Compile._IConstructorPart>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<CompoundBeacon_Compile._IConstructorPart>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.ISequence<CompoundBeacon_Compile._IConstructorPart> __source) {
      Dafny.ISequence<CompoundBeacon_Compile._IConstructorPart> _5_x = __source;
      return (new BigInteger((_5_x).Count)).Sign == 1;
    }
  }

  public interface _IConstructor {
    bool is_Constructor { get; }
    Dafny.ISequence<CompoundBeacon_Compile._IConstructorPart> dtor_parts { get; }
    _IConstructor DowncastClone();
    Dafny.ISet<CompoundBeacon_Compile._IBeaconPart> getReqParts();
  }
  public class Constructor : _IConstructor {
    public readonly Dafny.ISequence<CompoundBeacon_Compile._IConstructorPart> _parts;
    public Constructor(Dafny.ISequence<CompoundBeacon_Compile._IConstructorPart> parts) {
      this._parts = parts;
    }
    public _IConstructor DowncastClone() {
      if (this is _IConstructor dt) { return dt; }
      return new Constructor(_parts);
    }
    public override bool Equals(object other) {
      var oth = other as CompoundBeacon_Compile.Constructor;
      return oth != null && object.Equals(this._parts, oth._parts);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._parts));
      return (int) hash;
    }
    public override string ToString() {
      string s = "CompoundBeacon.Constructor.Constructor";
      s += "(";
      s += Dafny.Helpers.ToString(this._parts);
      s += ")";
      return s;
    }
    private static readonly CompoundBeacon_Compile._IConstructor theDefault = create(Dafny.Sequence<CompoundBeacon_Compile._IConstructorPart>.Empty);
    public static CompoundBeacon_Compile._IConstructor Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<CompoundBeacon_Compile._IConstructor> _TYPE = new Dafny.TypeDescriptor<CompoundBeacon_Compile._IConstructor>(CompoundBeacon_Compile.Constructor.Default());
    public static Dafny.TypeDescriptor<CompoundBeacon_Compile._IConstructor> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IConstructor create(Dafny.ISequence<CompoundBeacon_Compile._IConstructorPart> parts) {
      return new Constructor(parts);
    }
    public static _IConstructor create_Constructor(Dafny.ISequence<CompoundBeacon_Compile._IConstructorPart> parts) {
      return create(parts);
    }
    public bool is_Constructor { get { return true; } }
    public Dafny.ISequence<CompoundBeacon_Compile._IConstructorPart> dtor_parts {
      get {
        return this._parts;
      }
    }
    public Dafny.ISet<CompoundBeacon_Compile._IBeaconPart> getReqParts() {
      return ((System.Func<Dafny.ISet<CompoundBeacon_Compile._IBeaconPart>>)(() => {
        var _coll0 = new System.Collections.Generic.List<CompoundBeacon_Compile._IBeaconPart>();
        foreach (CompoundBeacon_Compile._IConstructorPart _compr_0 in ((this).dtor_parts).CloneAsArray()) {
          CompoundBeacon_Compile._IConstructorPart _0_k = (CompoundBeacon_Compile._IConstructorPart)_compr_0;
          if ((((this).dtor_parts).Contains(_0_k)) && ((_0_k).dtor_required)) {
            _coll0.Add((_0_k).dtor_part);
          }
        }
        return Dafny.Set<CompoundBeacon_Compile._IBeaconPart>.FromCollection(_coll0);
      }))();
    }
  }

  public partial class ConstructorList {
    private static readonly Dafny.TypeDescriptor<Dafny.ISequence<CompoundBeacon_Compile._IConstructor>> _TYPE = new Dafny.TypeDescriptor<Dafny.ISequence<CompoundBeacon_Compile._IConstructor>>(Dafny.Sequence<CompoundBeacon_Compile._IConstructor>.Empty);
    public static Dafny.TypeDescriptor<Dafny.ISequence<CompoundBeacon_Compile._IConstructor>> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(Dafny.ISequence<CompoundBeacon_Compile._IConstructor> __source) {
      Dafny.ISequence<CompoundBeacon_Compile._IConstructor> _1_x = __source;
      return (new BigInteger((_1_x).Count)).Sign == 1;
    }
  }

  public partial class ValidCompoundBeacon {
    private static readonly Dafny.TypeDescriptor<CompoundBeacon_Compile._ICompoundBeacon> _TYPE = new Dafny.TypeDescriptor<CompoundBeacon_Compile._ICompoundBeacon>(CompoundBeacon_Compile.CompoundBeacon.Default());
    public static Dafny.TypeDescriptor<CompoundBeacon_Compile._ICompoundBeacon> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public interface _ICompoundBeacon {
    bool is_CompoundBeacon { get; }
    BaseBeacon_Compile._IBeaconBase dtor_base { get; }
    char dtor_split { get; }
    Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> dtor_parts { get; }
    BigInteger dtor_numSigned { get; }
    Dafny.ISequence<CompoundBeacon_Compile._IConstructor> dtor_construct { get; }
    _ICompoundBeacon DowncastClone();
    bool HasBeacon2(Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> parts, Dafny.ISequence<char> name);
    bool HasBeacon(Dafny.ISequence<char> name);
    bool isEncrypted();
    Wrappers_Compile._IResult<CompoundBeacon_Compile._IBeaconPart, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> getPartFromPrefix(Dafny.ISequence<char> @value);
    Dafny.ISequence<char> PartsToString(Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> p);
    Dafny.ISequence<char> CPartToString(CompoundBeacon_Compile._IConstructorPart s);
    Dafny.ISequence<char> CPartsToString(Dafny.ISequence<CompoundBeacon_Compile._IConstructorPart> p);
    Dafny.ISequence<char> CListToString(Dafny.ISequence<CompoundBeacon_Compile._IConstructor> p);
    bool CanConstruct(Dafny.ISequence<CompoundBeacon_Compile._IConstructorPart> con, Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> inParts, bool matched);
    bool IsValidPartOrder(Dafny.ISequence<CompoundBeacon_Compile._IConstructor> candidates, Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> inParts);
    Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> ValidatePartOrder(Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> inParts, Dafny.ISequence<char> orig);
    Wrappers_Compile._IResult<CompoundBeacon_Compile._IBeaconPart, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> partFromPrefix(Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> p, Dafny.ISequence<char> @value);
    Wrappers_Compile._IResult<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> SkipSignedPieces(Dafny.ISequence<Dafny.ISequence<char>> pieces);
    Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> IsLessThanComparable(Dafny.ISequence<Dafny.ISequence<char>> pieces);
    Dafny.ISequence<Dafny.ISequence<char>> GetFields(Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> virtualFields);
    Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> FindAndCalcPart(Dafny.ISequence<char> @value, DynamoDbEncryptionUtil_Compile._IMaybeKeyMap keys);
    Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> justPrefix(Dafny.ISequence<char> @value);
    Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetBeaconValue(software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue @value, DynamoDbEncryptionUtil_Compile._IMaybeKeyMap keys, bool forEquality);
    Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> TryConstructor(Dafny.ISequence<CompoundBeacon_Compile._IConstructorPart> consFields, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> vf, DynamoDbEncryptionUtil_Compile._IMaybeKeyMap keys, Dafny.ISequence<char> acc);
    Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> TryConstructors(Dafny.ISequence<CompoundBeacon_Compile._IConstructor> construct, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> vf, DynamoDbEncryptionUtil_Compile._IMaybeKeyMap keys);
    Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> hash(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> vf, DynamoDbEncryptionUtil_Compile._IMaybeKeyMap keys);
    Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> getNaked(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> vf);
    Wrappers_Compile._IResult<CompoundBeacon_Compile._IBeaconPart, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> findPart(Dafny.ISequence<char> val);
    Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> getPart(Dafny.ISequence<char> val, Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>> keys);
    Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> calcPart(Dafny.ISequence<char> piece, Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>> keys);
    Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> calcParts(Dafny.ISequence<Dafny.ISequence<char>> pieces, Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>> keys, Dafny.ISequence<char> acc);
    bool OkPrefixPair(BigInteger pos1, BigInteger pos2);
    Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> CheckOnePrefixPart(BigInteger pos1, BigInteger pos2);
    Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> CheckOnePrefix(BigInteger pos);
    Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> ValidPrefixSetResultPos(BigInteger index);
    Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> ValidPrefixSetResult();
    Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> PartValueCalc(Dafny.ISequence<char> data, DynamoDbEncryptionUtil_Compile._IMaybeKeyMap keys, CompoundBeacon_Compile._IBeaconPart part);
  }
  public class CompoundBeacon : _ICompoundBeacon {
    public readonly BaseBeacon_Compile._IBeaconBase _base;
    public readonly char _split;
    public readonly Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> _parts;
    public readonly BigInteger _numSigned;
    public readonly Dafny.ISequence<CompoundBeacon_Compile._IConstructor> _construct;
    public CompoundBeacon(BaseBeacon_Compile._IBeaconBase @base, char split, Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> parts, BigInteger numSigned, Dafny.ISequence<CompoundBeacon_Compile._IConstructor> construct) {
      this._base = @base;
      this._split = split;
      this._parts = parts;
      this._numSigned = numSigned;
      this._construct = construct;
    }
    public _ICompoundBeacon DowncastClone() {
      if (this is _ICompoundBeacon dt) { return dt; }
      return new CompoundBeacon(_base, _split, _parts, _numSigned, _construct);
    }
    public override bool Equals(object other) {
      var oth = other as CompoundBeacon_Compile.CompoundBeacon;
      return oth != null && object.Equals(this._base, oth._base) && this._split == oth._split && object.Equals(this._parts, oth._parts) && this._numSigned == oth._numSigned && object.Equals(this._construct, oth._construct);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._base));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._split));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._parts));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._numSigned));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._construct));
      return (int) hash;
    }
    public override string ToString() {
      string s = "CompoundBeacon.CompoundBeacon.CompoundBeacon";
      s += "(";
      s += Dafny.Helpers.ToString(this._base);
      s += ", ";
      s += Dafny.Helpers.ToString(this._split);
      s += ", ";
      s += Dafny.Helpers.ToString(this._parts);
      s += ", ";
      s += Dafny.Helpers.ToString(this._numSigned);
      s += ", ";
      s += Dafny.Helpers.ToString(this._construct);
      s += ")";
      return s;
    }
    private static readonly CompoundBeacon_Compile._ICompoundBeacon theDefault = create(BaseBeacon_Compile.BeaconBase.Default(), 'D', Dafny.Sequence<CompoundBeacon_Compile._IBeaconPart>.Empty, BigInteger.Zero, Dafny.Sequence<CompoundBeacon_Compile._IConstructor>.Empty);
    public static CompoundBeacon_Compile._ICompoundBeacon Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<CompoundBeacon_Compile._ICompoundBeacon> _TYPE = new Dafny.TypeDescriptor<CompoundBeacon_Compile._ICompoundBeacon>(CompoundBeacon_Compile.CompoundBeacon.Default());
    public static Dafny.TypeDescriptor<CompoundBeacon_Compile._ICompoundBeacon> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ICompoundBeacon create(BaseBeacon_Compile._IBeaconBase @base, char split, Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> parts, BigInteger numSigned, Dafny.ISequence<CompoundBeacon_Compile._IConstructor> construct) {
      return new CompoundBeacon(@base, split, parts, numSigned, construct);
    }
    public static _ICompoundBeacon create_CompoundBeacon(BaseBeacon_Compile._IBeaconBase @base, char split, Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> parts, BigInteger numSigned, Dafny.ISequence<CompoundBeacon_Compile._IConstructor> construct) {
      return create(@base, split, parts, numSigned, construct);
    }
    public bool is_CompoundBeacon { get { return true; } }
    public BaseBeacon_Compile._IBeaconBase dtor_base {
      get {
        return this._base;
      }
    }
    public char dtor_split {
      get {
        return this._split;
      }
    }
    public Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> dtor_parts {
      get {
        return this._parts;
      }
    }
    public BigInteger dtor_numSigned {
      get {
        return this._numSigned;
      }
    }
    public Dafny.ISequence<CompoundBeacon_Compile._IConstructor> dtor_construct {
      get {
        return this._construct;
      }
    }
    public bool HasBeacon2(Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> parts, Dafny.ISequence<char> name)
    {
      _ICompoundBeacon _this = this;
    TAIL_CALL_START: ;
      if ((new BigInteger((parts).Count)).Sign == 0) {
        return false;
      } else if ((((parts).Select(BigInteger.Zero)).getName()).Equals(name)) {
        return true;
      } else {
        CompoundBeacon_Compile._ICompoundBeacon _in0 = _this;
        Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> _in1 = (parts).Drop(BigInteger.One);
        Dafny.ISequence<char> _in2 = name;
        _this = _in0;
        ;
        parts = _in1;
        name = _in2;
        goto TAIL_CALL_START;
      }
    }
    public bool HasBeacon(Dafny.ISequence<char> name) {
      return (this).HasBeacon2((this).dtor_parts, name);
    }
    public bool isEncrypted() {
      return ((this).dtor_numSigned) < (new BigInteger(((this).dtor_parts).Count));
    }
    public Wrappers_Compile._IResult<CompoundBeacon_Compile._IBeaconPart, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> getPartFromPrefix(Dafny.ISequence<char> @value) {
      return (this).partFromPrefix((this).dtor_parts, @value);
    }
    public Dafny.ISequence<char> PartsToString(Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> p) {
      Dafny.ISequence<Dafny.ISequence<char>> _0_beaconParts = Seq_Compile.__default.Map<CompoundBeacon_Compile._IBeaconPart, Dafny.ISequence<char>>(((System.Func<CompoundBeacon_Compile._IBeaconPart, Dafny.ISequence<char>>)((_1_s) => {
        return (_1_s).getPrefix();
      })), p);
      if ((new BigInteger((_0_beaconParts).Count)).Sign == 0) {
        return Dafny.Sequence<char>.FromString("");
      } else {
        return StandardLibrary_Compile.__default.Join<char>(_0_beaconParts, Dafny.Sequence<char>.FromString(""));
      }
    }
    public Dafny.ISequence<char> CPartToString(CompoundBeacon_Compile._IConstructorPart s) {
      if ((s).dtor_required) {
        return ((s).dtor_part).getPrefix();
      } else {
        return Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("["), ((s).dtor_part).getPrefix()), Dafny.Sequence<char>.FromString("]"));
      }
    }
    public Dafny.ISequence<char> CPartsToString(Dafny.ISequence<CompoundBeacon_Compile._IConstructorPart> p) {
      Dafny.ISequence<Dafny.ISequence<char>> _0_beaconParts = Seq_Compile.__default.Map<CompoundBeacon_Compile._IConstructorPart, Dafny.ISequence<char>>(((System.Func<CompoundBeacon_Compile._IConstructorPart, Dafny.ISequence<char>>)((_1_s) => {
        return (this).CPartToString(_1_s);
      })), p);
      if ((new BigInteger((_0_beaconParts).Count)).Sign == 0) {
        return Dafny.Sequence<char>.FromString("");
      } else {
        return StandardLibrary_Compile.__default.Join<char>(_0_beaconParts, Dafny.Sequence<char>.FromString(""));
      }
    }
    public Dafny.ISequence<char> CListToString(Dafny.ISequence<CompoundBeacon_Compile._IConstructor> p) {
      Dafny.ISequence<Dafny.ISequence<char>> _0_beaconParts = Seq_Compile.__default.Map<CompoundBeacon_Compile._IConstructor, Dafny.ISequence<char>>(((System.Func<CompoundBeacon_Compile._IConstructor, Dafny.ISequence<char>>)((_1_s) => {
        return (this).CPartsToString((_1_s).dtor_parts);
      })), p);
      return StandardLibrary_Compile.__default.Join<char>(_0_beaconParts, Dafny.Sequence<char>.FromString(", "));
    }
    public bool CanConstruct(Dafny.ISequence<CompoundBeacon_Compile._IConstructorPart> con, Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> inParts, bool matched)
    {
      _ICompoundBeacon _this = this;
    TAIL_CALL_START: ;
      if ((new BigInteger((inParts).Count)).Sign == 0) {
        return true;
      } else if ((new BigInteger((con).Count)).Sign == 0) {
        return false;
      } else if (object.Equals(((con).Select(BigInteger.Zero)).dtor_part, (inParts).Select(BigInteger.Zero))) {
        CompoundBeacon_Compile._ICompoundBeacon _in0 = _this;
        Dafny.ISequence<CompoundBeacon_Compile._IConstructorPart> _in1 = (con).Drop(BigInteger.One);
        Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> _in2 = (inParts).Drop(BigInteger.One);
        bool _in3 = true;
        _this = _in0;
        ;
        con = _in1;
        inParts = _in2;
        matched = _in3;
        goto TAIL_CALL_START;
      } else if ((!(((con).Select(BigInteger.Zero)).dtor_required)) || (!(matched))) {
        CompoundBeacon_Compile._ICompoundBeacon _in4 = _this;
        Dafny.ISequence<CompoundBeacon_Compile._IConstructorPart> _in5 = (con).Drop(BigInteger.One);
        Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> _in6 = inParts;
        bool _in7 = matched;
        _this = _in4;
        ;
        con = _in5;
        inParts = _in6;
        matched = _in7;
        goto TAIL_CALL_START;
      } else {
        return false;
      }
    }
    public bool IsValidPartOrder(Dafny.ISequence<CompoundBeacon_Compile._IConstructor> candidates, Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> inParts)
    {
      _ICompoundBeacon _this = this;
    TAIL_CALL_START: ;
      if ((new BigInteger((candidates).Count)).Sign == 0) {
        return false;
      } else if ((_this).CanConstruct(((candidates).Select(BigInteger.Zero)).dtor_parts, inParts, false)) {
        return true;
      } else {
        CompoundBeacon_Compile._ICompoundBeacon _in0 = _this;
        Dafny.ISequence<CompoundBeacon_Compile._IConstructor> _in1 = (candidates).Drop(BigInteger.One);
        Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> _in2 = inParts;
        _this = _in0;
        ;
        candidates = _in1;
        inParts = _in2;
        goto TAIL_CALL_START;
      }
    }
    public Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> ValidatePartOrder(Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> inParts, Dafny.ISequence<char> orig)
    {
      if ((this).IsValidPartOrder((this).dtor_construct, inParts)) {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(true);
      } else {
        Dafny.ISequence<char> _0_msg = Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Compound Beacon value '"), orig), Dafny.Sequence<char>.FromString("' cannot be constructed from any available constructor for ")), ((this).dtor_base).dtor_name), Dafny.Sequence<char>.FromString(" value parsed as ")), (this).PartsToString(inParts)), Dafny.Sequence<char>.FromString(" available constructors are ")), (this).CListToString((this).dtor_construct)), Dafny.Sequence<char>.FromString("."));
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(_0_msg));
      }
    }
    public Wrappers_Compile._IResult<CompoundBeacon_Compile._IBeaconPart, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> partFromPrefix(Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> p, Dafny.ISequence<char> @value)
    {
      _ICompoundBeacon _this = this;
    TAIL_CALL_START: ;
      if ((new BigInteger((p).Count)).Sign == 0) {
        return Wrappers_Compile.Result<CompoundBeacon_Compile._IBeaconPart, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Value "), @value), Dafny.Sequence<char>.FromString(" for beacon ")), ((_this).dtor_base).dtor_name), Dafny.Sequence<char>.FromString(" does not match the prefix of any configured part."))));
      } else if (Dafny.Sequence<char>.IsPrefixOf(((p).Select(BigInteger.Zero)).dtor_prefix, @value)) {
        return Wrappers_Compile.Result<CompoundBeacon_Compile._IBeaconPart, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success((p).Select(BigInteger.Zero));
      } else {
        CompoundBeacon_Compile._ICompoundBeacon _in0 = _this;
        Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> _in1 = (p).Drop(BigInteger.One);
        Dafny.ISequence<char> _in2 = @value;
        _this = _in0;
        ;
        p = _in1;
        @value = _in2;
        goto TAIL_CALL_START;
      }
    }
    public Wrappers_Compile._IResult<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> SkipSignedPieces(Dafny.ISequence<Dafny.ISequence<char>> pieces) {
      _ICompoundBeacon _this = this;
    TAIL_CALL_START: ;
      if ((new BigInteger((pieces).Count)).Sign == 0) {
        return Wrappers_Compile.Result<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(pieces);
      } else {
        Wrappers_Compile._IResult<CompoundBeacon_Compile._IBeaconPart, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = (_this).partFromPrefix((_this).dtor_parts, (pieces).Select(BigInteger.Zero));
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<Dafny.ISequence<char>>>();
        } else {
          CompoundBeacon_Compile._IBeaconPart _1_p = (_0_valueOrError0).Extract();
          if ((_1_p).is_Encrypted) {
            return Wrappers_Compile.Result<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(pieces);
          } else {
            CompoundBeacon_Compile._ICompoundBeacon _in0 = _this;
            Dafny.ISequence<Dafny.ISequence<char>> _in1 = (pieces).Drop(BigInteger.One);
            _this = _in0;
            ;
            pieces = _in1;
            goto TAIL_CALL_START;
          }
        }
      }
    }
    public Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> IsLessThanComparable(Dafny.ISequence<Dafny.ISequence<char>> pieces) {
      Wrappers_Compile._IResult<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = (this).SkipSignedPieces(pieces);
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<bool>();
      } else {
        Dafny.ISequence<Dafny.ISequence<char>> _1_rest = (_0_valueOrError0).Extract();
        if ((new BigInteger((_1_rest).Count)).Sign == 0) {
          return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(true);
        } else if ((new BigInteger((_1_rest).Count)) != (BigInteger.One)) {
          return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(false);
        } else {
          Wrappers_Compile._IResult<CompoundBeacon_Compile._IBeaconPart, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _2_valueOrError1 = (this).partFromPrefix((this).dtor_parts, (_1_rest).Select(BigInteger.Zero));
          if ((_2_valueOrError1).IsFailure()) {
            return (_2_valueOrError1).PropagateFailure<bool>();
          } else {
            CompoundBeacon_Compile._IBeaconPart _3_p = (_2_valueOrError1).Extract();
            return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(((_3_p).dtor_prefix).Equals((_1_rest).Select(BigInteger.Zero)));
          }
        }
      }
    }
    public Dafny.ISequence<Dafny.ISequence<char>> GetFields(Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> virtualFields) {
      return Seq_Compile.__default.Flatten<Dafny.ISequence<char>>(Seq_Compile.__default.Map<CompoundBeacon_Compile._IBeaconPart, Dafny.ISequence<Dafny.ISequence<char>>>(Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField>, Func<CompoundBeacon_Compile._IBeaconPart, Dafny.ISequence<Dafny.ISequence<char>>>>>((_0_virtualFields) => ((System.Func<CompoundBeacon_Compile._IBeaconPart, Dafny.ISequence<Dafny.ISequence<char>>>)((_1_p) => {
        return (_1_p).GetFields(_0_virtualFields);
      })))(virtualFields), (this).dtor_parts));
    }
    public Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> FindAndCalcPart(Dafny.ISequence<char> @value, DynamoDbEncryptionUtil_Compile._IMaybeKeyMap keys)
    {
      Wrappers_Compile._IResult<CompoundBeacon_Compile._IBeaconPart, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = (this).partFromPrefix((this).dtor_parts, @value);
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<char>>();
      } else {
        CompoundBeacon_Compile._IBeaconPart _1_part = (_0_valueOrError0).Extract();
        return (this).PartValueCalc((@value).Drop(new BigInteger(((_1_part).dtor_prefix).Count)), keys, _1_part);
      }
    }
    public Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> justPrefix(Dafny.ISequence<char> @value) {
      Wrappers_Compile._IResult<CompoundBeacon_Compile._IBeaconPart, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = (this).partFromPrefix((this).dtor_parts, @value);
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<bool>();
      } else {
        CompoundBeacon_Compile._IBeaconPart _1_part = (_0_valueOrError0).Extract();
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success((@value).Equals((_1_part).dtor_prefix));
      }
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetBeaconValue(software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue @value, DynamoDbEncryptionUtil_Compile._IMaybeKeyMap keys, bool forEquality)
    {
      if (!((@value).is_S)) {
        return Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("CompoundBeacon "), ((this).dtor_base).dtor_name), Dafny.Sequence<char>.FromString(" can only be queried as a string, not as ")), DynamoDbEncryptionUtil_Compile.__default.AttrTypeToStr(@value))));
      } else {
        Dafny.ISequence<Dafny.ISequence<char>> _0_parts = StandardLibrary_Compile.__default.Split<char>((@value).dtor_S, (this).dtor_split);
        Wrappers_Compile._IResult<Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _1_valueOrError0 = Seq_Compile.__default.MapWithResult<Dafny.ISequence<char>, CompoundBeacon_Compile._IBeaconPart, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(((System.Func<Dafny.ISequence<char>, Wrappers_Compile._IResult<CompoundBeacon_Compile._IBeaconPart, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>>)((_2_s) => {
          return (this).getPartFromPrefix(_2_s);
        })), _0_parts);
        if ((_1_valueOrError0).IsFailure()) {
          return (_1_valueOrError0).PropagateFailure<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>();
        } else {
          Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> _3_partsUsed = (_1_valueOrError0).Extract();
          Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _4_valueOrError1 = (this).ValidatePartOrder(_3_partsUsed, (@value).dtor_S);
          if ((_4_valueOrError1).IsFailure()) {
            return (_4_valueOrError1).PropagateFailure<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>();
          } else {
            bool _5___v1 = (_4_valueOrError1).Extract();
            Wrappers_Compile._IResult<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _6_valueOrError2 = Seq_Compile.__default.MapWithResult<Dafny.ISequence<char>, Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(Dafny.Helpers.Id<Func<DynamoDbEncryptionUtil_Compile._IMaybeKeyMap, Func<Dafny.ISequence<char>, Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>>>>((_7_keys) => ((System.Func<Dafny.ISequence<char>, Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>>)((_8_s) => {
              return (this).FindAndCalcPart(_8_s, _7_keys);
            })))(keys), _0_parts);
            if ((_6_valueOrError2).IsFailure()) {
              return (_6_valueOrError2).PropagateFailure<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>();
            } else {
              Dafny.ISequence<Dafny.ISequence<char>> _9_beaconParts = (_6_valueOrError2).Extract();
              Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _10_valueOrError3 = (this).justPrefix(Seq_Compile.__default.Last<Dafny.ISequence<char>>(_0_parts));
              if ((_10_valueOrError3).IsFailure()) {
                return (_10_valueOrError3).PropagateFailure<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>();
              } else {
                bool _11_lastIsPrefix = (_10_valueOrError3).Extract();
                if ((!(forEquality)) && (_11_lastIsPrefix)) {
                  Dafny.ISequence<char> _12_result = StandardLibrary_Compile.__default.Join<char>(Dafny.Sequence<Dafny.ISequence<char>>.Concat((_9_beaconParts).Take((new BigInteger((_0_parts).Count)) - (BigInteger.One)), Dafny.Sequence<Dafny.ISequence<char>>.FromElements(Seq_Compile.__default.Last<Dafny.ISequence<char>>(_0_parts))), Dafny.Sequence<char>.FromElements((this).dtor_split));
                  return Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_S(_12_result));
                } else {
                  Dafny.ISequence<char> _13_result = StandardLibrary_Compile.__default.Join<char>(_9_beaconParts, Dafny.Sequence<char>.FromElements((this).dtor_split));
                  return Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_S(_13_result));
                }
              }
            }
          }
        }
      }
    }
    public Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> TryConstructor(Dafny.ISequence<CompoundBeacon_Compile._IConstructorPart> consFields, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> vf, DynamoDbEncryptionUtil_Compile._IMaybeKeyMap keys, Dafny.ISequence<char> acc)
    {
      _ICompoundBeacon _this = this;
    TAIL_CALL_START: ;
      if ((new BigInteger((consFields).Count)).Sign == 0) {
        if ((new BigInteger((acc).Count)).Sign == 0) {
          return Wrappers_Compile.Result<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Internal Error : Empty beacon created.")));
        } else {
          return Wrappers_Compile.Result<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Wrappers_Compile.Option<Dafny.ISequence<char>>.create_Some(acc));
        }
      } else {
        CompoundBeacon_Compile._IBeaconPart _0_part = ((consFields).Select(BigInteger.Zero)).dtor_part;
        Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _1_valueOrError0 = (_0_part).getString(item, vf);
        if ((_1_valueOrError0).IsFailure()) {
          return (_1_valueOrError0).PropagateFailure<Wrappers_Compile._IOption<Dafny.ISequence<char>>>();
        } else {
          Wrappers_Compile._IOption<Dafny.ISequence<char>> _2_strValue = (_1_valueOrError0).Extract();
          if ((_2_strValue).is_Some) {
            Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _3_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(!((_2_strValue).dtor_value).Contains((_this).dtor_split), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Part "), (_0_part).getName()), Dafny.Sequence<char>.FromString(" for beacon ")), ((_this).dtor_base).dtor_name), Dafny.Sequence<char>.FromString(" has value '")), (_2_strValue).dtor_value), Dafny.Sequence<char>.FromString("' which contains the split character ")), Dafny.Sequence<char>.FromElements((_this).dtor_split)), Dafny.Sequence<char>.FromString("'."))));
            if ((_3_valueOrError1).IsFailure()) {
              return (_3_valueOrError1).PropagateFailure<Wrappers_Compile._IOption<Dafny.ISequence<char>>>();
            } else {
              Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _4_valueOrError2 = (((keys).is_DontUseKeys) ? (Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Dafny.Sequence<char>.Concat((_0_part).dtor_prefix, (_2_strValue).dtor_value))) : ((_this).PartValueCalc((_2_strValue).dtor_value, keys, _0_part)));
              if ((_4_valueOrError2).IsFailure()) {
                return (_4_valueOrError2).PropagateFailure<Wrappers_Compile._IOption<Dafny.ISequence<char>>>();
              } else {
                Dafny.ISequence<char> _5_val = (_4_valueOrError2).Extract();
                if ((new BigInteger((acc).Count)).Sign == 0) {
                  CompoundBeacon_Compile._ICompoundBeacon _in0 = _this;
                  Dafny.ISequence<CompoundBeacon_Compile._IConstructorPart> _in1 = (consFields).Drop(BigInteger.One);
                  Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in2 = item;
                  Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> _in3 = vf;
                  DynamoDbEncryptionUtil_Compile._IMaybeKeyMap _in4 = keys;
                  Dafny.ISequence<char> _in5 = _5_val;
                  _this = _in0;
                  ;
                  consFields = _in1;
                  item = _in2;
                  vf = _in3;
                  keys = _in4;
                  acc = _in5;
                  goto TAIL_CALL_START;
                } else {
                  CompoundBeacon_Compile._ICompoundBeacon _in6 = _this;
                  Dafny.ISequence<CompoundBeacon_Compile._IConstructorPart> _in7 = (consFields).Drop(BigInteger.One);
                  Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in8 = item;
                  Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> _in9 = vf;
                  DynamoDbEncryptionUtil_Compile._IMaybeKeyMap _in10 = keys;
                  Dafny.ISequence<char> _in11 = Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(acc, Dafny.Sequence<char>.FromElements((_this).dtor_split)), _5_val);
                  _this = _in6;
                  ;
                  consFields = _in7;
                  item = _in8;
                  vf = _in9;
                  keys = _in10;
                  acc = _in11;
                  goto TAIL_CALL_START;
                }
              }
            }
          } else if (((consFields).Select(BigInteger.Zero)).dtor_required) {
            return Wrappers_Compile.Result<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None());
          } else {
            CompoundBeacon_Compile._ICompoundBeacon _in12 = _this;
            Dafny.ISequence<CompoundBeacon_Compile._IConstructorPart> _in13 = (consFields).Drop(BigInteger.One);
            Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in14 = item;
            Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> _in15 = vf;
            DynamoDbEncryptionUtil_Compile._IMaybeKeyMap _in16 = keys;
            Dafny.ISequence<char> _in17 = acc;
            _this = _in12;
            ;
            consFields = _in13;
            item = _in14;
            vf = _in15;
            keys = _in16;
            acc = _in17;
            goto TAIL_CALL_START;
          }
        }
      }
    }
    public Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> TryConstructors(Dafny.ISequence<CompoundBeacon_Compile._IConstructor> construct, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> vf, DynamoDbEncryptionUtil_Compile._IMaybeKeyMap keys)
    {
      _ICompoundBeacon _this = this;
    TAIL_CALL_START: ;
      if ((new BigInteger((construct).Count)).Sign == 0) {
        return Wrappers_Compile.Result<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None());
      } else {
        Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = (_this).TryConstructor(((construct).Select(BigInteger.Zero)).dtor_parts, item, vf, keys, Dafny.Sequence<char>.FromString(""));
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<Wrappers_Compile._IOption<Dafny.ISequence<char>>>();
        } else {
          Wrappers_Compile._IOption<Dafny.ISequence<char>> _1_x = (_0_valueOrError0).Extract();
          if ((_1_x).is_Some) {
            return Wrappers_Compile.Result<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(_1_x);
          } else {
            CompoundBeacon_Compile._ICompoundBeacon _in0 = _this;
            Dafny.ISequence<CompoundBeacon_Compile._IConstructor> _in1 = (construct).Drop(BigInteger.One);
            Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in2 = item;
            Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> _in3 = vf;
            DynamoDbEncryptionUtil_Compile._IMaybeKeyMap _in4 = keys;
            _this = _in0;
            ;
            construct = _in1;
            item = _in2;
            vf = _in3;
            keys = _in4;
            goto TAIL_CALL_START;
          }
        }
      }
    }
    public Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> hash(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> vf, DynamoDbEncryptionUtil_Compile._IMaybeKeyMap keys)
    {
      return (this).TryConstructors((this).dtor_construct, item, vf, keys);
    }
    public Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> getNaked(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> vf)
    {
      return (this).TryConstructors((this).dtor_construct, item, vf, DynamoDbEncryptionUtil_Compile.MaybeKeyMap.create_DontUseKeys());
    }
    public Wrappers_Compile._IResult<CompoundBeacon_Compile._IBeaconPart, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> findPart(Dafny.ISequence<char> val) {
      Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> _0_thePart = Seq_Compile.__default.Filter<CompoundBeacon_Compile._IBeaconPart>(Dafny.Helpers.Id<Func<Dafny.ISequence<char>, Func<CompoundBeacon_Compile._IBeaconPart, bool>>>((_1_val) => ((System.Func<CompoundBeacon_Compile._IBeaconPart, bool>)((_2_x) => {
        return Dafny.Sequence<char>.IsPrefixOf((_2_x).dtor_prefix, _1_val);
      })))(val), (this).dtor_parts);
      if ((new BigInteger((_0_thePart).Count)).Sign == 0) {
        return Wrappers_Compile.Result<CompoundBeacon_Compile._IBeaconPart, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("No part found in beacon "), ((this).dtor_base).dtor_name), Dafny.Sequence<char>.FromString(" match prefix ")), val)));
      } else if ((new BigInteger((_0_thePart).Count)) > (BigInteger.One)) {
        return Wrappers_Compile.Result<CompoundBeacon_Compile._IBeaconPart, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Internal error. Multiple parts for beacon "), ((this).dtor_base).dtor_name), Dafny.Sequence<char>.FromString(" matched prefix of ")), val)));
      } else {
        return Wrappers_Compile.Result<CompoundBeacon_Compile._IBeaconPart, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success((_0_thePart).Select(BigInteger.Zero));
      }
    }
    public Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> getPart(Dafny.ISequence<char> val, Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>> keys)
    {
      Dafny.ISequence<Dafny.ISequence<char>> _0_pieces = StandardLibrary_Compile.__default.Split<char>(val, (this).dtor_split);
      return (this).calcParts(_0_pieces, keys, Dafny.Sequence<char>.FromElements());
    }
    public Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> calcPart(Dafny.ISequence<char> piece, Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>> keys)
    {
      Wrappers_Compile._IResult<CompoundBeacon_Compile._IBeaconPart, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = (this).findPart(piece);
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<char>>();
      } else {
        CompoundBeacon_Compile._IBeaconPart _1_thePart = (_0_valueOrError0).Extract();
        return (this).PartValueCalc(piece, DynamoDbEncryptionUtil_Compile.MaybeKeyMap.create_Keys(keys), _1_thePart);
      }
    }
    public Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> calcParts(Dafny.ISequence<Dafny.ISequence<char>> pieces, Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>> keys, Dafny.ISequence<char> acc)
    {
      _ICompoundBeacon _this = this;
    TAIL_CALL_START: ;
      if ((new BigInteger((pieces).Count)).Sign == 0) {
        return Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(acc);
      } else {
        Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = (_this).calcPart((pieces).Select(BigInteger.Zero), keys);
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<char>>();
        } else {
          Dafny.ISequence<char> _1_theBeacon = (_0_valueOrError0).Extract();
          if ((new BigInteger((acc).Count)).Sign == 0) {
            CompoundBeacon_Compile._ICompoundBeacon _in0 = _this;
            Dafny.ISequence<Dafny.ISequence<char>> _in1 = (pieces).Drop(BigInteger.One);
            Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>> _in2 = keys;
            Dafny.ISequence<char> _in3 = _1_theBeacon;
            _this = _in0;
            ;
            pieces = _in1;
            keys = _in2;
            acc = _in3;
            goto TAIL_CALL_START;
          } else {
            CompoundBeacon_Compile._ICompoundBeacon _in4 = _this;
            Dafny.ISequence<Dafny.ISequence<char>> _in5 = (pieces).Drop(BigInteger.One);
            Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>> _in6 = keys;
            Dafny.ISequence<char> _in7 = Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(acc, Dafny.Sequence<char>.FromElements((_this).dtor_split)), _1_theBeacon);
            _this = _in4;
            ;
            pieces = _in5;
            keys = _in6;
            acc = _in7;
            goto TAIL_CALL_START;
          }
        }
      }
    }
    public static bool OkPrefixStringPair(Dafny.ISequence<char> x, Dafny.ISequence<char> y)
    {
      return (!(Dafny.Sequence<char>.IsPrefixOf(x, y))) && (!(Dafny.Sequence<char>.IsPrefixOf(y, x)));
    }
    public bool OkPrefixPair(BigInteger pos1, BigInteger pos2)
    {
      return ((pos1) == (pos2)) || (CompoundBeacon_Compile.CompoundBeacon.OkPrefixStringPair((((this).dtor_parts).Select(pos1)).dtor_prefix, (((this).dtor_parts).Select(pos2)).dtor_prefix));
    }
    public Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> CheckOnePrefixPart(BigInteger pos1, BigInteger pos2)
    {
      if (!((this).OkPrefixPair(pos1, pos2))) {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Compound beacon "), ((this).dtor_base).dtor_name), Dafny.Sequence<char>.FromString(" defines part ")), (((this).dtor_parts).Select(pos1)).getName()), Dafny.Sequence<char>.FromString(" with prefix ")), (((this).dtor_parts).Select(pos1)).dtor_prefix), Dafny.Sequence<char>.FromString(" which is incompatible with part ")), (((this).dtor_parts).Select(pos2)).getName()), Dafny.Sequence<char>.FromString(" which has a prefix of ")), (((this).dtor_parts).Select(pos2)).dtor_prefix), Dafny.Sequence<char>.FromString("."))));
      } else {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(true);
      }
    }
    public Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> CheckOnePrefix(BigInteger pos) {
      Dafny.ISequence<BigInteger> _0_partNumbers = ((System.Func<Dafny.ISequence<BigInteger>>) (() => {
        BigInteger dim1 = new BigInteger(((this).dtor_parts).Count);
        var arr1 = new BigInteger[Dafny.Helpers.ToIntChecked(dim1, "array size exceeds memory limit")];
        for (int i1 = 0; i1 < dim1; i1++) {
          var _1_i = (BigInteger) i1;
          arr1[(int)(_1_i)] = _1_i;
        }
        return Dafny.Sequence<BigInteger>.FromArray(arr1);
      }))();
      Wrappers_Compile._IResult<Dafny.ISequence<bool>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _2_valueOrError0 = Seq_Compile.__default.MapWithResult<BigInteger, bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(Dafny.Helpers.Id<Func<BigInteger, Func<BigInteger, Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>>>>((_3_pos) => ((System.Func<BigInteger, Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>>)((_4_p) => {
        return (this).CheckOnePrefixPart(_3_pos, _4_p);
      })))(pos), ((System.Func<Dafny.ISequence<BigInteger>>) (() => {
        BigInteger dim2 = new BigInteger(((this).dtor_parts).Count);
        var arr2 = new BigInteger[Dafny.Helpers.ToIntChecked(dim2, "array size exceeds memory limit")];
        for (int i2 = 0; i2 < dim2; i2++) {
          var _5_i = (BigInteger) i2;
          arr2[(int)(_5_i)] = _5_i;
        }
        return Dafny.Sequence<BigInteger>.FromArray(arr2);
      }))());
      if ((_2_valueOrError0).IsFailure()) {
        return (_2_valueOrError0).PropagateFailure<bool>();
      } else {
        Dafny.ISequence<bool> _6___v2 = (_2_valueOrError0).Extract();
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(true);
      }
    }
    public Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> ValidPrefixSetResultPos(BigInteger index) {
      _ICompoundBeacon _this = this;
    TAIL_CALL_START: ;
      if ((new BigInteger(((_this).dtor_parts).Count)) <= (index)) {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(true);
      } else {
        Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = (_this).CheckOnePrefix(index);
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<bool>();
        } else {
          bool _1___v3 = (_0_valueOrError0).Extract();
          CompoundBeacon_Compile._ICompoundBeacon _in0 = _this;
          BigInteger _in1 = (index) + (BigInteger.One);
          _this = _in0;
          ;
          index = _in1;
          goto TAIL_CALL_START;
        }
      }
    }
    public Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> ValidPrefixSetResult() {
      Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = (this).ValidPrefixSetResultPos(BigInteger.Zero);
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<bool>();
      } else {
        bool _1___v4 = (_0_valueOrError0).Extract();
        if (Dafny.Helpers.Quantifier<BigInteger>(Dafny.Helpers.IntegerRange(BigInteger.Zero, new BigInteger(((this).dtor_parts).Count)), true, (((_forall_var_0) => {
          BigInteger _2_x = (BigInteger)_forall_var_0;
          if (_System.nat._Is(_2_x)) {
            return Dafny.Helpers.Quantifier<BigInteger>(Dafny.Helpers.IntegerRange(BigInteger.Zero, new BigInteger(((this).dtor_parts).Count)), true, (((_forall_var_1) => {
              BigInteger _3_y = (BigInteger)_forall_var_1;
              if (_System.nat._Is(_3_y)) {
                return !((((_2_x).Sign != -1) && ((_2_x) < (new BigInteger(((this).dtor_parts).Count)))) && (((_2_x) < (_3_y)) && ((_3_y) < (new BigInteger(((this).dtor_parts).Count))))) || ((this).OkPrefixPair(_2_x, _3_y));
              } else {
                return true;
              }
            })));
          } else {
            return true;
          }
        })))) {
          return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(true);
        } else {
          return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Internal Error")));
        }
      }
    }
    public Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> PartValueCalc(Dafny.ISequence<char> data, DynamoDbEncryptionUtil_Compile._IMaybeKeyMap keys, CompoundBeacon_Compile._IBeaconPart part)
    {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(!(data).Contains((this).dtor_split), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Value '"), data), Dafny.Sequence<char>.FromString("' for beacon part ")), (part).getName()), Dafny.Sequence<char>.FromString(" contains the split character '")), Dafny.Sequence<char>.FromElements((this).dtor_split)), Dafny.Sequence<char>.FromString("'."))));
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<char>>();
      } else {
        CompoundBeacon_Compile._IBeaconPart _source0 = part;
        {
          if (_source0.is_Encrypted) {
            Dafny.ISequence<char> _1_p = _source0.dtor_prefix;
            BaseBeacon_Compile._IStandardBeacon _2_b = _source0.dtor_beacon;
            Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _3_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>((keys).is_Keys, DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Need KeyId for beacon "), ((_2_b).dtor_base).dtor_name), Dafny.Sequence<char>.FromString(" but no KeyId found in query."))));
            if ((_3_valueOrError1).IsFailure()) {
              return (_3_valueOrError1).PropagateFailure<Dafny.ISequence<char>>();
            } else {
              Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _4_valueOrError2 = (_2_b).hashStr(data, (keys).dtor_value);
              if ((_4_valueOrError2).IsFailure()) {
                return (_4_valueOrError2).PropagateFailure<Dafny.ISequence<char>>();
              } else {
                Dafny.ISequence<char> _5_hash = (_4_valueOrError2).Extract();
                return Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Dafny.Sequence<char>.Concat((part).dtor_prefix, _5_hash));
              }
            }
          }
        }
        {
          CompoundBeacon_Compile._IBeaconPart _6_Signed = _source0;
          return Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Dafny.Sequence<char>.Concat((part).dtor_prefix, data));
        }
      }
    }
  }
} // end of namespace CompoundBeacon_Compile
namespace SearchableEncryptionInfo_Compile {

  public partial class __default {
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetAllKeys(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient client, Dafny.ISequence<Dafny.ISequence<char>> stdNames, Dafny.ISequence<byte> key)
    {
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<byte>>.Empty);
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<byte>>.Empty);
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
      _out0 = SearchableEncryptionInfo_Compile.__default.GetHmacKeys(client, stdNames, stdNames, key, Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<byte>>.FromElements());
      _0_valueOrError0 = _out0;
      if ((_0_valueOrError0).IsFailure()) {
        output = (_0_valueOrError0).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>>();
        return output;
      }
      Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>> _1_newKeys;
      _1_newKeys = (_0_valueOrError0).Extract();
      output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(_1_newKeys);
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetHmacKeys(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient client, Dafny.ISequence<Dafny.ISequence<char>> allKeys, Dafny.ISequence<Dafny.ISequence<char>> keysLeft, Dafny.ISequence<byte> key, Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>> acc)
    {
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<byte>>.Empty);
      if ((new BigInteger((keysLeft).Count)).Sign == 0) {
        output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(acc);
        return output;
      } else {
        Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
        Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
        _out0 = SearchableEncryptionInfo_Compile.__default.GetBeaconKey(client, key, (keysLeft).Select(BigInteger.Zero));
        _0_valueOrError0 = _out0;
        if ((_0_valueOrError0).IsFailure()) {
          output = (_0_valueOrError0).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>>();
          return output;
        }
        Dafny.ISequence<byte> _1_newKey;
        _1_newKey = (_0_valueOrError0).Extract();
        Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out1;
        _out1 = SearchableEncryptionInfo_Compile.__default.GetHmacKeys(client, allKeys, (keysLeft).Drop(BigInteger.One), key, Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<byte>>.Update(acc, (keysLeft).Select(BigInteger.Zero), _1_newKey));
        output = _out1;
      }
      return output;
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetBeaconKey(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient client, Dafny.ISequence<byte> key, Dafny.ISequence<char> name)
    {
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(UTF8.ValidUTF8Bytes.Default());
      _0_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(UTF8.__default.Encode(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("AWS_DBE_SCAN_BEACON"), name)), ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>)((_1_e) => {
        return DynamoDbEncryptionUtil_Compile.__default.E(_1_e);
      })));
      if ((_0_valueOrError0).IsFailure()) {
        output = (_0_valueOrError0).PropagateFailure<Dafny.ISequence<byte>>();
        return output;
      }
      Dafny.ISequence<byte> _2_info;
      _2_info = (_0_valueOrError0).Extract();
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _3_keyR;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError> _out0;
      _out0 = (client).Hkdf(software.amazon.cryptography.primitives.internaldafny.types.HkdfInput.create(software.amazon.cryptography.primitives.internaldafny.types.DigestAlgorithm.create_SHA__512(), Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None(), key, _2_info, 64));
      _3_keyR = _out0;
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _4_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Sequence<byte>.Empty);
      _4_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(_3_keyR, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>)((_5_e) => {
        return software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Error.create_AwsCryptographyPrimitives(_5_e);
      })));
      if ((_4_valueOrError1).IsFailure()) {
        output = (_4_valueOrError1).PropagateFailure<Dafny.ISequence<byte>>();
        return output;
      }
      Dafny.ISequence<byte> _6_newKey;
      _6_newKey = (_4_valueOrError1).Extract();
      output = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(_6_newKey);
      return output;
      return output;
    }
    public static SearchableEncryptionInfo_Compile._ISearchInfo MakeSearchInfo(SearchableEncryptionInfo_Compile._IBeaconVersion version) {
      return SearchableEncryptionInfo_Compile.SearchInfo.create(Dafny.Sequence<SearchableEncryptionInfo_Compile._IBeaconVersion>.FromElements(version), BigInteger.Zero);
    }
    public static bool IsPartOnly(SearchableEncryptionInfo_Compile._IBeacon b) {
      return ((b).is_Standard) && (((b).dtor_std).dtor_partOnly);
    }
    public static bool IsBeaconOfType(SearchableEncryptionInfo_Compile._IBeacon b, SearchableEncryptionInfo_Compile._IBeaconType t)
    {
      SearchableEncryptionInfo_Compile._IBeaconType _source0 = t;
      {
        if (_source0.is_AnyBeacon) {
          return true;
        }
      }
      {
        if (_source0.is_SignedBeacon) {
          return !((b).isEncrypted());
        }
      }
      {
        return (b).isEncrypted();
      }
    }
    public static Wrappers_Compile._IResult<SearchableEncryptionInfo_Compile._IBeaconVersion, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> MakeBeaconVersion(byte version, SearchableEncryptionInfo_Compile._IKeySource keySource, Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon> beacons, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> virtualFields, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> actions)
    {
      Dafny.ISequence<Dafny.ISequence<char>> _0_beaconNames = SortedSets.__default.SetToOrderedSequence2<char>((beacons).Keys, DynamoDbEncryptionUtil_Compile.__default.CharLess);
      Dafny.ISequence<Dafny.ISequence<char>> _1_stdKeys = Seq_Compile.__default.Filter<Dafny.ISequence<char>>(Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon>, Func<Dafny.ISequence<char>, bool>>>((_2_beacons) => ((System.Func<Dafny.ISequence<char>, bool>)((_3_k) => {
        return ((_2_beacons).Contains(_3_k)) && ((Dafny.Map<Dafny.ISequence<char>, SearchableEncryptionInfo_Compile._IBeacon>.Select(_2_beacons,_3_k)).is_Standard);
      })))(beacons), _0_beaconNames);
      Dafny.ISet<Dafny.ISequence<char>> _4_encrypted = Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>, Dafny.ISet<Dafny.ISequence<char>>>>((_5_actions) => ((System.Func<Dafny.ISet<Dafny.ISequence<char>>>)(() => {
        var _coll0 = new System.Collections.Generic.List<Dafny.ISequence<char>>();
        foreach (Dafny.ISequence<char> _compr_0 in (_5_actions).Keys.Elements) {
          Dafny.ISequence<char> _6_k = (Dafny.ISequence<char>)_compr_0;
          if (((_5_actions).Contains(_6_k)) && (object.Equals(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Select(_5_actions,_6_k), software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_ENCRYPT__AND__SIGN()))) {
            _coll0.Add(_6_k);
          }
        }
        return Dafny.Set<Dafny.ISequence<char>>.FromCollection(_coll0);
      }))())(actions);
      SearchableEncryptionInfo_Compile._IBeaconVersion _7_bv = SearchableEncryptionInfo_Compile.BeaconVersion.create(version, keySource, virtualFields, beacons, _0_beaconNames, _1_stdKeys, _4_encrypted);
      return Wrappers_Compile.Result<SearchableEncryptionInfo_Compile._IBeaconVersion, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(_7_bv);
    }
  }

  public partial class VersionNumber {
    public static System.Collections.Generic.IEnumerable<byte> IntegerRange(BigInteger lo, BigInteger hi) {
      for (var j = lo; j < hi; j++) { yield return (byte)j; }
    }
    public static readonly byte Witness = (byte)(BigInteger.One);
    private static readonly Dafny.TypeDescriptor<byte> _TYPE = new Dafny.TypeDescriptor<byte>(SearchableEncryptionInfo_Compile.VersionNumber.Witness);
    public static Dafny.TypeDescriptor<byte> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(byte __source) {
      BigInteger _8_x = new BigInteger(__source);
      return (_8_x) == (BigInteger.One);
    }
  }

  public partial class ValidSearchInfo {
    private static readonly Dafny.TypeDescriptor<SearchableEncryptionInfo_Compile._ISearchInfo> _TYPE = new Dafny.TypeDescriptor<SearchableEncryptionInfo_Compile._ISearchInfo>(SearchableEncryptionInfo_Compile.SearchInfo.Default());
    public static Dafny.TypeDescriptor<SearchableEncryptionInfo_Compile._ISearchInfo> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public partial class ValidStore {
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient>(default(software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient));
    public static Dafny.TypeDescriptor<software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public interface _IKeyLocation {
    bool is_LiteralLoc { get; }
    bool is_SingleLoc { get; }
    bool is_MultiLoc { get; }
    Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>> dtor_keys { get; }
    Dafny.ISequence<char> dtor_keyId { get; }
    Dafny.ISequence<char> dtor_keyName { get; }
    bool dtor_deleteKey { get; }
    _IKeyLocation DowncastClone();
  }
  public abstract class KeyLocation : _IKeyLocation {
    public KeyLocation() {
    }
    private static readonly SearchableEncryptionInfo_Compile._IKeyLocation theDefault = create_LiteralLoc(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<byte>>.Empty);
    public static SearchableEncryptionInfo_Compile._IKeyLocation Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<SearchableEncryptionInfo_Compile._IKeyLocation> _TYPE = new Dafny.TypeDescriptor<SearchableEncryptionInfo_Compile._IKeyLocation>(SearchableEncryptionInfo_Compile.KeyLocation.Default());
    public static Dafny.TypeDescriptor<SearchableEncryptionInfo_Compile._IKeyLocation> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IKeyLocation create_LiteralLoc(Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>> keys) {
      return new KeyLocation_LiteralLoc(keys);
    }
    public static _IKeyLocation create_SingleLoc(Dafny.ISequence<char> keyId) {
      return new KeyLocation_SingleLoc(keyId);
    }
    public static _IKeyLocation create_MultiLoc(Dafny.ISequence<char> keyName, bool deleteKey) {
      return new KeyLocation_MultiLoc(keyName, deleteKey);
    }
    public bool is_LiteralLoc { get { return this is KeyLocation_LiteralLoc; } }
    public bool is_SingleLoc { get { return this is KeyLocation_SingleLoc; } }
    public bool is_MultiLoc { get { return this is KeyLocation_MultiLoc; } }
    public Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>> dtor_keys {
      get {
        var d = this;
        return ((KeyLocation_LiteralLoc)d)._keys;
      }
    }
    public Dafny.ISequence<char> dtor_keyId {
      get {
        var d = this;
        return ((KeyLocation_SingleLoc)d)._keyId;
      }
    }
    public Dafny.ISequence<char> dtor_keyName {
      get {
        var d = this;
        return ((KeyLocation_MultiLoc)d)._keyName;
      }
    }
    public bool dtor_deleteKey {
      get {
        var d = this;
        return ((KeyLocation_MultiLoc)d)._deleteKey;
      }
    }
    public abstract _IKeyLocation DowncastClone();
  }
  public class KeyLocation_LiteralLoc : KeyLocation {
    public readonly Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>> _keys;
    public KeyLocation_LiteralLoc(Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>> keys) : base() {
      this._keys = keys;
    }
    public override _IKeyLocation DowncastClone() {
      if (this is _IKeyLocation dt) { return dt; }
      return new KeyLocation_LiteralLoc(_keys);
    }
    public override bool Equals(object other) {
      var oth = other as SearchableEncryptionInfo_Compile.KeyLocation_LiteralLoc;
      return oth != null && object.Equals(this._keys, oth._keys);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._keys));
      return (int) hash;
    }
    public override string ToString() {
      string s = "SearchableEncryptionInfo.KeyLocation.LiteralLoc";
      s += "(";
      s += Dafny.Helpers.ToString(this._keys);
      s += ")";
      return s;
    }
  }
  public class KeyLocation_SingleLoc : KeyLocation {
    public readonly Dafny.ISequence<char> _keyId;
    public KeyLocation_SingleLoc(Dafny.ISequence<char> keyId) : base() {
      this._keyId = keyId;
    }
    public override _IKeyLocation DowncastClone() {
      if (this is _IKeyLocation dt) { return dt; }
      return new KeyLocation_SingleLoc(_keyId);
    }
    public override bool Equals(object other) {
      var oth = other as SearchableEncryptionInfo_Compile.KeyLocation_SingleLoc;
      return oth != null && object.Equals(this._keyId, oth._keyId);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._keyId));
      return (int) hash;
    }
    public override string ToString() {
      string s = "SearchableEncryptionInfo.KeyLocation.SingleLoc";
      s += "(";
      s += Dafny.Helpers.ToString(this._keyId);
      s += ")";
      return s;
    }
  }
  public class KeyLocation_MultiLoc : KeyLocation {
    public readonly Dafny.ISequence<char> _keyName;
    public readonly bool _deleteKey;
    public KeyLocation_MultiLoc(Dafny.ISequence<char> keyName, bool deleteKey) : base() {
      this._keyName = keyName;
      this._deleteKey = deleteKey;
    }
    public override _IKeyLocation DowncastClone() {
      if (this is _IKeyLocation dt) { return dt; }
      return new KeyLocation_MultiLoc(_keyName, _deleteKey);
    }
    public override bool Equals(object other) {
      var oth = other as SearchableEncryptionInfo_Compile.KeyLocation_MultiLoc;
      return oth != null && object.Equals(this._keyName, oth._keyName) && this._deleteKey == oth._deleteKey;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._keyName));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._deleteKey));
      return (int) hash;
    }
    public override string ToString() {
      string s = "SearchableEncryptionInfo.KeyLocation.MultiLoc";
      s += "(";
      s += Dafny.Helpers.ToString(this._keyName);
      s += ", ";
      s += Dafny.Helpers.ToString(this._deleteKey);
      s += ")";
      return s;
    }
  }

  public interface _IKeySource {
    bool is_KeySource { get; }
    software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient dtor_client { get; }
    software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient dtor_store { get; }
    SearchableEncryptionInfo_Compile._IKeyLocation dtor_keyLoc { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache dtor_cache { get; }
    uint dtor_cacheTTL { get; }
    _IKeySource DowncastClone();
    Wrappers_Compile._IResult<DynamoDbEncryptionUtil_Compile._IMaybeKeyMap, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> getKeyMap(Dafny.ISequence<Dafny.ISequence<char>> stdNames, DynamoDbEncryptionUtil_Compile._IMaybeKeyId keyId);
    Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> getKeysLiteral();
    Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> getKeysCache(Dafny.ISequence<Dafny.ISequence<char>> stdNames, Dafny.ISequence<char> keyId);
    Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> getAllKeys(Dafny.ISequence<Dafny.ISequence<char>> stdNames, Dafny.ISequence<byte> key);
  }
  public class KeySource : _IKeySource {
    public readonly software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient _client;
    public readonly software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient _store;
    public readonly SearchableEncryptionInfo_Compile._IKeyLocation _keyLoc;
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache _cache;
    public readonly uint _cacheTTL;
    public KeySource(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient client, software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient store, SearchableEncryptionInfo_Compile._IKeyLocation keyLoc, software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache cache, uint cacheTTL) {
      this._client = client;
      this._store = store;
      this._keyLoc = keyLoc;
      this._cache = cache;
      this._cacheTTL = cacheTTL;
    }
    public _IKeySource DowncastClone() {
      if (this is _IKeySource dt) { return dt; }
      return new KeySource(_client, _store, _keyLoc, _cache, _cacheTTL);
    }
    public override bool Equals(object other) {
      var oth = other as SearchableEncryptionInfo_Compile.KeySource;
      return oth != null && this._client == oth._client && this._store == oth._store && object.Equals(this._keyLoc, oth._keyLoc) && this._cache == oth._cache && this._cacheTTL == oth._cacheTTL;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._client));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._store));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._keyLoc));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._cache));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._cacheTTL));
      return (int) hash;
    }
    public override string ToString() {
      string s = "SearchableEncryptionInfo.KeySource.KeySource";
      s += "(";
      s += Dafny.Helpers.ToString(this._client);
      s += ", ";
      s += Dafny.Helpers.ToString(this._store);
      s += ", ";
      s += Dafny.Helpers.ToString(this._keyLoc);
      s += ", ";
      s += Dafny.Helpers.ToString(this._cache);
      s += ", ";
      s += Dafny.Helpers.ToString(this._cacheTTL);
      s += ")";
      return s;
    }
    private static readonly SearchableEncryptionInfo_Compile._IKeySource theDefault = create(default(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient), default(software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient), SearchableEncryptionInfo_Compile.KeyLocation.Default(), default(software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache), 0);
    public static SearchableEncryptionInfo_Compile._IKeySource Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<SearchableEncryptionInfo_Compile._IKeySource> _TYPE = new Dafny.TypeDescriptor<SearchableEncryptionInfo_Compile._IKeySource>(SearchableEncryptionInfo_Compile.KeySource.Default());
    public static Dafny.TypeDescriptor<SearchableEncryptionInfo_Compile._IKeySource> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IKeySource create(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient client, software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient store, SearchableEncryptionInfo_Compile._IKeyLocation keyLoc, software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache cache, uint cacheTTL) {
      return new KeySource(client, store, keyLoc, cache, cacheTTL);
    }
    public static _IKeySource create_KeySource(software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient client, software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient store, SearchableEncryptionInfo_Compile._IKeyLocation keyLoc, software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache cache, uint cacheTTL) {
      return create(client, store, keyLoc, cache, cacheTTL);
    }
    public bool is_KeySource { get { return true; } }
    public software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient dtor_client {
      get {
        return this._client;
      }
    }
    public software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient dtor_store {
      get {
        return this._store;
      }
    }
    public SearchableEncryptionInfo_Compile._IKeyLocation dtor_keyLoc {
      get {
        return this._keyLoc;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache dtor_cache {
      get {
        return this._cache;
      }
    }
    public uint dtor_cacheTTL {
      get {
        return this._cacheTTL;
      }
    }
    public Wrappers_Compile._IResult<DynamoDbEncryptionUtil_Compile._IMaybeKeyMap, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> getKeyMap(Dafny.ISequence<Dafny.ISequence<char>> stdNames, DynamoDbEncryptionUtil_Compile._IMaybeKeyId keyId)
    {
      Wrappers_Compile._IResult<DynamoDbEncryptionUtil_Compile._IMaybeKeyMap, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = Wrappers_Compile.Result<DynamoDbEncryptionUtil_Compile._IMaybeKeyMap, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(DynamoDbEncryptionUtil_Compile.MaybeKeyMap.Default());
      if (((this).dtor_keyLoc).is_SingleLoc) {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default();
        _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>((keyId).is_DontUseKeyId, DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("KeyID should not be supplied with a SingleKeyStore")));
        if ((_0_valueOrError0).IsFailure()) {
          output = (_0_valueOrError0).PropagateFailure<DynamoDbEncryptionUtil_Compile._IMaybeKeyMap>();
          return output;
        }
        Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _1_valueOrError1 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<byte>>.Empty);
        Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
        _out0 = (this).getKeysCache(stdNames, ((this).dtor_keyLoc).dtor_keyId);
        _1_valueOrError1 = _out0;
        if ((_1_valueOrError1).IsFailure()) {
          output = (_1_valueOrError1).PropagateFailure<DynamoDbEncryptionUtil_Compile._IMaybeKeyMap>();
          return output;
        }
        Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>> _2_theMap;
        _2_theMap = (_1_valueOrError1).Extract();
        output = Wrappers_Compile.Result<DynamoDbEncryptionUtil_Compile._IMaybeKeyMap, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(DynamoDbEncryptionUtil_Compile.MaybeKeyMap.create_Keys(_2_theMap));
        return output;
      } else if (((this).dtor_keyLoc).is_LiteralLoc) {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _3_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default();
        _3_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>((keyId).is_DontUseKeyId, DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("KeyID should not be supplied with a LiteralKeyStore")));
        if ((_3_valueOrError2).IsFailure()) {
          output = (_3_valueOrError2).PropagateFailure<DynamoDbEncryptionUtil_Compile._IMaybeKeyMap>();
          return output;
        }
        Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _4_valueOrError3 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<byte>>.Empty);
        Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out1;
        _out1 = (this).getKeysLiteral();
        _4_valueOrError3 = _out1;
        if ((_4_valueOrError3).IsFailure()) {
          output = (_4_valueOrError3).PropagateFailure<DynamoDbEncryptionUtil_Compile._IMaybeKeyMap>();
          return output;
        }
        Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>> _5_theMap;
        _5_theMap = (_4_valueOrError3).Extract();
        output = Wrappers_Compile.Result<DynamoDbEncryptionUtil_Compile._IMaybeKeyMap, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(DynamoDbEncryptionUtil_Compile.MaybeKeyMap.create_Keys(_5_theMap));
        return output;
      } else {
        DynamoDbEncryptionUtil_Compile._IMaybeKeyId _source0 = keyId;
        {
          if (_source0.is_DontUseKeyId) {
            output = Wrappers_Compile.Result<DynamoDbEncryptionUtil_Compile._IMaybeKeyMap, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("KeyID must not be supplied with a MultiKeyStore")));
            return output;
            goto after_match0;
          }
        }
        {
          if (_source0.is_ShouldHaveKeyId) {
            output = Wrappers_Compile.Result<DynamoDbEncryptionUtil_Compile._IMaybeKeyMap, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(DynamoDbEncryptionUtil_Compile.MaybeKeyMap.create_ShouldHaveKeys());
            return output;
            goto after_match0;
          }
        }
        {
          Dafny.ISequence<char> _6_id = _source0.dtor_value;
          Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _7_valueOrError4 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<byte>>.Empty);
          Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out2;
          _out2 = (this).getKeysCache(stdNames, _6_id);
          _7_valueOrError4 = _out2;
          if ((_7_valueOrError4).IsFailure()) {
            output = (_7_valueOrError4).PropagateFailure<DynamoDbEncryptionUtil_Compile._IMaybeKeyMap>();
            return output;
          }
          Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>> _8_theMap;
          _8_theMap = (_7_valueOrError4).Extract();
          output = Wrappers_Compile.Result<DynamoDbEncryptionUtil_Compile._IMaybeKeyMap, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(DynamoDbEncryptionUtil_Compile.MaybeKeyMap.create_Keys(_8_theMap));
          return output;
        }
      after_match0: ;
      }
      return output;
    }
    public Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> getKeysLiteral()
    {
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<byte>>.Empty);
      output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(((this).dtor_keyLoc).dtor_keys);
      return output;
      return output;
    }
    public Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> getKeysCache(Dafny.ISequence<Dafny.ISequence<char>> stdNames, Dafny.ISequence<char> keyId)
    {
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<byte>>.Empty);
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, Dafny.ISequence<char>> _0_keyIdBytesR;
      _0_keyIdBytesR = UTF8.__default.Encode(keyId);
      Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _1_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(UTF8.ValidUTF8Bytes.Default());
      _1_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(_0_keyIdBytesR, ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>)((_2_e) => {
        return DynamoDbEncryptionUtil_Compile.__default.E(_2_e);
      })));
      if ((_1_valueOrError0).IsFailure()) {
        output = (_1_valueOrError0).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>>();
        return output;
      }
      Dafny.ISequence<byte> _3_keyIdBytes;
      _3_keyIdBytes = (_1_valueOrError0).Extract();
      software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryInput _4_getCacheInput;
      _4_getCacheInput = software.amazon.cryptography.materialproviders.internaldafny.types.GetCacheEntryInput.create(_3_keyIdBytes, Wrappers_Compile.Option<long>.create_None());
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _5_getCacheOutput;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types._IGetCacheEntryOutput, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out0;
      _out0 = ((this).dtor_cache).GetCacheEntry(_4_getCacheInput);
      _5_getCacheOutput = _out0;
      if (((_5_getCacheOutput).is_Failure) && (!(((_5_getCacheOutput).dtor_error).is_EntryDoesNotExist))) {
        output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Error.create_AwsCryptographyMaterialProviders((_5_getCacheOutput).dtor_error));
        return output;
      }
      if ((_5_getCacheOutput).is_Failure) {
        Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> _6_maybeRawBeaconKeyMaterials;
        Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError> _out1;
        _out1 = ((this).dtor_store).GetBeaconKey(software.amazon.cryptography.keystore.internaldafny.types.GetBeaconKeyInput.create(keyId));
        _6_maybeRawBeaconKeyMaterials = _out1;
        Wrappers_Compile._IResult<software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _7_valueOrError1 = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(software.amazon.cryptography.keystore.internaldafny.types.GetBeaconKeyOutput.Default());
        _7_valueOrError1 = Wrappers_Compile.Result<software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyOutput, software.amazon.cryptography.keystore.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(_6_maybeRawBeaconKeyMaterials, ((System.Func<software.amazon.cryptography.keystore.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>)((_8_e) => {
          return software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Error.create_AwsCryptographyKeyStore(_8_e);
        })));
        if ((_7_valueOrError1).IsFailure()) {
          output = (_7_valueOrError1).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>>();
          return output;
        }
        software.amazon.cryptography.keystore.internaldafny.types._IGetBeaconKeyOutput _9_rawBeaconKeyMaterials;
        _9_rawBeaconKeyMaterials = (_7_valueOrError1).Extract();
        Wrappers_Compile._IOption<Dafny.ISequence<byte>> _10_key;
        _10_key = ((_9_rawBeaconKeyMaterials).dtor_beaconKeyMaterials).dtor_beaconKey;
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _11_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default();
        _11_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>((_10_key).is_Some, DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("beacon key unexpectedly empty")));
        if ((_11_valueOrError2).IsFailure()) {
          output = (_11_valueOrError2).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>>();
          return output;
        }
        Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _12_valueOrError3 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<byte>>.Empty);
        Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out2;
        _out2 = (this).getAllKeys(stdNames, (_10_key).dtor_value);
        _12_valueOrError3 = _out2;
        if ((_12_valueOrError3).IsFailure()) {
          output = (_12_valueOrError3).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>>();
          return output;
        }
        Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>> _13_keyMap;
        _13_keyMap = (_12_valueOrError3).Extract();
        software.amazon.cryptography.keystore.internaldafny.types._IBeaconKeyMaterials _14_beaconKeyMaterials;
        software.amazon.cryptography.keystore.internaldafny.types._IBeaconKeyMaterials _15_dt__update__tmp_h0 = (_9_rawBeaconKeyMaterials).dtor_beaconKeyMaterials;
        Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>> _16_dt__update_hhmacKeys_h0 = Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>>.create_Some(_13_keyMap);
        Wrappers_Compile._IOption<Dafny.ISequence<byte>> _17_dt__update_hbeaconKey_h0 = Wrappers_Compile.Option<Dafny.ISequence<byte>>.create_None();
        _14_beaconKeyMaterials = software.amazon.cryptography.keystore.internaldafny.types.BeaconKeyMaterials.create((_15_dt__update__tmp_h0).dtor_beaconKeyIdentifier, (_15_dt__update__tmp_h0).dtor_encryptionContext, _17_dt__update_hbeaconKey_h0, _16_dt__update_hhmacKeys_h0);
        long _18_now;
        long _out3;
        _out3 = Time.__default.CurrentRelativeTime();
        _18_now = _out3;
        software.amazon.cryptography.materialproviders.internaldafny.types._IPutCacheEntryInput _19_putCacheEntryInput;
        _19_putCacheEntryInput = software.amazon.cryptography.materialproviders.internaldafny.types.PutCacheEntryInput.create(_3_keyIdBytes, software.amazon.cryptography.materialproviders.internaldafny.types.Materials.create_BeaconKey(_14_beaconKeyMaterials), _18_now, (_18_now) + ((long)((this).dtor_cacheTTL)), Wrappers_Compile.Option<int>.create_None(), Wrappers_Compile.Option<int>.create_None());
        Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _20_putResult;
        Wrappers_Compile._IResult<_System._ITuple0, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out4;
        _out4 = ((this).dtor_cache).PutCacheEntry(_19_putCacheEntryInput);
        _20_putResult = _out4;
        if (((_20_putResult).is_Failure) && (!(((_20_putResult).dtor_error).is_EntryAlreadyExists))) {
          output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Error.create_AwsCryptographyMaterialProviders((_20_putResult).dtor_error));
          return output;
        }
        output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(_13_keyMap);
        return output;
      } else {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _21_valueOrError4 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default();
        _21_valueOrError4 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(((((((_5_getCacheOutput).dtor_value).dtor_materials).is_BeaconKey) && ((((((_5_getCacheOutput).dtor_value).dtor_materials).dtor_BeaconKey).dtor_hmacKeys).is_Some)) && ((((((_5_getCacheOutput).dtor_value).dtor_materials).dtor_BeaconKey).dtor_beaconKeyIdentifier).Equals(keyId))) && ((((((_5_getCacheOutput).dtor_value).dtor_materials).dtor_BeaconKey).dtor_hmacKeys).is_Some), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Invalid Material Type.")));
        if ((_21_valueOrError4).IsFailure()) {
          output = (_21_valueOrError4).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>>();
          return output;
        }
        output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success((((((_5_getCacheOutput).dtor_value).dtor_materials).dtor_BeaconKey).dtor_hmacKeys).dtor_value);
        return output;
      }
      return output;
    }
    public Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> getAllKeys(Dafny.ISequence<Dafny.ISequence<char>> stdNames, Dafny.ISequence<byte> key)
    {
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<byte>>.Empty);
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
      _out0 = SearchableEncryptionInfo_Compile.__default.GetAllKeys((this).dtor_client, stdNames, key);
      output = _out0;
      return output;
    }
  }

  public interface _ISearchInfo {
    bool is_SearchInfo { get; }
    Dafny.ISequence<SearchableEncryptionInfo_Compile._IBeaconVersion> dtor_versions { get; }
    BigInteger dtor_currWrite { get; }
    _ISearchInfo DowncastClone();
    SearchableEncryptionInfo_Compile._IBeaconVersion curr();
    bool IsBeacon(Dafny.ISequence<char> field);
    bool IsVirtualField(Dafny.ISequence<char> field);
    Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GeneratePlainBeacons(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item);
    Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GenerateSignedBeacons(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item);
    Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GenerateEncryptedBeacons(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, DynamoDbEncryptionUtil_Compile._IMaybeKeyId keyId);
  }
  public class SearchInfo : _ISearchInfo {
    public readonly Dafny.ISequence<SearchableEncryptionInfo_Compile._IBeaconVersion> _versions;
    public readonly BigInteger _currWrite;
    public SearchInfo(Dafny.ISequence<SearchableEncryptionInfo_Compile._IBeaconVersion> versions, BigInteger currWrite) {
      this._versions = versions;
      this._currWrite = currWrite;
    }
    public _ISearchInfo DowncastClone() {
      if (this is _ISearchInfo dt) { return dt; }
      return new SearchInfo(_versions, _currWrite);
    }
    public override bool Equals(object other) {
      var oth = other as SearchableEncryptionInfo_Compile.SearchInfo;
      return oth != null && object.Equals(this._versions, oth._versions) && this._currWrite == oth._currWrite;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._versions));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._currWrite));
      return (int) hash;
    }
    public override string ToString() {
      string s = "SearchableEncryptionInfo.SearchInfo.SearchInfo";
      s += "(";
      s += Dafny.Helpers.ToString(this._versions);
      s += ", ";
      s += Dafny.Helpers.ToString(this._currWrite);
      s += ")";
      return s;
    }
    private static readonly SearchableEncryptionInfo_Compile._ISearchInfo theDefault = create(Dafny.Sequence<SearchableEncryptionInfo_Compile._IBeaconVersion>.Empty, BigInteger.Zero);
    public static SearchableEncryptionInfo_Compile._ISearchInfo Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<SearchableEncryptionInfo_Compile._ISearchInfo> _TYPE = new Dafny.TypeDescriptor<SearchableEncryptionInfo_Compile._ISearchInfo>(SearchableEncryptionInfo_Compile.SearchInfo.Default());
    public static Dafny.TypeDescriptor<SearchableEncryptionInfo_Compile._ISearchInfo> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ISearchInfo create(Dafny.ISequence<SearchableEncryptionInfo_Compile._IBeaconVersion> versions, BigInteger currWrite) {
      return new SearchInfo(versions, currWrite);
    }
    public static _ISearchInfo create_SearchInfo(Dafny.ISequence<SearchableEncryptionInfo_Compile._IBeaconVersion> versions, BigInteger currWrite) {
      return create(versions, currWrite);
    }
    public bool is_SearchInfo { get { return true; } }
    public Dafny.ISequence<SearchableEncryptionInfo_Compile._IBeaconVersion> dtor_versions {
      get {
        return this._versions;
      }
    }
    public BigInteger dtor_currWrite {
      get {
        return this._currWrite;
      }
    }
    public SearchableEncryptionInfo_Compile._IBeaconVersion curr() {
      return ((this).dtor_versions).Select((this).dtor_currWrite);
    }
    public bool IsBeacon(Dafny.ISequence<char> field) {
      return (((this).dtor_versions).Select((this).dtor_currWrite)).IsBeacon(field);
    }
    public bool IsVirtualField(Dafny.ISequence<char> field) {
      return (((this).dtor_versions).Select((this).dtor_currWrite)).IsVirtualField(field);
    }
    public Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GeneratePlainBeacons(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item)
    {
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
      _out0 = (((this).dtor_versions).Select((this).dtor_currWrite)).GeneratePlainBeacons(item);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GenerateSignedBeacons(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item)
    {
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
      _out0 = (((this).dtor_versions).Select((this).dtor_currWrite)).GenerateSignedBeacons(item);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GenerateEncryptedBeacons(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, DynamoDbEncryptionUtil_Compile._IMaybeKeyId keyId)
    {
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
      _out0 = (((this).dtor_versions).Select((this).dtor_currWrite)).GenerateEncryptedBeacons(item, keyId);
      output = _out0;
      return output;
    }
  }

  public interface _IBeacon {
    bool is_Standard { get; }
    bool is_Compound { get; }
    BaseBeacon_Compile._IStandardBeacon dtor_std { get; }
    CompoundBeacon_Compile._ICompoundBeacon dtor_cmp { get; }
    _IBeacon DowncastClone();
    bool isEncrypted();
    Wrappers_Compile._IResult<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> hash(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> vf, DynamoDbEncryptionUtil_Compile._IMaybeKeyMap keys);
    Wrappers_Compile._IResult<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> naked(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> vf);
    Wrappers_Compile._IResult<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> attrHash(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> vf, DynamoDbEncryptionUtil_Compile._IMaybeKeyMap keys);
    Dafny.ISequence<char> getName();
    Dafny.ISequence<char> getBeaconName();
    Dafny.ISequence<Dafny.ISequence<char>> GetFields(Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> virtualFields);
    Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetBeaconValue(software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue @value, DynamoDbEncryptionUtil_Compile._IMaybeKeyMap keys, bool forEquality, bool forContains);
  }
  public abstract class Beacon : _IBeacon {
    public Beacon() {
    }
    private static readonly SearchableEncryptionInfo_Compile._IBeacon theDefault = create_Standard(BaseBeacon_Compile.StandardBeacon.Default());
    public static SearchableEncryptionInfo_Compile._IBeacon Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<SearchableEncryptionInfo_Compile._IBeacon> _TYPE = new Dafny.TypeDescriptor<SearchableEncryptionInfo_Compile._IBeacon>(SearchableEncryptionInfo_Compile.Beacon.Default());
    public static Dafny.TypeDescriptor<SearchableEncryptionInfo_Compile._IBeacon> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IBeacon create_Standard(BaseBeacon_Compile._IStandardBeacon std) {
      return new Beacon_Standard(std);
    }
    public static _IBeacon create_Compound(CompoundBeacon_Compile._ICompoundBeacon cmp) {
      return new Beacon_Compound(cmp);
    }
    public bool is_Standard { get { return this is Beacon_Standard; } }
    public bool is_Compound { get { return this is Beacon_Compound; } }
    public BaseBeacon_Compile._IStandardBeacon dtor_std {
      get {
        var d = this;
        return ((Beacon_Standard)d)._std;
      }
    }
    public CompoundBeacon_Compile._ICompoundBeacon dtor_cmp {
      get {
        var d = this;
        return ((Beacon_Compound)d)._cmp;
      }
    }
    public abstract _IBeacon DowncastClone();
    public bool isEncrypted() {
      if ((this).is_Standard) {
        return true;
      } else {
        return ((this).dtor_cmp).isEncrypted();
      }
    }
    public Wrappers_Compile._IResult<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> hash(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> vf, DynamoDbEncryptionUtil_Compile._IMaybeKeyMap keys)
    {
      if ((this).is_Standard) {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>((keys).is_Keys, DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Need key for beacon "), ((this).dtor_std).keyName()), Dafny.Sequence<char>.FromString(" but no keyId found in query."))));
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
        } else if (((keys).dtor_value).Contains(((this).dtor_std).keyName())) {
          return ((this).dtor_std).getHash(item, vf, Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<byte>>.Select((keys).dtor_value,((this).dtor_std).keyName()));
        } else {
          return Wrappers_Compile.Result<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Internal error. Beacon "), ((this).dtor_std).keyName()), Dafny.Sequence<char>.FromString(" has no key!"))));
        }
      } else {
        Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _1_valueOrError1 = ((this).dtor_cmp).hash(item, vf, keys);
        if ((_1_valueOrError1).IsFailure()) {
          return (_1_valueOrError1).PropagateFailure<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
        } else {
          Wrappers_Compile._IOption<Dafny.ISequence<char>> _2_strHash = (_1_valueOrError1).Extract();
          if ((_2_strHash).is_None) {
            return Wrappers_Compile.Result<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.create_None());
          } else {
            return Wrappers_Compile.Result<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.create_Some(software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_S((_2_strHash).dtor_value)));
          }
        }
      }
    }
    public Wrappers_Compile._IResult<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> naked(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> vf)
    {
      if ((this).is_Standard) {
        return ((this).dtor_std).getNaked(item, vf);
      } else {
        Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = ((this).dtor_cmp).getNaked(item, vf);
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
        } else {
          Wrappers_Compile._IOption<Dafny.ISequence<char>> _1_str = (_0_valueOrError0).Extract();
          if ((_1_str).is_None) {
            return Wrappers_Compile.Result<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.create_None());
          } else {
            return Wrappers_Compile.Result<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.create_Some(DdbVirtualFields_Compile.__default.DS((_1_str).dtor_value)));
          }
        }
      }
    }
    public Wrappers_Compile._IResult<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> attrHash(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> vf, DynamoDbEncryptionUtil_Compile._IMaybeKeyMap keys)
    {
      if ((keys).is_DontUseKeys) {
        return (this).naked(item, vf);
      } else {
        return (this).hash(item, vf, keys);
      }
    }
    public Dafny.ISequence<char> getName() {
      if ((this).is_Standard) {
        return (((this).dtor_std).dtor_base).dtor_name;
      } else {
        return (((this).dtor_cmp).dtor_base).dtor_name;
      }
    }
    public Dafny.ISequence<char> getBeaconName() {
      if ((this).is_Standard) {
        return (((this).dtor_std).dtor_base).dtor_beaconName;
      } else {
        return (((this).dtor_cmp).dtor_base).dtor_beaconName;
      }
    }
    public Dafny.ISequence<Dafny.ISequence<char>> GetFields(Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> virtualFields) {
      if ((this).is_Standard) {
        return ((this).dtor_std).GetFields(virtualFields);
      } else {
        return ((this).dtor_cmp).GetFields(virtualFields);
      }
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetBeaconValue(software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue @value, DynamoDbEncryptionUtil_Compile._IMaybeKeyMap keys, bool forEquality, bool forContains)
    {
      if ((keys).is_DontUseKeys) {
        return Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(@value);
      } else if ((this).is_Standard) {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(!((keys).is_ShouldHaveKeys), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Need KeyId because of beacon "), ((this).dtor_std).keyName()), Dafny.Sequence<char>.FromString(" but no KeyId found in query"))));
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>();
        } else {
          Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<byte>> _1_keys = (keys).dtor_value;
          if ((_1_keys).Contains(((this).dtor_std).keyName())) {
            return ((this).dtor_std).GetBeaconValue(@value, Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<byte>>.Select(_1_keys,((this).dtor_std).keyName()), forContains);
          } else {
            return Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Internal error. Beacon "), ((this).dtor_std).keyName()), Dafny.Sequence<char>.FromString(" has no key."))));
          }
        }
      } else {
        return ((this).dtor_cmp).GetBeaconValue(@value, keys, forEquality);
      }
    }
  }
  public class Beacon_Standard : Beacon {
    public readonly BaseBeacon_Compile._IStandardBeacon _std;
    public Beacon_Standard(BaseBeacon_Compile._IStandardBeacon std) : base() {
      this._std = std;
    }
    public override _IBeacon DowncastClone() {
      if (this is _IBeacon dt) { return dt; }
      return new Beacon_Standard(_std);
    }
    public override bool Equals(object other) {
      var oth = other as SearchableEncryptionInfo_Compile.Beacon_Standard;
      return oth != null && object.Equals(this._std, oth._std);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._std));
      return (int) hash;
    }
    public override string ToString() {
      string s = "SearchableEncryptionInfo.Beacon.Standard";
      s += "(";
      s += Dafny.Helpers.ToString(this._std);
      s += ")";
      return s;
    }
  }
  public class Beacon_Compound : Beacon {
    public readonly CompoundBeacon_Compile._ICompoundBeacon _cmp;
    public Beacon_Compound(CompoundBeacon_Compile._ICompoundBeacon cmp) : base() {
      this._cmp = cmp;
    }
    public override _IBeacon DowncastClone() {
      if (this is _IBeacon dt) { return dt; }
      return new Beacon_Compound(_cmp);
    }
    public override bool Equals(object other) {
      var oth = other as SearchableEncryptionInfo_Compile.Beacon_Compound;
      return oth != null && object.Equals(this._cmp, oth._cmp);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._cmp));
      return (int) hash;
    }
    public override string ToString() {
      string s = "SearchableEncryptionInfo.Beacon.Compound";
      s += "(";
      s += Dafny.Helpers.ToString(this._cmp);
      s += ")";
      return s;
    }
  }

  public partial class BeaconMap {
    private static readonly Dafny.TypeDescriptor<Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon>> _TYPE = new Dafny.TypeDescriptor<Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon>>(Dafny.Map<Dafny.ISequence<char>, SearchableEncryptionInfo_Compile._IBeacon>.Empty);
    public static Dafny.TypeDescriptor<Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon>> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public interface _IBeaconType {
    bool is_AnyBeacon { get; }
    bool is_SignedBeacon { get; }
    bool is_EncryptedBeacon { get; }
    _IBeaconType DowncastClone();
  }
  public abstract class BeaconType : _IBeaconType {
    public BeaconType() {
    }
    private static readonly SearchableEncryptionInfo_Compile._IBeaconType theDefault = create_AnyBeacon();
    public static SearchableEncryptionInfo_Compile._IBeaconType Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<SearchableEncryptionInfo_Compile._IBeaconType> _TYPE = new Dafny.TypeDescriptor<SearchableEncryptionInfo_Compile._IBeaconType>(SearchableEncryptionInfo_Compile.BeaconType.Default());
    public static Dafny.TypeDescriptor<SearchableEncryptionInfo_Compile._IBeaconType> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IBeaconType create_AnyBeacon() {
      return new BeaconType_AnyBeacon();
    }
    public static _IBeaconType create_SignedBeacon() {
      return new BeaconType_SignedBeacon();
    }
    public static _IBeaconType create_EncryptedBeacon() {
      return new BeaconType_EncryptedBeacon();
    }
    public bool is_AnyBeacon { get { return this is BeaconType_AnyBeacon; } }
    public bool is_SignedBeacon { get { return this is BeaconType_SignedBeacon; } }
    public bool is_EncryptedBeacon { get { return this is BeaconType_EncryptedBeacon; } }
    public static System.Collections.Generic.IEnumerable<_IBeaconType> AllSingletonConstructors {
      get {
        yield return BeaconType.create_AnyBeacon();
        yield return BeaconType.create_SignedBeacon();
        yield return BeaconType.create_EncryptedBeacon();
      }
    }
    public abstract _IBeaconType DowncastClone();
  }
  public class BeaconType_AnyBeacon : BeaconType {
    public BeaconType_AnyBeacon() : base() {
    }
    public override _IBeaconType DowncastClone() {
      if (this is _IBeaconType dt) { return dt; }
      return new BeaconType_AnyBeacon();
    }
    public override bool Equals(object other) {
      var oth = other as SearchableEncryptionInfo_Compile.BeaconType_AnyBeacon;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      return (int) hash;
    }
    public override string ToString() {
      string s = "SearchableEncryptionInfo.BeaconType.AnyBeacon";
      return s;
    }
  }
  public class BeaconType_SignedBeacon : BeaconType {
    public BeaconType_SignedBeacon() : base() {
    }
    public override _IBeaconType DowncastClone() {
      if (this is _IBeaconType dt) { return dt; }
      return new BeaconType_SignedBeacon();
    }
    public override bool Equals(object other) {
      var oth = other as SearchableEncryptionInfo_Compile.BeaconType_SignedBeacon;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      return (int) hash;
    }
    public override string ToString() {
      string s = "SearchableEncryptionInfo.BeaconType.SignedBeacon";
      return s;
    }
  }
  public class BeaconType_EncryptedBeacon : BeaconType {
    public BeaconType_EncryptedBeacon() : base() {
    }
    public override _IBeaconType DowncastClone() {
      if (this is _IBeaconType dt) { return dt; }
      return new BeaconType_EncryptedBeacon();
    }
    public override bool Equals(object other) {
      var oth = other as SearchableEncryptionInfo_Compile.BeaconType_EncryptedBeacon;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      return (int) hash;
    }
    public override string ToString() {
      string s = "SearchableEncryptionInfo.BeaconType.EncryptedBeacon";
      return s;
    }
  }

  public partial class ValidBeaconVersion {
    private static readonly Dafny.TypeDescriptor<SearchableEncryptionInfo_Compile._IBeaconVersion> _TYPE = new Dafny.TypeDescriptor<SearchableEncryptionInfo_Compile._IBeaconVersion>(SearchableEncryptionInfo_Compile.BeaconVersion.Default());
    public static Dafny.TypeDescriptor<SearchableEncryptionInfo_Compile._IBeaconVersion> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public interface _IBeaconVersion {
    bool is_BeaconVersion { get; }
    byte dtor_version { get; }
    SearchableEncryptionInfo_Compile._IKeySource dtor_keySource { get; }
    Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> dtor_virtualFields { get; }
    Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon> dtor_beacons { get; }
    Dafny.ISequence<Dafny.ISequence<char>> dtor_beaconNames { get; }
    Dafny.ISequence<Dafny.ISequence<char>> dtor_stdNames { get; }
    Dafny.ISet<Dafny.ISequence<char>> dtor_encryptedFields { get; }
    _IBeaconVersion DowncastClone();
    bool IsBeacon(Dafny.ISequence<char> field);
    bool IsVirtualField(Dafny.ISequence<char> field);
    Dafny.ISequence<Dafny.ISequence<char>> GetFields(Dafny.ISequence<char> field);
    Wrappers_Compile._IResult<DynamoDbEncryptionUtil_Compile._IMaybeKeyMap, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> getKeyMap(DynamoDbEncryptionUtil_Compile._IMaybeKeyId keyId);
    Dafny.ISequence<Dafny.ISequence<char>> ListSignedBeacons();
    Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GeneratePlainBeacons(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item);
    Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GenerateSignedBeacons(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item);
    Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GenerateEncryptedBeacons(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, DynamoDbEncryptionUtil_Compile._IMaybeKeyId keyId);
    Wrappers_Compile._IResult<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GenerateBeacon(Dafny.ISequence<char> name, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, DynamoDbEncryptionUtil_Compile._IMaybeKeyMap keys);
    Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GenerateBeacons2(Dafny.ISequence<Dafny.ISequence<char>> names, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, DynamoDbEncryptionUtil_Compile._IMaybeKeyMap keys, SearchableEncryptionInfo_Compile._IBeaconType bType, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> acc);
  }
  public class BeaconVersion : _IBeaconVersion {
    public readonly byte _version;
    public readonly SearchableEncryptionInfo_Compile._IKeySource _keySource;
    public readonly Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> _virtualFields;
    public readonly Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon> _beacons;
    public readonly Dafny.ISequence<Dafny.ISequence<char>> _beaconNames;
    public readonly Dafny.ISequence<Dafny.ISequence<char>> _stdNames;
    public readonly Dafny.ISet<Dafny.ISequence<char>> _encryptedFields;
    public BeaconVersion(byte version, SearchableEncryptionInfo_Compile._IKeySource keySource, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> virtualFields, Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon> beacons, Dafny.ISequence<Dafny.ISequence<char>> beaconNames, Dafny.ISequence<Dafny.ISequence<char>> stdNames, Dafny.ISet<Dafny.ISequence<char>> encryptedFields) {
      this._version = version;
      this._keySource = keySource;
      this._virtualFields = virtualFields;
      this._beacons = beacons;
      this._beaconNames = beaconNames;
      this._stdNames = stdNames;
      this._encryptedFields = encryptedFields;
    }
    public _IBeaconVersion DowncastClone() {
      if (this is _IBeaconVersion dt) { return dt; }
      return new BeaconVersion(_version, _keySource, _virtualFields, _beacons, _beaconNames, _stdNames, _encryptedFields);
    }
    public override bool Equals(object other) {
      var oth = other as SearchableEncryptionInfo_Compile.BeaconVersion;
      return oth != null && this._version == oth._version && object.Equals(this._keySource, oth._keySource) && object.Equals(this._virtualFields, oth._virtualFields) && object.Equals(this._beacons, oth._beacons) && object.Equals(this._beaconNames, oth._beaconNames) && object.Equals(this._stdNames, oth._stdNames) && object.Equals(this._encryptedFields, oth._encryptedFields);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._version));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._keySource));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._virtualFields));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._beacons));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._beaconNames));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._stdNames));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._encryptedFields));
      return (int) hash;
    }
    public override string ToString() {
      string s = "SearchableEncryptionInfo.BeaconVersion.BeaconVersion";
      s += "(";
      s += Dafny.Helpers.ToString(this._version);
      s += ", ";
      s += Dafny.Helpers.ToString(this._keySource);
      s += ", ";
      s += Dafny.Helpers.ToString(this._virtualFields);
      s += ", ";
      s += Dafny.Helpers.ToString(this._beacons);
      s += ", ";
      s += Dafny.Helpers.ToString(this._beaconNames);
      s += ", ";
      s += Dafny.Helpers.ToString(this._stdNames);
      s += ", ";
      s += Dafny.Helpers.ToString(this._encryptedFields);
      s += ")";
      return s;
    }
    private static readonly SearchableEncryptionInfo_Compile._IBeaconVersion theDefault = create(SearchableEncryptionInfo_Compile.VersionNumber.Witness, SearchableEncryptionInfo_Compile.KeySource.Default(), Dafny.Map<Dafny.ISequence<char>, DdbVirtualFields_Compile._IVirtField>.Empty, Dafny.Map<Dafny.ISequence<char>, SearchableEncryptionInfo_Compile._IBeacon>.Empty, Dafny.Sequence<Dafny.ISequence<char>>.Empty, Dafny.Sequence<Dafny.ISequence<char>>.Empty, Dafny.Set<Dafny.ISequence<char>>.Empty);
    public static SearchableEncryptionInfo_Compile._IBeaconVersion Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<SearchableEncryptionInfo_Compile._IBeaconVersion> _TYPE = new Dafny.TypeDescriptor<SearchableEncryptionInfo_Compile._IBeaconVersion>(SearchableEncryptionInfo_Compile.BeaconVersion.Default());
    public static Dafny.TypeDescriptor<SearchableEncryptionInfo_Compile._IBeaconVersion> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IBeaconVersion create(byte version, SearchableEncryptionInfo_Compile._IKeySource keySource, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> virtualFields, Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon> beacons, Dafny.ISequence<Dafny.ISequence<char>> beaconNames, Dafny.ISequence<Dafny.ISequence<char>> stdNames, Dafny.ISet<Dafny.ISequence<char>> encryptedFields) {
      return new BeaconVersion(version, keySource, virtualFields, beacons, beaconNames, stdNames, encryptedFields);
    }
    public static _IBeaconVersion create_BeaconVersion(byte version, SearchableEncryptionInfo_Compile._IKeySource keySource, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> virtualFields, Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon> beacons, Dafny.ISequence<Dafny.ISequence<char>> beaconNames, Dafny.ISequence<Dafny.ISequence<char>> stdNames, Dafny.ISet<Dafny.ISequence<char>> encryptedFields) {
      return create(version, keySource, virtualFields, beacons, beaconNames, stdNames, encryptedFields);
    }
    public bool is_BeaconVersion { get { return true; } }
    public byte dtor_version {
      get {
        return this._version;
      }
    }
    public SearchableEncryptionInfo_Compile._IKeySource dtor_keySource {
      get {
        return this._keySource;
      }
    }
    public Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> dtor_virtualFields {
      get {
        return this._virtualFields;
      }
    }
    public Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon> dtor_beacons {
      get {
        return this._beacons;
      }
    }
    public Dafny.ISequence<Dafny.ISequence<char>> dtor_beaconNames {
      get {
        return this._beaconNames;
      }
    }
    public Dafny.ISequence<Dafny.ISequence<char>> dtor_stdNames {
      get {
        return this._stdNames;
      }
    }
    public Dafny.ISet<Dafny.ISequence<char>> dtor_encryptedFields {
      get {
        return this._encryptedFields;
      }
    }
    public bool IsBeacon(Dafny.ISequence<char> field) {
      return ((this).dtor_beacons).Contains(field);
    }
    public bool IsVirtualField(Dafny.ISequence<char> field) {
      return ((this).dtor_virtualFields).Contains(field);
    }
    public Dafny.ISequence<Dafny.ISequence<char>> GetFields(Dafny.ISequence<char> field) {
      if ((this).IsBeacon(field)) {
        return Dafny.Sequence<Dafny.ISequence<char>>.Concat((Dafny.Map<Dafny.ISequence<char>, SearchableEncryptionInfo_Compile._IBeacon>.Select((this).dtor_beacons,field)).GetFields((this).dtor_virtualFields), Dafny.Sequence<Dafny.ISequence<char>>.FromElements(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("aws_dbe_b_"), field)));
      } else {
        return Dafny.Sequence<Dafny.ISequence<char>>.FromElements(field);
      }
    }
    public Wrappers_Compile._IResult<DynamoDbEncryptionUtil_Compile._IMaybeKeyMap, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> getKeyMap(DynamoDbEncryptionUtil_Compile._IMaybeKeyId keyId)
    {
      Wrappers_Compile._IResult<DynamoDbEncryptionUtil_Compile._IMaybeKeyMap, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = Wrappers_Compile.Result<DynamoDbEncryptionUtil_Compile._IMaybeKeyMap, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(DynamoDbEncryptionUtil_Compile.MaybeKeyMap.Default());
      Wrappers_Compile._IResult<DynamoDbEncryptionUtil_Compile._IMaybeKeyMap, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
      _out0 = ((this).dtor_keySource).getKeyMap((this).dtor_stdNames, keyId);
      output = _out0;
      return output;
    }
    public Dafny.ISequence<Dafny.ISequence<char>> ListSignedBeacons() {
      return Seq_Compile.__default.Filter<Dafny.ISequence<char>>(((System.Func<Dafny.ISequence<char>, bool>)((_0_s) => {
        return SearchableEncryptionInfo_Compile.__default.IsBeaconOfType(Dafny.Map<Dafny.ISequence<char>, SearchableEncryptionInfo_Compile._IBeacon>.Select((this).dtor_beacons,_0_s), SearchableEncryptionInfo_Compile.BeaconType.create_SignedBeacon());
      })), (this).dtor_beaconNames);
    }
    public Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GeneratePlainBeacons(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item)
    {
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
      output = (this).GenerateBeacons2((this).dtor_beaconNames, item, DynamoDbEncryptionUtil_Compile.MaybeKeyMap.create_DontUseKeys(), SearchableEncryptionInfo_Compile.BeaconType.create_AnyBeacon(), Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.FromElements());
      return output;
    }
    public Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GenerateSignedBeacons(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item)
    {
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
      output = (this).GenerateBeacons2((this).dtor_beaconNames, item, DynamoDbEncryptionUtil_Compile.MaybeKeyMap.create_DontUseKeys(), SearchableEncryptionInfo_Compile.BeaconType.create_SignedBeacon(), Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.FromElements());
      return output;
    }
    public Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GenerateEncryptedBeacons(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, DynamoDbEncryptionUtil_Compile._IMaybeKeyId keyId)
    {
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
      Wrappers_Compile._IResult<DynamoDbEncryptionUtil_Compile._IMaybeKeyMap, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Result<DynamoDbEncryptionUtil_Compile._IMaybeKeyMap, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(DynamoDbEncryptionUtil_Compile.MaybeKeyMap.Default());
      Wrappers_Compile._IResult<DynamoDbEncryptionUtil_Compile._IMaybeKeyMap, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
      _out0 = (this).getKeyMap(keyId);
      _0_valueOrError0 = _out0;
      if ((_0_valueOrError0).IsFailure()) {
        output = (_0_valueOrError0).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
        return output;
      }
      DynamoDbEncryptionUtil_Compile._IMaybeKeyMap _1_hmacKeys;
      _1_hmacKeys = (_0_valueOrError0).Extract();
      output = (this).GenerateBeacons2((this).dtor_beaconNames, item, _1_hmacKeys, SearchableEncryptionInfo_Compile.BeaconType.create_EncryptedBeacon(), Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.FromElements());
      return output;
    }
    public Wrappers_Compile._IResult<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GenerateBeacon(Dafny.ISequence<char> name, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, DynamoDbEncryptionUtil_Compile._IMaybeKeyMap keys)
    {
      return (Dafny.Map<Dafny.ISequence<char>, SearchableEncryptionInfo_Compile._IBeacon>.Select((this).dtor_beacons,name)).attrHash(item, (this).dtor_virtualFields, keys);
    }
    public Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GenerateBeacons2(Dafny.ISequence<Dafny.ISequence<char>> names, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, DynamoDbEncryptionUtil_Compile._IMaybeKeyMap keys, SearchableEncryptionInfo_Compile._IBeaconType bType, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> acc)
    {
      _IBeaconVersion _this = this;
    TAIL_CALL_START: ;
      if ((new BigInteger((names).Count)).Sign == 0) {
        return Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(acc);
      } else if ((SearchableEncryptionInfo_Compile.__default.IsBeaconOfType(Dafny.Map<Dafny.ISequence<char>, SearchableEncryptionInfo_Compile._IBeacon>.Select((_this).dtor_beacons,(names).Select(BigInteger.Zero)), bType)) && (!(SearchableEncryptionInfo_Compile.__default.IsPartOnly(Dafny.Map<Dafny.ISequence<char>, SearchableEncryptionInfo_Compile._IBeacon>.Select((_this).dtor_beacons,(names).Select(BigInteger.Zero)))))) {
        Wrappers_Compile._IResult<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = (_this).GenerateBeacon((names).Select(BigInteger.Zero), item, keys);
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
        } else {
          Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _1_value = (_0_valueOrError0).Extract();
          if ((_1_value).is_Some) {
            SearchableEncryptionInfo_Compile._IBeaconVersion _in0 = _this;
            Dafny.ISequence<Dafny.ISequence<char>> _in1 = (names).Drop(BigInteger.One);
            Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in2 = item;
            DynamoDbEncryptionUtil_Compile._IMaybeKeyMap _in3 = keys;
            SearchableEncryptionInfo_Compile._IBeaconType _in4 = bType;
            Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in5 = Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Update(acc, (Dafny.Map<Dafny.ISequence<char>, SearchableEncryptionInfo_Compile._IBeacon>.Select((_this).dtor_beacons,(names).Select(BigInteger.Zero))).getBeaconName(), (_1_value).dtor_value);
            _this = _in0;
            ;
            names = _in1;
            item = _in2;
            keys = _in3;
            bType = _in4;
            acc = _in5;
            goto TAIL_CALL_START;
          } else {
            SearchableEncryptionInfo_Compile._IBeaconVersion _in6 = _this;
            Dafny.ISequence<Dafny.ISequence<char>> _in7 = (names).Drop(BigInteger.One);
            Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in8 = item;
            DynamoDbEncryptionUtil_Compile._IMaybeKeyMap _in9 = keys;
            SearchableEncryptionInfo_Compile._IBeaconType _in10 = bType;
            Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in11 = acc;
            _this = _in6;
            ;
            names = _in7;
            item = _in8;
            keys = _in9;
            bType = _in10;
            acc = _in11;
            goto TAIL_CALL_START;
          }
        }
      } else {
        SearchableEncryptionInfo_Compile._IBeaconVersion _in12 = _this;
        Dafny.ISequence<Dafny.ISequence<char>> _in13 = (names).Drop(BigInteger.One);
        Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in14 = item;
        DynamoDbEncryptionUtil_Compile._IMaybeKeyMap _in15 = keys;
        SearchableEncryptionInfo_Compile._IBeaconType _in16 = bType;
        Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in17 = acc;
        _this = _in12;
        ;
        names = _in13;
        item = _in14;
        keys = _in15;
        bType = _in16;
        acc = _in17;
        goto TAIL_CALL_START;
      }
    }
  }
} // end of namespace SearchableEncryptionInfo_Compile
namespace DynamoDBFilterExpr_Compile {

  public partial class __default {
    public static Dafny.ISequence<Dafny.ISequence<char>> ExtractAttributes(Dafny.ISequence<char> s, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> ex)
    {
      Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _0_tokens = DynamoDBFilterExpr_Compile.__default.ParseExpr(s);
      return DynamoDBFilterExpr_Compile.__default.ExtractAttributes2(_0_tokens, ex, new BigInteger(-1));
    }
    public static bool IsSpecial(DynamoDBFilterExpr_Compile._IToken t) {
      return (((t).is_AttributeExists) || ((t).is_AttributeNotExists)) || ((t).is_Size);
    }
    public static Dafny.ISequence<Dafny.ISequence<char>> ExtractAttributes2(Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> tokens, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> names, BigInteger tokensUntilSkip)
    {
      Dafny.ISequence<Dafny.ISequence<char>> _0___accumulator = Dafny.Sequence<Dafny.ISequence<char>>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((tokens).Count)).Sign == 0) {
        return Dafny.Sequence<Dafny.ISequence<char>>.Concat(_0___accumulator, Dafny.Sequence<Dafny.ISequence<char>>.FromElements());
      } else if (DynamoDBFilterExpr_Compile.__default.IsSpecial((tokens).Select(BigInteger.Zero))) {
        Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in0 = (tokens).Drop(BigInteger.One);
        Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> _in1 = names;
        BigInteger _in2 = BigInteger.One;
        tokens = _in0;
        names = _in1;
        tokensUntilSkip = _in2;
        goto TAIL_CALL_START;
      } else if ((((tokens).Select(BigInteger.Zero)).is_Attr) && ((tokensUntilSkip).Sign == 0)) {
        Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in3 = (tokens).Drop(BigInteger.One);
        Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> _in4 = names;
        BigInteger _in5 = new BigInteger(-1);
        tokens = _in3;
        names = _in4;
        tokensUntilSkip = _in5;
        goto TAIL_CALL_START;
      } else if (((tokens).Select(BigInteger.Zero)).is_Attr) {
        _0___accumulator = Dafny.Sequence<Dafny.ISequence<char>>.Concat(_0___accumulator, Dafny.Sequence<Dafny.ISequence<char>>.FromElements(DynamoDBFilterExpr_Compile.__default.GetAttrName((tokens).Select(BigInteger.Zero), names)));
        Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in6 = (tokens).Drop(BigInteger.One);
        Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> _in7 = names;
        BigInteger _in8 = new BigInteger(-1);
        tokens = _in6;
        names = _in7;
        tokensUntilSkip = _in8;
        goto TAIL_CALL_START;
      } else {
        Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in9 = (tokens).Drop(BigInteger.One);
        Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> _in10 = names;
        BigInteger _in11 = (tokensUntilSkip) - (BigInteger.One);
        tokens = _in9;
        names = _in10;
        tokensUntilSkip = _in11;
        goto TAIL_CALL_START;
      }
    }
    public static bool IsEquality(DynamoDBFilterExpr_Compile._IToken t) {
      return (((t).is_Eq) || ((t).is_Ne)) || ((t).is_In);
    }
    public static bool IsInequality(DynamoDBFilterExpr_Compile._IToken t) {
      return ((((t).is_Lt) || ((t).is_Le)) || ((t).is_Gt)) || ((t).is_Ge);
    }
    public static Dafny.ISequence<char> TokenToString(DynamoDBFilterExpr_Compile._IToken t) {
      DynamoDBFilterExpr_Compile._IToken _source0 = t;
      {
        if (_source0.is_Attr) {
          Dafny.ISequence<char> _0_s = _source0.dtor_s;
          Dafny.ISequence<TermLoc_Compile._ISelector> _1_l = _source0.dtor_loc;
          return _0_s;
        }
      }
      {
        if (_source0.is_Value) {
          Dafny.ISequence<char> _2_s = _source0.dtor_s;
          return _2_s;
        }
      }
      {
        if (_source0.is_Eq) {
          return Dafny.Sequence<char>.FromString("=");
        }
      }
      {
        if (_source0.is_Ne) {
          return Dafny.Sequence<char>.FromString("<>");
        }
      }
      {
        if (_source0.is_Lt) {
          return Dafny.Sequence<char>.FromString("<");
        }
      }
      {
        if (_source0.is_Gt) {
          return Dafny.Sequence<char>.FromString(">");
        }
      }
      {
        if (_source0.is_Le) {
          return Dafny.Sequence<char>.FromString("<=");
        }
      }
      {
        if (_source0.is_Ge) {
          return Dafny.Sequence<char>.FromString(">=");
        }
      }
      {
        if (_source0.is_Between) {
          return Dafny.Sequence<char>.FromString("BETWEEN");
        }
      }
      {
        if (_source0.is_In) {
          return Dafny.Sequence<char>.FromString("IN");
        }
      }
      {
        if (_source0.is_Open) {
          return Dafny.Sequence<char>.FromString("(");
        }
      }
      {
        if (_source0.is_Close) {
          return Dafny.Sequence<char>.FromString(")");
        }
      }
      {
        if (_source0.is_Comma) {
          return Dafny.Sequence<char>.FromString(",");
        }
      }
      {
        if (_source0.is_Not) {
          return Dafny.Sequence<char>.FromString("NOT");
        }
      }
      {
        if (_source0.is_And) {
          return Dafny.Sequence<char>.FromString("AND");
        }
      }
      {
        if (_source0.is_Or) {
          return Dafny.Sequence<char>.FromString("OR");
        }
      }
      {
        if (_source0.is_AttributeExists) {
          return Dafny.Sequence<char>.FromString("attribute_exists");
        }
      }
      {
        if (_source0.is_AttributeNotExists) {
          return Dafny.Sequence<char>.FromString("attribute_not_exists");
        }
      }
      {
        if (_source0.is_AttributeType) {
          return Dafny.Sequence<char>.FromString("attribute_type");
        }
      }
      {
        if (_source0.is_BeginsWith) {
          return Dafny.Sequence<char>.FromString("begins_with");
        }
      }
      {
        if (_source0.is_Contains) {
          return Dafny.Sequence<char>.FromString("contains");
        }
      }
      {
        return Dafny.Sequence<char>.FromString("size");
      }
    }
    public static Wrappers_Compile._IOption<BigInteger> GetInPos(Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> expr, BigInteger pos)
    {
    TAIL_CALL_START: ;
      if ((pos) < (new BigInteger(3))) {
        return Wrappers_Compile.Option<BigInteger>.create_None();
      } else if ((((expr).Select((pos) - (BigInteger.One))).is_Open) && (((expr).Select((pos) - (new BigInteger(2)))).is_In)) {
        return Wrappers_Compile.Option<BigInteger>.create_Some((pos) - (new BigInteger(2)));
      } else if ((((expr).Select((pos) - (BigInteger.One))).is_Comma) && (((expr).Select((pos) - (new BigInteger(2)))).is_Value)) {
        Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in0 = expr;
        BigInteger _in1 = (pos) - (new BigInteger(2));
        expr = _in0;
        pos = _in1;
        goto TAIL_CALL_START;
      } else {
        return Wrappers_Compile.Option<BigInteger>.create_None();
      }
    }
    public static Dafny.ISequence<char> RealName(Dafny.ISequence<char> s) {
      if (Dafny.Sequence<char>.IsProperPrefixOf(DynamoDbEncryptionUtil_Compile.__default.BeaconPrefix, s)) {
        return (s).Drop(new BigInteger((DynamoDbEncryptionUtil_Compile.__default.BeaconPrefix).Count));
      } else {
        return s;
      }
    }
    public static bool HasBeacon(SearchableEncryptionInfo_Compile._IBeaconVersion b, DynamoDBFilterExpr_Compile._IToken t, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> names)
    {
      if ((t).is_Attr) {
        Dafny.ISequence<char> _0_name = DynamoDBFilterExpr_Compile.__default.RealName((t).dtor_s);
        return (((((b).dtor_beacons).Contains(_0_name)) || ((((names).is_Some) && (((names).dtor_value).Contains(_0_name))) && (((b).dtor_beacons).Contains(DynamoDBFilterExpr_Compile.__default.RealName(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Select((names).dtor_value,_0_name)))))) || (((b).dtor_encryptedFields).Contains(_0_name))) || ((((names).is_Some) && (((names).dtor_value).Contains(_0_name))) && (((b).dtor_encryptedFields).Contains(DynamoDBFilterExpr_Compile.__default.RealName(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Select((names).dtor_value,_0_name)))));
      } else {
        return false;
      }
    }
    public static Wrappers_Compile._IResult<SearchableEncryptionInfo_Compile._IBeacon, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetBeacon2(SearchableEncryptionInfo_Compile._IBeaconVersion b, DynamoDBFilterExpr_Compile._IToken t, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> names)
    {
      Dafny.ISequence<char> _0_name = DynamoDBFilterExpr_Compile.__default.RealName((t).dtor_s);
      if (((b).dtor_beacons).Contains(_0_name)) {
        if (SearchableEncryptionInfo_Compile.__default.IsPartOnly(Dafny.Map<Dafny.ISequence<char>, SearchableEncryptionInfo_Compile._IBeacon>.Select((b).dtor_beacons,_0_name))) {
          return Wrappers_Compile.Result<SearchableEncryptionInfo_Compile._IBeacon, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Field "), _0_name), Dafny.Sequence<char>.FromString(" is encrypted, and has a PartOnly beacon, and so can only be used as part of a compound beacon."))));
        } else {
          return Wrappers_Compile.Result<SearchableEncryptionInfo_Compile._IBeacon, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Dafny.Map<Dafny.ISequence<char>, SearchableEncryptionInfo_Compile._IBeacon>.Select((b).dtor_beacons,_0_name));
        }
      } else if ((((names).is_Some) && (((names).dtor_value).Contains(_0_name))) && (((b).dtor_beacons).Contains(DynamoDBFilterExpr_Compile.__default.RealName(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Select((names).dtor_value,_0_name))))) {
        Dafny.ISequence<char> _1_name2 = DynamoDBFilterExpr_Compile.__default.RealName(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Select((names).dtor_value,_0_name));
        return Wrappers_Compile.Result<SearchableEncryptionInfo_Compile._IBeacon, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Dafny.Map<Dafny.ISequence<char>, SearchableEncryptionInfo_Compile._IBeacon>.Select((b).dtor_beacons,_1_name2));
      } else if (((b).dtor_encryptedFields).Contains(_0_name)) {
        return Wrappers_Compile.Result<SearchableEncryptionInfo_Compile._IBeacon, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Field "), _0_name), Dafny.Sequence<char>.FromString(" is encrypted, and cannot be searched without a beacon."))));
      } else {
        Dafny.ISequence<char> _2_name2 = DynamoDBFilterExpr_Compile.__default.RealName(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Select((names).dtor_value,_0_name));
        return Wrappers_Compile.Result<SearchableEncryptionInfo_Compile._IBeacon, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Field "), _2_name2), Dafny.Sequence<char>.FromString(" is encrypted, and cannot be searched without a beacon."))));
      }
    }
    public static Wrappers_Compile._IResult<DynamoDBFilterExpr_Compile._IEqualityBeacon, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetBeacon(SearchableEncryptionInfo_Compile._IBeaconVersion bv, DynamoDBFilterExpr_Compile._IToken t, DynamoDBFilterExpr_Compile._IToken op, DynamoDBFilterExpr_Compile._IToken @value, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> names, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> values)
    {
      Wrappers_Compile._IResult<SearchableEncryptionInfo_Compile._IBeacon, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = DynamoDBFilterExpr_Compile.__default.GetBeacon2(bv, t, names);
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<DynamoDBFilterExpr_Compile._IEqualityBeacon>();
      } else {
        SearchableEncryptionInfo_Compile._IBeacon _1_b = (_0_valueOrError0).Extract();
        Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _2_valueOrError1 = DynamoDBFilterExpr_Compile.__default.CanBeacon(_1_b, op, (@value).dtor_s, values);
        if ((_2_valueOrError1).IsFailure()) {
          return (_2_valueOrError1).PropagateFailure<DynamoDBFilterExpr_Compile._IEqualityBeacon>();
        } else {
          bool _3___v0 = (_2_valueOrError1).Extract();
          return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IEqualityBeacon, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(DynamoDBFilterExpr_Compile.EqualityBeacon.create(Wrappers_Compile.Option<SearchableEncryptionInfo_Compile._IBeacon>.create_Some(_1_b), DynamoDBFilterExpr_Compile.__default.IsEquality(op), object.Equals(op, DynamoDBFilterExpr_Compile.Token.create_Contains())));
        }
      }
    }
    public static Wrappers_Compile._IResult<DynamoDBFilterExpr_Compile._IEqualityBeacon, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetBetweenBeacon(SearchableEncryptionInfo_Compile._IBeaconVersion bv, DynamoDBFilterExpr_Compile._IToken t, DynamoDBFilterExpr_Compile._IToken op, DynamoDBFilterExpr_Compile._IToken leftValue, DynamoDBFilterExpr_Compile._IToken rightValue, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> names, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> values)
    {
      Wrappers_Compile._IResult<SearchableEncryptionInfo_Compile._IBeacon, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = DynamoDBFilterExpr_Compile.__default.GetBeacon2(bv, t, names);
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<DynamoDBFilterExpr_Compile._IEqualityBeacon>();
      } else {
        SearchableEncryptionInfo_Compile._IBeacon _1_b = (_0_valueOrError0).Extract();
        Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _2_valueOrError1 = DynamoDBFilterExpr_Compile.__default.CanBetween(_1_b, op, (leftValue).dtor_s, (rightValue).dtor_s, values);
        if ((_2_valueOrError1).IsFailure()) {
          return (_2_valueOrError1).PropagateFailure<DynamoDBFilterExpr_Compile._IEqualityBeacon>();
        } else {
          bool _3___v1 = (_2_valueOrError1).Extract();
          return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IEqualityBeacon, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(DynamoDBFilterExpr_Compile.EqualityBeacon.create(Wrappers_Compile.Option<SearchableEncryptionInfo_Compile._IBeacon>.create_Some(_1_b), false, false));
        }
      }
    }
    public static Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> CanStandardBeacon(DynamoDBFilterExpr_Compile._IToken op) {
      DynamoDBFilterExpr_Compile._IToken _source0 = op;
      {
        bool disjunctiveMatch0 = false;
        if (_source0.is_Ne) {
          disjunctiveMatch0 = true;
        }
        if (_source0.is_Lt) {
          disjunctiveMatch0 = true;
        }
        if (_source0.is_Gt) {
          disjunctiveMatch0 = true;
        }
        if (_source0.is_Le) {
          disjunctiveMatch0 = true;
        }
        if (_source0.is_Ge) {
          disjunctiveMatch0 = true;
        }
        if (_source0.is_Between) {
          disjunctiveMatch0 = true;
        }
        if (_source0.is_BeginsWith) {
          disjunctiveMatch0 = true;
        }
        if (disjunctiveMatch0) {
          return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("The operation '"), DynamoDBFilterExpr_Compile.__default.TokenToString(op)), Dafny.Sequence<char>.FromString("' cannot be used with a standard beacon."))));
        }
      }
      {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(true);
      }
    }
    public static Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> CanCompoundBeacon(SearchableEncryptionInfo_Compile._IBeacon b, DynamoDBFilterExpr_Compile._IToken op, Dafny.ISequence<char> @value)
    {
      DynamoDBFilterExpr_Compile._IToken _source0 = op;
      {
        bool disjunctiveMatch0 = false;
        if (_source0.is_Lt) {
          disjunctiveMatch0 = true;
        }
        if (_source0.is_Gt) {
          disjunctiveMatch0 = true;
        }
        if (_source0.is_Le) {
          disjunctiveMatch0 = true;
        }
        if (_source0.is_Ge) {
          disjunctiveMatch0 = true;
        }
        if (disjunctiveMatch0) {
          Dafny.ISequence<Dafny.ISequence<char>> _0_pieces = StandardLibrary_Compile.__default.Split<char>(@value, ((b).dtor_cmp).dtor_split);
          Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _1_valueOrError0 = ((b).dtor_cmp).IsLessThanComparable(_0_pieces);
          if ((_1_valueOrError0).IsFailure()) {
            return (_1_valueOrError0).PropagateFailure<bool>();
          } else {
            bool _2_canLess = (_1_valueOrError0).Extract();
            if (_2_canLess) {
              return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(true);
            } else {
              return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("The operation '"), DynamoDBFilterExpr_Compile.__default.TokenToString(op)), Dafny.Sequence<char>.FromString("' cannot be used with a compound beacon, unless the value is LessThanComparable : ")), @value)));
            }
          }
        }
      }
      {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(true);
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetStringFromValue(Dafny.ISequence<char> @value, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> values, SearchableEncryptionInfo_Compile._IBeacon b)
    {
      if ((values).Contains(@value)) {
        software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue _0_val = Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(values,@value);
        if ((_0_val).is_S) {
          return Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success((_0_val).dtor_S);
        } else {
          return Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Value "), @value), Dafny.Sequence<char>.FromString(" supplied for compound beacon ")), (((b).dtor_cmp).dtor_base).dtor_name), Dafny.Sequence<char>.FromString(" is of type ")), DynamoDbEncryptionUtil_Compile.__default.AttrTypeToStr(_0_val)), Dafny.Sequence<char>.FromString(" but must be of type S (string)."))));
        }
      } else {
        return Wrappers_Compile.Result<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Value "), @value), Dafny.Sequence<char>.FromString(" used in query string, but not supplied in value map."))));
      }
    }
    public static Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> CanBeacon(SearchableEncryptionInfo_Compile._IBeacon b, DynamoDBFilterExpr_Compile._IToken op, Dafny.ISequence<char> @value, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> values)
    {
      if ((b).is_Standard) {
        return DynamoDBFilterExpr_Compile.__default.CanStandardBeacon(op);
      } else {
        Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = DynamoDBFilterExpr_Compile.__default.GetStringFromValue(@value, values, b);
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<bool>();
        } else {
          Dafny.ISequence<char> _1_val = (_0_valueOrError0).Extract();
          return DynamoDBFilterExpr_Compile.__default.CanCompoundBeacon(b, op, _1_val);
        }
      }
    }
    public static _System._ITuple2<Dafny.ISequence<Dafny.ISequence<char>>, Dafny.ISequence<Dafny.ISequence<char>>> RemoveCommonPrefix(Dafny.ISequence<Dafny.ISequence<char>> x, Dafny.ISequence<Dafny.ISequence<char>> y)
    {
    TAIL_CALL_START: ;
      if ((((new BigInteger((x).Count)).Sign == 0) || ((new BigInteger((y).Count)).Sign == 0)) || (!((x).Select(BigInteger.Zero)).Equals((y).Select(BigInteger.Zero)))) {
        return _System.Tuple2<Dafny.ISequence<Dafny.ISequence<char>>, Dafny.ISequence<Dafny.ISequence<char>>>.create(x, y);
      } else {
        Dafny.ISequence<Dafny.ISequence<char>> _in0 = (x).Drop(BigInteger.One);
        Dafny.ISequence<Dafny.ISequence<char>> _in1 = (y).Drop(BigInteger.One);
        x = _in0;
        y = _in1;
        goto TAIL_CALL_START;
      }
    }
    public static Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> CanBetween(SearchableEncryptionInfo_Compile._IBeacon b, DynamoDBFilterExpr_Compile._IToken op, Dafny.ISequence<char> leftValue, Dafny.ISequence<char> rightValue, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> values)
    {
      if ((b).is_Standard) {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("The operation BETWEEN cannot be used with a standard beacon.")));
      } else {
        Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = DynamoDBFilterExpr_Compile.__default.GetStringFromValue(leftValue, values, b);
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<bool>();
        } else {
          Dafny.ISequence<char> _1_leftVal = (_0_valueOrError0).Extract();
          Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _2_valueOrError1 = DynamoDBFilterExpr_Compile.__default.GetStringFromValue(rightValue, values, b);
          if ((_2_valueOrError1).IsFailure()) {
            return (_2_valueOrError1).PropagateFailure<bool>();
          } else {
            Dafny.ISequence<char> _3_rightVal = (_2_valueOrError1).Extract();
            Dafny.ISequence<Dafny.ISequence<char>> _4_leftParts = StandardLibrary_Compile.__default.Split<char>(_1_leftVal, ((b).dtor_cmp).dtor_split);
            Dafny.ISequence<Dafny.ISequence<char>> _5_rightParts = StandardLibrary_Compile.__default.Split<char>(_3_rightVal, ((b).dtor_cmp).dtor_split);
            _System._ITuple2<Dafny.ISequence<Dafny.ISequence<char>>, Dafny.ISequence<Dafny.ISequence<char>>> _let_tmp_rhs0 = DynamoDBFilterExpr_Compile.__default.RemoveCommonPrefix(_4_leftParts, _5_rightParts);
            Dafny.ISequence<Dafny.ISequence<char>> _6_newLeft = _let_tmp_rhs0.dtor__0;
            Dafny.ISequence<Dafny.ISequence<char>> _7_newRight = _let_tmp_rhs0.dtor__1;
            Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _8_valueOrError2 = ((b).dtor_cmp).IsLessThanComparable(_6_newLeft);
            if ((_8_valueOrError2).IsFailure()) {
              return (_8_valueOrError2).PropagateFailure<bool>();
            } else {
              bool _9_leftCanLess = (_8_valueOrError2).Extract();
              Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _10_valueOrError3 = ((b).dtor_cmp).IsLessThanComparable(_7_newRight);
              if ((_10_valueOrError3).IsFailure()) {
                return (_10_valueOrError3).PropagateFailure<bool>();
              } else {
                bool _11_rightCanLess = (_10_valueOrError3).Extract();
                Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _12_valueOrError4 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>((_9_leftCanLess) && (_11_rightCanLess), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("To use BETWEEN with a compound beacon, the part after any common prefix must be LessThanComparable : "), Dafny.Sequence<char>.FromString("BETWEEN ")), _1_leftVal), Dafny.Sequence<char>.FromString(" AND ")), _3_rightVal)));
                if ((_12_valueOrError4).IsFailure()) {
                  return (_12_valueOrError4).PropagateFailure<bool>();
                } else {
                  return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(true);
                }
              }
            }
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<DynamoDBFilterExpr_Compile._IEqualityBeacon, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> BeaconForValue(SearchableEncryptionInfo_Compile._IBeaconVersion b, Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> expr, BigInteger pos, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> names, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> values)
    {
      if (((((pos) + (new BigInteger(2))) < (new BigInteger((expr).Count))) && (DynamoDBFilterExpr_Compile.__default.IsComp((expr).Select((pos) + (BigInteger.One))))) && (DynamoDBFilterExpr_Compile.__default.HasBeacon(b, (expr).Select((pos) + (new BigInteger(2))), names))) {
        return DynamoDBFilterExpr_Compile.__default.GetBeacon(b, (expr).Select((pos) + (new BigInteger(2))), (expr).Select((pos) + (BigInteger.One)), (expr).Select(pos), names, values);
      } else if ((((new BigInteger(2)) <= (pos)) && (DynamoDBFilterExpr_Compile.__default.IsComp((expr).Select((pos) - (BigInteger.One))))) && (DynamoDBFilterExpr_Compile.__default.HasBeacon(b, (expr).Select((pos) - (new BigInteger(2))), names))) {
        return DynamoDBFilterExpr_Compile.__default.GetBeacon(b, (expr).Select((pos) - (new BigInteger(2))), (expr).Select((pos) - (BigInteger.One)), (expr).Select(pos), names, values);
      } else if ((((((new BigInteger(4)) <= (pos)) && ((((expr).Select((pos) - (new BigInteger(4)))).is_Contains) || (((expr).Select((pos) - (new BigInteger(4)))).is_BeginsWith))) && (((expr).Select((pos) - (new BigInteger(3)))).is_Open)) && (DynamoDBFilterExpr_Compile.__default.HasBeacon(b, (expr).Select((pos) - (new BigInteger(2))), names))) && (((expr).Select((pos) - (BigInteger.One))).is_Comma)) {
        return DynamoDBFilterExpr_Compile.__default.GetBeacon(b, (expr).Select((pos) - (new BigInteger(2))), (expr).Select((pos) - (new BigInteger(4))), (expr).Select(pos), names, values);
      } else if (((((((new BigInteger(2)) <= (pos)) && ((pos) < ((new BigInteger((expr).Count)) - (new BigInteger(2))))) && ((((expr).Select((pos) - (new BigInteger(2)))).is_Contains) || (((expr).Select((pos) - (new BigInteger(2)))).is_BeginsWith))) && (((expr).Select((pos) - (BigInteger.One))).is_Open)) && (DynamoDBFilterExpr_Compile.__default.HasBeacon(b, (expr).Select((pos) + (new BigInteger(2))), names))) && (((expr).Select((pos) + (BigInteger.One))).is_Comma)) {
        return DynamoDBFilterExpr_Compile.__default.GetBeacon(b, (expr).Select((pos) + (new BigInteger(2))), (expr).Select((pos) - (new BigInteger(2))), (expr).Select(pos), names, values);
      } else if ((((((new BigInteger(2)) <= (pos)) && ((pos) < ((new BigInteger((expr).Count)) - (new BigInteger(2))))) && (((expr).Select((pos) - (BigInteger.One))).is_Between)) && (DynamoDBFilterExpr_Compile.__default.HasBeacon(b, (expr).Select((pos) - (new BigInteger(2))), names))) && (((expr).Select((pos) + (new BigInteger(2)))).is_Value)) {
        return DynamoDBFilterExpr_Compile.__default.GetBetweenBeacon(b, (expr).Select((pos) - (new BigInteger(2))), (expr).Select((pos) - (BigInteger.One)), (expr).Select(pos), (expr).Select((pos) + (new BigInteger(2))), names, values);
      } else if ((((((new BigInteger(4)) <= (pos)) && (((expr).Select((pos) - (BigInteger.One))).is_And)) && (((expr).Select((pos) - (new BigInteger(3)))).is_Between)) && (DynamoDBFilterExpr_Compile.__default.HasBeacon(b, (expr).Select((pos) - (new BigInteger(4))), names))) && (((expr).Select((pos) - (new BigInteger(2)))).is_Value)) {
        return DynamoDBFilterExpr_Compile.__default.GetBetweenBeacon(b, (expr).Select((pos) - (new BigInteger(4))), (expr).Select((pos) - (new BigInteger(3))), (expr).Select((pos) - (new BigInteger(2))), (expr).Select(pos), names, values);
      } else if (((expr).Select(pos)).is_Value) {
        Wrappers_Compile._IOption<BigInteger> _0_in__pos = DynamoDBFilterExpr_Compile.__default.GetInPos(expr, pos);
        if ((_0_in__pos).is_None) {
          return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IEqualityBeacon, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(DynamoDBFilterExpr_Compile.EqualityBeacon.create(Wrappers_Compile.Option<SearchableEncryptionInfo_Compile._IBeacon>.create_None(), true, false));
        } else if (DynamoDBFilterExpr_Compile.__default.HasBeacon(b, (expr).Select(((_0_in__pos).dtor_value) - (BigInteger.One)), names)) {
          return DynamoDBFilterExpr_Compile.__default.GetBeacon(b, (expr).Select(((_0_in__pos).dtor_value) - (BigInteger.One)), (expr).Select((_0_in__pos).dtor_value), (expr).Select(pos), names, values);
        } else {
          return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IEqualityBeacon, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(DynamoDBFilterExpr_Compile.EqualityBeacon.create(Wrappers_Compile.Option<SearchableEncryptionInfo_Compile._IBeacon>.create_None(), true, false));
        }
      } else {
        return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IEqualityBeacon, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(DynamoDBFilterExpr_Compile.EqualityBeacon.create(Wrappers_Compile.Option<SearchableEncryptionInfo_Compile._IBeacon>.create_None(), true, false));
      }
    }
    public static Wrappers_Compile._IOption<DynamoDBFilterExpr_Compile._IToken> AttrForValue(Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> expr, BigInteger pos)
    {
      if (((((pos) + (new BigInteger(2))) < (new BigInteger((expr).Count))) && (DynamoDBFilterExpr_Compile.__default.IsComp((expr).Select((pos) + (BigInteger.One))))) && (((expr).Select((pos) + (new BigInteger(2)))).is_Attr)) {
        return Wrappers_Compile.Option<DynamoDBFilterExpr_Compile._IToken>.create_Some((expr).Select((pos) + (new BigInteger(2))));
      } else if ((((new BigInteger(2)) <= (pos)) && (DynamoDBFilterExpr_Compile.__default.IsComp((expr).Select((pos) - (BigInteger.One))))) && (((expr).Select((pos) - (new BigInteger(2)))).is_Attr)) {
        return Wrappers_Compile.Option<DynamoDBFilterExpr_Compile._IToken>.create_Some((expr).Select((pos) - (new BigInteger(2))));
      } else if ((((((new BigInteger(4)) <= (pos)) && ((((expr).Select((pos) - (new BigInteger(4)))).is_Contains) || (((expr).Select((pos) - (new BigInteger(4)))).is_BeginsWith))) && (((expr).Select((pos) - (new BigInteger(3)))).is_Open)) && (((expr).Select((pos) - (new BigInteger(2)))).is_Attr)) && (((expr).Select((pos) - (BigInteger.One))).is_Comma)) {
        return Wrappers_Compile.Option<DynamoDBFilterExpr_Compile._IToken>.create_Some((expr).Select((pos) - (new BigInteger(2))));
      } else if ((((new BigInteger(2)) <= (pos)) && (((expr).Select((pos) - (BigInteger.One))).is_Between)) && (((expr).Select((pos) - (new BigInteger(2)))).is_Attr)) {
        return Wrappers_Compile.Option<DynamoDBFilterExpr_Compile._IToken>.create_Some((expr).Select((pos) - (new BigInteger(2))));
      } else if (((((new BigInteger(4)) <= (pos)) && (((expr).Select((pos) - (BigInteger.One))).is_And)) && (((expr).Select((pos) - (new BigInteger(3)))).is_Between)) && (((expr).Select((pos) - (new BigInteger(4)))).is_Attr)) {
        return Wrappers_Compile.Option<DynamoDBFilterExpr_Compile._IToken>.create_Some((expr).Select((pos) - (new BigInteger(4))));
      } else {
        Wrappers_Compile._IOption<BigInteger> _0_in__pos = DynamoDBFilterExpr_Compile.__default.GetInPos(expr, pos);
        if ((_0_in__pos).is_None) {
          return Wrappers_Compile.Option<DynamoDBFilterExpr_Compile._IToken>.create_None();
        } else if (((expr).Select(((_0_in__pos).dtor_value) - (BigInteger.One))).is_Attr) {
          return Wrappers_Compile.Option<DynamoDBFilterExpr_Compile._IToken>.create_Some((expr).Select(((_0_in__pos).dtor_value) - (BigInteger.One)));
        } else {
          return Wrappers_Compile.Option<DynamoDBFilterExpr_Compile._IToken>.create_None();
        }
      }
    }
    public static bool OpNeedsBeacon(Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> expr, BigInteger pos)
    {
      if ((pos) < (new BigInteger(2))) {
        return true;
      } else if (!(((expr).Select((pos) - (BigInteger.One))).is_Open)) {
        return true;
      } else {
        return DynamoDBFilterExpr_Compile.__default.TokenNeedsBeacon((expr).Select((pos) - (new BigInteger(2))));
      }
    }
    public static bool IsAllowedOnBeaconPred(Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> expr, BigInteger pos)
    {
      if ((pos) < (new BigInteger(2))) {
        return true;
      } else if (!(((expr).Select((pos) - (BigInteger.One))).is_Open)) {
        return true;
      } else if (DynamoDBFilterExpr_Compile.__default.TokenAllowsBeacon((expr).Select((pos) - (new BigInteger(2))))) {
        return true;
      } else {
        return false;
      }
    }
    public static Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> IsAllowedOnBeacon(Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> expr, BigInteger pos, Dafny.ISequence<char> name)
    {
      if (DynamoDBFilterExpr_Compile.__default.IsAllowedOnBeaconPred(expr, pos)) {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(true);
      } else {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Function "), DynamoDBFilterExpr_Compile.__default.TokenToString((expr).Select((pos) - (new BigInteger(2))))), Dafny.Sequence<char>.FromString(" cannot be used on encrypted fields, but it is being used with ")), name)));
      }
    }
    public static bool TokenNeedsBeacon(DynamoDBFilterExpr_Compile._IToken t) {
      return !(((t).is_AttributeExists) || ((t).is_AttributeNotExists));
    }
    public static bool TokenAllowsBeacon(DynamoDBFilterExpr_Compile._IToken t) {
      return !(((t).is_AttributeType) || ((t).is_Size));
    }
    public static Wrappers_Compile._IResult<DynamoDBFilterExpr_Compile._IParsedContext, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> BeaconizeParsedExpr(SearchableEncryptionInfo_Compile._IBeaconVersion b, Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> expr, BigInteger pos, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> oldValues, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> names, DynamoDbEncryptionUtil_Compile._IMaybeKeyMap keys, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> newValues, Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> acc)
    {
    TAIL_CALL_START: ;
      if ((pos) == (new BigInteger((expr).Count))) {
        return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IParsedContext, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(DynamoDBFilterExpr_Compile.ParsedContext.create(acc, newValues, names));
      } else if (((expr).Select(pos)).is_Attr) {
        bool _0_isIndirectName = Dafny.Sequence<char>.IsPrefixOf(Dafny.Sequence<char>.FromString("#"), ((expr).Select(pos)).dtor_s);
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _1_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>((!(_0_isIndirectName)) || (((names).is_Some) && (((names).dtor_value).Contains(((expr).Select(pos)).dtor_s))), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Name "), ((expr).Select(pos)).dtor_s), Dafny.Sequence<char>.FromString(" not in ExpressionAttributeNameMap."))));
        if ((_1_valueOrError0).IsFailure()) {
          return (_1_valueOrError0).PropagateFailure<DynamoDBFilterExpr_Compile._IParsedContext>();
        } else {
          Dafny.ISequence<char> _2_oldName = ((_0_isIndirectName) ? (Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Select((names).dtor_value,((expr).Select(pos)).dtor_s)) : (((expr).Select(pos)).dtor_s));
          bool _3_exclude = ((keys).is_DontUseKeys) && (!(DynamoDBFilterExpr_Compile.__default.IsAllowedOnBeaconPred(expr, pos)));
          if (((b).IsBeacon(_2_oldName)) && (!(_3_exclude))) {
            Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _4_valueOrError1 = DynamoDBFilterExpr_Compile.__default.IsAllowedOnBeacon(expr, pos, _2_oldName);
            if ((_4_valueOrError1).IsFailure()) {
              return (_4_valueOrError1).PropagateFailure<DynamoDBFilterExpr_Compile._IParsedContext>();
            } else {
              bool _5___v4 = (_4_valueOrError1).Extract();
              if (DynamoDBFilterExpr_Compile.__default.OpNeedsBeacon(expr, pos)) {
                Dafny.ISequence<char> _6_newName = (Dafny.Map<Dafny.ISequence<char>, SearchableEncryptionInfo_Compile._IBeacon>.Select((b).dtor_beacons,_2_oldName)).getBeaconName();
                if (_0_isIndirectName) {
                  SearchableEncryptionInfo_Compile._IBeaconVersion _in0 = b;
                  Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in1 = expr;
                  BigInteger _in2 = (pos) + (BigInteger.One);
                  Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in3 = oldValues;
                  Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> _in4 = Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>.create_Some(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Update((names).dtor_value, ((expr).Select(pos)).dtor_s, _6_newName));
                  DynamoDbEncryptionUtil_Compile._IMaybeKeyMap _in5 = keys;
                  Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in6 = newValues;
                  Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in7 = Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.Concat(acc, Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.FromElements((expr).Select(pos)));
                  b = _in0;
                  expr = _in1;
                  pos = _in2;
                  oldValues = _in3;
                  names = _in4;
                  keys = _in5;
                  newValues = _in6;
                  acc = _in7;
                  goto TAIL_CALL_START;
                } else {
                  SearchableEncryptionInfo_Compile._IBeaconVersion _in8 = b;
                  Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in9 = expr;
                  BigInteger _in10 = (pos) + (BigInteger.One);
                  Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in11 = oldValues;
                  Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> _in12 = names;
                  DynamoDbEncryptionUtil_Compile._IMaybeKeyMap _in13 = keys;
                  Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in14 = newValues;
                  Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in15 = Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.Concat(acc, Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.FromElements(DynamoDBFilterExpr_Compile.Token.create_Attr(_6_newName, TermLoc_Compile.__default.TermLocMap(_6_newName))));
                  b = _in8;
                  expr = _in9;
                  pos = _in10;
                  oldValues = _in11;
                  names = _in12;
                  keys = _in13;
                  newValues = _in14;
                  acc = _in15;
                  goto TAIL_CALL_START;
                }
              } else {
                SearchableEncryptionInfo_Compile._IBeaconVersion _in16 = b;
                Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in17 = expr;
                BigInteger _in18 = (pos) + (BigInteger.One);
                Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in19 = oldValues;
                Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> _in20 = names;
                DynamoDbEncryptionUtil_Compile._IMaybeKeyMap _in21 = keys;
                Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in22 = newValues;
                Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in23 = Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.Concat(acc, Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.FromElements((expr).Select(pos)));
                b = _in16;
                expr = _in17;
                pos = _in18;
                oldValues = _in19;
                names = _in20;
                keys = _in21;
                newValues = _in22;
                acc = _in23;
                goto TAIL_CALL_START;
              }
            }
          } else {
            SearchableEncryptionInfo_Compile._IBeaconVersion _in24 = b;
            Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in25 = expr;
            BigInteger _in26 = (pos) + (BigInteger.One);
            Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in27 = oldValues;
            Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> _in28 = names;
            DynamoDbEncryptionUtil_Compile._IMaybeKeyMap _in29 = keys;
            Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in30 = newValues;
            Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in31 = Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.Concat(acc, Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.FromElements((expr).Select(pos)));
            b = _in24;
            expr = _in25;
            pos = _in26;
            oldValues = _in27;
            names = _in28;
            keys = _in29;
            newValues = _in30;
            acc = _in31;
            goto TAIL_CALL_START;
          }
        }
      } else if (((expr).Select(pos)).is_Value) {
        Dafny.ISequence<char> _7_name = ((expr).Select(pos)).dtor_s;
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _8_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>((oldValues).Contains(_7_name), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(_7_name, Dafny.Sequence<char>.FromString(" not found in ExpressionAttributeValueMap"))));
        if ((_8_valueOrError2).IsFailure()) {
          return (_8_valueOrError2).PropagateFailure<DynamoDBFilterExpr_Compile._IParsedContext>();
        } else {
          software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue _9_oldValue = Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(oldValues,_7_name);
          Wrappers_Compile._IResult<DynamoDBFilterExpr_Compile._IEqualityBeacon, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _10_valueOrError3 = DynamoDBFilterExpr_Compile.__default.BeaconForValue(b, expr, pos, names, oldValues);
          if ((_10_valueOrError3).IsFailure()) {
            return (_10_valueOrError3).PropagateFailure<DynamoDBFilterExpr_Compile._IParsedContext>();
          } else {
            DynamoDBFilterExpr_Compile._IEqualityBeacon _11_eb = (_10_valueOrError3).Extract();
            Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _12_valueOrError4 = ((((_11_eb).dtor_beacon).is_None) ? (Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(_9_oldValue)) : ((((_11_eb).dtor_beacon).dtor_value).GetBeaconValue(_9_oldValue, keys, (_11_eb).dtor_forEquality, (_11_eb).dtor_forContains)));
            if ((_12_valueOrError4).IsFailure()) {
              return (_12_valueOrError4).PropagateFailure<DynamoDBFilterExpr_Compile._IParsedContext>();
            } else {
              software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue _13_newValue = (_12_valueOrError4).Extract();
              Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _14_valueOrError5 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>((!(newValues).Contains(_7_name)) || (object.Equals(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(newValues,_7_name), _13_newValue)), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(_7_name, Dafny.Sequence<char>.FromString(" used in two different contexts, which is not allowed."))));
              if ((_14_valueOrError5).IsFailure()) {
                return (_14_valueOrError5).PropagateFailure<DynamoDBFilterExpr_Compile._IParsedContext>();
              } else {
                SearchableEncryptionInfo_Compile._IBeaconVersion _in32 = b;
                Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in33 = expr;
                BigInteger _in34 = (pos) + (BigInteger.One);
                Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in35 = oldValues;
                Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> _in36 = names;
                DynamoDbEncryptionUtil_Compile._IMaybeKeyMap _in37 = keys;
                Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in38 = Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Update(newValues, _7_name, _13_newValue);
                Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in39 = Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.Concat(acc, Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.FromElements((expr).Select(pos)));
                b = _in32;
                expr = _in33;
                pos = _in34;
                oldValues = _in35;
                names = _in36;
                keys = _in37;
                newValues = _in38;
                acc = _in39;
                goto TAIL_CALL_START;
              }
            }
          }
        }
      } else {
        SearchableEncryptionInfo_Compile._IBeaconVersion _in40 = b;
        Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in41 = expr;
        BigInteger _in42 = (pos) + (BigInteger.One);
        Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in43 = oldValues;
        Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> _in44 = names;
        DynamoDbEncryptionUtil_Compile._IMaybeKeyMap _in45 = keys;
        Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in46 = newValues;
        Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in47 = Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.Concat(acc, Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.FromElements((expr).Select(pos)));
        b = _in40;
        expr = _in41;
        pos = _in42;
        oldValues = _in43;
        names = _in44;
        keys = _in45;
        newValues = _in46;
        acc = _in47;
        goto TAIL_CALL_START;
      }
    }
    public static Dafny.ISequence<char> ParsedExprToString(Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> t) {
      Dafny.ISequence<Dafny.ISequence<char>> _0_x = Seq_Compile.__default.Map<DynamoDBFilterExpr_Compile._IToken, Dafny.ISequence<char>>(((System.Func<DynamoDBFilterExpr_Compile._IToken, Dafny.ISequence<char>>)((_1_x) => {
        return DynamoDBFilterExpr_Compile.__default.TokenToString(_1_x);
      })), t);
      if ((new BigInteger((_0_x).Count)).Sign == 0) {
        return Dafny.Sequence<char>.FromString("");
      } else {
        return StandardLibrary_Compile.__default.Join<char>(_0_x, Dafny.Sequence<char>.FromString(" "));
      }
    }
    public static bool IsUnary(DynamoDBFilterExpr_Compile._IToken t) {
      DynamoDBFilterExpr_Compile._IToken _source0 = t;
      {
        if (_source0.is_Not) {
          return true;
        }
      }
      {
        return false;
      }
    }
    public static bool IsComp(DynamoDBFilterExpr_Compile._IToken t) {
      DynamoDBFilterExpr_Compile._IToken _source0 = t;
      {
        bool disjunctiveMatch0 = false;
        if (_source0.is_Eq) {
          disjunctiveMatch0 = true;
        }
        if (_source0.is_Ne) {
          disjunctiveMatch0 = true;
        }
        if (_source0.is_Lt) {
          disjunctiveMatch0 = true;
        }
        if (_source0.is_Gt) {
          disjunctiveMatch0 = true;
        }
        if (_source0.is_Le) {
          disjunctiveMatch0 = true;
        }
        if (_source0.is_Ge) {
          disjunctiveMatch0 = true;
        }
        if (disjunctiveMatch0) {
          return true;
        }
      }
      {
        return false;
      }
    }
    public static bool IsBinaryBool(DynamoDBFilterExpr_Compile._IToken t) {
      DynamoDBFilterExpr_Compile._IToken _source0 = t;
      {
        bool disjunctiveMatch0 = false;
        if (_source0.is_And) {
          disjunctiveMatch0 = true;
        }
        if (_source0.is_Or) {
          disjunctiveMatch0 = true;
        }
        if (disjunctiveMatch0) {
          return true;
        }
      }
      {
        return false;
      }
    }
    public static bool IsBinary(DynamoDBFilterExpr_Compile._IToken t) {
      return (DynamoDBFilterExpr_Compile.__default.IsComp(t)) || (DynamoDBFilterExpr_Compile.__default.IsBinaryBool(t));
    }
    public static bool IsVar(DynamoDBFilterExpr_Compile._IToken t) {
      DynamoDBFilterExpr_Compile._IToken _source0 = t;
      {
        if (_source0.is_Value) {
          Dafny.ISequence<char> _0_s = _source0.dtor_s;
          return true;
        }
      }
      {
        if (_source0.is_Attr) {
          Dafny.ISequence<char> _1_s = _source0.dtor_s;
          Dafny.ISequence<TermLoc_Compile._ISelector> _2_loc = _source0.dtor_loc;
          return true;
        }
      }
      {
        return false;
      }
    }
    public static bool IsFunction(DynamoDBFilterExpr_Compile._IToken t) {
      DynamoDBFilterExpr_Compile._IToken _source0 = t;
      {
        bool disjunctiveMatch0 = false;
        if (_source0.is_Between) {
          disjunctiveMatch0 = true;
        }
        if (_source0.is_In) {
          disjunctiveMatch0 = true;
        }
        if (_source0.is_AttributeExists) {
          disjunctiveMatch0 = true;
        }
        if (_source0.is_AttributeNotExists) {
          disjunctiveMatch0 = true;
        }
        if (_source0.is_AttributeType) {
          disjunctiveMatch0 = true;
        }
        if (_source0.is_BeginsWith) {
          disjunctiveMatch0 = true;
        }
        if (_source0.is_Contains) {
          disjunctiveMatch0 = true;
        }
        if (_source0.is_Size) {
          disjunctiveMatch0 = true;
        }
        if (disjunctiveMatch0) {
          return true;
        }
      }
      {
        return false;
      }
    }
    public static BigInteger Precedence(DynamoDBFilterExpr_Compile._IToken t) {
      DynamoDBFilterExpr_Compile._IToken _source0 = t;
      {
        if (_source0.is_Open) {
          return new BigInteger(11);
        }
      }
      {
        if (_source0.is_Close) {
          return new BigInteger(11);
        }
      }
      {
        if (_source0.is_Comma) {
          return new BigInteger(11);
        }
      }
      {
        if (_source0.is_Attr) {
          Dafny.ISequence<char> _0_s = _source0.dtor_s;
          Dafny.ISequence<TermLoc_Compile._ISelector> _1_loc = _source0.dtor_loc;
          return new BigInteger(10);
        }
      }
      {
        if (_source0.is_Value) {
          Dafny.ISequence<char> _2_s = _source0.dtor_s;
          return new BigInteger(10);
        }
      }
      {
        if (_source0.is_Eq) {
          return new BigInteger(9);
        }
      }
      {
        if (_source0.is_Ne) {
          return new BigInteger(9);
        }
      }
      {
        if (_source0.is_Lt) {
          return new BigInteger(9);
        }
      }
      {
        if (_source0.is_Gt) {
          return new BigInteger(9);
        }
      }
      {
        if (_source0.is_Le) {
          return new BigInteger(9);
        }
      }
      {
        if (_source0.is_Ge) {
          return new BigInteger(9);
        }
      }
      {
        if (_source0.is_In) {
          return new BigInteger(8);
        }
      }
      {
        if (_source0.is_Between) {
          return new BigInteger(7);
        }
      }
      {
        if (_source0.is_AttributeExists) {
          return new BigInteger(6);
        }
      }
      {
        if (_source0.is_AttributeNotExists) {
          return new BigInteger(6);
        }
      }
      {
        if (_source0.is_AttributeType) {
          return new BigInteger(6);
        }
      }
      {
        if (_source0.is_BeginsWith) {
          return new BigInteger(6);
        }
      }
      {
        if (_source0.is_Contains) {
          return new BigInteger(6);
        }
      }
      {
        if (_source0.is_Size) {
          return new BigInteger(6);
        }
      }
      {
        if (_source0.is_Not) {
          return new BigInteger(5);
        }
      }
      {
        if (_source0.is_And) {
          return new BigInteger(4);
        }
      }
      {
        return new BigInteger(3);
      }
    }
    public static Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> ParseExpr(Dafny.ISequence<char> s) {
      Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _0___accumulator = Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.FromElements();
    TAIL_CALL_START: ;
      _System._ITuple2<BigInteger, DynamoDBFilterExpr_Compile._IToken> _1_tup = DynamoDBFilterExpr_Compile.__default.FindIndexToken(s);
      if (((_1_tup).dtor__0).Sign == 1) {
        _0___accumulator = Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.Concat(_0___accumulator, Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.FromElements((_1_tup).dtor__1));
        Dafny.ISequence<char> _in0 = (s).Drop((_1_tup).dtor__0);
        s = _in0;
        goto TAIL_CALL_START;
      } else {
        return Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.Concat(_0___accumulator, Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.FromElements());
      }
    }
    public static byte ByteLower(byte ch) {
      if ((((byte)('A')) <= (ch)) && ((ch) <= ((byte)('Z')))) {
        return (byte)(((byte)((ch) - ((byte)('A')))) + ((byte)('a')));
      } else {
        return ch;
      }
    }
    public static char CharLower(char ch) {
      if ((('A') <= (ch)) && ((ch) <= ('Z'))) {
        return (char)(((char)((ch) - ('A'))) + ('a'));
      } else {
        return ch;
      }
    }
    public static Dafny.ISequence<char> strLower(Dafny.ISequence<char> s) {
      Dafny.ISequence<char> _0___accumulator = Dafny.Sequence<char>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((s).Count)).Sign == 0) {
        return Dafny.Sequence<char>.Concat(_0___accumulator, s);
      } else {
        _0___accumulator = Dafny.Sequence<char>.Concat(_0___accumulator, Dafny.Sequence<char>.FromElements(DynamoDBFilterExpr_Compile.__default.CharLower((s).Select(BigInteger.Zero))));
        Dafny.ISequence<char> _in0 = (s).Drop(BigInteger.One);
        s = _in0;
        goto TAIL_CALL_START;
      }
    }
    public static bool PrefixLower(Dafny.ISequence<char> pre, Dafny.ISequence<char> s)
    {
      return Dafny.Sequence<char>.IsPrefixOf(DynamoDBFilterExpr_Compile.__default.strLower(pre), DynamoDBFilterExpr_Compile.__default.strLower(s));
    }
    public static bool ValueChar(char ch) {
      if ((('a') <= (ch)) && ((ch) <= ('z'))) {
        return true;
      } else if ((('A') <= (ch)) && ((ch) <= ('Z'))) {
        return true;
      } else if ((('0') <= (ch)) && ((ch) <= ('9'))) {
        return true;
      } else if ((ch) == ('_')) {
        return true;
      } else {
        return false;
      }
    }
    public static bool AttributeChar(char ch) {
      if (DynamoDBFilterExpr_Compile.__default.ValueChar(ch)) {
        return true;
      } else if ((Dafny.Sequence<char>.FromElements(':', '[', ']', '.', '#')).Contains(ch)) {
        return true;
      } else {
        return false;
      }
    }
    public static BigInteger ValueLen(Dafny.ISequence<char> s) {
      BigInteger _0___accumulator = BigInteger.Zero;
    TAIL_CALL_START: ;
      if ((new BigInteger((s).Count)).Sign == 0) {
        return (BigInteger.Zero) + (_0___accumulator);
      } else if (DynamoDBFilterExpr_Compile.__default.ValueChar((s).Select(BigInteger.Zero))) {
        _0___accumulator = (BigInteger.One) + (_0___accumulator);
        Dafny.ISequence<char> _in0 = (s).Drop(BigInteger.One);
        s = _in0;
        goto TAIL_CALL_START;
      } else {
        return (BigInteger.Zero) + (_0___accumulator);
      }
    }
    public static BigInteger AttributeLen(Dafny.ISequence<char> s) {
      BigInteger _0___accumulator = BigInteger.Zero;
    TAIL_CALL_START: ;
      if ((new BigInteger((s).Count)).Sign == 0) {
        return (BigInteger.Zero) + (_0___accumulator);
      } else if (DynamoDBFilterExpr_Compile.__default.AttributeChar((s).Select(BigInteger.Zero))) {
        _0___accumulator = (BigInteger.One) + (_0___accumulator);
        Dafny.ISequence<char> _in0 = (s).Drop(BigInteger.One);
        s = _in0;
        goto TAIL_CALL_START;
      } else {
        return (BigInteger.Zero) + (_0___accumulator);
      }
    }
    public static DynamoDBFilterExpr_Compile._IToken MakeAttr(Dafny.ISequence<char> s) {
      Wrappers_Compile._IResult<Dafny.ISequence<TermLoc_Compile._ISelector>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_loc = TermLoc_Compile.__default.MakeTermLoc(s);
      if ((_0_loc).is_Success) {
        return DynamoDBFilterExpr_Compile.Token.create_Attr(s, (_0_loc).dtor_value);
      } else {
        return DynamoDBFilterExpr_Compile.Token.create_Attr(s, TermLoc_Compile.__default.TermLocMap(s));
      }
    }
    public static _System._ITuple2<BigInteger, DynamoDBFilterExpr_Compile._IToken> FindIndexToken(Dafny.ISequence<char> s) {
      if ((new BigInteger((s).Count)).Sign == 0) {
        return _System.Tuple2<BigInteger, DynamoDBFilterExpr_Compile._IToken>.create(BigInteger.Zero, DynamoDBFilterExpr_Compile.Token.create_Close());
      } else {
        char _0_ch = (s).Select(BigInteger.Zero);
        if ((_0_ch) == (' ')) {
          _System._ITuple2<BigInteger, DynamoDBFilterExpr_Compile._IToken> _1_foo = DynamoDBFilterExpr_Compile.__default.FindIndexToken((s).Drop(BigInteger.One));
          if (((_1_foo).dtor__0).Sign == 0) {
            return _System.Tuple2<BigInteger, DynamoDBFilterExpr_Compile._IToken>.create((_1_foo).dtor__0, (_1_foo).dtor__1);
          } else {
            return _System.Tuple2<BigInteger, DynamoDBFilterExpr_Compile._IToken>.create(((_1_foo).dtor__0) + (BigInteger.One), (_1_foo).dtor__1);
          }
        } else if ((_0_ch) == ('(')) {
          return _System.Tuple2<BigInteger, DynamoDBFilterExpr_Compile._IToken>.create(BigInteger.One, DynamoDBFilterExpr_Compile.Token.create_Open());
        } else if ((_0_ch) == (')')) {
          return _System.Tuple2<BigInteger, DynamoDBFilterExpr_Compile._IToken>.create(BigInteger.One, DynamoDBFilterExpr_Compile.Token.create_Close());
        } else if ((_0_ch) == (',')) {
          return _System.Tuple2<BigInteger, DynamoDBFilterExpr_Compile._IToken>.create(BigInteger.One, DynamoDBFilterExpr_Compile.Token.create_Comma());
        } else if ((_0_ch) == ('=')) {
          return _System.Tuple2<BigInteger, DynamoDBFilterExpr_Compile._IToken>.create(BigInteger.One, DynamoDBFilterExpr_Compile.Token.create_Eq());
        } else if ((_0_ch) == ('<')) {
          if (Dafny.Sequence<char>.IsPrefixOf(Dafny.Sequence<char>.FromString("<="), s)) {
            return _System.Tuple2<BigInteger, DynamoDBFilterExpr_Compile._IToken>.create(new BigInteger(2), DynamoDBFilterExpr_Compile.Token.create_Le());
          } else if (Dafny.Sequence<char>.IsPrefixOf(Dafny.Sequence<char>.FromString("<>"), s)) {
            return _System.Tuple2<BigInteger, DynamoDBFilterExpr_Compile._IToken>.create(new BigInteger(2), DynamoDBFilterExpr_Compile.Token.create_Ne());
          } else {
            return _System.Tuple2<BigInteger, DynamoDBFilterExpr_Compile._IToken>.create(BigInteger.One, DynamoDBFilterExpr_Compile.Token.create_Lt());
          }
        } else if ((_0_ch) == ('>')) {
          if (Dafny.Sequence<char>.IsPrefixOf(Dafny.Sequence<char>.FromString(">="), s)) {
            return _System.Tuple2<BigInteger, DynamoDBFilterExpr_Compile._IToken>.create(new BigInteger(2), DynamoDBFilterExpr_Compile.Token.create_Ge());
          } else {
            return _System.Tuple2<BigInteger, DynamoDBFilterExpr_Compile._IToken>.create(BigInteger.One, DynamoDBFilterExpr_Compile.Token.create_Gt());
          }
        } else if (DynamoDBFilterExpr_Compile.__default.PrefixLower(Dafny.Sequence<char>.FromString("in"), s)) {
          return _System.Tuple2<BigInteger, DynamoDBFilterExpr_Compile._IToken>.create(new BigInteger(2), DynamoDBFilterExpr_Compile.Token.create_In());
        } else if (DynamoDBFilterExpr_Compile.__default.PrefixLower(Dafny.Sequence<char>.FromString("between"), s)) {
          return _System.Tuple2<BigInteger, DynamoDBFilterExpr_Compile._IToken>.create(new BigInteger(7), DynamoDBFilterExpr_Compile.Token.create_Between());
        } else if (DynamoDBFilterExpr_Compile.__default.PrefixLower(Dafny.Sequence<char>.FromString("and"), s)) {
          return _System.Tuple2<BigInteger, DynamoDBFilterExpr_Compile._IToken>.create(new BigInteger(3), DynamoDBFilterExpr_Compile.Token.create_And());
        } else if (DynamoDBFilterExpr_Compile.__default.PrefixLower(Dafny.Sequence<char>.FromString("or"), s)) {
          return _System.Tuple2<BigInteger, DynamoDBFilterExpr_Compile._IToken>.create(new BigInteger(2), DynamoDBFilterExpr_Compile.Token.create_Or());
        } else if (DynamoDBFilterExpr_Compile.__default.PrefixLower(Dafny.Sequence<char>.FromString("not"), s)) {
          return _System.Tuple2<BigInteger, DynamoDBFilterExpr_Compile._IToken>.create(new BigInteger(3), DynamoDBFilterExpr_Compile.Token.create_Not());
        } else if (DynamoDBFilterExpr_Compile.__default.PrefixLower(Dafny.Sequence<char>.FromString("attribute_not_exists"), s)) {
          return _System.Tuple2<BigInteger, DynamoDBFilterExpr_Compile._IToken>.create(new BigInteger(20), DynamoDBFilterExpr_Compile.Token.create_AttributeNotExists());
        } else if (DynamoDBFilterExpr_Compile.__default.PrefixLower(Dafny.Sequence<char>.FromString("attribute_type"), s)) {
          return _System.Tuple2<BigInteger, DynamoDBFilterExpr_Compile._IToken>.create(new BigInteger(14), DynamoDBFilterExpr_Compile.Token.create_AttributeType());
        } else if (DynamoDBFilterExpr_Compile.__default.PrefixLower(Dafny.Sequence<char>.FromString("begins_with"), s)) {
          return _System.Tuple2<BigInteger, DynamoDBFilterExpr_Compile._IToken>.create(new BigInteger(11), DynamoDBFilterExpr_Compile.Token.create_BeginsWith());
        } else if (DynamoDBFilterExpr_Compile.__default.PrefixLower(Dafny.Sequence<char>.FromString("attribute_exists"), s)) {
          return _System.Tuple2<BigInteger, DynamoDBFilterExpr_Compile._IToken>.create(new BigInteger(16), DynamoDBFilterExpr_Compile.Token.create_AttributeExists());
        } else if (DynamoDBFilterExpr_Compile.__default.PrefixLower(Dafny.Sequence<char>.FromString("contains"), s)) {
          return _System.Tuple2<BigInteger, DynamoDBFilterExpr_Compile._IToken>.create(new BigInteger(8), DynamoDBFilterExpr_Compile.Token.create_Contains());
        } else if (DynamoDBFilterExpr_Compile.__default.PrefixLower(Dafny.Sequence<char>.FromString("size"), s)) {
          return _System.Tuple2<BigInteger, DynamoDBFilterExpr_Compile._IToken>.create(new BigInteger(4), DynamoDBFilterExpr_Compile.Token.create_Size());
        } else if ((_0_ch) == (':')) {
          BigInteger _2_x = (DynamoDBFilterExpr_Compile.__default.ValueLen((s).Drop(BigInteger.One))) + (BigInteger.One);
          return _System.Tuple2<BigInteger, DynamoDBFilterExpr_Compile._IToken>.create(_2_x, DynamoDBFilterExpr_Compile.Token.create_Value((s).Subsequence(BigInteger.Zero, _2_x)));
        } else if ((_0_ch) == ('#')) {
          BigInteger _3_x = (DynamoDBFilterExpr_Compile.__default.ValueLen((s).Drop(BigInteger.One))) + (BigInteger.One);
          return _System.Tuple2<BigInteger, DynamoDBFilterExpr_Compile._IToken>.create(_3_x, DynamoDBFilterExpr_Compile.__default.MakeAttr((s).Subsequence(BigInteger.Zero, _3_x)));
        } else {
          BigInteger _4_x = DynamoDBFilterExpr_Compile.__default.AttributeLen(s);
          return _System.Tuple2<BigInteger, DynamoDBFilterExpr_Compile._IToken>.create(_4_x, DynamoDBFilterExpr_Compile.__default.MakeAttr((s).Subsequence(BigInteger.Zero, _4_x)));
        }
      }
    }
    public static BigInteger VarOrSize(Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> input) {
      if ((new BigInteger((input).Count)).Sign == 0) {
        return BigInteger.Zero;
      } else if ((((input).Select(BigInteger.Zero)).is_Value) || (((input).Select(BigInteger.Zero)).is_Attr)) {
        return BigInteger.One;
      } else if ((((((new BigInteger(3)) < (new BigInteger((input).Count))) && (((input).Select(BigInteger.Zero)).is_Size)) && (((input).Select(BigInteger.One)).is_Open)) && (DynamoDBFilterExpr_Compile.__default.IsVar((input).Select(new BigInteger(2))))) && (((input).Select(new BigInteger(3))).is_Close)) {
        return new BigInteger(4);
      } else {
        return BigInteger.Zero;
      }
    }
    public static Wrappers_Compile._IOption<_System._ITuple3<BigInteger, BigInteger, BigInteger>> IsBetween(Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> input) {
      if ((new BigInteger((input).Count)) < (new BigInteger(5))) {
        return Wrappers_Compile.Option<_System._ITuple3<BigInteger, BigInteger, BigInteger>>.create_None();
      } else {
        BigInteger _0_p1 = DynamoDBFilterExpr_Compile.__default.VarOrSize(input);
        if ((((_0_p1).Sign == 1) && (((_0_p1) + (BigInteger.One)) < (new BigInteger((input).Count)))) && (((input).Select(_0_p1)).is_Between)) {
          BigInteger _1_p2 = DynamoDBFilterExpr_Compile.__default.VarOrSize((input).Drop((_0_p1) + (BigInteger.One)));
          if ((((_1_p2).Sign == 1) && ((((_0_p1) + (_1_p2)) + (new BigInteger(2))) < (new BigInteger((input).Count)))) && (((input).Select(((_0_p1) + (_1_p2)) + (BigInteger.One))).is_And)) {
            BigInteger _2_p3 = DynamoDBFilterExpr_Compile.__default.VarOrSize((input).Drop(((_0_p1) + (_1_p2)) + (new BigInteger(2))));
            if ((_2_p3).Sign == 1) {
              return Wrappers_Compile.Option<_System._ITuple3<BigInteger, BigInteger, BigInteger>>.create_Some(_System.Tuple3<BigInteger, BigInteger, BigInteger>.create(_0_p1, _1_p2, _2_p3));
            } else {
              return Wrappers_Compile.Option<_System._ITuple3<BigInteger, BigInteger, BigInteger>>.create_None();
            }
          } else {
            return Wrappers_Compile.Option<_System._ITuple3<BigInteger, BigInteger, BigInteger>>.create_None();
          }
        } else {
          return Wrappers_Compile.Option<_System._ITuple3<BigInteger, BigInteger, BigInteger>>.create_None();
        }
      }
    }
    public static bool IsIN(Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> input) {
      if ((new BigInteger((input).Count)) < (new BigInteger(3))) {
        return false;
      } else if (!(DynamoDBFilterExpr_Compile.__default.IsVar((input).Select(BigInteger.Zero)))) {
        return false;
      } else if (!object.Equals((input).Select(BigInteger.One), DynamoDBFilterExpr_Compile.Token.create_In())) {
        return false;
      } else if (!object.Equals((input).Select(new BigInteger(2)), DynamoDBFilterExpr_Compile.Token.create_Open())) {
        return false;
      } else {
        return true;
      }
    }
    public static Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> ConvertToPrefix(Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> input) {
      Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _0___accumulator = Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.FromElements();
    TAIL_CALL_START: ;
      Wrappers_Compile._IOption<_System._ITuple3<BigInteger, BigInteger, BigInteger>> _1_between = DynamoDBFilterExpr_Compile.__default.IsBetween(input);
      if ((new BigInteger((input).Count)) < (new BigInteger(5))) {
        return Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.Concat(_0___accumulator, input);
      } else if (DynamoDBFilterExpr_Compile.__default.IsIN(input)) {
        _0___accumulator = Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.Concat(_0___accumulator, Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.FromElements((input).Select(BigInteger.One), (input).Select(new BigInteger(2)), (input).Select(BigInteger.Zero), DynamoDBFilterExpr_Compile.Token.create_Comma()));
        Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in0 = (input).Drop(new BigInteger(3));
        input = _in0;
        goto TAIL_CALL_START;
      } else if ((_1_between).is_Some) {
        _System._ITuple3<BigInteger, BigInteger, BigInteger> _2_b = (_1_between).dtor_value;
        _0___accumulator = Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.Concat(_0___accumulator, Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.Concat(Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.Concat(Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.Concat(Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.Concat(Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.Concat(Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.Concat(Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.FromElements(DynamoDBFilterExpr_Compile.Token.create_Between(), DynamoDBFilterExpr_Compile.Token.create_Open()), (input).Subsequence(BigInteger.Zero, (_2_b).dtor__0)), Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.FromElements(DynamoDBFilterExpr_Compile.Token.create_Comma())), (input).Subsequence(((_2_b).dtor__0) + (BigInteger.One), (((_2_b).dtor__0) + ((_2_b).dtor__1)) + (BigInteger.One))), Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.FromElements(DynamoDBFilterExpr_Compile.Token.create_Comma())), (input).Subsequence((((_2_b).dtor__0) + ((_2_b).dtor__1)) + (new BigInteger(2)), ((((_2_b).dtor__0) + ((_2_b).dtor__1)) + ((_2_b).dtor__2)) + (new BigInteger(2)))), Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.FromElements(DynamoDBFilterExpr_Compile.Token.create_Close())));
        Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in1 = (input).Drop(((((_2_b).dtor__0) + ((_2_b).dtor__1)) + ((_2_b).dtor__2)) + (new BigInteger(2)));
        input = _in1;
        goto TAIL_CALL_START;
      } else {
        _0___accumulator = Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.Concat(_0___accumulator, Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.FromElements((input).Select(BigInteger.Zero)));
        Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in2 = (input).Drop(BigInteger.One);
        input = _in2;
        goto TAIL_CALL_START;
      }
    }
    public static Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> ConvertToRpn(Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> input) {
      Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _0_stack = Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.FromElements();
      return DynamoDBFilterExpr_Compile.__default.ConvertToRpn__inner(input, _0_stack);
    }
    public static Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> ConvertToRpn__inner(Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> input, Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> stack)
    {
      Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _0___accumulator = Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((input).Count)).Sign == 0) {
        if ((new BigInteger((stack).Count)).Sign == 0) {
          return Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.Concat(_0___accumulator, Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.FromElements());
        } else {
          _0___accumulator = Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.Concat(_0___accumulator, Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.FromElements((stack).Select((new BigInteger((stack).Count)) - (BigInteger.One))));
          Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in0 = input;
          Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in1 = (stack).Take((new BigInteger((stack).Count)) - (BigInteger.One));
          input = _in0;
          stack = _in1;
          goto TAIL_CALL_START;
        }
      } else {
        DynamoDBFilterExpr_Compile._IToken _source0 = (input).Select(BigInteger.Zero);
        {
          if (_source0.is_Attr) {
            Dafny.ISequence<char> _1_s = _source0.dtor_s;
            Dafny.ISequence<TermLoc_Compile._ISelector> _2_loc = _source0.dtor_loc;
            return Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.Concat(Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.FromElements((input).Select(BigInteger.Zero)), DynamoDBFilterExpr_Compile.__default.ConvertToRpn__inner((input).Drop(BigInteger.One), stack));
          }
        }
        {
          if (_source0.is_Value) {
            Dafny.ISequence<char> _3_s = _source0.dtor_s;
            return Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.Concat(Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.FromElements((input).Select(BigInteger.Zero)), DynamoDBFilterExpr_Compile.__default.ConvertToRpn__inner((input).Drop(BigInteger.One), stack));
          }
        }
        {
          bool disjunctiveMatch0 = false;
          if (_source0.is_Between) {
            disjunctiveMatch0 = true;
          }
          if (_source0.is_In) {
            disjunctiveMatch0 = true;
          }
          if (_source0.is_Not) {
            disjunctiveMatch0 = true;
          }
          if (_source0.is_AttributeExists) {
            disjunctiveMatch0 = true;
          }
          if (_source0.is_AttributeNotExists) {
            disjunctiveMatch0 = true;
          }
          if (_source0.is_AttributeType) {
            disjunctiveMatch0 = true;
          }
          if (_source0.is_BeginsWith) {
            disjunctiveMatch0 = true;
          }
          if (_source0.is_Contains) {
            disjunctiveMatch0 = true;
          }
          if (_source0.is_Size) {
            disjunctiveMatch0 = true;
          }
          if (disjunctiveMatch0) {
            Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in2 = (input).Drop(BigInteger.One);
            Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in3 = Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.Concat(stack, Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.FromElements((input).Select(BigInteger.Zero)));
            input = _in2;
            stack = _in3;
            goto TAIL_CALL_START;
          }
        }
        {
          if (_source0.is_Comma) {
            if ((new BigInteger((stack).Count)).Sign == 1) {
              if (DynamoDBFilterExpr_Compile.__default.IsFunction((stack).Select((new BigInteger((stack).Count)) - (BigInteger.One)))) {
                Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in4 = (input).Drop(BigInteger.One);
                Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in5 = stack;
                input = _in4;
                stack = _in5;
                goto TAIL_CALL_START;
              } else {
                return Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.Concat(Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.FromElements((stack).Select((new BigInteger((stack).Count)) - (BigInteger.One))), DynamoDBFilterExpr_Compile.__default.ConvertToRpn__inner((input).Drop(BigInteger.One), (stack).Take((new BigInteger((stack).Count)) - (BigInteger.One))));
              }
            } else {
              Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in6 = (input).Drop(BigInteger.One);
              Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in7 = stack;
              input = _in6;
              stack = _in7;
              goto TAIL_CALL_START;
            }
          }
        }
        {
          if (_source0.is_Close) {
            if ((new BigInteger((stack).Count)).Sign == 0) {
              Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in8 = (input).Drop(BigInteger.One);
              Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in9 = stack;
              input = _in8;
              stack = _in9;
              goto TAIL_CALL_START;
            } else if (object.Equals((stack).Select((new BigInteger((stack).Count)) - (BigInteger.One)), DynamoDBFilterExpr_Compile.Token.create_Open())) {
              Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in10 = (input).Drop(BigInteger.One);
              Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in11 = (stack).Take((new BigInteger((stack).Count)) - (BigInteger.One));
              input = _in10;
              stack = _in11;
              goto TAIL_CALL_START;
            } else {
              return Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.Concat(Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.FromElements((stack).Select((new BigInteger((stack).Count)) - (BigInteger.One))), DynamoDBFilterExpr_Compile.__default.ConvertToRpn__inner((input).Drop(BigInteger.One), (stack).Take((new BigInteger((stack).Count)) - (BigInteger.One))));
            }
          }
        }
        {
          bool disjunctiveMatch1 = false;
          if (_source0.is_Eq) {
            disjunctiveMatch1 = true;
          }
          if (_source0.is_Ne) {
            disjunctiveMatch1 = true;
          }
          if (_source0.is_Lt) {
            disjunctiveMatch1 = true;
          }
          if (_source0.is_Gt) {
            disjunctiveMatch1 = true;
          }
          if (_source0.is_Le) {
            disjunctiveMatch1 = true;
          }
          if (_source0.is_Ge) {
            disjunctiveMatch1 = true;
          }
          if (_source0.is_And) {
            disjunctiveMatch1 = true;
          }
          if (_source0.is_Or) {
            disjunctiveMatch1 = true;
          }
          if (disjunctiveMatch1) {
            if ((new BigInteger((stack).Count)).Sign == 0) {
              Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in12 = (input).Drop(BigInteger.One);
              Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in13 = Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.Concat(stack, Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.FromElements((input).Select(BigInteger.Zero)));
              input = _in12;
              stack = _in13;
              goto TAIL_CALL_START;
            } else if ((DynamoDBFilterExpr_Compile.__default.Precedence((stack).Select((new BigInteger((stack).Count)) - (BigInteger.One)))) >= (DynamoDBFilterExpr_Compile.__default.Precedence((input).Select(BigInteger.Zero)))) {
              return Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.Concat(Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.FromElements((stack).Select((new BigInteger((stack).Count)) - (BigInteger.One))), DynamoDBFilterExpr_Compile.__default.ConvertToRpn__inner(input, (stack).Take((new BigInteger((stack).Count)) - (BigInteger.One))));
            } else {
              Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in14 = (input).Drop(BigInteger.One);
              Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in15 = Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.Concat(stack, Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.FromElements((input).Select(BigInteger.Zero)));
              input = _in14;
              stack = _in15;
              goto TAIL_CALL_START;
            }
          }
        }
        {
          Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in16 = (input).Drop(BigInteger.One);
          Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in17 = stack;
          input = _in16;
          stack = _in17;
          goto TAIL_CALL_START;
        }
      }
    }
    public static BigInteger GetSize(software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue @value) {
      software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue _source0 = @value;
      {
        if (_source0.is_S) {
          Dafny.ISequence<char> _0_s = _source0.dtor_S;
          return new BigInteger((_0_s).Count);
        }
      }
      {
        if (_source0.is_N) {
          Dafny.ISequence<char> _1_n = _source0.dtor_N;
          return new BigInteger((_1_n).Count);
        }
      }
      {
        if (_source0.is_B) {
          Dafny.ISequence<byte> _2_n = _source0.dtor_B;
          return new BigInteger((_2_n).Count);
        }
      }
      {
        if (_source0.is_SS) {
          Dafny.ISequence<Dafny.ISequence<char>> _3_n = _source0.dtor_SS;
          return new BigInteger((_3_n).Count);
        }
      }
      {
        if (_source0.is_NS) {
          Dafny.ISequence<Dafny.ISequence<char>> _4_n = _source0.dtor_NS;
          return new BigInteger((_4_n).Count);
        }
      }
      {
        if (_source0.is_BS) {
          Dafny.ISequence<Dafny.ISequence<byte>> _5_n = _source0.dtor_BS;
          return new BigInteger((_5_n).Count);
        }
      }
      {
        if (_source0.is_M) {
          Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _6_n = _source0.dtor_M;
          return new BigInteger((_6_n).Count);
        }
      }
      {
        if (_source0.is_L) {
          Dafny.ISequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _7_n = _source0.dtor_L;
          return new BigInteger((_7_n).Count);
        }
      }
      {
        if (_source0.is_NULL) {
          bool _8_n = _source0.dtor_NULL;
          return BigInteger.One;
        }
      }
      {
        bool _9_n = _source0.dtor_BOOL;
        return BigInteger.One;
      }
    }
    public static software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue GetStr(DynamoDBFilterExpr_Compile._IStackValue s) {
      DynamoDBFilterExpr_Compile._IStackValue _source0 = s;
      {
        if (_source0.is_Bool) {
          bool _0_b = _source0.dtor_b;
          return software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_NULL(true);
        }
      }
      {
        if (_source0.is_Str) {
          software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue _1_s = _source0.dtor_s;
          return _1_s;
        }
      }
      {
        return software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_NULL(true);
      }
    }
    public static DynamoDBFilterExpr_Compile._IStackValue AsStr(Dafny.ISequence<char> s) {
      return DynamoDBFilterExpr_Compile.StackValue.create_Str(software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_S(s));
    }
    public static DynamoDBFilterExpr_Compile._IStackValue StackValueFromValue(Dafny.ISequence<char> s, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> values)
    {
      if ((values).Contains(s)) {
        return DynamoDBFilterExpr_Compile.StackValue.create_Str(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(values,s));
      } else {
        return DynamoDBFilterExpr_Compile.StackValue.create_DoesNotExist();
      }
    }
    public static DynamoDBFilterExpr_Compile._IStackValue StackValueFromItem(Dafny.ISequence<char> s, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item)
    {
      if ((item).Contains(s)) {
        return DynamoDBFilterExpr_Compile.StackValue.create_Str(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(item,s));
      } else {
        return DynamoDBFilterExpr_Compile.StackValue.create_DoesNotExist();
      }
    }
    public static DynamoDBFilterExpr_Compile._IStackValue StackValueFromAttr(DynamoDBFilterExpr_Compile._IToken t, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> names)
    {
      if (((names).is_Some) && (((names).dtor_value).Contains((t).dtor_s))) {
        return DynamoDBFilterExpr_Compile.__default.StackValueFromItem(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Select((names).dtor_value,(t).dtor_s), item);
      } else {
        Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _0_attr = TermLoc_Compile.__default.TermToAttr((t).dtor_loc, item, names);
        if ((_0_attr).is_Some) {
          return DynamoDBFilterExpr_Compile.StackValue.create_Str((_0_attr).dtor_value);
        } else {
          return DynamoDBFilterExpr_Compile.StackValue.create_DoesNotExist();
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetParsedExpr(Dafny.ISequence<char> input) {
      Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _0_seq1 = DynamoDBFilterExpr_Compile.__default.ParseExpr(input);
      Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _1_seq2 = DynamoDBFilterExpr_Compile.__default.ConvertToPrefix(_0_seq1);
      return Wrappers_Compile.Result<Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(DynamoDBFilterExpr_Compile.__default.ConvertToRpn(_1_seq2));
    }
    public static Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> EvalExpr(Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> input, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> names, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> values)
    {
      return DynamoDBFilterExpr_Compile.__default.InnerEvalExpr(input, Dafny.Sequence<DynamoDBFilterExpr_Compile._IStackValue>.FromElements(), item, names, values);
    }
    public static BigInteger StringsFollowing(Dafny.ISequence<DynamoDBFilterExpr_Compile._IStackValue> input) {
      BigInteger _0___accumulator = BigInteger.Zero;
    TAIL_CALL_START: ;
      if ((new BigInteger((input).Count)).Sign == 0) {
        return (BigInteger.Zero) + (_0___accumulator);
      } else if (!(((input).Select((new BigInteger((input).Count)) - (BigInteger.One))).is_Str)) {
        return (BigInteger.Zero) + (_0___accumulator);
      } else {
        _0___accumulator = (_0___accumulator) + (BigInteger.One);
        Dafny.ISequence<DynamoDBFilterExpr_Compile._IStackValue> _in0 = (input).Take((new BigInteger((input).Count)) - (BigInteger.One));
        input = _in0;
        goto TAIL_CALL_START;
      }
    }
    public static bool seq__contains<__T>(Dafny.ISequence<__T> haystack, Dafny.ISequence<__T> needle)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((needle).Count)).Sign == 0) {
        return true;
      } else if ((new BigInteger((haystack).Count)).Sign == 0) {
        return false;
      } else if ((new BigInteger((haystack).Count)) < (new BigInteger((needle).Count))) {
        return false;
      } else if ((object.Equals((needle).Select(BigInteger.Zero), (haystack).Select(BigInteger.Zero))) && (Dafny.Sequence<__T>.IsPrefixOf((needle).Drop(BigInteger.One), (haystack).Drop(BigInteger.One)))) {
        return true;
      } else {
        Dafny.ISequence<__T> _in0 = (haystack).Drop(BigInteger.One);
        Dafny.ISequence<__T> _in1 = needle;
        haystack = _in0;
        needle = _in1;
        goto TAIL_CALL_START;
      }
    }
    public static bool does__contain(software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue haystack, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue needle)
    {
      software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue _source0 = haystack;
      {
        if (_source0.is_S) {
          Dafny.ISequence<char> _0_s = _source0.dtor_S;
          if ((needle).is_S) {
            return DynamoDBFilterExpr_Compile.__default.seq__contains<char>((haystack).dtor_S, (needle).dtor_S);
          } else {
            return false;
          }
        }
      }
      {
        if (_source0.is_N) {
          Dafny.ISequence<char> _1_n = _source0.dtor_N;
          if ((needle).is_N) {
            return DynamoDBFilterExpr_Compile.__default.seq__contains<char>((haystack).dtor_N, (needle).dtor_N);
          } else {
            return false;
          }
        }
      }
      {
        if (_source0.is_B) {
          Dafny.ISequence<byte> _2_n = _source0.dtor_B;
          if ((needle).is_B) {
            return DynamoDBFilterExpr_Compile.__default.seq__contains<byte>((haystack).dtor_B, (needle).dtor_B);
          } else {
            return false;
          }
        }
      }
      {
        if (_source0.is_SS) {
          Dafny.ISequence<Dafny.ISequence<char>> _3_s = _source0.dtor_SS;
          if ((needle).is_S) {
            return ((haystack).dtor_SS).Contains((needle).dtor_S);
          } else {
            return false;
          }
        }
      }
      {
        if (_source0.is_NS) {
          Dafny.ISequence<Dafny.ISequence<char>> _4_s = _source0.dtor_NS;
          if ((needle).is_N) {
            return ((haystack).dtor_NS).Contains((needle).dtor_N);
          } else {
            return false;
          }
        }
      }
      {
        if (_source0.is_BS) {
          Dafny.ISequence<Dafny.ISequence<byte>> _5_s = _source0.dtor_BS;
          if ((needle).is_B) {
            return ((haystack).dtor_BS).Contains((needle).dtor_B);
          } else {
            return false;
          }
        }
      }
      {
        if (_source0.is_L) {
          Dafny.ISequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _6_list = _source0.dtor_L;
          return (_6_list).Contains(needle);
        }
      }
      {
        return false;
      }
    }
    public static bool begins__with(software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue haystack, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue needle)
    {
      software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue _source0 = haystack;
      {
        if (_source0.is_S) {
          Dafny.ISequence<char> _0_s = _source0.dtor_S;
          if ((needle).is_S) {
            return Dafny.Sequence<char>.IsPrefixOf((needle).dtor_S, (haystack).dtor_S);
          } else {
            return false;
          }
        }
      }
      {
        if (_source0.is_N) {
          Dafny.ISequence<char> _1_n = _source0.dtor_N;
          if ((needle).is_N) {
            return Dafny.Sequence<char>.IsPrefixOf((needle).dtor_N, (haystack).dtor_N);
          } else {
            return false;
          }
        }
      }
      {
        if (_source0.is_B) {
          Dafny.ISequence<byte> _2_n = _source0.dtor_B;
          if ((needle).is_B) {
            return Dafny.Sequence<byte>.IsPrefixOf((needle).dtor_B, (haystack).dtor_B);
          } else {
            return false;
          }
        }
      }
      {
        if (_source0.is_L) {
          Dafny.ISequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _3_list = _source0.dtor_L;
          if ((new BigInteger((_3_list).Count)).Sign == 0) {
            return false;
          } else if (object.Equals((_3_list).Select(BigInteger.Zero), needle)) {
            return true;
          } else if ((needle).is_L) {
            return Dafny.Sequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.IsPrefixOf((needle).dtor_L, _3_list);
          } else {
            return false;
          }
        }
      }
      {
        return false;
      }
    }
    public static Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> is__between(software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue middle, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue left, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue right)
    {
      Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = DynamoDBFilterExpr_Compile.__default.AttributeLE(left, middle);
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<bool>();
      } else {
        bool _1_leftRet = (_0_valueOrError0).Extract();
        Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _2_valueOrError1 = DynamoDBFilterExpr_Compile.__default.AttributeLE(middle, right);
        if ((_2_valueOrError1).IsFailure()) {
          return (_2_valueOrError1).PropagateFailure<bool>();
        } else {
          bool _3_rightRet = (_2_valueOrError1).Extract();
          return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success((_1_leftRet) && (_3_rightRet));
        }
      }
    }
    public static bool is__in(software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue target, Dafny.ISequence<DynamoDBFilterExpr_Compile._IStackValue> list)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((list).Count)).Sign == 0) {
        return false;
      } else if (object.Equals(DynamoDBFilterExpr_Compile.__default.GetStr((list).Select(BigInteger.Zero)), target)) {
        return true;
      } else {
        software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue _in0 = target;
        Dafny.ISequence<DynamoDBFilterExpr_Compile._IStackValue> _in1 = (list).Drop(BigInteger.One);
        target = _in0;
        list = _in1;
        goto TAIL_CALL_START;
      }
    }
    public static Dafny.ISequence<char> AttrToStr(software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue attr) {
      software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue _source0 = attr;
      {
        if (_source0.is_S) {
          Dafny.ISequence<char> _0_s = _source0.dtor_S;
          return _0_s;
        }
      }
      {
        if (_source0.is_N) {
          Dafny.ISequence<char> _1_n = _source0.dtor_N;
          return _1_n;
        }
      }
      {
        return Dafny.Sequence<char>.FromString("");
      }
    }
    public static bool IsAttrType(DynamoDBFilterExpr_Compile._IStackValue attr, DynamoDBFilterExpr_Compile._IStackValue typeStr)
    {
      return (DynamoDbEncryptionUtil_Compile.__default.AttrTypeToStr(DynamoDBFilterExpr_Compile.__default.GetStr(attr))).Equals(DynamoDBFilterExpr_Compile.__default.AttrToStr(DynamoDBFilterExpr_Compile.__default.GetStr(typeStr)));
    }
    public static Wrappers_Compile._IResult<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> apply__function(DynamoDBFilterExpr_Compile._IToken input, Dafny.ISequence<DynamoDBFilterExpr_Compile._IStackValue> stack, BigInteger num__args)
    {
      DynamoDBFilterExpr_Compile._IToken _source0 = input;
      {
        if (_source0.is_Between) {
          if ((new BigInteger((stack).Count)) < (new BigInteger(3))) {
            return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("No Stack for Between")));
          } else if (((((stack).Select((new BigInteger((stack).Count)) - (BigInteger.One))).is_Str) && (((stack).Select((new BigInteger((stack).Count)) - (new BigInteger(2)))).is_Str)) && (((stack).Select((new BigInteger((stack).Count)) - (new BigInteger(3)))).is_Str)) {
            Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = DynamoDBFilterExpr_Compile.__default.is__between(((stack).Select((new BigInteger((stack).Count)) - (new BigInteger(3)))).dtor_s, ((stack).Select((new BigInteger((stack).Count)) - (new BigInteger(2)))).dtor_s, ((stack).Select((new BigInteger((stack).Count)) - (BigInteger.One))).dtor_s);
            if ((_0_valueOrError0).IsFailure()) {
              return (_0_valueOrError0).PropagateFailure<DynamoDBFilterExpr_Compile._IStackValue>();
            } else {
              bool _1_ret = (_0_valueOrError0).Extract();
              return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(DynamoDBFilterExpr_Compile.StackValue.create_Bool(_1_ret));
            }
          } else {
            return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Wrong Types for contains")));
          }
        }
      }
      {
        if (_source0.is_In) {
          BigInteger _2_num = DynamoDBFilterExpr_Compile.__default.StringsFollowing(stack);
          if ((new BigInteger((stack).Count)) < (_2_num)) {
            return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Tautology False")));
          } else if ((_2_num).Sign == 0) {
            return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("In has no args")));
          } else {
            return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(DynamoDBFilterExpr_Compile.StackValue.create_Bool(DynamoDBFilterExpr_Compile.__default.is__in(DynamoDBFilterExpr_Compile.__default.GetStr((stack).Select((new BigInteger((stack).Count)) - (_2_num))), (stack).Drop(((new BigInteger((stack).Count)) - (_2_num)) + (BigInteger.One)))));
          }
        }
      }
      {
        if (_source0.is_AttributeExists) {
          if ((new BigInteger((stack).Count)) < (BigInteger.One)) {
            return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("No Stack for AttributeExists")));
          } else {
            return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(DynamoDBFilterExpr_Compile.StackValue.create_Bool(!(((stack).Select((new BigInteger((stack).Count)) - (BigInteger.One))).is_DoesNotExist)));
          }
        }
      }
      {
        if (_source0.is_AttributeNotExists) {
          if ((new BigInteger((stack).Count)) < (BigInteger.One)) {
            return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("No Stack for AttributeExists")));
          } else {
            return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(DynamoDBFilterExpr_Compile.StackValue.create_Bool(((stack).Select((new BigInteger((stack).Count)) - (BigInteger.One))).is_DoesNotExist));
          }
        }
      }
      {
        if (_source0.is_AttributeType) {
          if ((new BigInteger((stack).Count)) < (new BigInteger(2))) {
            return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("No Stack for AttributeType")));
          } else {
            return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(DynamoDBFilterExpr_Compile.StackValue.create_Bool(DynamoDBFilterExpr_Compile.__default.IsAttrType((stack).Select((new BigInteger((stack).Count)) - (new BigInteger(2))), (stack).Select((new BigInteger((stack).Count)) - (BigInteger.One)))));
          }
        }
      }
      {
        if (_source0.is_BeginsWith) {
          if ((new BigInteger((stack).Count)) < (new BigInteger(2))) {
            return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("No Stack for BeginsWith")));
          } else if ((((stack).Select((new BigInteger((stack).Count)) - (BigInteger.One))).is_Str) && (((stack).Select((new BigInteger((stack).Count)) - (new BigInteger(2)))).is_Str)) {
            return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(DynamoDBFilterExpr_Compile.StackValue.create_Bool(DynamoDBFilterExpr_Compile.__default.begins__with(((stack).Select((new BigInteger((stack).Count)) - (new BigInteger(2)))).dtor_s, ((stack).Select((new BigInteger((stack).Count)) - (BigInteger.One))).dtor_s)));
          } else {
            return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Wrong Types for BeginsWith")));
          }
        }
      }
      {
        if (_source0.is_Contains) {
          if ((new BigInteger((stack).Count)) < (new BigInteger(2))) {
            return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("No Stack for contains")));
          } else if ((((stack).Select((new BigInteger((stack).Count)) - (BigInteger.One))).is_Str) && (((stack).Select((new BigInteger((stack).Count)) - (new BigInteger(2)))).is_Str)) {
            return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(DynamoDBFilterExpr_Compile.StackValue.create_Bool(DynamoDBFilterExpr_Compile.__default.does__contain(((stack).Select((new BigInteger((stack).Count)) - (new BigInteger(2)))).dtor_s, ((stack).Select((new BigInteger((stack).Count)) - (BigInteger.One))).dtor_s)));
          } else {
            return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Wrong Types for contains")));
          }
        }
      }
      {
        if (_source0.is_Size) {
          if ((new BigInteger((stack).Count)) < (BigInteger.One)) {
            return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("No Stack for Size")));
          } else if (!(((stack).Select((new BigInteger((stack).Count)) - (BigInteger.One))).is_Str)) {
            return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Wrong Types for Size")));
          } else {
            BigInteger _3_n = DynamoDBFilterExpr_Compile.__default.GetSize(((stack).Select((new BigInteger((stack).Count)) - (BigInteger.One))).dtor_s);
            return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(DynamoDBFilterExpr_Compile.StackValue.create_Str(software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeValue.create_N(StandardLibrary_mString_Compile.__default.Base10Int2String(_3_n))));
          }
        }
      }
      {
        return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(DynamoDBFilterExpr_Compile.StackValue.create_Bool(true));
      }
    }
    public static Wrappers_Compile._IResult<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> apply__unary(DynamoDBFilterExpr_Compile._IToken input, DynamoDBFilterExpr_Compile._IStackValue stack)
    {
      if ((stack).is_Bool) {
        return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(DynamoDBFilterExpr_Compile.StackValue.create_Bool(!((stack).dtor_b)));
      } else {
        return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("wrong type for Not")));
      }
    }
    public static Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> apply__binary__bool(DynamoDBFilterExpr_Compile._IToken input, bool x, bool y)
    {
      DynamoDBFilterExpr_Compile._IToken _source0 = input;
      {
        if (_source0.is_And) {
          return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success((x) && (y));
        }
      }
      {
        if (_source0.is_Or) {
          return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success((x) || (y));
        }
      }
      {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("invalid op in apply_binary_bool")));
      }
    }
    public static bool IsHighSurrogate(char ch) {
      return (((char)(new BigInteger(55296))) <= (ch)) && ((ch) <= ((char)(new BigInteger(56319))));
    }
    public static bool UnicodeLess(Dafny.ISequence<char> a, Dafny.ISequence<char> b)
    {
    TAIL_CALL_START: ;
      if (((new BigInteger((a).Count)).Sign == 0) && ((new BigInteger((b).Count)).Sign == 0)) {
        return false;
      } else if ((new BigInteger((a).Count)).Sign == 0) {
        return true;
      } else if ((new BigInteger((b).Count)).Sign == 0) {
        return false;
      } else if (((a).Select(BigInteger.Zero)) == ((b).Select(BigInteger.Zero))) {
        Dafny.ISequence<char> _in0 = (a).Drop(BigInteger.One);
        Dafny.ISequence<char> _in1 = (b).Drop(BigInteger.One);
        a = _in0;
        b = _in1;
        goto TAIL_CALL_START;
      } else {
        bool _0_aIsHighSurrogate = DynamoDBFilterExpr_Compile.__default.IsHighSurrogate((a).Select(BigInteger.Zero));
        bool _1_bIsHighSurrogate = DynamoDBFilterExpr_Compile.__default.IsHighSurrogate((b).Select(BigInteger.Zero));
        if ((_0_aIsHighSurrogate) == (_1_bIsHighSurrogate)) {
          return ((a).Select(BigInteger.Zero)) < ((b).Select(BigInteger.Zero));
        } else {
          return _1_bIsHighSurrogate;
        }
      }
    }
    public static bool UnicodeLessOrEqual(Dafny.ISequence<char> a, Dafny.ISequence<char> b)
    {
      return !(DynamoDBFilterExpr_Compile.__default.UnicodeLess(b, a));
    }
    public static Wrappers_Compile._IResult<sbyte, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> CompareFloat(Dafny.ISequence<char> x, Dafny.ISequence<char> y)
    {
      Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(DynamoDbNormalizeNumber_Compile.__default.NormalizeNumber(x), ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>)((_1_e) => {
        return DynamoDbEncryptionUtil_Compile.__default.E(_1_e);
      })));
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<sbyte>();
      } else {
        Dafny.ISequence<char> _2_newX = (_0_valueOrError0).Extract();
        Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _3_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(DynamoDbNormalizeNumber_Compile.__default.NormalizeNumber(y), ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>)((_4_e) => {
          return DynamoDbEncryptionUtil_Compile.__default.E(_4_e);
        })));
        if ((_3_valueOrError1).IsFailure()) {
          return (_3_valueOrError1).PropagateFailure<sbyte>();
        } else {
          Dafny.ISequence<char> _5_newY = (_3_valueOrError1).Extract();
          return Wrappers_Compile.Result<sbyte, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(FloatCompare_Compile.__default.CompareFloat(_2_newX, _5_newY));
        }
      }
    }
    public static Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> AttributeEQ(software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue a, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue b)
    {
      if (((a).is_N) && ((b).is_N)) {
        Wrappers_Compile._IResult<sbyte, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = DynamoDBFilterExpr_Compile.__default.CompareFloat((a).dtor_N, (b).dtor_N);
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<bool>();
        } else {
          sbyte _1_ret = (_0_valueOrError0).Extract();
          return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success((_1_ret) == ((sbyte)(0)));
        }
      } else {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(object.Equals(a, b));
      }
    }
    public static Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> AttributeNE(software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue a, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue b)
    {
      Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = DynamoDBFilterExpr_Compile.__default.AttributeEQ(a, b);
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<bool>();
      } else {
        bool _1_ret = (_0_valueOrError0).Extract();
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(!(_1_ret));
      }
    }
    public static Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> AttributeLE(software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue a, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue b)
    {
      if (((a).is_N) && ((b).is_N)) {
        Wrappers_Compile._IResult<sbyte, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = DynamoDBFilterExpr_Compile.__default.CompareFloat((a).dtor_N, (b).dtor_N);
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<bool>();
        } else {
          sbyte _1_ret = (_0_valueOrError0).Extract();
          return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success((_1_ret) <= ((sbyte)(0)));
        }
      } else if (((a).is_S) && ((b).is_S)) {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(DynamoDBFilterExpr_Compile.__default.UnicodeLessOrEqual((a).dtor_S, (b).dtor_S));
      } else if (((a).is_B) && ((b).is_B)) {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(StandardLibrary_Compile.__default.LexicographicLessOrEqual<byte>((a).dtor_B, (b).dtor_B, DynamoDbEncryptionUtil_Compile.__default.ByteLess));
      } else {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(false);
      }
    }
    public static Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> AttributeLT(software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue a, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue b)
    {
      Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = DynamoDBFilterExpr_Compile.__default.AttributeLE(b, a);
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<bool>();
      } else {
        bool _1_ret = (_0_valueOrError0).Extract();
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(!(_1_ret));
      }
    }
    public static Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> AttributeGT(software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue a, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue b)
    {
      Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = DynamoDBFilterExpr_Compile.__default.AttributeLE(a, b);
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<bool>();
      } else {
        bool _1_ret = (_0_valueOrError0).Extract();
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(!(_1_ret));
      }
    }
    public static Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> AttributeGE(software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue a, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue b)
    {
      Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = DynamoDBFilterExpr_Compile.__default.AttributeLE(b, a);
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<bool>();
      } else {
        bool _1_ret = (_0_valueOrError0).Extract();
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(_1_ret);
      }
    }
    public static Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> apply__binary__comp(DynamoDBFilterExpr_Compile._IToken input, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue x, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue y)
    {
      DynamoDBFilterExpr_Compile._IToken _source0 = input;
      {
        if (_source0.is_Eq) {
          return DynamoDBFilterExpr_Compile.__default.AttributeEQ(x, y);
        }
      }
      {
        if (_source0.is_Ne) {
          return DynamoDBFilterExpr_Compile.__default.AttributeNE(x, y);
        }
      }
      {
        if (_source0.is_Le) {
          return DynamoDBFilterExpr_Compile.__default.AttributeLE(x, y);
        }
      }
      {
        if (_source0.is_Lt) {
          return DynamoDBFilterExpr_Compile.__default.AttributeLT(x, y);
        }
      }
      {
        if (_source0.is_Ge) {
          return DynamoDBFilterExpr_Compile.__default.AttributeGE(x, y);
        }
      }
      {
        if (_source0.is_Gt) {
          return DynamoDBFilterExpr_Compile.__default.AttributeGT(x, y);
        }
      }
      {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("invalid op in apply_binary_bool")));
      }
    }
    public static Wrappers_Compile._IResult<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> apply__binary(DynamoDBFilterExpr_Compile._IToken input, DynamoDBFilterExpr_Compile._IStackValue x, DynamoDBFilterExpr_Compile._IStackValue y)
    {
      if (DynamoDBFilterExpr_Compile.__default.IsComp(input)) {
        if (((x).is_Str) && ((y).is_Str)) {
          Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = DynamoDBFilterExpr_Compile.__default.apply__binary__comp(input, (x).dtor_s, (y).dtor_s);
          if ((_0_valueOrError0).IsFailure()) {
            return (_0_valueOrError0).PropagateFailure<DynamoDBFilterExpr_Compile._IStackValue>();
          } else {
            bool _1_val = (_0_valueOrError0).Extract();
            return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(DynamoDBFilterExpr_Compile.StackValue.create_Bool(_1_val));
          }
        } else {
          return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("wrong types for comparison")));
        }
      } else if (((x).is_Bool) && ((y).is_Bool)) {
        Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _2_valueOrError1 = DynamoDBFilterExpr_Compile.__default.apply__binary__bool(input, (x).dtor_b, (y).dtor_b);
        if ((_2_valueOrError1).IsFailure()) {
          return (_2_valueOrError1).PropagateFailure<DynamoDBFilterExpr_Compile._IStackValue>();
        } else {
          bool _3_val = (_2_valueOrError1).Extract();
          return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(DynamoDBFilterExpr_Compile.StackValue.create_Bool(_3_val));
        }
      } else {
        return Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("wrong types for boolean binary")));
      }
    }
    public static BigInteger NumArgs(DynamoDBFilterExpr_Compile._IToken t, Dafny.ISequence<DynamoDBFilterExpr_Compile._IStackValue> stack)
    {
      DynamoDBFilterExpr_Compile._IToken _source0 = t;
      {
        if (_source0.is_Between) {
          return new BigInteger(3);
        }
      }
      {
        if (_source0.is_In) {
          return DynamoDBFilterExpr_Compile.__default.StringsFollowing(stack);
        }
      }
      {
        if (_source0.is_AttributeExists) {
          return BigInteger.One;
        }
      }
      {
        if (_source0.is_AttributeNotExists) {
          return BigInteger.One;
        }
      }
      {
        if (_source0.is_AttributeType) {
          return new BigInteger(2);
        }
      }
      {
        if (_source0.is_BeginsWith) {
          return new BigInteger(2);
        }
      }
      {
        if (_source0.is_Contains) {
          return new BigInteger(2);
        }
      }
      {
        if (_source0.is_Size) {
          return BigInteger.One;
        }
      }
      {
        return BigInteger.Zero;
      }
    }
    public static Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> InnerEvalExpr(Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> input, Dafny.ISequence<DynamoDBFilterExpr_Compile._IStackValue> stack, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> names, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> values)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((input).Count)).Sign == 0) {
        if (((BigInteger.One) == (new BigInteger((stack).Count))) && (((stack).Select(BigInteger.Zero)).is_Bool)) {
          return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(((stack).Select(BigInteger.Zero)).dtor_b);
        } else {
          return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("ended with bad stack")));
        }
      } else {
        DynamoDBFilterExpr_Compile._IToken _0_t = (input).Select(BigInteger.Zero);
        if ((_0_t).is_Value) {
          Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in0 = (input).Drop(BigInteger.One);
          Dafny.ISequence<DynamoDBFilterExpr_Compile._IStackValue> _in1 = Dafny.Sequence<DynamoDBFilterExpr_Compile._IStackValue>.Concat(stack, Dafny.Sequence<DynamoDBFilterExpr_Compile._IStackValue>.FromElements(DynamoDBFilterExpr_Compile.__default.StackValueFromValue((_0_t).dtor_s, values)));
          Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in2 = item;
          Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> _in3 = names;
          Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in4 = values;
          input = _in0;
          stack = _in1;
          item = _in2;
          names = _in3;
          values = _in4;
          goto TAIL_CALL_START;
        } else if ((_0_t).is_Attr) {
          Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in5 = (input).Drop(BigInteger.One);
          Dafny.ISequence<DynamoDBFilterExpr_Compile._IStackValue> _in6 = Dafny.Sequence<DynamoDBFilterExpr_Compile._IStackValue>.Concat(stack, Dafny.Sequence<DynamoDBFilterExpr_Compile._IStackValue>.FromElements(DynamoDBFilterExpr_Compile.__default.StackValueFromAttr(_0_t, item, names)));
          Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in7 = item;
          Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> _in8 = names;
          Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in9 = values;
          input = _in5;
          stack = _in6;
          item = _in7;
          names = _in8;
          values = _in9;
          goto TAIL_CALL_START;
        } else if (DynamoDBFilterExpr_Compile.__default.IsUnary(_0_t)) {
          if ((new BigInteger((stack).Count)).Sign == 0) {
            return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Empty stack for unary op")));
          } else {
            Wrappers_Compile._IResult<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _1_valueOrError0 = DynamoDBFilterExpr_Compile.__default.apply__unary(_0_t, (stack).Select((new BigInteger((stack).Count)) - (BigInteger.One)));
            if ((_1_valueOrError0).IsFailure()) {
              return (_1_valueOrError0).PropagateFailure<bool>();
            } else {
              DynamoDBFilterExpr_Compile._IStackValue _2_val = (_1_valueOrError0).Extract();
              Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in10 = (input).Drop(BigInteger.One);
              Dafny.ISequence<DynamoDBFilterExpr_Compile._IStackValue> _in11 = Dafny.Sequence<DynamoDBFilterExpr_Compile._IStackValue>.Concat((stack).Take((new BigInteger((stack).Count)) - (BigInteger.One)), Dafny.Sequence<DynamoDBFilterExpr_Compile._IStackValue>.FromElements(_2_val));
              Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in12 = item;
              Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> _in13 = names;
              Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in14 = values;
              input = _in10;
              stack = _in11;
              item = _in12;
              names = _in13;
              values = _in14;
              goto TAIL_CALL_START;
            }
          }
        } else if (DynamoDBFilterExpr_Compile.__default.IsBinary(_0_t)) {
          if ((new BigInteger((stack).Count)) < (new BigInteger(2))) {
            return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Empty stack for binary op")));
          } else {
            Wrappers_Compile._IResult<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _3_valueOrError1 = DynamoDBFilterExpr_Compile.__default.apply__binary(_0_t, (stack).Select((new BigInteger((stack).Count)) - (new BigInteger(2))), (stack).Select((new BigInteger((stack).Count)) - (BigInteger.One)));
            if ((_3_valueOrError1).IsFailure()) {
              return (_3_valueOrError1).PropagateFailure<bool>();
            } else {
              DynamoDBFilterExpr_Compile._IStackValue _4_val = (_3_valueOrError1).Extract();
              Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in15 = (input).Drop(BigInteger.One);
              Dafny.ISequence<DynamoDBFilterExpr_Compile._IStackValue> _in16 = Dafny.Sequence<DynamoDBFilterExpr_Compile._IStackValue>.Concat((stack).Take((new BigInteger((stack).Count)) - (new BigInteger(2))), Dafny.Sequence<DynamoDBFilterExpr_Compile._IStackValue>.FromElements(_4_val));
              Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in17 = item;
              Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> _in18 = names;
              Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in19 = values;
              input = _in15;
              stack = _in16;
              item = _in17;
              names = _in18;
              values = _in19;
              goto TAIL_CALL_START;
            }
          }
        } else if (DynamoDBFilterExpr_Compile.__default.IsFunction(_0_t)) {
          BigInteger _5_num__args = DynamoDBFilterExpr_Compile.__default.NumArgs(_0_t, stack);
          if ((new BigInteger((stack).Count)) < (_5_num__args)) {
            return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Empty stack for function call")));
          } else {
            Wrappers_Compile._IResult<DynamoDBFilterExpr_Compile._IStackValue, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _6_valueOrError2 = DynamoDBFilterExpr_Compile.__default.apply__function(_0_t, stack, _5_num__args);
            if ((_6_valueOrError2).IsFailure()) {
              return (_6_valueOrError2).PropagateFailure<bool>();
            } else {
              DynamoDBFilterExpr_Compile._IStackValue _7_val = (_6_valueOrError2).Extract();
              Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in20 = (input).Drop(BigInteger.One);
              Dafny.ISequence<DynamoDBFilterExpr_Compile._IStackValue> _in21 = Dafny.Sequence<DynamoDBFilterExpr_Compile._IStackValue>.Concat((stack).Take((new BigInteger((stack).Count)) - (_5_num__args)), Dafny.Sequence<DynamoDBFilterExpr_Compile._IStackValue>.FromElements(_7_val));
              Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in22 = item;
              Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> _in23 = names;
              Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in24 = values;
              input = _in20;
              stack = _in21;
              item = _in22;
              names = _in23;
              values = _in24;
              goto TAIL_CALL_START;
            }
          }
        } else {
          return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(true);
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> FilterItems(SearchableEncryptionInfo_Compile._IBeaconVersion b, Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> parsed, Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> ItemList, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> names, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> values)
    {
      Wrappers_Compile._IResult<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = Wrappers_Compile.Result<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Sequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.Empty);
      Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> _0_acc;
      _0_acc = Dafny.Sequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.FromElements();
      BigInteger _hi0 = new BigInteger((ItemList).Count);
      for (BigInteger _1_i = BigInteger.Zero; _1_i < _hi0; _1_i++) {
        Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _2_valueOrError0 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
        Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
        _out0 = (b).GeneratePlainBeacons((ItemList).Select(_1_i));
        _2_valueOrError0 = _out0;
        if ((_2_valueOrError0).IsFailure()) {
          output = (_2_valueOrError0).PropagateFailure<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>();
          return output;
        }
        Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _3_newAttrs;
        _3_newAttrs = (_2_valueOrError0).Extract();
        Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _4_valueOrError1 = Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(false);
        _4_valueOrError1 = DynamoDBFilterExpr_Compile.__default.EvalExpr(parsed, Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Merge((ItemList).Select(_1_i), _3_newAttrs), names, values);
        if ((_4_valueOrError1).IsFailure()) {
          output = (_4_valueOrError1).PropagateFailure<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>();
          return output;
        }
        bool _5_doesMatch;
        _5_doesMatch = (_4_valueOrError1).Extract();
        if (_5_doesMatch) {
          _0_acc = Dafny.Sequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.Concat(_0_acc, Dafny.Sequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.FromElements((ItemList).Select(_1_i)));
        }
      }
      output = Wrappers_Compile.Result<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(_0_acc);
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> FilterResults(SearchableEncryptionInfo_Compile._IBeaconVersion b, Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> ItemList, Wrappers_Compile._IOption<Dafny.ISequence<char>> KeyExpression, Wrappers_Compile._IOption<Dafny.ISequence<char>> FilterExpression, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> names, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> values)
    {
      Wrappers_Compile._IResult<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = Wrappers_Compile.Result<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Sequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.Empty);
      if (((new BigInteger((ItemList).Count)).Sign == 0) || (((KeyExpression).is_None) && ((FilterExpression).is_None))) {
        output = Wrappers_Compile.Result<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(ItemList);
        return output;
      } else {
        Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> _0_afterKeys = Dafny.Sequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.Empty;
        if ((KeyExpression).is_Some) {
          Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _1_parsed;
          _1_parsed = DynamoDBFilterExpr_Compile.__default.ParseExpr((KeyExpression).dtor_value);
          Wrappers_Compile._IResult<DynamoDBFilterExpr_Compile._IParsedContext, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _2_valueOrError0 = Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IParsedContext, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(DynamoDBFilterExpr_Compile.ParsedContext.Default());
          _2_valueOrError0 = DynamoDBFilterExpr_Compile.__default.BeaconizeParsedExpr(b, _1_parsed, BigInteger.Zero, Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.UnwrapOr(values, Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.FromElements()), names, DynamoDbEncryptionUtil_Compile.MaybeKeyMap.create_DontUseKeys(), Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.FromElements(), Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.FromElements());
          if ((_2_valueOrError0).IsFailure()) {
            output = (_2_valueOrError0).PropagateFailure<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>();
            return output;
          }
          DynamoDBFilterExpr_Compile._IParsedContext _3_expr;
          _3_expr = (_2_valueOrError0).Extract();
          Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _4_expr1;
          _4_expr1 = DynamoDBFilterExpr_Compile.__default.ConvertToPrefix((_3_expr).dtor_expr);
          Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _5_expr2;
          _5_expr2 = DynamoDBFilterExpr_Compile.__default.ConvertToRpn(_4_expr1);
          Wrappers_Compile._IResult<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _6_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Sequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.Empty);
          Wrappers_Compile._IResult<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
          _out0 = DynamoDBFilterExpr_Compile.__default.FilterItems(b, _5_expr2, ItemList, (_3_expr).dtor_names, (_3_expr).dtor_values);
          _6_valueOrError1 = _out0;
          if ((_6_valueOrError1).IsFailure()) {
            output = (_6_valueOrError1).PropagateFailure<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>();
            return output;
          }
          _0_afterKeys = (_6_valueOrError1).Extract();
        } else {
          _0_afterKeys = ItemList;
        }
        if ((FilterExpression).is_Some) {
          Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _7_parsed;
          _7_parsed = DynamoDBFilterExpr_Compile.__default.ParseExpr((FilterExpression).dtor_value);
          Wrappers_Compile._IResult<DynamoDBFilterExpr_Compile._IParsedContext, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _8_valueOrError2 = Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IParsedContext, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(DynamoDBFilterExpr_Compile.ParsedContext.Default());
          _8_valueOrError2 = DynamoDBFilterExpr_Compile.__default.BeaconizeParsedExpr(b, _7_parsed, BigInteger.Zero, Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.UnwrapOr(values, Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.FromElements()), names, DynamoDbEncryptionUtil_Compile.MaybeKeyMap.create_DontUseKeys(), Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.FromElements(), Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.FromElements());
          if ((_8_valueOrError2).IsFailure()) {
            output = (_8_valueOrError2).PropagateFailure<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>();
            return output;
          }
          DynamoDBFilterExpr_Compile._IParsedContext _9_expr;
          _9_expr = (_8_valueOrError2).Extract();
          Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _10_expr1;
          _10_expr1 = DynamoDBFilterExpr_Compile.__default.ConvertToPrefix((_9_expr).dtor_expr);
          Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _11_expr2;
          _11_expr2 = DynamoDBFilterExpr_Compile.__default.ConvertToRpn(_10_expr1);
          Wrappers_Compile._IResult<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out1;
          _out1 = DynamoDBFilterExpr_Compile.__default.FilterItems(b, _11_expr2, _0_afterKeys, (_9_expr).dtor_names, (_9_expr).dtor_values);
          output = _out1;
        } else {
          output = Wrappers_Compile.Result<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(_0_afterKeys);
          return output;
        }
      }
      return output;
    }
    public static Wrappers_Compile._IOption<Dafny.ISequence<char>> KeyIdFromPart(SearchableEncryptionInfo_Compile._IBeaconVersion bv, Dafny.ISequence<char> keyIdField, Dafny.ISequence<char> attr, Dafny.ISequence<char> @value)
    {
      if ((!((bv).dtor_beacons).Contains(attr)) || ((Dafny.Map<Dafny.ISequence<char>, SearchableEncryptionInfo_Compile._IBeacon>.Select((bv).dtor_beacons,attr)).is_Standard)) {
        return Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None();
      } else {
        Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> _0_parts = ((Dafny.Map<Dafny.ISequence<char>, SearchableEncryptionInfo_Compile._IBeacon>.Select((bv).dtor_beacons,attr)).dtor_cmp).dtor_parts;
        Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> _1_theParts = Seq_Compile.__default.Filter<CompoundBeacon_Compile._IBeaconPart>(Dafny.Helpers.Id<Func<Dafny.ISequence<char>, Func<CompoundBeacon_Compile._IBeaconPart, bool>>>((_2_keyIdField) => ((System.Func<CompoundBeacon_Compile._IBeaconPart, bool>)((_3_p) => {
          return ((_3_p).is_Signed) && (((((_3_p).dtor_loc).Select(BigInteger.Zero)).dtor_key).Equals(_2_keyIdField));
        })))(keyIdField), _0_parts);
        if ((new BigInteger((_1_theParts).Count)) != (BigInteger.One)) {
          return Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None();
        } else {
          Dafny.ISequence<Dafny.ISequence<char>> _4_pieces = StandardLibrary_Compile.__default.Split<char>(@value, ((Dafny.Map<Dafny.ISequence<char>, SearchableEncryptionInfo_Compile._IBeacon>.Select((bv).dtor_beacons,attr)).dtor_cmp).dtor_split);
          Dafny.ISequence<Dafny.ISequence<char>> _5_piece = Seq_Compile.__default.Filter<Dafny.ISequence<char>>(Dafny.Helpers.Id<Func<Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart>, Func<Dafny.ISequence<char>, bool>>>((_6_theParts) => ((System.Func<Dafny.ISequence<char>, bool>)((_7_s) => {
            return Dafny.Sequence<char>.IsPrefixOf(((_6_theParts).Select(BigInteger.Zero)).dtor_prefix, _7_s);
          })))(_1_theParts), _4_pieces);
          if ((new BigInteger((_5_piece).Count)) != (BigInteger.One)) {
            return Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None();
          } else {
            Dafny.ISequence<char> _8_p = (_5_piece).Select(BigInteger.Zero);
            return Wrappers_Compile.Option<Dafny.ISequence<char>>.create_Some((_8_p).Drop(new BigInteger((((_1_theParts).Select(BigInteger.Zero)).dtor_prefix).Count)));
          }
        }
      }
    }
    public static Wrappers_Compile._IOption<Dafny.ISequence<char>> KeyIdFromAttr(SearchableEncryptionInfo_Compile._IBeaconVersion bv, Wrappers_Compile._IOption<DynamoDBFilterExpr_Compile._IToken> attr, Dafny.ISequence<char> @value, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> names)
    {
      if ((attr).is_None) {
        return Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None();
      } else {
        Dafny.ISequence<char> _0_name = ((((names).is_Some) && (((names).dtor_value).Contains(((attr).dtor_value).dtor_s))) ? (Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Select((names).dtor_value,((attr).dtor_value).dtor_s)) : (((attr).dtor_value).dtor_s));
        Dafny.ISequence<char> _1_keyIdField = (((bv).dtor_keySource).dtor_keyLoc).dtor_keyName;
        if ((_1_keyIdField).Equals(_0_name)) {
          return Wrappers_Compile.Option<Dafny.ISequence<char>>.create_Some(@value);
        } else {
          return DynamoDBFilterExpr_Compile.__default.KeyIdFromPart(bv, _1_keyIdField, ((attr).dtor_value).dtor_s, @value);
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetBeaconKeyIds2(BigInteger pos, SearchableEncryptionInfo_Compile._IBeaconVersion bv, Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> expr, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> values, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> names, Dafny.ISequence<Dafny.ISequence<char>> soFar)
    {
    TAIL_CALL_START: ;
      if ((pos) == (new BigInteger((expr).Count))) {
        return Wrappers_Compile.Result<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(soFar);
      } else if (((expr).Select(pos)).is_Value) {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>((values).Contains(((expr).Select(pos)).dtor_s), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(((expr).Select(pos)).dtor_s, Dafny.Sequence<char>.FromString(" not found in ExpressionAttributeValueMap"))));
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<Dafny.ISequence<char>>>();
        } else {
          software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue _1_oldValue = Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(values,((expr).Select(pos)).dtor_s);
          if ((_1_oldValue).is_S) {
            Wrappers_Compile._IOption<DynamoDBFilterExpr_Compile._IToken> _2_attr = DynamoDBFilterExpr_Compile.__default.AttrForValue(expr, pos);
            Wrappers_Compile._IOption<Dafny.ISequence<char>> _3_keyId = DynamoDBFilterExpr_Compile.__default.KeyIdFromAttr(bv, _2_attr, (_1_oldValue).dtor_S, names);
            if (((_3_keyId).is_None) || ((soFar).Contains((_3_keyId).dtor_value))) {
              BigInteger _in0 = (pos) + (BigInteger.One);
              SearchableEncryptionInfo_Compile._IBeaconVersion _in1 = bv;
              Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in2 = expr;
              Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in3 = values;
              Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> _in4 = names;
              Dafny.ISequence<Dafny.ISequence<char>> _in5 = soFar;
              pos = _in0;
              bv = _in1;
              expr = _in2;
              values = _in3;
              names = _in4;
              soFar = _in5;
              goto TAIL_CALL_START;
            } else {
              BigInteger _in6 = (pos) + (BigInteger.One);
              SearchableEncryptionInfo_Compile._IBeaconVersion _in7 = bv;
              Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in8 = expr;
              Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in9 = values;
              Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> _in10 = names;
              Dafny.ISequence<Dafny.ISequence<char>> _in11 = Dafny.Sequence<Dafny.ISequence<char>>.Concat(soFar, Dafny.Sequence<Dafny.ISequence<char>>.FromElements((_3_keyId).dtor_value));
              pos = _in6;
              bv = _in7;
              expr = _in8;
              values = _in9;
              names = _in10;
              soFar = _in11;
              goto TAIL_CALL_START;
            }
          } else {
            BigInteger _in12 = (pos) + (BigInteger.One);
            SearchableEncryptionInfo_Compile._IBeaconVersion _in13 = bv;
            Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in14 = expr;
            Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in15 = values;
            Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> _in16 = names;
            Dafny.ISequence<Dafny.ISequence<char>> _in17 = soFar;
            pos = _in12;
            bv = _in13;
            expr = _in14;
            values = _in15;
            names = _in16;
            soFar = _in17;
            goto TAIL_CALL_START;
          }
        }
      } else {
        BigInteger _in18 = (pos) + (BigInteger.One);
        SearchableEncryptionInfo_Compile._IBeaconVersion _in19 = bv;
        Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _in20 = expr;
        Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in21 = values;
        Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> _in22 = names;
        Dafny.ISequence<Dafny.ISequence<char>> _in23 = soFar;
        pos = _in18;
        bv = _in19;
        expr = _in20;
        values = _in21;
        names = _in22;
        soFar = _in23;
        goto TAIL_CALL_START;
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetBeaconKeyIds(SearchableEncryptionInfo_Compile._IBeaconVersion bv, Wrappers_Compile._IOption<Dafny.ISequence<char>> expr, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> values, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> names, Dafny.ISequence<Dafny.ISequence<char>> soFar)
    {
      if ((expr).is_None) {
        return Wrappers_Compile.Result<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(soFar);
      } else {
        Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _0_parsed = DynamoDBFilterExpr_Compile.__default.ParseExpr((expr).dtor_value);
        return DynamoDBFilterExpr_Compile.__default.GetBeaconKeyIds2(BigInteger.Zero, bv, _0_parsed, values, names, soFar);
      }
    }
    public static Wrappers_Compile._IResult<DynamoDbEncryptionUtil_Compile._IMaybeKeyId, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetBeaconKeyId(SearchableEncryptionInfo_Compile._IBeaconVersion bv, Wrappers_Compile._IOption<Dafny.ISequence<char>> keyExpr, Wrappers_Compile._IOption<Dafny.ISequence<char>> filterExpr, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> values, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> names)
    {
      if (!((((bv).dtor_keySource).dtor_keyLoc).is_MultiLoc)) {
        return Wrappers_Compile.Result<DynamoDbEncryptionUtil_Compile._IMaybeKeyId, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(DynamoDbEncryptionUtil_Compile.MaybeKeyId.create_DontUseKeyId());
      } else if ((values).is_None) {
        return Wrappers_Compile.Result<DynamoDbEncryptionUtil_Compile._IMaybeKeyId, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(DynamoDbEncryptionUtil_Compile.MaybeKeyId.create_ShouldHaveKeyId());
      } else {
        Wrappers_Compile._IResult<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = DynamoDBFilterExpr_Compile.__default.GetBeaconKeyIds(bv, keyExpr, (values).dtor_value, names, Dafny.Sequence<Dafny.ISequence<char>>.FromElements());
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<DynamoDbEncryptionUtil_Compile._IMaybeKeyId>();
        } else {
          Dafny.ISequence<Dafny.ISequence<char>> _1_soFar = (_0_valueOrError0).Extract();
          Wrappers_Compile._IResult<Dafny.ISequence<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _2_valueOrError1 = DynamoDBFilterExpr_Compile.__default.GetBeaconKeyIds(bv, filterExpr, (values).dtor_value, names, _1_soFar);
          if ((_2_valueOrError1).IsFailure()) {
            return (_2_valueOrError1).PropagateFailure<DynamoDbEncryptionUtil_Compile._IMaybeKeyId>();
          } else {
            Dafny.ISequence<Dafny.ISequence<char>> _3_final = (_2_valueOrError1).Extract();
            if ((new BigInteger((_3_final).Count)) == (BigInteger.One)) {
              return Wrappers_Compile.Result<DynamoDbEncryptionUtil_Compile._IMaybeKeyId, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(DynamoDbEncryptionUtil_Compile.MaybeKeyId.create_KeyId((_3_final).Select(BigInteger.Zero)));
            } else if ((new BigInteger((_3_final).Count)).Sign == 0) {
              return Wrappers_Compile.Result<DynamoDbEncryptionUtil_Compile._IMaybeKeyId, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(DynamoDbEncryptionUtil_Compile.MaybeKeyId.create_ShouldHaveKeyId());
            } else {
              return Wrappers_Compile.Result<DynamoDbEncryptionUtil_Compile._IMaybeKeyId, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Multiple values found for "), (((bv).dtor_keySource).dtor_keyLoc).dtor_keyName), Dafny.Sequence<char>.FromString(" in query : ")), StandardLibrary_Compile.__default.Join<char>(_3_final, Dafny.Sequence<char>.FromString(", ")))));
            }
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<DynamoDBFilterExpr_Compile._IExprContext, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> Beaconize(SearchableEncryptionInfo_Compile._IBeaconVersion b, DynamoDBFilterExpr_Compile._IExprContext context, DynamoDbEncryptionUtil_Compile._IMaybeKeyId keyId, bool naked)
    {
      Wrappers_Compile._IResult<DynamoDBFilterExpr_Compile._IExprContext, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IExprContext, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(DynamoDBFilterExpr_Compile.ExprContext.Default());
      if ((((context).dtor_keyExpr).is_None) && (((context).dtor_filterExpr).is_None)) {
        output = Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IExprContext, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(context);
        return output;
      } else {
        DynamoDbEncryptionUtil_Compile._IMaybeKeyMap _0_keys;
        _0_keys = DynamoDbEncryptionUtil_Compile.MaybeKeyMap.create_DontUseKeys();
        if (!(naked)) {
          Wrappers_Compile._IResult<DynamoDbEncryptionUtil_Compile._IMaybeKeyMap, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _1_valueOrError0 = Wrappers_Compile.Result<DynamoDbEncryptionUtil_Compile._IMaybeKeyMap, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(DynamoDbEncryptionUtil_Compile.MaybeKeyMap.Default());
          Wrappers_Compile._IResult<DynamoDbEncryptionUtil_Compile._IMaybeKeyMap, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
          _out0 = (b).getKeyMap(keyId);
          _1_valueOrError0 = _out0;
          if ((_1_valueOrError0).IsFailure()) {
            output = (_1_valueOrError0).PropagateFailure<DynamoDBFilterExpr_Compile._IExprContext>();
            return output;
          }
          _0_keys = (_1_valueOrError0).Extract();
        }
        Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _2_values;
        if (((context).dtor_values).is_Some) {
          _2_values = ((context).dtor_values).dtor_value;
        } else {
          _2_values = Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.FromElements();
        }
        Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _3_newValues;
        _3_newValues = Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.FromElements();
        Wrappers_Compile._IOption<Dafny.ISequence<char>> _4_newKeyExpr;
        _4_newKeyExpr = (context).dtor_keyExpr;
        Wrappers_Compile._IOption<Dafny.ISequence<char>> _5_newFilterExpr;
        _5_newFilterExpr = (context).dtor_filterExpr;
        Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> _6_newNames;
        _6_newNames = (context).dtor_names;
        if (((context).dtor_keyExpr).is_Some) {
          Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _7_parsed;
          _7_parsed = DynamoDBFilterExpr_Compile.__default.ParseExpr(((context).dtor_keyExpr).dtor_value);
          Wrappers_Compile._IResult<DynamoDBFilterExpr_Compile._IParsedContext, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _8_valueOrError1 = Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IParsedContext, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(DynamoDBFilterExpr_Compile.ParsedContext.Default());
          _8_valueOrError1 = DynamoDBFilterExpr_Compile.__default.BeaconizeParsedExpr(b, _7_parsed, BigInteger.Zero, _2_values, _6_newNames, _0_keys, _3_newValues, Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.FromElements());
          if ((_8_valueOrError1).IsFailure()) {
            output = (_8_valueOrError1).PropagateFailure<DynamoDBFilterExpr_Compile._IExprContext>();
            return output;
          }
          DynamoDBFilterExpr_Compile._IParsedContext _9_newContext;
          _9_newContext = (_8_valueOrError1).Extract();
          _4_newKeyExpr = Wrappers_Compile.Option<Dafny.ISequence<char>>.create_Some(DynamoDBFilterExpr_Compile.__default.ParsedExprToString((_9_newContext).dtor_expr));
          _3_newValues = (_9_newContext).dtor_values;
          _6_newNames = (_9_newContext).dtor_names;
        }
        if (((context).dtor_filterExpr).is_Some) {
          Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _10_parsed;
          _10_parsed = DynamoDBFilterExpr_Compile.__default.ParseExpr(((context).dtor_filterExpr).dtor_value);
          Wrappers_Compile._IResult<DynamoDBFilterExpr_Compile._IParsedContext, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _11_valueOrError2 = Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IParsedContext, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(DynamoDBFilterExpr_Compile.ParsedContext.Default());
          _11_valueOrError2 = DynamoDBFilterExpr_Compile.__default.BeaconizeParsedExpr(b, _10_parsed, BigInteger.Zero, _2_values, _6_newNames, _0_keys, _3_newValues, Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.FromElements());
          if ((_11_valueOrError2).IsFailure()) {
            output = (_11_valueOrError2).PropagateFailure<DynamoDBFilterExpr_Compile._IExprContext>();
            return output;
          }
          DynamoDBFilterExpr_Compile._IParsedContext _12_newContext;
          _12_newContext = (_11_valueOrError2).Extract();
          _5_newFilterExpr = Wrappers_Compile.Option<Dafny.ISequence<char>>.create_Some(DynamoDBFilterExpr_Compile.__default.ParsedExprToString((_12_newContext).dtor_expr));
          _3_newValues = (_12_newContext).dtor_values;
          _6_newNames = (_12_newContext).dtor_names;
        }
        output = Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IExprContext, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(DynamoDBFilterExpr_Compile.ExprContext.create(_4_newKeyExpr, _5_newFilterExpr, (((new BigInteger((_3_newValues).Count)).Sign == 0) ? (Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.create_None()) : (Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.create_Some(_3_newValues))), _6_newNames));
        return output;
      }
      return output;
    }
    public static Dafny.ISequence<char> GetAttrName(DynamoDBFilterExpr_Compile._IToken t, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> names)
    {
      if (((names).is_Some) && (((names).dtor_value).Contains((t).dtor_s))) {
        return Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Select((names).dtor_value,(t).dtor_s);
      } else {
        return (t).dtor_s;
      }
    }
    public static Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> TestParsedExpr(Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> expr, Dafny.ISet<Dafny.ISequence<char>> encrypted, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> names)
    {
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default();
      BigInteger _hi0 = new BigInteger((expr).Count);
      for (BigInteger _0_i = BigInteger.Zero; _0_i < _hi0; _0_i++) {
        if (((expr).Select(_0_i)).is_Attr) {
          Dafny.ISequence<char> _1_name;
          _1_name = DynamoDBFilterExpr_Compile.__default.GetAttrName((expr).Select(_0_i), names);
          if ((encrypted).Contains(_1_name)) {
            output = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Fail(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Query is using encrypted field : "), _1_name), Dafny.Sequence<char>.FromString("."))));
            return output;
          }
        }
      }
      output = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Pass();
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> TestBeaconize(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> actions, Wrappers_Compile._IOption<Dafny.ISequence<char>> keyExpr, Wrappers_Compile._IOption<Dafny.ISequence<char>> filterExpr, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> names)
    {
      Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(false);
      Dafny.ISet<Dafny.ISequence<char>> _0_encrypted;
      _0_encrypted = Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>, Dafny.ISet<Dafny.ISequence<char>>>>((_1_actions) => ((System.Func<Dafny.ISet<Dafny.ISequence<char>>>)(() => {
        var _coll0 = new System.Collections.Generic.List<Dafny.ISequence<char>>();
        foreach (Dafny.ISequence<char> _compr_0 in (_1_actions).Keys.Elements) {
          Dafny.ISequence<char> _2_k = (Dafny.ISequence<char>)_compr_0;
          if (((_1_actions).Contains(_2_k)) && (object.Equals(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Select(_1_actions,_2_k), software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_ENCRYPT__AND__SIGN()))) {
            _coll0.Add(_2_k);
          }
        }
        return Dafny.Set<Dafny.ISequence<char>>.FromCollection(_coll0);
      }))())(actions);
      if ((keyExpr).is_Some) {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _3_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default();
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
        _out0 = DynamoDBFilterExpr_Compile.__default.TestParsedExpr(DynamoDBFilterExpr_Compile.__default.ParseExpr((keyExpr).dtor_value), _0_encrypted, names);
        _3_valueOrError0 = _out0;
        if ((_3_valueOrError0).IsFailure()) {
          output = (_3_valueOrError0).PropagateFailure<bool>();
          return output;
        }
      }
      if ((filterExpr).is_Some) {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _4_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default();
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out1;
        _out1 = DynamoDBFilterExpr_Compile.__default.TestParsedExpr(DynamoDBFilterExpr_Compile.__default.ParseExpr((filterExpr).dtor_value), _0_encrypted, names);
        _4_valueOrError1 = _out1;
        if ((_4_valueOrError1).IsFailure()) {
          output = (_4_valueOrError1).PropagateFailure<bool>();
          return output;
        }
      }
      output = Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(true);
      return output;
      return output;
    }
  }

  public interface _IToken {
    bool is_Attr { get; }
    bool is_Value { get; }
    bool is_Eq { get; }
    bool is_Ne { get; }
    bool is_Lt { get; }
    bool is_Gt { get; }
    bool is_Le { get; }
    bool is_Ge { get; }
    bool is_Between { get; }
    bool is_In { get; }
    bool is_Open { get; }
    bool is_Close { get; }
    bool is_Comma { get; }
    bool is_Not { get; }
    bool is_And { get; }
    bool is_Or { get; }
    bool is_AttributeExists { get; }
    bool is_AttributeNotExists { get; }
    bool is_AttributeType { get; }
    bool is_BeginsWith { get; }
    bool is_Contains { get; }
    bool is_Size { get; }
    Dafny.ISequence<char> dtor_s { get; }
    Dafny.ISequence<TermLoc_Compile._ISelector> dtor_loc { get; }
    _IToken DowncastClone();
  }
  public abstract class Token : _IToken {
    public Token() {
    }
    private static readonly DynamoDBFilterExpr_Compile._IToken theDefault = create_Attr(Dafny.Sequence<char>.Empty, Dafny.Sequence<TermLoc_Compile._ISelector>.Empty);
    public static DynamoDBFilterExpr_Compile._IToken Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<DynamoDBFilterExpr_Compile._IToken> _TYPE = new Dafny.TypeDescriptor<DynamoDBFilterExpr_Compile._IToken>(DynamoDBFilterExpr_Compile.Token.Default());
    public static Dafny.TypeDescriptor<DynamoDBFilterExpr_Compile._IToken> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IToken create_Attr(Dafny.ISequence<char> s, Dafny.ISequence<TermLoc_Compile._ISelector> loc) {
      return new Token_Attr(s, loc);
    }
    public static _IToken create_Value(Dafny.ISequence<char> s) {
      return new Token_Value(s);
    }
    public static _IToken create_Eq() {
      return new Token_Eq();
    }
    public static _IToken create_Ne() {
      return new Token_Ne();
    }
    public static _IToken create_Lt() {
      return new Token_Lt();
    }
    public static _IToken create_Gt() {
      return new Token_Gt();
    }
    public static _IToken create_Le() {
      return new Token_Le();
    }
    public static _IToken create_Ge() {
      return new Token_Ge();
    }
    public static _IToken create_Between() {
      return new Token_Between();
    }
    public static _IToken create_In() {
      return new Token_In();
    }
    public static _IToken create_Open() {
      return new Token_Open();
    }
    public static _IToken create_Close() {
      return new Token_Close();
    }
    public static _IToken create_Comma() {
      return new Token_Comma();
    }
    public static _IToken create_Not() {
      return new Token_Not();
    }
    public static _IToken create_And() {
      return new Token_And();
    }
    public static _IToken create_Or() {
      return new Token_Or();
    }
    public static _IToken create_AttributeExists() {
      return new Token_AttributeExists();
    }
    public static _IToken create_AttributeNotExists() {
      return new Token_AttributeNotExists();
    }
    public static _IToken create_AttributeType() {
      return new Token_AttributeType();
    }
    public static _IToken create_BeginsWith() {
      return new Token_BeginsWith();
    }
    public static _IToken create_Contains() {
      return new Token_Contains();
    }
    public static _IToken create_Size() {
      return new Token_Size();
    }
    public bool is_Attr { get { return this is Token_Attr; } }
    public bool is_Value { get { return this is Token_Value; } }
    public bool is_Eq { get { return this is Token_Eq; } }
    public bool is_Ne { get { return this is Token_Ne; } }
    public bool is_Lt { get { return this is Token_Lt; } }
    public bool is_Gt { get { return this is Token_Gt; } }
    public bool is_Le { get { return this is Token_Le; } }
    public bool is_Ge { get { return this is Token_Ge; } }
    public bool is_Between { get { return this is Token_Between; } }
    public bool is_In { get { return this is Token_In; } }
    public bool is_Open { get { return this is Token_Open; } }
    public bool is_Close { get { return this is Token_Close; } }
    public bool is_Comma { get { return this is Token_Comma; } }
    public bool is_Not { get { return this is Token_Not; } }
    public bool is_And { get { return this is Token_And; } }
    public bool is_Or { get { return this is Token_Or; } }
    public bool is_AttributeExists { get { return this is Token_AttributeExists; } }
    public bool is_AttributeNotExists { get { return this is Token_AttributeNotExists; } }
    public bool is_AttributeType { get { return this is Token_AttributeType; } }
    public bool is_BeginsWith { get { return this is Token_BeginsWith; } }
    public bool is_Contains { get { return this is Token_Contains; } }
    public bool is_Size { get { return this is Token_Size; } }
    public Dafny.ISequence<char> dtor_s {
      get {
        var d = this;
        if (d is Token_Attr) { return ((Token_Attr)d)._s; }
        return ((Token_Value)d)._s;
      }
    }
    public Dafny.ISequence<TermLoc_Compile._ISelector> dtor_loc {
      get {
        var d = this;
        return ((Token_Attr)d)._loc;
      }
    }
    public abstract _IToken DowncastClone();
  }
  public class Token_Attr : Token {
    public readonly Dafny.ISequence<char> _s;
    public readonly Dafny.ISequence<TermLoc_Compile._ISelector> _loc;
    public Token_Attr(Dafny.ISequence<char> s, Dafny.ISequence<TermLoc_Compile._ISelector> loc) : base() {
      this._s = s;
      this._loc = loc;
    }
    public override _IToken DowncastClone() {
      if (this is _IToken dt) { return dt; }
      return new Token_Attr(_s, _loc);
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDBFilterExpr_Compile.Token_Attr;
      return oth != null && object.Equals(this._s, oth._s) && object.Equals(this._loc, oth._loc);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._s));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._loc));
      return (int) hash;
    }
    public override string ToString() {
      string ss = "DynamoDBFilterExpr.Token.Attr";
      ss += "(";
      ss += Dafny.Helpers.ToString(this._s);
      ss += ", ";
      ss += Dafny.Helpers.ToString(this._loc);
      ss += ")";
      return ss;
    }
  }
  public class Token_Value : Token {
    public readonly Dafny.ISequence<char> _s;
    public Token_Value(Dafny.ISequence<char> s) : base() {
      this._s = s;
    }
    public override _IToken DowncastClone() {
      if (this is _IToken dt) { return dt; }
      return new Token_Value(_s);
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDBFilterExpr_Compile.Token_Value;
      return oth != null && object.Equals(this._s, oth._s);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._s));
      return (int) hash;
    }
    public override string ToString() {
      string ss = "DynamoDBFilterExpr.Token.Value";
      ss += "(";
      ss += Dafny.Helpers.ToString(this._s);
      ss += ")";
      return ss;
    }
  }
  public class Token_Eq : Token {
    public Token_Eq() : base() {
    }
    public override _IToken DowncastClone() {
      if (this is _IToken dt) { return dt; }
      return new Token_Eq();
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDBFilterExpr_Compile.Token_Eq;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      return (int) hash;
    }
    public override string ToString() {
      string s = "DynamoDBFilterExpr.Token.Eq";
      return s;
    }
  }
  public class Token_Ne : Token {
    public Token_Ne() : base() {
    }
    public override _IToken DowncastClone() {
      if (this is _IToken dt) { return dt; }
      return new Token_Ne();
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDBFilterExpr_Compile.Token_Ne;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 3;
      return (int) hash;
    }
    public override string ToString() {
      string s = "DynamoDBFilterExpr.Token.Ne";
      return s;
    }
  }
  public class Token_Lt : Token {
    public Token_Lt() : base() {
    }
    public override _IToken DowncastClone() {
      if (this is _IToken dt) { return dt; }
      return new Token_Lt();
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDBFilterExpr_Compile.Token_Lt;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 4;
      return (int) hash;
    }
    public override string ToString() {
      string s = "DynamoDBFilterExpr.Token.Lt";
      return s;
    }
  }
  public class Token_Gt : Token {
    public Token_Gt() : base() {
    }
    public override _IToken DowncastClone() {
      if (this is _IToken dt) { return dt; }
      return new Token_Gt();
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDBFilterExpr_Compile.Token_Gt;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 5;
      return (int) hash;
    }
    public override string ToString() {
      string s = "DynamoDBFilterExpr.Token.Gt";
      return s;
    }
  }
  public class Token_Le : Token {
    public Token_Le() : base() {
    }
    public override _IToken DowncastClone() {
      if (this is _IToken dt) { return dt; }
      return new Token_Le();
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDBFilterExpr_Compile.Token_Le;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 6;
      return (int) hash;
    }
    public override string ToString() {
      string s = "DynamoDBFilterExpr.Token.Le";
      return s;
    }
  }
  public class Token_Ge : Token {
    public Token_Ge() : base() {
    }
    public override _IToken DowncastClone() {
      if (this is _IToken dt) { return dt; }
      return new Token_Ge();
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDBFilterExpr_Compile.Token_Ge;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 7;
      return (int) hash;
    }
    public override string ToString() {
      string s = "DynamoDBFilterExpr.Token.Ge";
      return s;
    }
  }
  public class Token_Between : Token {
    public Token_Between() : base() {
    }
    public override _IToken DowncastClone() {
      if (this is _IToken dt) { return dt; }
      return new Token_Between();
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDBFilterExpr_Compile.Token_Between;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 8;
      return (int) hash;
    }
    public override string ToString() {
      string s = "DynamoDBFilterExpr.Token.Between";
      return s;
    }
  }
  public class Token_In : Token {
    public Token_In() : base() {
    }
    public override _IToken DowncastClone() {
      if (this is _IToken dt) { return dt; }
      return new Token_In();
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDBFilterExpr_Compile.Token_In;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 9;
      return (int) hash;
    }
    public override string ToString() {
      string s = "DynamoDBFilterExpr.Token.In";
      return s;
    }
  }
  public class Token_Open : Token {
    public Token_Open() : base() {
    }
    public override _IToken DowncastClone() {
      if (this is _IToken dt) { return dt; }
      return new Token_Open();
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDBFilterExpr_Compile.Token_Open;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 10;
      return (int) hash;
    }
    public override string ToString() {
      string s = "DynamoDBFilterExpr.Token.Open";
      return s;
    }
  }
  public class Token_Close : Token {
    public Token_Close() : base() {
    }
    public override _IToken DowncastClone() {
      if (this is _IToken dt) { return dt; }
      return new Token_Close();
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDBFilterExpr_Compile.Token_Close;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 11;
      return (int) hash;
    }
    public override string ToString() {
      string s = "DynamoDBFilterExpr.Token.Close";
      return s;
    }
  }
  public class Token_Comma : Token {
    public Token_Comma() : base() {
    }
    public override _IToken DowncastClone() {
      if (this is _IToken dt) { return dt; }
      return new Token_Comma();
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDBFilterExpr_Compile.Token_Comma;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 12;
      return (int) hash;
    }
    public override string ToString() {
      string s = "DynamoDBFilterExpr.Token.Comma";
      return s;
    }
  }
  public class Token_Not : Token {
    public Token_Not() : base() {
    }
    public override _IToken DowncastClone() {
      if (this is _IToken dt) { return dt; }
      return new Token_Not();
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDBFilterExpr_Compile.Token_Not;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 13;
      return (int) hash;
    }
    public override string ToString() {
      string s = "DynamoDBFilterExpr.Token.Not";
      return s;
    }
  }
  public class Token_And : Token {
    public Token_And() : base() {
    }
    public override _IToken DowncastClone() {
      if (this is _IToken dt) { return dt; }
      return new Token_And();
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDBFilterExpr_Compile.Token_And;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 14;
      return (int) hash;
    }
    public override string ToString() {
      string s = "DynamoDBFilterExpr.Token.And";
      return s;
    }
  }
  public class Token_Or : Token {
    public Token_Or() : base() {
    }
    public override _IToken DowncastClone() {
      if (this is _IToken dt) { return dt; }
      return new Token_Or();
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDBFilterExpr_Compile.Token_Or;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 15;
      return (int) hash;
    }
    public override string ToString() {
      string s = "DynamoDBFilterExpr.Token.Or";
      return s;
    }
  }
  public class Token_AttributeExists : Token {
    public Token_AttributeExists() : base() {
    }
    public override _IToken DowncastClone() {
      if (this is _IToken dt) { return dt; }
      return new Token_AttributeExists();
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDBFilterExpr_Compile.Token_AttributeExists;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 16;
      return (int) hash;
    }
    public override string ToString() {
      string s = "DynamoDBFilterExpr.Token.AttributeExists";
      return s;
    }
  }
  public class Token_AttributeNotExists : Token {
    public Token_AttributeNotExists() : base() {
    }
    public override _IToken DowncastClone() {
      if (this is _IToken dt) { return dt; }
      return new Token_AttributeNotExists();
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDBFilterExpr_Compile.Token_AttributeNotExists;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 17;
      return (int) hash;
    }
    public override string ToString() {
      string s = "DynamoDBFilterExpr.Token.AttributeNotExists";
      return s;
    }
  }
  public class Token_AttributeType : Token {
    public Token_AttributeType() : base() {
    }
    public override _IToken DowncastClone() {
      if (this is _IToken dt) { return dt; }
      return new Token_AttributeType();
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDBFilterExpr_Compile.Token_AttributeType;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 18;
      return (int) hash;
    }
    public override string ToString() {
      string s = "DynamoDBFilterExpr.Token.AttributeType";
      return s;
    }
  }
  public class Token_BeginsWith : Token {
    public Token_BeginsWith() : base() {
    }
    public override _IToken DowncastClone() {
      if (this is _IToken dt) { return dt; }
      return new Token_BeginsWith();
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDBFilterExpr_Compile.Token_BeginsWith;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 19;
      return (int) hash;
    }
    public override string ToString() {
      string s = "DynamoDBFilterExpr.Token.BeginsWith";
      return s;
    }
  }
  public class Token_Contains : Token {
    public Token_Contains() : base() {
    }
    public override _IToken DowncastClone() {
      if (this is _IToken dt) { return dt; }
      return new Token_Contains();
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDBFilterExpr_Compile.Token_Contains;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 20;
      return (int) hash;
    }
    public override string ToString() {
      string s = "DynamoDBFilterExpr.Token.Contains";
      return s;
    }
  }
  public class Token_Size : Token {
    public Token_Size() : base() {
    }
    public override _IToken DowncastClone() {
      if (this is _IToken dt) { return dt; }
      return new Token_Size();
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDBFilterExpr_Compile.Token_Size;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 21;
      return (int) hash;
    }
    public override string ToString() {
      string s = "DynamoDBFilterExpr.Token.Size";
      return s;
    }
  }

  public interface _IEqualityBeacon {
    bool is_EqualityBeacon { get; }
    Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._IBeacon> dtor_beacon { get; }
    bool dtor_forEquality { get; }
    bool dtor_forContains { get; }
    _IEqualityBeacon DowncastClone();
  }
  public class EqualityBeacon : _IEqualityBeacon {
    public readonly Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._IBeacon> _beacon;
    public readonly bool _forEquality;
    public readonly bool _forContains;
    public EqualityBeacon(Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._IBeacon> beacon, bool forEquality, bool forContains) {
      this._beacon = beacon;
      this._forEquality = forEquality;
      this._forContains = forContains;
    }
    public _IEqualityBeacon DowncastClone() {
      if (this is _IEqualityBeacon dt) { return dt; }
      return new EqualityBeacon(_beacon, _forEquality, _forContains);
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDBFilterExpr_Compile.EqualityBeacon;
      return oth != null && object.Equals(this._beacon, oth._beacon) && this._forEquality == oth._forEquality && this._forContains == oth._forContains;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._beacon));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._forEquality));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._forContains));
      return (int) hash;
    }
    public override string ToString() {
      string s = "DynamoDBFilterExpr.EqualityBeacon.EqualityBeacon";
      s += "(";
      s += Dafny.Helpers.ToString(this._beacon);
      s += ", ";
      s += Dafny.Helpers.ToString(this._forEquality);
      s += ", ";
      s += Dafny.Helpers.ToString(this._forContains);
      s += ")";
      return s;
    }
    private static readonly DynamoDBFilterExpr_Compile._IEqualityBeacon theDefault = create(Wrappers_Compile.Option<SearchableEncryptionInfo_Compile._IBeacon>.Default(), false, false);
    public static DynamoDBFilterExpr_Compile._IEqualityBeacon Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<DynamoDBFilterExpr_Compile._IEqualityBeacon> _TYPE = new Dafny.TypeDescriptor<DynamoDBFilterExpr_Compile._IEqualityBeacon>(DynamoDBFilterExpr_Compile.EqualityBeacon.Default());
    public static Dafny.TypeDescriptor<DynamoDBFilterExpr_Compile._IEqualityBeacon> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IEqualityBeacon create(Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._IBeacon> beacon, bool forEquality, bool forContains) {
      return new EqualityBeacon(beacon, forEquality, forContains);
    }
    public static _IEqualityBeacon create_EqualityBeacon(Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._IBeacon> beacon, bool forEquality, bool forContains) {
      return create(beacon, forEquality, forContains);
    }
    public bool is_EqualityBeacon { get { return true; } }
    public Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._IBeacon> dtor_beacon {
      get {
        return this._beacon;
      }
    }
    public bool dtor_forEquality {
      get {
        return this._forEquality;
      }
    }
    public bool dtor_forContains {
      get {
        return this._forContains;
      }
    }
  }

  public interface _IStackValue {
    bool is_Bool { get; }
    bool is_Str { get; }
    bool is_DoesNotExist { get; }
    bool dtor_b { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue dtor_s { get; }
    _IStackValue DowncastClone();
  }
  public abstract class StackValue : _IStackValue {
    public StackValue() {
    }
    private static readonly DynamoDBFilterExpr_Compile._IStackValue theDefault = create_Bool(false);
    public static DynamoDBFilterExpr_Compile._IStackValue Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<DynamoDBFilterExpr_Compile._IStackValue> _TYPE = new Dafny.TypeDescriptor<DynamoDBFilterExpr_Compile._IStackValue>(DynamoDBFilterExpr_Compile.StackValue.Default());
    public static Dafny.TypeDescriptor<DynamoDBFilterExpr_Compile._IStackValue> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IStackValue create_Bool(bool b) {
      return new StackValue_Bool(b);
    }
    public static _IStackValue create_Str(software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue s) {
      return new StackValue_Str(s);
    }
    public static _IStackValue create_DoesNotExist() {
      return new StackValue_DoesNotExist();
    }
    public bool is_Bool { get { return this is StackValue_Bool; } }
    public bool is_Str { get { return this is StackValue_Str; } }
    public bool is_DoesNotExist { get { return this is StackValue_DoesNotExist; } }
    public bool dtor_b {
      get {
        var d = this;
        return ((StackValue_Bool)d)._b;
      }
    }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue dtor_s {
      get {
        var d = this;
        return ((StackValue_Str)d)._s;
      }
    }
    public abstract _IStackValue DowncastClone();
  }
  public class StackValue_Bool : StackValue {
    public readonly bool _b;
    public StackValue_Bool(bool b) : base() {
      this._b = b;
    }
    public override _IStackValue DowncastClone() {
      if (this is _IStackValue dt) { return dt; }
      return new StackValue_Bool(_b);
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDBFilterExpr_Compile.StackValue_Bool;
      return oth != null && this._b == oth._b;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._b));
      return (int) hash;
    }
    public override string ToString() {
      string s = "DynamoDBFilterExpr.StackValue.Bool";
      s += "(";
      s += Dafny.Helpers.ToString(this._b);
      s += ")";
      return s;
    }
  }
  public class StackValue_Str : StackValue {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue _s;
    public StackValue_Str(software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue s) : base() {
      this._s = s;
    }
    public override _IStackValue DowncastClone() {
      if (this is _IStackValue dt) { return dt; }
      return new StackValue_Str(_s);
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDBFilterExpr_Compile.StackValue_Str;
      return oth != null && object.Equals(this._s, oth._s);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._s));
      return (int) hash;
    }
    public override string ToString() {
      string ss = "DynamoDBFilterExpr.StackValue.Str";
      ss += "(";
      ss += Dafny.Helpers.ToString(this._s);
      ss += ")";
      return ss;
    }
  }
  public class StackValue_DoesNotExist : StackValue {
    public StackValue_DoesNotExist() : base() {
    }
    public override _IStackValue DowncastClone() {
      if (this is _IStackValue dt) { return dt; }
      return new StackValue_DoesNotExist();
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDBFilterExpr_Compile.StackValue_DoesNotExist;
      return oth != null;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      return (int) hash;
    }
    public override string ToString() {
      string s = "DynamoDBFilterExpr.StackValue.DoesNotExist";
      return s;
    }
  }

  public interface _IExprContext {
    bool is_ExprContext { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_keyExpr { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_filterExpr { get; }
    Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> dtor_values { get; }
    Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> dtor_names { get; }
    _IExprContext DowncastClone();
  }
  public class ExprContext : _IExprContext {
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<char>> _keyExpr;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<char>> _filterExpr;
    public readonly Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> _values;
    public readonly Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> _names;
    public ExprContext(Wrappers_Compile._IOption<Dafny.ISequence<char>> keyExpr, Wrappers_Compile._IOption<Dafny.ISequence<char>> filterExpr, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> values, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> names) {
      this._keyExpr = keyExpr;
      this._filterExpr = filterExpr;
      this._values = values;
      this._names = names;
    }
    public _IExprContext DowncastClone() {
      if (this is _IExprContext dt) { return dt; }
      return new ExprContext(_keyExpr, _filterExpr, _values, _names);
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDBFilterExpr_Compile.ExprContext;
      return oth != null && object.Equals(this._keyExpr, oth._keyExpr) && object.Equals(this._filterExpr, oth._filterExpr) && object.Equals(this._values, oth._values) && object.Equals(this._names, oth._names);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._keyExpr));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._filterExpr));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._values));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._names));
      return (int) hash;
    }
    public override string ToString() {
      string s = "DynamoDBFilterExpr.ExprContext.ExprContext";
      s += "(";
      s += Dafny.Helpers.ToString(this._keyExpr);
      s += ", ";
      s += Dafny.Helpers.ToString(this._filterExpr);
      s += ", ";
      s += Dafny.Helpers.ToString(this._values);
      s += ", ";
      s += Dafny.Helpers.ToString(this._names);
      s += ")";
      return s;
    }
    private static readonly DynamoDBFilterExpr_Compile._IExprContext theDefault = create(Wrappers_Compile.Option<Dafny.ISequence<char>>.Default(), Wrappers_Compile.Option<Dafny.ISequence<char>>.Default(), Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.Default(), Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>.Default());
    public static DynamoDBFilterExpr_Compile._IExprContext Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<DynamoDBFilterExpr_Compile._IExprContext> _TYPE = new Dafny.TypeDescriptor<DynamoDBFilterExpr_Compile._IExprContext>(DynamoDBFilterExpr_Compile.ExprContext.Default());
    public static Dafny.TypeDescriptor<DynamoDBFilterExpr_Compile._IExprContext> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IExprContext create(Wrappers_Compile._IOption<Dafny.ISequence<char>> keyExpr, Wrappers_Compile._IOption<Dafny.ISequence<char>> filterExpr, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> values, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> names) {
      return new ExprContext(keyExpr, filterExpr, values, names);
    }
    public static _IExprContext create_ExprContext(Wrappers_Compile._IOption<Dafny.ISequence<char>> keyExpr, Wrappers_Compile._IOption<Dafny.ISequence<char>> filterExpr, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> values, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> names) {
      return create(keyExpr, filterExpr, values, names);
    }
    public bool is_ExprContext { get { return true; } }
    public Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_keyExpr {
      get {
        return this._keyExpr;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_filterExpr {
      get {
        return this._filterExpr;
      }
    }
    public Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> dtor_values {
      get {
        return this._values;
      }
    }
    public Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> dtor_names {
      get {
        return this._names;
      }
    }
  }

  public interface _IParsedContext {
    bool is_ParsedContext { get; }
    Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> dtor_expr { get; }
    Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> dtor_values { get; }
    Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> dtor_names { get; }
    _IParsedContext DowncastClone();
  }
  public class ParsedContext : _IParsedContext {
    public readonly Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> _expr;
    public readonly Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _values;
    public readonly Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> _names;
    public ParsedContext(Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> expr, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> values, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> names) {
      this._expr = expr;
      this._values = values;
      this._names = names;
    }
    public _IParsedContext DowncastClone() {
      if (this is _IParsedContext dt) { return dt; }
      return new ParsedContext(_expr, _values, _names);
    }
    public override bool Equals(object other) {
      var oth = other as DynamoDBFilterExpr_Compile.ParsedContext;
      return oth != null && object.Equals(this._expr, oth._expr) && object.Equals(this._values, oth._values) && object.Equals(this._names, oth._names);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._expr));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._values));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._names));
      return (int) hash;
    }
    public override string ToString() {
      string s = "DynamoDBFilterExpr.ParsedContext.ParsedContext";
      s += "(";
      s += Dafny.Helpers.ToString(this._expr);
      s += ", ";
      s += Dafny.Helpers.ToString(this._values);
      s += ", ";
      s += Dafny.Helpers.ToString(this._names);
      s += ")";
      return s;
    }
    private static readonly DynamoDBFilterExpr_Compile._IParsedContext theDefault = create(Dafny.Sequence<DynamoDBFilterExpr_Compile._IToken>.Empty, Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty, Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>.Default());
    public static DynamoDBFilterExpr_Compile._IParsedContext Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<DynamoDBFilterExpr_Compile._IParsedContext> _TYPE = new Dafny.TypeDescriptor<DynamoDBFilterExpr_Compile._IParsedContext>(DynamoDBFilterExpr_Compile.ParsedContext.Default());
    public static Dafny.TypeDescriptor<DynamoDBFilterExpr_Compile._IParsedContext> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IParsedContext create(Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> expr, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> values, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> names) {
      return new ParsedContext(expr, values, names);
    }
    public static _IParsedContext create_ParsedContext(Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> expr, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> values, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> names) {
      return create(expr, values, names);
    }
    public bool is_ParsedContext { get { return true; } }
    public Dafny.ISequence<DynamoDBFilterExpr_Compile._IToken> dtor_expr {
      get {
        return this._expr;
      }
    }
    public Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> dtor_values {
      get {
        return this._values;
      }
    }
    public Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> dtor_names {
      get {
        return this._names;
      }
    }
  }
} // end of namespace DynamoDBFilterExpr_Compile
namespace DynamoDBSupport_Compile {

  public partial class __default {
    public static Wrappers_Compile._IResult<bool, Dafny.ISequence<char>> IsWriteable(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item) {
      if (Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, bool>>((_0_item) => Dafny.Helpers.Quantifier<Dafny.ISequence<char>>((_0_item).Keys.Elements, true, (((_forall_var_0) => {
        Dafny.ISequence<char> _1_k = (Dafny.ISequence<char>)_forall_var_0;
        return !((_0_item).Contains(_1_k)) || (!(Dafny.Sequence<char>.IsPrefixOf(DynamoDbEncryptionUtil_Compile.__default.ReservedPrefix, _1_k)));
      }))))(item)) {
        return Wrappers_Compile.Result<bool, Dafny.ISequence<char>>.create_Success(true);
      } else {
        Dafny.ISet<Dafny.ISequence<char>> _2_bad = Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.ISet<Dafny.ISequence<char>>>>((_3_item) => ((System.Func<Dafny.ISet<Dafny.ISequence<char>>>)(() => {
          var _coll0 = new System.Collections.Generic.List<Dafny.ISequence<char>>();
          foreach (Dafny.ISequence<char> _compr_0 in (_3_item).Keys.Elements) {
            Dafny.ISequence<char> _4_k = (Dafny.ISequence<char>)_compr_0;
            if (((_3_item).Contains(_4_k)) && (Dafny.Sequence<char>.IsPrefixOf(DynamoDbEncryptionUtil_Compile.__default.ReservedPrefix, _4_k))) {
              _coll0.Add(_4_k);
            }
          }
          return Dafny.Set<Dafny.ISequence<char>>.FromCollection(_coll0);
        }))())(item);
        Dafny.ISequence<Dafny.ISequence<char>> _5_badSeq = SortedSets.__default.SetToOrderedSequence2<char>(_2_bad, DynamoDbEncryptionUtil_Compile.__default.CharLess);
        if ((new BigInteger((_5_badSeq).Count)).Sign == 0) {
          return Wrappers_Compile.Result<bool, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString(""));
        } else {
          return Wrappers_Compile.Result<bool, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Writing reserved attributes not allowed : "), StandardLibrary_Compile.__default.Join<char>(_5_badSeq, Dafny.Sequence<char>.FromString("\n"))));
        }
      }
    }
    public static Dafny.ISequence<Dafny.ISequence<char>> GetEncryptedAttributes(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> actions, Wrappers_Compile._IOption<Dafny.ISequence<char>> expr, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> attrNames)
    {
      if ((expr).is_None) {
        return Dafny.Sequence<Dafny.ISequence<char>>.FromElements();
      } else {
        Dafny.ISequence<Dafny.ISequence<char>> _0_attrs = DynamoDBFilterExpr_Compile.__default.ExtractAttributes((expr).dtor_value, attrNames);
        return Seq_Compile.__default.Filter<Dafny.ISequence<char>>(Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>, Func<Dafny.ISequence<char>, bool>>>((_1_actions) => ((System.Func<Dafny.ISequence<char>, bool>)((_2_attr) => {
          return DynamoDBSupport_Compile.__default.IsEncrypted(_1_actions, _2_attr);
        })))(actions), _0_attrs);
      }
    }
    public static Wrappers_Compile._IResult<bool, Dafny.ISequence<char>> TestConditionExpression(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> actions, Wrappers_Compile._IOption<Dafny.ISequence<char>> expr, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> attrNames, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> attrValues)
    {
      if ((expr).is_Some) {
        Dafny.ISequence<Dafny.ISequence<char>> _0_attrs = DynamoDBSupport_Compile.__default.GetEncryptedAttributes(actions, expr, attrNames);
        if ((new BigInteger((_0_attrs).Count)).Sign == 0) {
          return Wrappers_Compile.Result<bool, Dafny.ISequence<char>>.create_Success(true);
        } else {
          return Wrappers_Compile.Result<bool, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Condition Expressions forbidden on encrypted attributes : "), StandardLibrary_Compile.__default.Join<char>(_0_attrs, Dafny.Sequence<char>.FromString(","))));
        }
      } else {
        return Wrappers_Compile.Result<bool, Dafny.ISequence<char>>.create_Success(true);
      }
    }
    public static bool IsSigned(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> actions, Dafny.ISequence<char> attr)
    {
      return ((actions).Contains(attr)) && (!object.Equals(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Select(actions,attr), software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_DO__NOTHING()));
    }
    public static bool IsEncrypted(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> actions, Dafny.ISequence<char> attr)
    {
      return ((actions).Contains(attr)) && (object.Equals(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Select(actions,attr), software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_ENCRYPT__AND__SIGN()));
    }
    public static Wrappers_Compile._IResult<bool, Dafny.ISequence<char>> TestUpdateExpression(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> actions, Wrappers_Compile._IOption<Dafny.ISequence<char>> expr, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> attrNames, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> attrValues)
    {
      if ((expr).is_Some) {
        Dafny.ISequence<Dafny.ISequence<char>> _0_attrs = DynamoDbUpdateExpr_Compile.__default.ExtractAttributes((expr).dtor_value, attrNames);
        Dafny.ISequence<Dafny.ISequence<char>> _1_encryptedAttrs = Seq_Compile.__default.Filter<Dafny.ISequence<char>>(Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>, Func<Dafny.ISequence<char>, bool>>>((_2_actions) => ((System.Func<Dafny.ISequence<char>, bool>)((_3_s) => {
          return DynamoDBSupport_Compile.__default.IsSigned(_2_actions, _3_s);
        })))(actions), _0_attrs);
        if ((new BigInteger((_1_encryptedAttrs).Count)).Sign == 0) {
          return Wrappers_Compile.Result<bool, Dafny.ISequence<char>>.create_Success(true);
        } else {
          return Wrappers_Compile.Result<bool, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Update Expressions forbidden on signed attributes : "), StandardLibrary_Compile.__default.Join<char>(_1_encryptedAttrs, Dafny.Sequence<char>.FromString(","))));
        }
      } else {
        return Wrappers_Compile.Result<bool, Dafny.ISequence<char>>.create_Success(true);
      }
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetEncryptedBeacons(Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._ISearchInfo> search, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, DynamoDbEncryptionUtil_Compile._IMaybeKeyId keyId)
    {
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
      if ((search).is_None) {
        output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.FromElements());
        return output;
      } else {
        Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
        _out0 = ((search).dtor_value).GenerateEncryptedBeacons(item, keyId);
        output = _out0;
      }
      return output;
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> AddSignedBeacons(Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._ISearchInfo> search, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item)
    {
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
      if ((search).is_None) {
        output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(item);
        return output;
      } else {
        Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
        Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
        _out0 = ((search).dtor_value).GenerateSignedBeacons(item);
        _0_valueOrError0 = _out0;
        if ((_0_valueOrError0).IsFailure()) {
          output = (_0_valueOrError0).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
          return output;
        }
        Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _1_newAttrs;
        _1_newAttrs = (_0_valueOrError0).Extract();
        Dafny.ISet<Dafny.ISequence<char>> _2_badAttrs;
        _2_badAttrs = Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.ISet<Dafny.ISequence<char>>>>((_3_newAttrs, _4_item) => ((System.Func<Dafny.ISet<Dafny.ISequence<char>>>)(() => {
          var _coll0 = new System.Collections.Generic.List<Dafny.ISequence<char>>();
          foreach (Dafny.ISequence<char> _compr_0 in (_3_newAttrs).Keys.Elements) {
            Dafny.ISequence<char> _5_k = (Dafny.ISequence<char>)_compr_0;
            if (software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeName._Is(_5_k)) {
              if ((((_3_newAttrs).Contains(_5_k)) && ((_4_item).Contains(_5_k))) && (!object.Equals(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(_4_item,_5_k), Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(_3_newAttrs,_5_k)))) {
                _coll0.Add(_5_k);
              }
            }
          }
          return Dafny.Set<Dafny.ISequence<char>>.FromCollection(_coll0);
        }))())(_1_newAttrs, item);
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _6_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default();
        _6_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>((new BigInteger((_2_badAttrs).Count)).Sign == 0, DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Signed beacons have generated values different from supplied values.")));
        if ((_6_valueOrError1).IsFailure()) {
          output = (_6_valueOrError1).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
          return output;
        }
        Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _7_version;
        _7_version = Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.FromElements(new Dafny.Pair<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>(DynamoDBSupport_Compile.__default.VersionTag, DdbVirtualFields_Compile.__default.DS(Dafny.Sequence<char>.FromString(" "))));
        Dafny.ISet<Dafny.ISequence<char>> _8_both;
        _8_both = Dafny.Set<Dafny.ISequence<char>>.Intersect((_1_newAttrs).Keys, (item).Keys);
        Dafny.ISet<Dafny.ISequence<char>> _9_bad;
        _9_bad = Dafny.Helpers.Id<Func<Dafny.ISet<Dafny.ISequence<char>>, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.ISet<Dafny.ISequence<char>>>>((_10_both, _11_newAttrs, _12_item) => ((System.Func<Dafny.ISet<Dafny.ISequence<char>>>)(() => {
          var _coll1 = new System.Collections.Generic.List<Dafny.ISequence<char>>();
          foreach (Dafny.ISequence<char> _compr_1 in (_10_both).Elements) {
            Dafny.ISequence<char> _13_k = (Dafny.ISequence<char>)_compr_1;
            if (software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeName._Is(_13_k)) {
              if (((_10_both).Contains(_13_k)) && (!object.Equals(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(_11_newAttrs,_13_k), Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(_12_item,_13_k)))) {
                _coll1.Add(_13_k);
              }
            }
          }
          return Dafny.Set<Dafny.ISequence<char>>.FromCollection(_coll1);
        }))())(_8_both, _1_newAttrs, item);
        if ((new BigInteger((_9_bad).Count)).Sign == 1) {
          Dafny.ISequence<Dafny.ISequence<char>> _14_badSeq;
          _14_badSeq = SortedSets.__default.SetToOrderedSequence2<char>(_9_bad, DynamoDbEncryptionUtil_Compile.__default.CharLess);
          output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Supplied Beacons do not match calculated beacons : "), StandardLibrary_Compile.__default.Join<char>(_14_badSeq, Dafny.Sequence<char>.FromString(", ")))));
          return output;
        }
        if (((((((search).dtor_value).curr()).dtor_keySource).dtor_keyLoc).is_MultiLoc) && ((((((search).dtor_value).curr()).dtor_keySource).dtor_keyLoc).dtor_deleteKey)) {
          Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _15_newItem;
          _15_newItem = Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._ISearchInfo>, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>((_16_item, _17_search) => ((System.Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>)(() => {
            var _coll2 = new System.Collections.Generic.List<Dafny.Pair<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
            foreach (Dafny.ISequence<char> _compr_2 in (_16_item).Keys.Elements) {
              Dafny.ISequence<char> _18_k = (Dafny.ISequence<char>)_compr_2;
              if (software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeName._Is(_18_k)) {
                if (((_16_item).Contains(_18_k)) && (!(_18_k).Equals((((((_17_search).dtor_value).curr()).dtor_keySource).dtor_keyLoc).dtor_keyName))) {
                  _coll2.Add(new Dafny.Pair<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>(_18_k, Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(_16_item,_18_k)));
                }
              }
            }
            return Dafny.Map<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.FromCollection(_coll2);
          }))())(item, search);
          output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Merge(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Merge(_15_newItem, _1_newAttrs), _7_version));
          return output;
        } else {
          output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Merge(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Merge(item, _1_newAttrs), _7_version));
          return output;
        }
      }
      return output;
    }
    public static Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> DoRemoveBeacons(Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item) {
      return Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>((_0_item) => ((System.Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>)(() => {
        var _coll0 = new System.Collections.Generic.List<Dafny.Pair<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>();
        foreach (Dafny.ISequence<char> _compr_0 in (_0_item).Keys.Elements) {
          Dafny.ISequence<char> _1_k = (Dafny.ISequence<char>)_compr_0;
          if (software.amazon.cryptography.services.dynamodb.internaldafny.types.AttributeName._Is(_1_k)) {
            if (((_0_item).Contains(_1_k)) && (!(Dafny.Sequence<char>.IsPrefixOf(DynamoDbEncryptionUtil_Compile.__default.ReservedPrefix, _1_k)))) {
              _coll0.Add(new Dafny.Pair<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>(_1_k, Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(_0_item,_1_k)));
            }
          }
        }
        return Dafny.Map<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.FromCollection(_coll0);
      }))())(item);
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.ISequence<char>> RemoveBeacons(Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._ISearchInfo> search, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item)
    {
      return Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.ISequence<char>>.create_Success(DynamoDBSupport_Compile.__default.DoRemoveBeacons(item));
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> QueryInputForBeacons(Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._ISearchInfo> search, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> actions, software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput req)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>);
      if ((search).is_None) {
        Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(false);
        Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
        _out0 = DynamoDBFilterExpr_Compile.__default.TestBeaconize(actions, (req).dtor_KeyConditionExpression, (req).dtor_FilterExpression, (req).dtor_ExpressionAttributeNames);
        _0_valueOrError0 = _out0;
        if ((_0_valueOrError0).IsFailure()) {
          output = (_0_valueOrError0).PropagateFailure<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput>();
          return output;
        }
        bool _1___v0;
        _1___v0 = (_0_valueOrError0).Extract();
        output = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(req);
        return output;
      } else {
        Wrappers_Compile._IResult<DynamoDbEncryptionUtil_Compile._IMaybeKeyId, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _2_valueOrError1 = Wrappers_Compile.Result<DynamoDbEncryptionUtil_Compile._IMaybeKeyId, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(DynamoDbEncryptionUtil_Compile.MaybeKeyId.Default());
        _2_valueOrError1 = DynamoDBFilterExpr_Compile.__default.GetBeaconKeyId(((search).dtor_value).curr(), (req).dtor_KeyConditionExpression, (req).dtor_FilterExpression, (req).dtor_ExpressionAttributeValues, (req).dtor_ExpressionAttributeNames);
        if ((_2_valueOrError1).IsFailure()) {
          output = (_2_valueOrError1).PropagateFailure<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput>();
          return output;
        }
        DynamoDbEncryptionUtil_Compile._IMaybeKeyId _3_keyId;
        _3_keyId = (_2_valueOrError1).Extract();
        DynamoDBFilterExpr_Compile._IExprContext _4_oldContext;
        _4_oldContext = DynamoDBFilterExpr_Compile.ExprContext.create((req).dtor_KeyConditionExpression, (req).dtor_FilterExpression, (req).dtor_ExpressionAttributeValues, (req).dtor_ExpressionAttributeNames);
        Wrappers_Compile._IResult<DynamoDBFilterExpr_Compile._IExprContext, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _5_valueOrError2 = Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IExprContext, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(DynamoDBFilterExpr_Compile.ExprContext.Default());
        Wrappers_Compile._IResult<DynamoDBFilterExpr_Compile._IExprContext, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out1;
        _out1 = DynamoDBFilterExpr_Compile.__default.Beaconize(((search).dtor_value).curr(), _4_oldContext, _3_keyId, false);
        _5_valueOrError2 = _out1;
        if ((_5_valueOrError2).IsFailure()) {
          output = (_5_valueOrError2).PropagateFailure<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput>();
          return output;
        }
        DynamoDBFilterExpr_Compile._IExprContext _6_newContext;
        _6_newContext = (_5_valueOrError2).Extract();
        var _pat_let_tv0 = _6_newContext;
        var _pat_let_tv1 = _6_newContext;
        var _pat_let_tv2 = _6_newContext;
        var _pat_let_tv3 = _6_newContext;
        output = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput>(req, _pat_let1_0 => Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput>(_pat_let1_0, _7_dt__update__tmp_h0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput>((_pat_let_tv0).dtor_values, _pat_let2_0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput>(_pat_let2_0, _8_dt__update_hExpressionAttributeValues_h0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput>((_pat_let_tv1).dtor_names, _pat_let3_0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput>(_pat_let3_0, _9_dt__update_hExpressionAttributeNames_h0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput>((_pat_let_tv2).dtor_filterExpr, _pat_let4_0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput>(_pat_let4_0, _10_dt__update_hFilterExpression_h0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput>((_pat_let_tv3).dtor_keyExpr, _pat_let5_0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput>(_pat_let5_0, _11_dt__update_hKeyConditionExpression_h0 => software.amazon.cryptography.services.dynamodb.internaldafny.types.QueryInput.create((_7_dt__update__tmp_h0).dtor_TableName, (_7_dt__update__tmp_h0).dtor_IndexName, (_7_dt__update__tmp_h0).dtor_Select, (_7_dt__update__tmp_h0).dtor_AttributesToGet, (_7_dt__update__tmp_h0).dtor_Limit, (_7_dt__update__tmp_h0).dtor_ConsistentRead, (_7_dt__update__tmp_h0).dtor_KeyConditions, (_7_dt__update__tmp_h0).dtor_QueryFilter, (_7_dt__update__tmp_h0).dtor_ConditionalOperator, (_7_dt__update__tmp_h0).dtor_ScanIndexForward, (_7_dt__update__tmp_h0).dtor_ExclusiveStartKey, (_7_dt__update__tmp_h0).dtor_ReturnConsumedCapacity, (_7_dt__update__tmp_h0).dtor_ProjectionExpression, _10_dt__update_hFilterExpression_h0, _11_dt__update_hKeyConditionExpression_h0, _9_dt__update_hExpressionAttributeNames_h0, _8_dt__update_hExpressionAttributeValues_h0))))))))))));
        return output;
      }
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> QueryOutputForBeacons(Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._ISearchInfo> search, software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput req, software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput resp)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(software.amazon.cryptography.services.dynamodb.internaldafny.types.QueryOutput.Default());
      if ((search).is_None) {
        Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> _0_trimmedItems;
        _0_trimmedItems = Seq_Compile.__default.Map<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>(((System.Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>)((_1_i) => {
          return DynamoDBSupport_Compile.__default.DoRemoveBeacons(_1_i);
        })), ((resp).dtor_Items).dtor_value);
        var _pat_let_tv0 = _0_trimmedItems;
        output = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput>(resp, _pat_let6_0 => Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput>(_pat_let6_0, _2_dt__update__tmp_h0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput>(Wrappers_Compile.Option<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>.create_Some(_pat_let_tv0), _pat_let7_0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput>(_pat_let7_0, _3_dt__update_hItems_h0 => software.amazon.cryptography.services.dynamodb.internaldafny.types.QueryOutput.create(_3_dt__update_hItems_h0, (_2_dt__update__tmp_h0).dtor_Count, (_2_dt__update__tmp_h0).dtor_ScannedCount, (_2_dt__update__tmp_h0).dtor_LastEvaluatedKey, (_2_dt__update__tmp_h0).dtor_ConsumedCapacity))))));
        return output;
      } else {
        Wrappers_Compile._IResult<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _4_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Sequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.Empty);
        Wrappers_Compile._IResult<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
        _out0 = DynamoDBFilterExpr_Compile.__default.FilterResults(((search).dtor_value).curr(), ((resp).dtor_Items).dtor_value, (req).dtor_KeyConditionExpression, (req).dtor_FilterExpression, (req).dtor_ExpressionAttributeNames, (req).dtor_ExpressionAttributeValues);
        _4_valueOrError0 = _out0;
        if ((_4_valueOrError0).IsFailure()) {
          output = (_4_valueOrError0).PropagateFailure<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput>();
          return output;
        }
        Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> _5_newItems;
        _5_newItems = (_4_valueOrError0).Extract();
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _6_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default();
        _6_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>((new BigInteger((_5_newItems).Count)) < (StandardLibrary_mUInt_Compile.__default.INT32__MAX__LIMIT), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("This is impossible.")));
        if ((_6_valueOrError1).IsFailure()) {
          output = (_6_valueOrError1).PropagateFailure<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput>();
          return output;
        }
        Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> _7_trimmedItems;
        _7_trimmedItems = Seq_Compile.__default.Map<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>(((System.Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>)((_8_i) => {
          return DynamoDBSupport_Compile.__default.DoRemoveBeacons(_8_i);
        })), _5_newItems);
        Wrappers_Compile._IOption<int> _9_count;
        if (((resp).dtor_Count).is_Some) {
          _9_count = Wrappers_Compile.Option<int>.create_Some((int)(_7_trimmedItems).Count);
        } else {
          _9_count = Wrappers_Compile.Option<int>.create_None();
        }
        var _pat_let_tv1 = _9_count;
        var _pat_let_tv2 = _7_trimmedItems;
        output = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput>(resp, _pat_let8_0 => Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput>(_pat_let8_0, _10_dt__update__tmp_h1 => Dafny.Helpers.Let<Wrappers_Compile._IOption<int>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput>(_pat_let_tv1, _pat_let9_0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<int>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput>(_pat_let9_0, _11_dt__update_hCount_h0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput>(Wrappers_Compile.Option<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>.create_Some(_pat_let_tv2), _pat_let10_0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput>(_pat_let10_0, _12_dt__update_hItems_h1 => software.amazon.cryptography.services.dynamodb.internaldafny.types.QueryOutput.create(_12_dt__update_hItems_h1, _11_dt__update_hCount_h0, (_10_dt__update__tmp_h1).dtor_ScannedCount, (_10_dt__update__tmp_h1).dtor_LastEvaluatedKey, (_10_dt__update__tmp_h1).dtor_ConsumedCapacity))))))));
        return output;
      }
      return output;
    }
    public static Wrappers_Compile._IResult<DynamoDbEncryptionUtil_Compile._IMaybeKeyId, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetBeaconKeyId(Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._ISearchInfo> search, Wrappers_Compile._IOption<Dafny.ISequence<char>> keyExpr, Wrappers_Compile._IOption<Dafny.ISequence<char>> filterExpr, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> values, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> names)
    {
      if ((search).is_None) {
        return Wrappers_Compile.Result<DynamoDbEncryptionUtil_Compile._IMaybeKeyId, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(DynamoDbEncryptionUtil_Compile.MaybeKeyId.create_DontUseKeyId());
      } else {
        return DynamoDBFilterExpr_Compile.__default.GetBeaconKeyId(((search).dtor_value).curr(), keyExpr, filterExpr, values, names);
      }
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> ScanInputForBeacons(Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._ISearchInfo> search, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> actions, software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput req)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>);
      if ((search).is_None) {
        Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(false);
        Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
        _out0 = DynamoDBFilterExpr_Compile.__default.TestBeaconize(actions, Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None(), (req).dtor_FilterExpression, (req).dtor_ExpressionAttributeNames);
        _0_valueOrError0 = _out0;
        if ((_0_valueOrError0).IsFailure()) {
          output = (_0_valueOrError0).PropagateFailure<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput>();
          return output;
        }
        bool _1___v1;
        _1___v1 = (_0_valueOrError0).Extract();
        output = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(req);
        return output;
      } else {
        Wrappers_Compile._IResult<DynamoDbEncryptionUtil_Compile._IMaybeKeyId, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _2_valueOrError1 = Wrappers_Compile.Result<DynamoDbEncryptionUtil_Compile._IMaybeKeyId, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(DynamoDbEncryptionUtil_Compile.MaybeKeyId.Default());
        _2_valueOrError1 = DynamoDBFilterExpr_Compile.__default.GetBeaconKeyId(((search).dtor_value).curr(), Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None(), (req).dtor_FilterExpression, (req).dtor_ExpressionAttributeValues, (req).dtor_ExpressionAttributeNames);
        if ((_2_valueOrError1).IsFailure()) {
          output = (_2_valueOrError1).PropagateFailure<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput>();
          return output;
        }
        DynamoDbEncryptionUtil_Compile._IMaybeKeyId _3_keyId;
        _3_keyId = (_2_valueOrError1).Extract();
        DynamoDBFilterExpr_Compile._IExprContext _4_context;
        _4_context = DynamoDBFilterExpr_Compile.ExprContext.create(Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None(), (req).dtor_FilterExpression, (req).dtor_ExpressionAttributeValues, (req).dtor_ExpressionAttributeNames);
        Wrappers_Compile._IResult<DynamoDBFilterExpr_Compile._IExprContext, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _5_valueOrError2 = Wrappers_Compile.Result<DynamoDBFilterExpr_Compile._IExprContext, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(DynamoDBFilterExpr_Compile.ExprContext.Default());
        Wrappers_Compile._IResult<DynamoDBFilterExpr_Compile._IExprContext, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out1;
        _out1 = DynamoDBFilterExpr_Compile.__default.Beaconize(((search).dtor_value).curr(), _4_context, _3_keyId, false);
        _5_valueOrError2 = _out1;
        if ((_5_valueOrError2).IsFailure()) {
          output = (_5_valueOrError2).PropagateFailure<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput>();
          return output;
        }
        DynamoDBFilterExpr_Compile._IExprContext _6_newContext;
        _6_newContext = (_5_valueOrError2).Extract();
        var _pat_let_tv0 = _6_newContext;
        var _pat_let_tv1 = _6_newContext;
        var _pat_let_tv2 = _6_newContext;
        output = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput>(req, _pat_let11_0 => Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput>(_pat_let11_0, _7_dt__update__tmp_h0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput>((_pat_let_tv0).dtor_values, _pat_let12_0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput>(_pat_let12_0, _8_dt__update_hExpressionAttributeValues_h0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput>((_pat_let_tv1).dtor_names, _pat_let13_0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput>(_pat_let13_0, _9_dt__update_hExpressionAttributeNames_h0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput>((_pat_let_tv2).dtor_filterExpr, _pat_let14_0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput>(_pat_let14_0, _10_dt__update_hFilterExpression_h0 => software.amazon.cryptography.services.dynamodb.internaldafny.types.ScanInput.create((_7_dt__update__tmp_h0).dtor_TableName, (_7_dt__update__tmp_h0).dtor_IndexName, (_7_dt__update__tmp_h0).dtor_AttributesToGet, (_7_dt__update__tmp_h0).dtor_Limit, (_7_dt__update__tmp_h0).dtor_Select, (_7_dt__update__tmp_h0).dtor_ScanFilter, (_7_dt__update__tmp_h0).dtor_ConditionalOperator, (_7_dt__update__tmp_h0).dtor_ExclusiveStartKey, (_7_dt__update__tmp_h0).dtor_ReturnConsumedCapacity, (_7_dt__update__tmp_h0).dtor_TotalSegments, (_7_dt__update__tmp_h0).dtor_Segment, (_7_dt__update__tmp_h0).dtor_ProjectionExpression, _10_dt__update_hFilterExpression_h0, _9_dt__update_hExpressionAttributeNames_h0, _8_dt__update_hExpressionAttributeValues_h0, (_7_dt__update__tmp_h0).dtor_ConsistentRead))))))))));
        return output;
      }
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> ScanOutputForBeacons(Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._ISearchInfo> search, software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput req, software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput resp)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> ret = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(software.amazon.cryptography.services.dynamodb.internaldafny.types.ScanOutput.Default());
      if ((search).is_None) {
        Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> _0_trimmedItems;
        _0_trimmedItems = Seq_Compile.__default.Map<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>(((System.Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>)((_1_i) => {
          return DynamoDBSupport_Compile.__default.DoRemoveBeacons(_1_i);
        })), ((resp).dtor_Items).dtor_value);
        var _pat_let_tv0 = _0_trimmedItems;
        ret = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput>(resp, _pat_let15_0 => Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput>(_pat_let15_0, _2_dt__update__tmp_h0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput>(Wrappers_Compile.Option<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>.create_Some(_pat_let_tv0), _pat_let16_0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput>(_pat_let16_0, _3_dt__update_hItems_h0 => software.amazon.cryptography.services.dynamodb.internaldafny.types.ScanOutput.create(_3_dt__update_hItems_h0, (_2_dt__update__tmp_h0).dtor_Count, (_2_dt__update__tmp_h0).dtor_ScannedCount, (_2_dt__update__tmp_h0).dtor_LastEvaluatedKey, (_2_dt__update__tmp_h0).dtor_ConsumedCapacity))))));
        return ret;
      } else {
        Wrappers_Compile._IResult<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _4_valueOrError0 = Wrappers_Compile.Result<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Sequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.Empty);
        Wrappers_Compile._IResult<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
        _out0 = DynamoDBFilterExpr_Compile.__default.FilterResults(((search).dtor_value).curr(), ((resp).dtor_Items).dtor_value, Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None(), (req).dtor_FilterExpression, (req).dtor_ExpressionAttributeNames, (req).dtor_ExpressionAttributeValues);
        _4_valueOrError0 = _out0;
        if ((_4_valueOrError0).IsFailure()) {
          ret = (_4_valueOrError0).PropagateFailure<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput>();
          return ret;
        }
        Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> _5_newItems;
        _5_newItems = (_4_valueOrError0).Extract();
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _6_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default();
        _6_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>((new BigInteger((_5_newItems).Count)) < (StandardLibrary_mUInt_Compile.__default.INT32__MAX__LIMIT), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("This is impossible.")));
        if ((_6_valueOrError1).IsFailure()) {
          ret = (_6_valueOrError1).PropagateFailure<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput>();
          return ret;
        }
        Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> _7_trimmedItems;
        _7_trimmedItems = Seq_Compile.__default.Map<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>(((System.Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>)((_8_i) => {
          return DynamoDBSupport_Compile.__default.DoRemoveBeacons(_8_i);
        })), _5_newItems);
        Wrappers_Compile._IOption<int> _9_count;
        if (((resp).dtor_Count).is_Some) {
          _9_count = Wrappers_Compile.Option<int>.create_Some((int)(_7_trimmedItems).Count);
        } else {
          _9_count = Wrappers_Compile.Option<int>.create_None();
        }
        var _pat_let_tv1 = _9_count;
        var _pat_let_tv2 = _7_trimmedItems;
        ret = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput>(resp, _pat_let17_0 => Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput>(_pat_let17_0, _10_dt__update__tmp_h1 => Dafny.Helpers.Let<Wrappers_Compile._IOption<int>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput>(_pat_let_tv1, _pat_let18_0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<int>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput>(_pat_let18_0, _11_dt__update_hCount_h0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput>(Wrappers_Compile.Option<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>.create_Some(_pat_let_tv2), _pat_let19_0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput>(_pat_let19_0, _12_dt__update_hItems_h1 => software.amazon.cryptography.services.dynamodb.internaldafny.types.ScanOutput.create(_12_dt__update_hItems_h1, _11_dt__update_hCount_h0, (_10_dt__update__tmp_h1).dtor_ScannedCount, (_10_dt__update__tmp_h1).dtor_LastEvaluatedKey, (_10_dt__update__tmp_h1).dtor_ConsumedCapacity))))))));
        return ret;
      }
      return ret;
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetVirtualFieldsLoop(Dafny.ISequence<Dafny.ISequence<char>> fields, SearchableEncryptionInfo_Compile._IBeaconVersion bv, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> results)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((fields).Count)).Sign == 0) {
        return Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(results);
      } else {
        Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = DdbVirtualFields_Compile.__default.GetVirtField(Dafny.Map<Dafny.ISequence<char>, DdbVirtualFields_Compile._IVirtField>.Select((bv).dtor_virtualFields,(fields).Select(BigInteger.Zero)), item);
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>();
        } else {
          Wrappers_Compile._IOption<Dafny.ISequence<char>> _1_optValue = (_0_valueOrError0).Extract();
          if ((_1_optValue).is_Some) {
            Dafny.ISequence<Dafny.ISequence<char>> _in0 = (fields).Drop(BigInteger.One);
            SearchableEncryptionInfo_Compile._IBeaconVersion _in1 = bv;
            Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in2 = item;
            Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> _in3 = Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Update(results, (fields).Select(BigInteger.Zero), (_1_optValue).dtor_value);
            fields = _in0;
            bv = _in1;
            item = _in2;
            results = _in3;
            goto TAIL_CALL_START;
          } else {
            Dafny.ISequence<Dafny.ISequence<char>> _in4 = (fields).Drop(BigInteger.One);
            SearchableEncryptionInfo_Compile._IBeaconVersion _in5 = bv;
            Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in6 = item;
            Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> _in7 = results;
            fields = _in4;
            bv = _in5;
            item = _in6;
            results = _in7;
            goto TAIL_CALL_START;
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetVirtualFields(SearchableEncryptionInfo_Compile._IBeaconVersion beaconVersion, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item)
    {
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Empty);
      Dafny.ISequence<Dafny.ISequence<char>> _0_fieldNames;
      _0_fieldNames = SortedSets.__default.SetToOrderedSequence2<char>(((beaconVersion).dtor_virtualFields).Keys, DynamoDbEncryptionUtil_Compile.__default.CharLess);
      output = DynamoDBSupport_Compile.__default.GetVirtualFieldsLoop(_0_fieldNames, beaconVersion, item, Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.FromElements());
      return output;
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetCompoundBeaconsLoop(Dafny.ISequence<Dafny.ISequence<char>> fields, SearchableEncryptionInfo_Compile._IBeaconVersion bv, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> results)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((fields).Count)).Sign == 0) {
        return Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(results);
      } else {
        SearchableEncryptionInfo_Compile._IBeacon _0_beacon = Dafny.Map<Dafny.ISequence<char>, SearchableEncryptionInfo_Compile._IBeacon>.Select((bv).dtor_beacons,(fields).Select(BigInteger.Zero));
        if ((_0_beacon).is_Compound) {
          Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _1_valueOrError0 = ((_0_beacon).dtor_cmp).getNaked(item, (bv).dtor_virtualFields);
          if ((_1_valueOrError0).IsFailure()) {
            return (_1_valueOrError0).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>>();
          } else {
            Wrappers_Compile._IOption<Dafny.ISequence<char>> _2_optValue = (_1_valueOrError0).Extract();
            if ((_2_optValue).is_Some) {
              Dafny.ISequence<Dafny.ISequence<char>> _in0 = (fields).Drop(BigInteger.One);
              SearchableEncryptionInfo_Compile._IBeaconVersion _in1 = bv;
              Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in2 = item;
              Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> _in3 = Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Update(results, (fields).Select(BigInteger.Zero), (_2_optValue).dtor_value);
              fields = _in0;
              bv = _in1;
              item = _in2;
              results = _in3;
              goto TAIL_CALL_START;
            } else {
              Dafny.ISequence<Dafny.ISequence<char>> _in4 = (fields).Drop(BigInteger.One);
              SearchableEncryptionInfo_Compile._IBeaconVersion _in5 = bv;
              Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in6 = item;
              Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> _in7 = results;
              fields = _in4;
              bv = _in5;
              item = _in6;
              results = _in7;
              goto TAIL_CALL_START;
            }
          }
        } else {
          Dafny.ISequence<Dafny.ISequence<char>> _in8 = (fields).Drop(BigInteger.One);
          SearchableEncryptionInfo_Compile._IBeaconVersion _in9 = bv;
          Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _in10 = item;
          Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> _in11 = results;
          fields = _in8;
          bv = _in9;
          item = _in10;
          results = _in11;
          goto TAIL_CALL_START;
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetCompoundBeacons(SearchableEncryptionInfo_Compile._IBeaconVersion beaconVersion, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item)
    {
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Empty);
      Dafny.ISequence<Dafny.ISequence<char>> _0_beaconNames;
      _0_beaconNames = SortedSets.__default.SetToOrderedSequence2<char>(((beaconVersion).dtor_beacons).Keys, DynamoDbEncryptionUtil_Compile.__default.CharLess);
      output = DynamoDBSupport_Compile.__default.GetCompoundBeaconsLoop(_0_beaconNames, beaconVersion, item, Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.FromElements());
      return output;
    }
    public static Dafny.ISequence<char> VersionTag { get {
      return Dafny.Sequence<char>.Concat(DynamoDbEncryptionUtil_Compile.__default.VersionPrefix, Dafny.Sequence<char>.FromString("1"));
    } }
  }
} // end of namespace DynamoDBSupport_Compile
namespace SearchConfigToInfo_Compile {

  public partial class __default {
    public static Wrappers_Compile._IResult<Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._ISearchInfo>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> Convert(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig outer)
    {
      Wrappers_Compile._IResult<Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._ISearchInfo>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = Wrappers_Compile.Result<Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._ISearchInfo>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Wrappers_Compile.Option<SearchableEncryptionInfo_Compile._ISearchInfo>.Default());
      if (((outer).dtor_search).is_None) {
        output = Wrappers_Compile.Result<Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._ISearchInfo>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Wrappers_Compile.Option<SearchableEncryptionInfo_Compile._ISearchInfo>.create_None());
        return output;
      } else {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default();
        _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(((((outer).dtor_search).dtor_value).dtor_writeVersion) == (1), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("writeVersion must be '1'.")));
        if ((_0_valueOrError0).IsFailure()) {
          output = (_0_valueOrError0).PropagateFailure<Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._ISearchInfo>>();
          return output;
        }
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _1_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default();
        _1_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>((new BigInteger(((((outer).dtor_search).dtor_value).dtor_versions).Count)) == (BigInteger.One), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("search config must be have exactly one version.")));
        if ((_1_valueOrError1).IsFailure()) {
          output = (_1_valueOrError1).PropagateFailure<Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._ISearchInfo>>();
          return output;
        }
        Wrappers_Compile._IResult<SearchableEncryptionInfo_Compile._IBeaconVersion, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _2_valueOrError2 = default(Wrappers_Compile._IResult<SearchableEncryptionInfo_Compile._IBeaconVersion, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>);
        Wrappers_Compile._IResult<SearchableEncryptionInfo_Compile._IBeaconVersion, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
        _out0 = SearchConfigToInfo_Compile.__default.ConvertVersion(outer, ((((outer).dtor_search).dtor_value).dtor_versions).Select(BigInteger.Zero));
        _2_valueOrError2 = _out0;
        if ((_2_valueOrError2).IsFailure()) {
          output = (_2_valueOrError2).PropagateFailure<Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._ISearchInfo>>();
          return output;
        }
        SearchableEncryptionInfo_Compile._IBeaconVersion _3_version;
        _3_version = (_2_valueOrError2).Extract();
        SearchableEncryptionInfo_Compile._ISearchInfo _4_info;
        _4_info = SearchableEncryptionInfo_Compile.__default.MakeSearchInfo(_3_version);
        output = Wrappers_Compile.Result<Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._ISearchInfo>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Wrappers_Compile.Option<SearchableEncryptionInfo_Compile._ISearchInfo>.create_Some(_4_info));
        return output;
      }
      return output;
    }
    public static Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> ShouldDeleteKeyField(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig outer, Dafny.ISequence<char> keyFieldName)
    {
      if (!((outer).dtor_attributeActionsOnEncrypt).Contains(keyFieldName)) {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(true);
      } else {
        software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction _source0 = Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Select((outer).dtor_attributeActionsOnEncrypt,keyFieldName);
        {
          if (_source0.is_DO__NOTHING) {
            return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(true);
          }
        }
        {
          if (_source0.is_SIGN__ONLY) {
            return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(false);
          }
        }
        {
          if (_source0.is_SIGN__AND__INCLUDE__IN__ENCRYPTION__CONTEXT) {
            return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(false);
          }
        }
        {
          return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Beacon key field name "), keyFieldName), Dafny.Sequence<char>.FromString(" is configured as ENCRYPT_AND_SIGN which is not allowed."))));
        }
      }
    }
    public static Wrappers_Compile._IResult<SearchableEncryptionInfo_Compile._IKeySource, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> MakeKeySource(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig outer, software.amazon.cryptography.keystore.internaldafny.types.IKeyStoreClient keyStore, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconKeySource config, software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient client)
    {
      Wrappers_Compile._IResult<SearchableEncryptionInfo_Compile._IKeySource, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<SearchableEncryptionInfo_Compile._IKeySource, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _0_mplR;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out0;
      _out0 = software.amazon.cryptography.materialproviders.internaldafny.__default.MaterialProviders(software.amazon.cryptography.materialproviders.internaldafny.__default.DefaultMaterialProvidersConfig());
      _0_mplR = _out0;
      Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _1_valueOrError0 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>);
      _1_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(_0_mplR, ((System.Func<software.amazon.cryptography.materialproviders.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>)((_2_e) => {
        return software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Error.create_AwsCryptographyMaterialProviders(_2_e);
      })));
      if ((_1_valueOrError0).IsFailure()) {
        output = (_1_valueOrError0).PropagateFailure<SearchableEncryptionInfo_Compile._IKeySource>();
        return output;
      }
      software.amazon.cryptography.materialproviders.internaldafny.MaterialProvidersClient _3_mpl;
      _3_mpl = (_1_valueOrError0).Extract();
      software.amazon.cryptography.materialproviders.internaldafny.types._ICacheType _4_cacheType;
      if ((config).is_multi) {
        if ((((config).dtor_multi).dtor_cache).is_Some) {
          _4_cacheType = (((config).dtor_multi).dtor_cache).dtor_value;
        } else {
          _4_cacheType = software.amazon.cryptography.materialproviders.internaldafny.types.CacheType.create_Default(software.amazon.cryptography.materialproviders.internaldafny.types.DefaultCache.create(1000));
        }
      } else {
        _4_cacheType = software.amazon.cryptography.materialproviders.internaldafny.types.CacheType.create_Default(software.amazon.cryptography.materialproviders.internaldafny.types.DefaultCache.create(1));
      }
      software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache _5_cache = default(software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache);
      if ((_4_cacheType).is_Shared) {
        output = Wrappers_Compile.Result<SearchableEncryptionInfo_Compile._IKeySource, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Error.create_DynamoDbEncryptionException(Dafny.Sequence<char>.FromString("Searchable Encryption does not support the Shared Cache type at this time.")));
        return output;
      } else {
        software.amazon.cryptography.materialproviders.internaldafny.types._ICreateCryptographicMaterialsCacheInput _6_input;
        _6_input = software.amazon.cryptography.materialproviders.internaldafny.types.CreateCryptographicMaterialsCacheInput.create(_4_cacheType);
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _7_maybeCache;
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache, software.amazon.cryptography.materialproviders.internaldafny.types._IError> _out1;
        _out1 = (_3_mpl).CreateCryptographicMaterialsCache(_6_input);
        _7_maybeCache = _out1;
        Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _8_valueOrError1 = default(Wrappers_Compile._IResult<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>);
        _8_valueOrError1 = Wrappers_Compile.Result<software.amazon.cryptography.materialproviders.internaldafny.types.ICryptographicMaterialsCache, software.amazon.cryptography.materialproviders.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(_7_maybeCache, ((System.Func<software.amazon.cryptography.materialproviders.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>)((_9_e) => {
          return software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Error.create_AwsCryptographyMaterialProviders(_9_e);
        })));
        if ((_8_valueOrError1).IsFailure()) {
          output = (_8_valueOrError1).PropagateFailure<SearchableEncryptionInfo_Compile._IKeySource>();
          return output;
        }
        _5_cache = (_8_valueOrError1).Extract();
      }
      if ((config).is_multi) {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _10_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default();
        _10_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>((0) < (((config).dtor_multi).dtor_cacheTTL), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Beacon Cache TTL must be at least 1.")));
        if ((_10_valueOrError2).IsFailure()) {
          output = (_10_valueOrError2).PropagateFailure<SearchableEncryptionInfo_Compile._IKeySource>();
          return output;
        }
        Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _11_valueOrError3 = Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(false);
        _11_valueOrError3 = SearchConfigToInfo_Compile.__default.ShouldDeleteKeyField(outer, ((config).dtor_multi).dtor_keyFieldName);
        if ((_11_valueOrError3).IsFailure()) {
          output = (_11_valueOrError3).PropagateFailure<SearchableEncryptionInfo_Compile._IKeySource>();
          return output;
        }
        bool _12_deleteKey;
        _12_deleteKey = (_11_valueOrError3).Extract();
        output = Wrappers_Compile.Result<SearchableEncryptionInfo_Compile._IKeySource, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(SearchableEncryptionInfo_Compile.KeySource.create(client, keyStore, SearchableEncryptionInfo_Compile.KeyLocation.create_MultiLoc(((config).dtor_multi).dtor_keyFieldName, _12_deleteKey), _5_cache, (uint)(((config).dtor_multi).dtor_cacheTTL)));
      } else {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _13_valueOrError4 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default();
        _13_valueOrError4 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>((0) < (((config).dtor_single).dtor_cacheTTL), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Beacon Cache TTL must be at least 1.")));
        if ((_13_valueOrError4).IsFailure()) {
          output = (_13_valueOrError4).PropagateFailure<SearchableEncryptionInfo_Compile._IKeySource>();
          return output;
        }
        output = Wrappers_Compile.Result<SearchableEncryptionInfo_Compile._IKeySource, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(SearchableEncryptionInfo_Compile.KeySource.create(client, keyStore, SearchableEncryptionInfo_Compile.KeyLocation.create_SingleLoc(((config).dtor_single).dtor_keyId), _5_cache, (uint)(((config).dtor_single).dtor_cacheTTL)));
      }
      return output;
    }
    public static Wrappers_Compile._IResult<SearchableEncryptionInfo_Compile._IBeaconVersion, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> ConvertVersion(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig outer, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconVersion config)
    {
      Wrappers_Compile._IResult<SearchableEncryptionInfo_Compile._IBeaconVersion, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<SearchableEncryptionInfo_Compile._IBeaconVersion, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default();
      _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(((config).dtor_version) == (1), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Version number in BeaconVersion must be '1'.")));
      if ((_0_valueOrError0).IsFailure()) {
        output = (_0_valueOrError0).PropagateFailure<SearchableEncryptionInfo_Compile._IBeaconVersion>();
        return output;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _1_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default();
      _1_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>((new BigInteger(((config).dtor_standardBeacons).Count)).Sign == 1, DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("At least one standard beacon must be configured.")));
      if ((_1_valueOrError1).IsFailure()) {
        output = (_1_valueOrError1).PropagateFailure<SearchableEncryptionInfo_Compile._IBeaconVersion>();
        return output;
      }
      Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.primitives.internaldafny.types._IError> _2_maybePrimitives;
      Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.primitives.internaldafny.types._IError> _out0;
      _out0 = software.amazon.cryptography.primitives.internaldafny.__default.AtomicPrimitives(software.amazon.cryptography.primitives.internaldafny.__default.DefaultCryptoConfig());
      _2_maybePrimitives = _out0;
      Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _3_valueOrError2 = default(Wrappers_Compile._IResult<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>);
      _3_valueOrError2 = Wrappers_Compile.Result<software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient, software.amazon.cryptography.primitives.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(_2_maybePrimitives, ((System.Func<software.amazon.cryptography.primitives.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>)((_4_e) => {
        return software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.Error.create_AwsCryptographyPrimitives(_4_e);
      })));
      if ((_3_valueOrError2).IsFailure()) {
        output = (_3_valueOrError2).PropagateFailure<SearchableEncryptionInfo_Compile._IBeaconVersion>();
        return output;
      }
      software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient _5_primitives;
      _5_primitives = (_3_valueOrError2).Extract();
      Wrappers_Compile._IResult<SearchableEncryptionInfo_Compile._IKeySource, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _6_valueOrError3 = default(Wrappers_Compile._IResult<SearchableEncryptionInfo_Compile._IKeySource, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>);
      Wrappers_Compile._IResult<SearchableEncryptionInfo_Compile._IKeySource, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out1;
      _out1 = SearchConfigToInfo_Compile.__default.MakeKeySource(outer, (config).dtor_keyStore, (config).dtor_keySource, _5_primitives);
      _6_valueOrError3 = _out1;
      if ((_6_valueOrError3).IsFailure()) {
        output = (_6_valueOrError3).PropagateFailure<SearchableEncryptionInfo_Compile._IBeaconVersion>();
        return output;
      }
      SearchableEncryptionInfo_Compile._IKeySource _7_source;
      _7_source = (_6_valueOrError3).Extract();
      Wrappers_Compile._IResult<SearchableEncryptionInfo_Compile._IBeaconVersion, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out2;
      _out2 = SearchConfigToInfo_Compile.__default.ConvertVersionWithSource(outer, config, _7_source);
      output = _out2;
      return output;
    }
    public static Wrappers_Compile._IResult<SearchableEncryptionInfo_Compile._IBeaconVersion, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> ConvertVersionWithSource(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig outer, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconVersion config, SearchableEncryptionInfo_Compile._IKeySource source)
    {
      Wrappers_Compile._IResult<SearchableEncryptionInfo_Compile._IBeaconVersion, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<SearchableEncryptionInfo_Compile._IBeaconVersion, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>);
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, DdbVirtualFields_Compile._IVirtField>.Empty);
      _0_valueOrError0 = SearchConfigToInfo_Compile.__default.ConvertVirtualFields(outer, (config).dtor_virtualFields);
      if ((_0_valueOrError0).IsFailure()) {
        output = (_0_valueOrError0).PropagateFailure<SearchableEncryptionInfo_Compile._IBeaconVersion>();
        return output;
      }
      Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> _1_virtualFields;
      _1_virtualFields = (_0_valueOrError0).Extract();
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _2_valueOrError1 = default(Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>);
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
      _out0 = SearchConfigToInfo_Compile.__default.AddStandardBeacons((config).dtor_standardBeacons, outer, (source).dtor_client, _1_virtualFields, Dafny.Map<Dafny.ISequence<char>, SearchableEncryptionInfo_Compile._IBeacon>.FromElements());
      _2_valueOrError1 = _out0;
      if ((_2_valueOrError1).IsFailure()) {
        output = (_2_valueOrError1).PropagateFailure<SearchableEncryptionInfo_Compile._IBeaconVersion>();
        return output;
      }
      Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon> _3_std;
      _3_std = (_2_valueOrError1).Extract();
      Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart> _4_signed;
      if (((config).dtor_signedParts).is_Some) {
        _4_signed = ((config).dtor_signedParts).dtor_value;
      } else {
        _4_signed = Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart>.FromElements();
      }
      Wrappers_Compile._IResult<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _5_valueOrError2 = Wrappers_Compile.Result<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(SearchConfigToInfo_Compile.PartSet.Default());
      _5_valueOrError2 = SearchConfigToInfo_Compile.__default.GetSignedParts(_4_signed, outer, Dafny.Sequence<char>.FromString("Global Parts List"), SearchConfigToInfo_Compile.PartSet.create(Dafny.Sequence<CompoundBeacon_Compile._IBeaconPart>.FromElements(), Dafny.Set<Dafny.ISequence<char>>.FromElements(), Dafny.Set<Dafny.ISequence<char>>.FromElements()));
      if ((_5_valueOrError2).IsFailure()) {
        output = (_5_valueOrError2).PropagateFailure<SearchableEncryptionInfo_Compile._IBeaconVersion>();
        return output;
      }
      SearchConfigToInfo_Compile._IPartSet _6_globalSignedParts;
      _6_globalSignedParts = (_5_valueOrError2).Extract();
      SearchConfigToInfo_Compile._IPartSet _7_globalEncryptedParts;
      _7_globalEncryptedParts = SearchConfigToInfo_Compile.PartSet.create(Dafny.Sequence<CompoundBeacon_Compile._IBeaconPart>.FromElements(), Dafny.Set<Dafny.ISequence<char>>.FromElements(), Dafny.Set<Dafny.ISequence<char>>.FromElements());
      if (((config).dtor_encryptedParts).is_Some) {
        Wrappers_Compile._IResult<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _8_valueOrError3 = Wrappers_Compile.Result<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(SearchConfigToInfo_Compile.PartSet.Default());
        _8_valueOrError3 = SearchConfigToInfo_Compile.__default.GetEncryptedParts(((config).dtor_encryptedParts).dtor_value, _3_std, Dafny.Sequence<char>.FromString("Global Parts List"), SearchConfigToInfo_Compile.PartSet.create(Dafny.Sequence<CompoundBeacon_Compile._IBeaconPart>.FromElements(), Dafny.Set<Dafny.ISequence<char>>.FromElements(), Dafny.Set<Dafny.ISequence<char>>.FromElements()));
        if ((_8_valueOrError3).IsFailure()) {
          output = (_8_valueOrError3).PropagateFailure<SearchableEncryptionInfo_Compile._IBeaconVersion>();
          return output;
        }
        _7_globalEncryptedParts = (_8_valueOrError3).Extract();
      }
      Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon> _9_beacons = default(Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon>);
      if (((config).dtor_compoundBeacons).is_Some) {
        Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _10_valueOrError4 = default(Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>);
        Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out1;
        _out1 = SearchConfigToInfo_Compile.__default.AddCompoundBeacons(((config).dtor_compoundBeacons).dtor_value, outer, (source).dtor_client, _1_virtualFields, _3_std, _6_globalSignedParts, _7_globalEncryptedParts);
        _10_valueOrError4 = _out1;
        if ((_10_valueOrError4).IsFailure()) {
          output = (_10_valueOrError4).PropagateFailure<SearchableEncryptionInfo_Compile._IBeaconVersion>();
          return output;
        }
        _9_beacons = (_10_valueOrError4).Extract();
      } else {
        _9_beacons = _3_std;
      }
      Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _11_valueOrError5 = Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(false);
      _11_valueOrError5 = SearchConfigToInfo_Compile.__default.CheckBeacons(_9_beacons);
      if ((_11_valueOrError5).IsFailure()) {
        output = (_11_valueOrError5).PropagateFailure<SearchableEncryptionInfo_Compile._IBeaconVersion>();
        return output;
      }
      bool _12___v0;
      _12___v0 = (_11_valueOrError5).Extract();
      if (((source).dtor_keyLoc).is_MultiLoc) {
        Dafny.ISequence<char> _13_name;
        _13_name = ((source).dtor_keyLoc).dtor_keyName;
        if ((_9_beacons).Contains(_13_name)) {
          output = Wrappers_Compile.Result<SearchableEncryptionInfo_Compile._IBeaconVersion, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("A beacon key field name of "), _13_name), Dafny.Sequence<char>.FromString(" was configured, but there's also a beacon of that name."))));
          return output;
        }
        if ((_1_virtualFields).Contains(_13_name)) {
          output = Wrappers_Compile.Result<SearchableEncryptionInfo_Compile._IBeaconVersion, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("A beacon key field name of "), _13_name), Dafny.Sequence<char>.FromString(" was configured, but there's also a virtual field of that name."))));
          return output;
        }
      }
      output = SearchableEncryptionInfo_Compile.__default.MakeBeaconVersion((byte)((config).dtor_version), source, _9_beacons, _1_virtualFields, (outer).dtor_attributeActionsOnEncrypt);
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> ConvertVirtualFields(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig outer, Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualField>> vf)
    {
      if ((vf).is_None) {
        return Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Dafny.Map<Dafny.ISequence<char>, DdbVirtualFields_Compile._IVirtField>.FromElements());
      } else {
        return SearchConfigToInfo_Compile.__default.AddVirtualFields((vf).dtor_value, outer, Dafny.Map<Dafny.ISequence<char>, DdbVirtualFields_Compile._IVirtField>.FromElements());
      }
    }
    public static bool IsSigned(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig outer, Dafny.ISequence<TermLoc_Compile._ISelector> loc)
    {
      var _pat_let_tv0 = outer;
      var _pat_let_tv1 = outer;
      return (true) && (Dafny.Helpers.Let<Dafny.ISequence<char>, bool>(((loc).Select(BigInteger.Zero)).dtor_key, _pat_let20_0 => Dafny.Helpers.Let<Dafny.ISequence<char>, bool>(_pat_let20_0, _0_name => (((_pat_let_tv0).dtor_attributeActionsOnEncrypt).Contains(_0_name)) && (!object.Equals(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Select((_pat_let_tv1).dtor_attributeActionsOnEncrypt,_0_name), software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_DO__NOTHING())))));
    }
    public static bool IsSignOnly(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig outer, Dafny.ISequence<TermLoc_Compile._ISelector> loc)
    {
      var _pat_let_tv0 = outer;
      var _pat_let_tv1 = outer;
      var _pat_let_tv2 = outer;
      return (true) && (Dafny.Helpers.Let<Dafny.ISequence<char>, bool>(((loc).Select(BigInteger.Zero)).dtor_key, _pat_let21_0 => Dafny.Helpers.Let<Dafny.ISequence<char>, bool>(_pat_let21_0, _0_name => (((_pat_let_tv0).dtor_attributeActionsOnEncrypt).Contains(_0_name)) && ((object.Equals(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Select((_pat_let_tv1).dtor_attributeActionsOnEncrypt,_0_name), software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_SIGN__AND__INCLUDE__IN__ENCRYPTION__CONTEXT())) || (object.Equals(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Select((_pat_let_tv2).dtor_attributeActionsOnEncrypt,_0_name), software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_SIGN__ONLY()))))));
    }
    public static bool IsEncrypted(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig outer, Dafny.ISequence<TermLoc_Compile._ISelector> loc)
    {
      var _pat_let_tv0 = outer;
      var _pat_let_tv1 = outer;
      return (true) && (Dafny.Helpers.Let<Dafny.ISequence<char>, bool>(((loc).Select(BigInteger.Zero)).dtor_key, _pat_let22_0 => Dafny.Helpers.Let<Dafny.ISequence<char>, bool>(_pat_let22_0, _0_name => (((_pat_let_tv0).dtor_attributeActionsOnEncrypt).Contains(_0_name)) && (object.Equals(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Select((_pat_let_tv1).dtor_attributeActionsOnEncrypt,_0_name), software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_ENCRYPT__AND__SIGN())))));
    }
    public static bool IsEncryptedV(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig outer, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> virtualFields, Dafny.ISequence<TermLoc_Compile._ISelector> loc)
    {
      return (SearchConfigToInfo_Compile.__default.IsEncrypted(outer, loc)) || (((virtualFields).Contains(((loc).Select(BigInteger.Zero)).dtor_key)) && ((Dafny.Map<Dafny.ISequence<char>, DdbVirtualFields_Compile._IVirtField>.Select(virtualFields,((loc).Select(BigInteger.Zero)).dtor_key)).examine(Dafny.Helpers.Id<Func<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig, Func<Dafny.ISequence<TermLoc_Compile._ISelector>, bool>>>((_0_outer) => ((System.Func<Dafny.ISequence<TermLoc_Compile._ISelector>, bool>)((_1_t) => {
        return SearchConfigToInfo_Compile.__default.IsEncrypted(_0_outer, _1_t);
      })))(outer))));
    }
    public static Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> BeaconNameAllowed(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig outer, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> virtualFields, Dafny.ISequence<char> name, Dafny.ISequence<char> context, bool isSignedBeacon)
    {
      if ((((outer).dtor_attributeActionsOnEncrypt).Contains(name)) && (!object.Equals(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Select((outer).dtor_attributeActionsOnEncrypt,name), software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_ENCRYPT__AND__SIGN()))) {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(name, Dafny.Sequence<char>.FromString(" not allowed as a ")), context), Dafny.Sequence<char>.FromString(" because it is already an unencrypted attribute."))));
      } else if ((isSignedBeacon) && (((outer).dtor_attributeActionsOnEncrypt).Contains(name))) {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(name, Dafny.Sequence<char>.FromString(" not allowed as a ")), context), Dafny.Sequence<char>.FromString(" because a fully signed beacon cannot have the same name as an existing attribute."))));
      } else if ((((outer).dtor_allowedUnsignedAttributes).is_Some) && ((((outer).dtor_allowedUnsignedAttributes).dtor_value).Contains(name))) {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(name, Dafny.Sequence<char>.FromString(" not allowed as a ")), context), Dafny.Sequence<char>.FromString(" because it is already an allowed unauthenticated attribute."))));
      } else if ((((outer).dtor_allowedUnsignedAttributePrefix).is_Some) && (Dafny.Sequence<char>.IsPrefixOf(((outer).dtor_allowedUnsignedAttributePrefix).dtor_value, name))) {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(name, Dafny.Sequence<char>.FromString(" not allowed as a ")), context), Dafny.Sequence<char>.FromString(" because it begins with the allowed unauthenticated prefix."))));
      } else if (Dafny.Sequence<char>.IsPrefixOf(DynamoDbEncryptionUtil_Compile.__default.ReservedPrefix, name)) {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(name, Dafny.Sequence<char>.FromString(" not allowed as a ")), context), Dafny.Sequence<char>.FromString(" because it begins with the reserved prefix."))));
      } else {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(true);
      }
    }
    public static Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> VirtualFieldNameAllowed(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig outer, Dafny.ISequence<char> name)
    {
      if (((outer).dtor_attributeActionsOnEncrypt).Contains(name)) {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(name, Dafny.Sequence<char>.FromString(" not allowed as a Virtual Field because it is already a configured attribute."))));
      } else if ((((outer).dtor_allowedUnsignedAttributes).is_Some) && ((((outer).dtor_allowedUnsignedAttributes).dtor_value).Contains(name))) {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(name, Dafny.Sequence<char>.FromString(" not allowed as a Virtual Field because it is already an allowed unauthenticated attribute."))));
      } else if ((((outer).dtor_allowedUnsignedAttributePrefix).is_Some) && (Dafny.Sequence<char>.IsPrefixOf(((outer).dtor_allowedUnsignedAttributePrefix).dtor_value, name))) {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(name, Dafny.Sequence<char>.FromString(" not allowed as a Virtual Field because it begins with the allowed unauthenticated prefix."))));
      } else if (Dafny.Sequence<char>.IsPrefixOf(DynamoDbEncryptionUtil_Compile.__default.ReservedPrefix, name)) {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(name, Dafny.Sequence<char>.FromString(" not allowed as a Virtual Field because it begins with the reserved prefix."))));
      } else {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(true);
      }
    }
    public static Wrappers_Compile._IOption<Dafny.ISequence<char>> FindVirtualFieldWithThisLocation(Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> fields, Dafny.ISet<Dafny.ISequence<TermLoc_Compile._ISelector>> locs)
    {
      Dafny.ISet<Dafny.ISequence<char>> _0_badNames = Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField>, Dafny.ISet<Dafny.ISequence<TermLoc_Compile._ISelector>>, Dafny.ISet<Dafny.ISequence<char>>>>((_1_fields, _2_locs) => ((System.Func<Dafny.ISet<Dafny.ISequence<char>>>)(() => {
        var _coll0 = new System.Collections.Generic.List<Dafny.ISequence<char>>();
        foreach (Dafny.ISequence<char> _compr_0 in (_1_fields).Keys.Elements) {
          Dafny.ISequence<char> _3_b = (Dafny.ISequence<char>)_compr_0;
          if (((_1_fields).Contains(_3_b)) && (((Dafny.Map<Dafny.ISequence<char>, DdbVirtualFields_Compile._IVirtField>.Select(_1_fields,_3_b)).GetLocs()).Equals(_2_locs))) {
            _coll0.Add(_3_b);
          }
        }
        return Dafny.Set<Dafny.ISequence<char>>.FromCollection(_coll0);
      }))())(fields, locs);
      if ((new BigInteger((_0_badNames).Count)).Sign == 0) {
        return Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None();
      } else {
        Dafny.ISequence<Dafny.ISequence<char>> _4_badSeq = SortedSets.__default.SetToOrderedSequence2<char>(_0_badNames, DynamoDbEncryptionUtil_Compile.__default.CharLess);
        return Wrappers_Compile.Option<Dafny.ISequence<char>>.create_Some((_4_badSeq).Select(BigInteger.Zero));
      }
    }
    public static bool ExistsConstructorWithTheseRequired(Dafny.ISequence<CompoundBeacon_Compile._IConstructor> cons, Dafny.ISet<CompoundBeacon_Compile._IBeaconPart> locs)
    {
      return (SearchConfigToInfo_Compile.__default.SeqCount<CompoundBeacon_Compile._IConstructor>(Dafny.Helpers.Id<Func<Dafny.ISet<CompoundBeacon_Compile._IBeaconPart>, Func<CompoundBeacon_Compile._IConstructor, bool>>>((_0_locs) => ((System.Func<CompoundBeacon_Compile._IConstructor, bool>)((_1_c) => {
        return ((_1_c).getReqParts()).Equals(_0_locs);
      })))(locs), cons)).Sign == 1;
    }
    public static Dafny.ISequence<char> getPartsString(CompoundBeacon_Compile._IConstructor c) {
      Dafny.ISequence<CompoundBeacon_Compile._IConstructorPart> _0_req = Seq_Compile.__default.Filter<CompoundBeacon_Compile._IConstructorPart>(((System.Func<CompoundBeacon_Compile._IConstructorPart, bool>)((_1_p) => {
        return (_1_p).dtor_required;
      })), (c).dtor_parts);
      Dafny.ISequence<Dafny.ISequence<char>> _2_names = Seq_Compile.__default.Map<CompoundBeacon_Compile._IConstructorPart, Dafny.ISequence<char>>(((System.Func<CompoundBeacon_Compile._IConstructorPart, Dafny.ISequence<char>>)((_3_p) => {
        return ((_3_p).dtor_part).getName();
      })), _0_req);
      if ((new BigInteger((_2_names).Count)).Sign == 0) {
        return Dafny.Sequence<char>.FromString("");
      } else {
        return StandardLibrary_Compile.__default.Join<char>(_2_names, Dafny.Sequence<char>.FromString(", "));
      }
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> AddVirtualFields(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualField> vf, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig outer, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> converted)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((vf).Count)).Sign == 0) {
        return Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(converted);
      } else {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(!(converted).Contains(((vf).Select(BigInteger.Zero)).dtor_name), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Duplicate VirtualField name : "), ((vf).Select(BigInteger.Zero)).dtor_name)));
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField>>();
        } else {
          Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _1_valueOrError1 = SearchConfigToInfo_Compile.__default.VirtualFieldNameAllowed(outer, ((vf).Select(BigInteger.Zero)).dtor_name);
          if ((_1_valueOrError1).IsFailure()) {
            return (_1_valueOrError1).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField>>();
          } else {
            bool _2___v1 = (_1_valueOrError1).Extract();
            Wrappers_Compile._IResult<DdbVirtualFields_Compile._IVirtField, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _3_valueOrError2 = DdbVirtualFields_Compile.__default.ParseVirtualFieldConfig((vf).Select(BigInteger.Zero));
            if ((_3_valueOrError2).IsFailure()) {
              return (_3_valueOrError2).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField>>();
            } else {
              DdbVirtualFields_Compile._IVirtField _4_newField = (_3_valueOrError2).Extract();
              Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _5_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(!((_4_newField).examine(Dafny.Helpers.Id<Func<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig, Func<Dafny.ISequence<TermLoc_Compile._ISelector>, bool>>>((_6_outer) => ((System.Func<Dafny.ISequence<TermLoc_Compile._ISelector>, bool>)((_7_t) => {
                return !(SearchConfigToInfo_Compile.__default.IsSigned(_6_outer, _7_t));
              })))(outer))), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("VirtualField "), ((vf).Select(BigInteger.Zero)).dtor_name), Dafny.Sequence<char>.FromString(" must be defined on signed fields."))));
              if ((_5_valueOrError3).IsFailure()) {
                return (_5_valueOrError3).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField>>();
              } else {
                Wrappers_Compile._IOption<Dafny.ISequence<char>> _8_badField = SearchConfigToInfo_Compile.__default.FindVirtualFieldWithThisLocation(converted, (_4_newField).GetLocs());
                if ((_8_badField).is_Some) {
                  return Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Virtual field "), ((vf).Select(BigInteger.Zero)).dtor_name), Dafny.Sequence<char>.FromString(" is defined on the same locations as ")), (_8_badField).dtor_value), Dafny.Sequence<char>.FromString("."))));
                } else {
                  Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IVirtualField> _in0 = (vf).Drop(BigInteger.One);
                  software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig _in1 = outer;
                  Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> _in2 = Dafny.Map<Dafny.ISequence<char>, DdbVirtualFields_Compile._IVirtField>.Update(converted, ((vf).Select(BigInteger.Zero)).dtor_name, _4_newField);
                  vf = _in0;
                  outer = _in1;
                  converted = _in2;
                  goto TAIL_CALL_START;
                }
              }
            }
          }
        }
      }
    }
    public static Wrappers_Compile._IOption<Dafny.ISequence<char>> FindBeaconWithThisLocation(Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon> beacons, Dafny.ISequence<TermLoc_Compile._ISelector> loc)
    {
      Dafny.ISet<Dafny.ISequence<char>> _0_badNames = Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon>, Dafny.ISequence<TermLoc_Compile._ISelector>, Dafny.ISet<Dafny.ISequence<char>>>>((_1_beacons, _2_loc) => ((System.Func<Dafny.ISet<Dafny.ISequence<char>>>)(() => {
        var _coll0 = new System.Collections.Generic.List<Dafny.ISequence<char>>();
        foreach (Dafny.ISequence<char> _compr_0 in (_1_beacons).Keys.Elements) {
          Dafny.ISequence<char> _3_b = (Dafny.ISequence<char>)_compr_0;
          if ((((_1_beacons).Contains(_3_b)) && ((Dafny.Map<Dafny.ISequence<char>, SearchableEncryptionInfo_Compile._IBeacon>.Select(_1_beacons,_3_b)).is_Standard)) && ((((Dafny.Map<Dafny.ISequence<char>, SearchableEncryptionInfo_Compile._IBeacon>.Select(_1_beacons,_3_b)).dtor_std).dtor_loc).Equals(_2_loc))) {
            _coll0.Add(_3_b);
          }
        }
        return Dafny.Set<Dafny.ISequence<char>>.FromCollection(_coll0);
      }))())(beacons, loc);
      if ((new BigInteger((_0_badNames).Count)).Sign == 0) {
        return Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None();
      } else {
        Dafny.ISequence<Dafny.ISequence<char>> _4_badSeq = SortedSets.__default.SetToOrderedSequence2<char>(_0_badNames, DynamoDbEncryptionUtil_Compile.__default.CharLess);
        return Wrappers_Compile.Option<Dafny.ISequence<char>>.create_Some((_4_badSeq).Select(BigInteger.Zero));
      }
    }
    public static Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> IsValidShare(Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon> converted, Dafny.ISequence<char> name, byte length, Dafny.ISequence<char> share)
    {
      if ((converted).Contains(share)) {
        SearchableEncryptionInfo_Compile._IBeacon _0_tb = Dafny.Map<Dafny.ISequence<char>, SearchableEncryptionInfo_Compile._IBeacon>.Select(converted,share);
        if ((_0_tb).is_Standard) {
          if ((((_0_tb).dtor_std).dtor_share).is_Some) {
            if ((name).Equals(share)) {
              return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Beacon "), name), Dafny.Sequence<char>.FromString(" is shared to itself."))));
            } else {
              return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Beacon "), name), Dafny.Sequence<char>.FromString(" is shared to ")), share), Dafny.Sequence<char>.FromString(" which is in turn shared to ")), (((_0_tb).dtor_std).dtor_share).dtor_value), Dafny.Sequence<char>.FromString(". Share chains are not allowed."))));
            }
          } else if ((((_0_tb).dtor_std).dtor_length) == (length)) {
            return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(true);
          } else {
            return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Beacon "), name), Dafny.Sequence<char>.FromString(" is shared to ")), share), Dafny.Sequence<char>.FromString(" but ")), name), Dafny.Sequence<char>.FromString(" has length ")), StandardLibrary_mString_Compile.__default.Base10Int2String(new BigInteger(length))), Dafny.Sequence<char>.FromString(" and ")), share), Dafny.Sequence<char>.FromString(" has length ")), StandardLibrary_mString_Compile.__default.Base10Int2String(new BigInteger(((_0_tb).dtor_std).dtor_length))), Dafny.Sequence<char>.FromString("."))));
          }
        } else {
          return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Beacon "), name), Dafny.Sequence<char>.FromString(" is shared to ")), share), Dafny.Sequence<char>.FromString(" but ")), share), Dafny.Sequence<char>.FromString(" is a compound beacon."))));
        }
      } else {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Beacon "), name), Dafny.Sequence<char>.FromString(" is shared to ")), share), Dafny.Sequence<char>.FromString(" which is not defined."))));
      }
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> AddStandardBeacons(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IStandardBeacon> beacons, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig outer, software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient client, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> virtualFields, Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon> converted)
    {
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>);
      if ((new BigInteger((beacons).Count)).Sign == 0) {
        output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(converted);
        return output;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default();
      _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(!(converted).Contains(((beacons).Select(BigInteger.Zero)).dtor_name), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Duplicate StandardBeacon name : "), ((beacons).Select(BigInteger.Zero)).dtor_name)));
      if ((_0_valueOrError0).IsFailure()) {
        output = (_0_valueOrError0).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon>>();
        return output;
      }
      Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _1_valueOrError1 = Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default(false);
      _1_valueOrError1 = SearchConfigToInfo_Compile.__default.BeaconNameAllowed(outer, virtualFields, ((beacons).Select(BigInteger.Zero)).dtor_name, Dafny.Sequence<char>.FromString("StandardBeacon"), false);
      if ((_1_valueOrError1).IsFailure()) {
        output = (_1_valueOrError1).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon>>();
        return output;
      }
      bool _2___v2;
      _2___v2 = (_1_valueOrError1).Extract();
      Dafny.ISequence<char> _3_locString;
      _3_locString = SearchConfigToInfo_Compile.__default.GetLocStr(((beacons).Select(BigInteger.Zero)).dtor_name, ((beacons).Select(BigInteger.Zero)).dtor_loc);
      bool _4_isPartOnly;
      _4_isPartOnly = false;
      bool _5_isAsSet;
      _5_isAsSet = false;
      Wrappers_Compile._IOption<Dafny.ISequence<char>> _6_share;
      _6_share = Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None();
      if ((((beacons).Select(BigInteger.Zero)).dtor_style).is_Some) {
        software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IBeaconStyle _source0 = (((beacons).Select(BigInteger.Zero)).dtor_style).dtor_value;
        {
          if (_source0.is_partOnly) {
            software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPartOnly _7_t = _source0.dtor_partOnly;
            _4_isPartOnly = true;
            goto after_match0;
          }
        }
        {
          if (_source0.is_shared) {
            software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IShared _8_t = _source0.dtor_shared;
            _6_share = Wrappers_Compile.Option<Dafny.ISequence<char>>.create_Some((_8_t).dtor_other);
            goto after_match0;
          }
        }
        {
          if (_source0.is_asSet) {
            software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IAsSet _9_t = _source0.dtor_asSet;
            _5_isAsSet = true;
            goto after_match0;
          }
        }
        {
          software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISharedSet _10_t = _source0.dtor_sharedSet;
          _6_share = Wrappers_Compile.Option<Dafny.ISequence<char>>.create_Some((_10_t).dtor_other);
          _5_isAsSet = true;
        }
      after_match0: ;
      }
      Wrappers_Compile._IResult<BaseBeacon_Compile._IStandardBeacon, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _11_valueOrError2 = default(Wrappers_Compile._IResult<BaseBeacon_Compile._IStandardBeacon, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>);
      _11_valueOrError2 = BaseBeacon_Compile.__default.MakeStandardBeacon(client, ((beacons).Select(BigInteger.Zero)).dtor_name, (byte)(((beacons).Select(BigInteger.Zero)).dtor_length), _3_locString, _4_isPartOnly, _5_isAsSet, _6_share);
      if ((_11_valueOrError2).IsFailure()) {
        output = (_11_valueOrError2).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon>>();
        return output;
      }
      BaseBeacon_Compile._IStandardBeacon _12_newBeacon;
      _12_newBeacon = (_11_valueOrError2).Extract();
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _13_valueOrError3 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.Default();
      _13_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(SearchConfigToInfo_Compile.__default.IsEncryptedV(outer, virtualFields, (_12_newBeacon).dtor_loc), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("StandardBeacon "), ((beacons).Select(BigInteger.Zero)).dtor_name), Dafny.Sequence<char>.FromString(" not defined on an encrypted field."))));
      if ((_13_valueOrError3).IsFailure()) {
        output = (_13_valueOrError3).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon>>();
        return output;
      }
      Wrappers_Compile._IOption<Dafny.ISequence<char>> _14_badBeacon;
      _14_badBeacon = SearchConfigToInfo_Compile.__default.FindBeaconWithThisLocation(converted, (_12_newBeacon).dtor_loc);
      if ((_14_badBeacon).is_Some) {
        output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Beacon "), ((beacons).Select(BigInteger.Zero)).dtor_name), Dafny.Sequence<char>.FromString(" is defined on location ")), TermLoc_Compile.__default.TermLocToString((_12_newBeacon).dtor_loc)), Dafny.Sequence<char>.FromString(", but beacon ")), (_14_badBeacon).dtor_value), Dafny.Sequence<char>.FromString(" is already defined on that location."))));
        return output;
      }
      Wrappers_Compile._IOption<Dafny.ISequence<char>> _15_badField;
      _15_badField = SearchConfigToInfo_Compile.__default.FindVirtualFieldWithThisLocation(virtualFields, Dafny.Set<Dafny.ISequence<TermLoc_Compile._ISelector>>.FromElements((_12_newBeacon).dtor_loc));
      if ((_15_badField).is_Some) {
        output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Beacon "), ((beacons).Select(BigInteger.Zero)).dtor_name), Dafny.Sequence<char>.FromString(" is defined on location ")), TermLoc_Compile.__default.TermLocToString((_12_newBeacon).dtor_loc)), Dafny.Sequence<char>.FromString(", but virtual field ")), (_15_badField).dtor_value), Dafny.Sequence<char>.FromString(" is already defined on that single location."))));
        return output;
      }
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
      _out0 = SearchConfigToInfo_Compile.__default.AddStandardBeacons((beacons).Drop(BigInteger.One), outer, client, virtualFields, Dafny.Map<Dafny.ISequence<char>, SearchableEncryptionInfo_Compile._IBeacon>.Update(converted, ((beacons).Select(BigInteger.Zero)).dtor_name, SearchableEncryptionInfo_Compile.Beacon.create_Standard(_12_newBeacon)));
      output = _out0;
      return output;
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<TermLoc_Compile._ISelector>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetLoc(Dafny.ISequence<char> name, Wrappers_Compile._IOption<Dafny.ISequence<char>> loc)
    {
      if ((loc).is_None) {
        return Wrappers_Compile.Result<Dafny.ISequence<TermLoc_Compile._ISelector>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(TermLoc_Compile.__default.TermLocMap(name));
      } else {
        return TermLoc_Compile.__default.MakeTermLoc((loc).dtor_value);
      }
    }
    public static Dafny.ISequence<char> GetLocStr(Dafny.ISequence<char> name, Wrappers_Compile._IOption<Dafny.ISequence<char>> loc)
    {
      if ((loc).is_None) {
        return name;
      } else {
        return (loc).dtor_value;
      }
    }
    public static Wrappers_Compile._IResult<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetSignedParts(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart> parts, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig outer, Dafny.ISequence<char> name, SearchConfigToInfo_Compile._IPartSet converted)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((parts).Count)).Sign == 0) {
        return Wrappers_Compile.Result<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(converted);
      } else {
        Wrappers_Compile._IResult<Dafny.ISequence<TermLoc_Compile._ISelector>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = SearchConfigToInfo_Compile.__default.GetLoc(((parts).Select(BigInteger.Zero)).dtor_name, ((parts).Select(BigInteger.Zero)).dtor_loc);
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<SearchConfigToInfo_Compile._IPartSet>();
        } else {
          Dafny.ISequence<TermLoc_Compile._ISelector> _1_loc = (_0_valueOrError0).Extract();
          CompoundBeacon_Compile._IBeaconPart _2_newPart = CompoundBeacon_Compile.BeaconPart.create_Signed(((parts).Select(BigInteger.Zero)).dtor_prefix, ((parts).Select(BigInteger.Zero)).dtor_name, _1_loc);
          Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _3_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(SearchConfigToInfo_Compile.__default.IsSignOnly(outer, (_2_newPart).dtor_loc), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Signed Part "), (_2_newPart).dtor_name), Dafny.Sequence<char>.FromString(" is built from ")), SearchConfigToInfo_Compile.__default.GetLocStr(((parts).Select(BigInteger.Zero)).dtor_name, ((parts).Select(BigInteger.Zero)).dtor_loc)), Dafny.Sequence<char>.FromString(" which is not SIGN_ONLY."))));
          if ((_3_valueOrError1).IsFailure()) {
            return (_3_valueOrError1).PropagateFailure<SearchConfigToInfo_Compile._IPartSet>();
          } else {
            Wrappers_Compile._IResult<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _4_valueOrError2 = (converted).@add(_2_newPart, name);
            if ((_4_valueOrError2).IsFailure()) {
              return (_4_valueOrError2).PropagateFailure<SearchConfigToInfo_Compile._IPartSet>();
            } else {
              SearchConfigToInfo_Compile._IPartSet _5_newParts = (_4_valueOrError2).Extract();
              Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart> _in0 = (parts).Drop(BigInteger.One);
              software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig _in1 = outer;
              Dafny.ISequence<char> _in2 = name;
              SearchConfigToInfo_Compile._IPartSet _in3 = _5_newParts;
              parts = _in0;
              outer = _in1;
              name = _in2;
              converted = _in3;
              goto TAIL_CALL_START;
            }
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetEncryptedParts(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedPart> parts, Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon> std, Dafny.ISequence<char> name, SearchConfigToInfo_Compile._IPartSet converted)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((parts).Count)).Sign == 0) {
        return Wrappers_Compile.Result<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(converted);
      } else if ((((std).Contains(((parts).Select(BigInteger.Zero)).dtor_name)) && ((Dafny.Map<Dafny.ISequence<char>, SearchableEncryptionInfo_Compile._IBeacon>.Select(std,((parts).Select(BigInteger.Zero)).dtor_name)).is_Standard)) && (((Dafny.Map<Dafny.ISequence<char>, SearchableEncryptionInfo_Compile._IBeacon>.Select(std,((parts).Select(BigInteger.Zero)).dtor_name)).dtor_std).dtor_asSet)) {
        return Wrappers_Compile.Result<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(name, Dafny.Sequence<char>.FromString(" uses ")), ((parts).Select(BigInteger.Zero)).dtor_name), Dafny.Sequence<char>.FromString(" which is an AsSet beacon, and therefore cannot be used in a Compound Beacon."))));
      } else if (((std).Contains(((parts).Select(BigInteger.Zero)).dtor_name)) && ((Dafny.Map<Dafny.ISequence<char>, SearchableEncryptionInfo_Compile._IBeacon>.Select(std,((parts).Select(BigInteger.Zero)).dtor_name)).is_Standard)) {
        CompoundBeacon_Compile._IBeaconPart _0_newPart = CompoundBeacon_Compile.BeaconPart.create_Encrypted(((parts).Select(BigInteger.Zero)).dtor_prefix, (Dafny.Map<Dafny.ISequence<char>, SearchableEncryptionInfo_Compile._IBeacon>.Select(std,((parts).Select(BigInteger.Zero)).dtor_name)).dtor_std);
        Wrappers_Compile._IResult<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _1_valueOrError0 = (converted).@add(_0_newPart, name);
        if ((_1_valueOrError0).IsFailure()) {
          return (_1_valueOrError0).PropagateFailure<SearchConfigToInfo_Compile._IPartSet>();
        } else {
          SearchConfigToInfo_Compile._IPartSet _2_newParts = (_1_valueOrError0).Extract();
          Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedPart> _in0 = (parts).Drop(BigInteger.One);
          Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon> _in1 = std;
          Dafny.ISequence<char> _in2 = name;
          SearchConfigToInfo_Compile._IPartSet _in3 = _2_newParts;
          parts = _in0;
          std = _in1;
          name = _in2;
          converted = _in3;
          goto TAIL_CALL_START;
        }
      } else {
        return Wrappers_Compile.Result<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(name, Dafny.Sequence<char>.FromString(" refers to standard beacon ")), ((parts).Select(BigInteger.Zero)).dtor_name), Dafny.Sequence<char>.FromString(" which is not configured."))));
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<CompoundBeacon_Compile._IConstructor>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> MakeDefaultConstructor(Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> parts, Dafny.ISequence<CompoundBeacon_Compile._IConstructorPart> converted)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((parts).Count)).Sign == 0) {
        return Wrappers_Compile.Result<Dafny.ISequence<CompoundBeacon_Compile._IConstructor>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(Dafny.Sequence<CompoundBeacon_Compile._IConstructor>.FromElements(CompoundBeacon_Compile.Constructor.create(converted)));
      } else {
        Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> _in0 = (parts).Drop(BigInteger.One);
        Dafny.ISequence<CompoundBeacon_Compile._IConstructorPart> _in1 = Dafny.Sequence<CompoundBeacon_Compile._IConstructorPart>.Concat(converted, Dafny.Sequence<CompoundBeacon_Compile._IConstructorPart>.FromElements(CompoundBeacon_Compile.ConstructorPart.create((parts).Select(BigInteger.Zero), true)));
        parts = _in0;
        converted = _in1;
        goto TAIL_CALL_START;
      }
    }
    public static Dafny.ISequence<__T> MyFilter<__T>(Func<__T, bool> f, Dafny.ISequence<__T> xs)
    {
      Dafny.ISequence<__T> _0___accumulator = Dafny.Sequence<__T>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((xs).Count)).Sign == 0) {
        return Dafny.Sequence<__T>.Concat(_0___accumulator, Dafny.Sequence<__T>.FromElements());
      } else {
        _0___accumulator = Dafny.Sequence<__T>.Concat(_0___accumulator, ((Dafny.Helpers.Id<Func<__T, bool>>(f)((xs).Select(BigInteger.Zero))) ? (Dafny.Sequence<__T>.FromElements((xs).Select(BigInteger.Zero))) : (Dafny.Sequence<__T>.FromElements())));
        Func<__T, bool> _in0 = f;
        Dafny.ISequence<__T> _in1 = (xs).Drop(BigInteger.One);
        f = _in0;
        xs = _in1;
        goto TAIL_CALL_START;
      }
    }
    public static BigInteger SeqCount<__T>(Func<__T, bool> f, Dafny.ISequence<__T> xs)
    {
      BigInteger _0___accumulator = BigInteger.Zero;
    TAIL_CALL_START: ;
      if ((new BigInteger((xs).Count)).Sign == 0) {
        return (BigInteger.Zero) + (_0___accumulator);
      } else {
        _0___accumulator = (_0___accumulator) + (((Dafny.Helpers.Id<Func<__T, bool>>(f)((xs).Select(BigInteger.Zero))) ? (BigInteger.One) : (BigInteger.Zero)));
        Func<__T, bool> _in0 = f;
        Dafny.ISequence<__T> _in1 = (xs).Drop(BigInteger.One);
        f = _in0;
        xs = _in1;
        goto TAIL_CALL_START;
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<CompoundBeacon_Compile._IConstructorPart>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> MakeConstructor2(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructorPart> c, Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> parts, BigInteger origSize, Dafny.ISequence<CompoundBeacon_Compile._IConstructorPart> converted)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((c).Count)).Sign == 0) {
        return Wrappers_Compile.Result<Dafny.ISequence<CompoundBeacon_Compile._IConstructorPart>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(converted);
      } else {
        Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> _0_thePart = SearchConfigToInfo_Compile.__default.MyFilter<CompoundBeacon_Compile._IBeaconPart>(Dafny.Helpers.Id<Func<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructorPart>, Func<CompoundBeacon_Compile._IBeaconPart, bool>>>((_1_c) => ((System.Func<CompoundBeacon_Compile._IBeaconPart, bool>)((_2_p) => {
          return ((_2_p).getName()).Equals(((_1_c).Select(BigInteger.Zero)).dtor_name);
        })))(c), parts);
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _3_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>((new BigInteger((_0_thePart).Count)).Sign == 1, DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Constructor refers to part name "), ((c).Select(BigInteger.Zero)).dtor_name), Dafny.Sequence<char>.FromString(" but there is no part by that name."))));
        if ((_3_valueOrError0).IsFailure()) {
          return (_3_valueOrError0).PropagateFailure<Dafny.ISequence<CompoundBeacon_Compile._IConstructorPart>>();
        } else {
          CompoundBeacon_Compile._IConstructorPart _4_newPart = CompoundBeacon_Compile.ConstructorPart.create((_0_thePart).Select(BigInteger.Zero), ((c).Select(BigInteger.Zero)).dtor_required);
          Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructorPart> _in0 = (c).Drop(BigInteger.One);
          Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> _in1 = parts;
          BigInteger _in2 = origSize;
          Dafny.ISequence<CompoundBeacon_Compile._IConstructorPart> _in3 = Dafny.Sequence<CompoundBeacon_Compile._IConstructorPart>.Concat(converted, Dafny.Sequence<CompoundBeacon_Compile._IConstructorPart>.FromElements(_4_newPart));
          c = _in0;
          parts = _in1;
          origSize = _in2;
          converted = _in3;
          goto TAIL_CALL_START;
        }
      }
    }
    public static Wrappers_Compile._IResult<CompoundBeacon_Compile._IConstructor, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> MakeConstructor(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructor c, Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> parts)
    {
      Wrappers_Compile._IResult<Dafny.ISequence<CompoundBeacon_Compile._IConstructorPart>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = SearchConfigToInfo_Compile.__default.MakeConstructor2((c).dtor_parts, parts, new BigInteger(((c).dtor_parts).Count), Dafny.Sequence<CompoundBeacon_Compile._IConstructorPart>.FromElements());
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<CompoundBeacon_Compile._IConstructor>();
      } else {
        Dafny.ISequence<CompoundBeacon_Compile._IConstructorPart> _1_newParts = (_0_valueOrError0).Extract();
        return Wrappers_Compile.Result<CompoundBeacon_Compile._IConstructor, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(CompoundBeacon_Compile.Constructor.create(_1_newParts));
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<CompoundBeacon_Compile._IConstructor>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> AddConstructors2(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructor> constructors, Dafny.ISequence<char> name, Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> parts, BigInteger origSize, Dafny.ISequence<CompoundBeacon_Compile._IConstructor> converted)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((constructors).Count)).Sign == 0) {
        return Wrappers_Compile.Result<Dafny.ISequence<CompoundBeacon_Compile._IConstructor>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(converted);
      } else {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>((new BigInteger((((constructors).Select(BigInteger.Zero)).dtor_parts).Count)).Sign == 1, DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.FromString("Every constructor must have at least one part.")));
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<CompoundBeacon_Compile._IConstructor>>();
        } else {
          Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _1_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>((SearchConfigToInfo_Compile.__default.SeqCount<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructorPart>(((System.Func<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructorPart, bool>)((_2_p) => {
            return (_2_p).dtor_required;
          })), ((constructors).Select(BigInteger.Zero)).dtor_parts)).Sign == 1, DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("A Constructor for beacon "), name), Dafny.Sequence<char>.FromString(" lacks any required parts"))));
          if ((_1_valueOrError1).IsFailure()) {
            return (_1_valueOrError1).PropagateFailure<Dafny.ISequence<CompoundBeacon_Compile._IConstructor>>();
          } else {
            Wrappers_Compile._IResult<CompoundBeacon_Compile._IConstructor, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _3_valueOrError2 = SearchConfigToInfo_Compile.__default.MakeConstructor((constructors).Select(BigInteger.Zero), parts);
            if ((_3_valueOrError2).IsFailure()) {
              return (_3_valueOrError2).PropagateFailure<Dafny.ISequence<CompoundBeacon_Compile._IConstructor>>();
            } else {
              CompoundBeacon_Compile._IConstructor _4_c = (_3_valueOrError2).Extract();
              if (SearchConfigToInfo_Compile.__default.ExistsConstructorWithTheseRequired(converted, (_4_c).getReqParts())) {
                Dafny.ISequence<char> _5_p = SearchConfigToInfo_Compile.__default.getPartsString(_4_c);
                return Wrappers_Compile.Result<Dafny.ISequence<CompoundBeacon_Compile._IConstructor>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Multiple constructors for "), name), Dafny.Sequence<char>.FromString(" have the same set of required parts : ")), _5_p)));
              } else {
                Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructor> _in0 = (constructors).Drop(BigInteger.One);
                Dafny.ISequence<char> _in1 = name;
                Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> _in2 = parts;
                BigInteger _in3 = origSize;
                Dafny.ISequence<CompoundBeacon_Compile._IConstructor> _in4 = Dafny.Sequence<CompoundBeacon_Compile._IConstructor>.Concat(converted, Dafny.Sequence<CompoundBeacon_Compile._IConstructor>.FromElements(_4_c));
                constructors = _in0;
                name = _in1;
                parts = _in2;
                origSize = _in3;
                converted = _in4;
                goto TAIL_CALL_START;
              }
            }
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<CompoundBeacon_Compile._IConstructor>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> AddConstructors(Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructor>> constructors, Dafny.ISequence<char> name, Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> parts)
    {
      if ((constructors).is_None) {
        return SearchConfigToInfo_Compile.__default.MakeDefaultConstructor(parts, Dafny.Sequence<CompoundBeacon_Compile._IConstructorPart>.FromElements());
      } else {
        return SearchConfigToInfo_Compile.__default.AddConstructors2((constructors).dtor_value, name, parts, new BigInteger(((constructors).dtor_value).Count), Dafny.Sequence<CompoundBeacon_Compile._IConstructor>.FromElements());
      }
    }
    public static Wrappers_Compile._IResult<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetGlobalPartsFrom(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructorPart> cons, SearchConfigToInfo_Compile._IPartSet globalParts, bool signed, SearchConfigToInfo_Compile._IPartSet parts)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((cons).Count)).Sign == 0) {
        return Wrappers_Compile.Result<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(parts);
      } else {
        Wrappers_Compile._IOption<CompoundBeacon_Compile._IBeaconPart> _0_newPart = SearchConfigToInfo_Compile.__default.FindGlobalPart((globalParts).dtor_parts, (cons).Select(BigInteger.Zero), signed);
        if ((_0_newPart).is_Some) {
          Wrappers_Compile._IResult<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _1_valueOrError0 = (parts).@add((_0_newPart).dtor_value, Dafny.Sequence<char>.FromString("Global Parts List"));
          if ((_1_valueOrError0).IsFailure()) {
            return (_1_valueOrError0).PropagateFailure<SearchConfigToInfo_Compile._IPartSet>();
          } else {
            SearchConfigToInfo_Compile._IPartSet _2_newParts = (_1_valueOrError0).Extract();
            Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructorPart> _in0 = (cons).Drop(BigInteger.One);
            SearchConfigToInfo_Compile._IPartSet _in1 = globalParts;
            bool _in2 = signed;
            SearchConfigToInfo_Compile._IPartSet _in3 = _2_newParts;
            cons = _in0;
            globalParts = _in1;
            signed = _in2;
            parts = _in3;
            goto TAIL_CALL_START;
          }
        } else {
          Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructorPart> _in4 = (cons).Drop(BigInteger.One);
          SearchConfigToInfo_Compile._IPartSet _in5 = globalParts;
          bool _in6 = signed;
          SearchConfigToInfo_Compile._IPartSet _in7 = parts;
          cons = _in4;
          globalParts = _in5;
          signed = _in6;
          parts = _in7;
          goto TAIL_CALL_START;
        }
      }
    }
    public static Wrappers_Compile._IResult<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetGlobalParts(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructor> cons, SearchConfigToInfo_Compile._IPartSet globalParts, bool signed, SearchConfigToInfo_Compile._IPartSet parts)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((cons).Count)).Sign == 0) {
        return Wrappers_Compile.Result<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(parts);
      } else {
        Wrappers_Compile._IResult<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = SearchConfigToInfo_Compile.__default.GetGlobalPartsFrom(((cons).Select(BigInteger.Zero)).dtor_parts, globalParts, signed, parts);
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<SearchConfigToInfo_Compile._IPartSet>();
        } else {
          SearchConfigToInfo_Compile._IPartSet _1_newParts = (_0_valueOrError0).Extract();
          Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructor> _in0 = (cons).Drop(BigInteger.One);
          SearchConfigToInfo_Compile._IPartSet _in1 = globalParts;
          bool _in2 = signed;
          SearchConfigToInfo_Compile._IPartSet _in3 = _1_newParts;
          cons = _in0;
          globalParts = _in1;
          signed = _in2;
          parts = _in3;
          goto TAIL_CALL_START;
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetAllEncryptedParts(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedPart> parts, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructor> cons, SearchConfigToInfo_Compile._IPartSet globalEncryptedParts, Dafny.ISequence<char> name, Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon> std)
    {
      Wrappers_Compile._IResult<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = SearchConfigToInfo_Compile.__default.GetEncryptedParts(parts, std, Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Compound beacon "), name), SearchConfigToInfo_Compile.PartSet.create(Dafny.Sequence<CompoundBeacon_Compile._IBeaconPart>.FromElements(), Dafny.Set<Dafny.ISequence<char>>.FromElements(), Dafny.Set<Dafny.ISequence<char>>.FromElements()));
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart>>();
      } else {
        SearchConfigToInfo_Compile._IPartSet _1_p1 = (_0_valueOrError0).Extract();
        Wrappers_Compile._IResult<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _2_valueOrError1 = SearchConfigToInfo_Compile.__default.GetGlobalParts(cons, globalEncryptedParts, false, SearchConfigToInfo_Compile.PartSet.create(Dafny.Sequence<CompoundBeacon_Compile._IBeaconPart>.FromElements(), Dafny.Set<Dafny.ISequence<char>>.FromElements(), Dafny.Set<Dafny.ISequence<char>>.FromElements()));
        if ((_2_valueOrError1).IsFailure()) {
          return (_2_valueOrError1).PropagateFailure<Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart>>();
        } else {
          SearchConfigToInfo_Compile._IPartSet _3_p2 = (_2_valueOrError1).Extract();
          Wrappers_Compile._IResult<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _4_valueOrError2 = (_1_p1).combine(_3_p2, name, Dafny.Sequence<char>.FromString("Global Parts List"));
          if ((_4_valueOrError2).IsFailure()) {
            return (_4_valueOrError2).PropagateFailure<Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart>>();
          } else {
            SearchConfigToInfo_Compile._IPartSet _5_both = (_4_valueOrError2).Extract();
            return Wrappers_Compile.Result<Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success((_5_both).dtor_parts);
          }
        }
      }
    }
    public static bool IsSignedPart(CompoundBeacon_Compile._IBeaconPart part, bool signed)
    {
      if (signed) {
        return (part).is_Signed;
      } else {
        return (part).is_Encrypted;
      }
    }
    public static Wrappers_Compile._IOption<CompoundBeacon_Compile._IBeaconPart> FindGlobalPart(Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> globalParts, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructorPart cons, bool signed)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((globalParts).Count)).Sign == 0) {
        return Wrappers_Compile.Option<CompoundBeacon_Compile._IBeaconPart>.create_None();
      } else if ((SearchConfigToInfo_Compile.__default.IsSignedPart((globalParts).Select(BigInteger.Zero), signed)) && ((((globalParts).Select(BigInteger.Zero)).getName()).Equals((cons).dtor_name))) {
        return Wrappers_Compile.Option<CompoundBeacon_Compile._IBeaconPart>.create_Some((globalParts).Select(BigInteger.Zero));
      } else {
        Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> _in0 = (globalParts).Drop(BigInteger.One);
        software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructorPart _in1 = cons;
        bool _in2 = signed;
        globalParts = _in0;
        cons = _in1;
        signed = _in2;
        goto TAIL_CALL_START;
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> GetAllSignedParts(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart> parts, Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructor> cons, SearchConfigToInfo_Compile._IPartSet globalSignedParts, Dafny.ISequence<char> name, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig outer)
    {
      Wrappers_Compile._IResult<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = SearchConfigToInfo_Compile.__default.GetSignedParts(parts, outer, name, SearchConfigToInfo_Compile.PartSet.create(Dafny.Sequence<CompoundBeacon_Compile._IBeaconPart>.FromElements(), Dafny.Set<Dafny.ISequence<char>>.FromElements(), Dafny.Set<Dafny.ISequence<char>>.FromElements()));
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart>>();
      } else {
        SearchConfigToInfo_Compile._IPartSet _1_p1 = (_0_valueOrError0).Extract();
        Wrappers_Compile._IResult<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _2_valueOrError1 = SearchConfigToInfo_Compile.__default.GetGlobalParts(cons, globalSignedParts, true, SearchConfigToInfo_Compile.PartSet.create(Dafny.Sequence<CompoundBeacon_Compile._IBeaconPart>.FromElements(), Dafny.Set<Dafny.ISequence<char>>.FromElements(), Dafny.Set<Dafny.ISequence<char>>.FromElements()));
        if ((_2_valueOrError1).IsFailure()) {
          return (_2_valueOrError1).PropagateFailure<Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart>>();
        } else {
          SearchConfigToInfo_Compile._IPartSet _3_p2 = (_2_valueOrError1).Extract();
          Wrappers_Compile._IResult<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _4_valueOrError2 = (_1_p1).combine(_3_p2, name, Dafny.Sequence<char>.FromString("Global Parts List"));
          if ((_4_valueOrError2).IsFailure()) {
            return (_4_valueOrError2).PropagateFailure<Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart>>();
          } else {
            SearchConfigToInfo_Compile._IPartSet _5_both = (_4_valueOrError2).Extract();
            return Wrappers_Compile.Result<Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success((_5_both).dtor_parts);
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> CheckSignedParts(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart> parts, SearchConfigToInfo_Compile._IPartSet globals, Dafny.ISequence<char> name)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((parts).Count)).Sign == 0) {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(true);
      } else if (((globals).dtor_names).Contains(((parts).Select(BigInteger.Zero)).dtor_name)) {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Compound beacon "), name), Dafny.Sequence<char>.FromString(" defines signed part ")), ((parts).Select(BigInteger.Zero)).dtor_name), Dafny.Sequence<char>.FromString(" which is already defined as a global part."))));
      } else if (((globals).dtor_prefixes).Contains(((parts).Select(BigInteger.Zero)).dtor_prefix)) {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Compound beacon "), name), Dafny.Sequence<char>.FromString(" defines signed part ")), ((parts).Select(BigInteger.Zero)).dtor_name), Dafny.Sequence<char>.FromString(" with prefix ")), ((parts).Select(BigInteger.Zero)).dtor_prefix), Dafny.Sequence<char>.FromString(" which is already defined as the prefix of a global part."))));
      } else {
        Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart> _in0 = (parts).Drop(BigInteger.One);
        SearchConfigToInfo_Compile._IPartSet _in1 = globals;
        Dafny.ISequence<char> _in2 = name;
        parts = _in0;
        globals = _in1;
        name = _in2;
        goto TAIL_CALL_START;
      }
    }
    public static Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> CheckEncryptedParts(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedPart> parts, SearchConfigToInfo_Compile._IPartSet globals, Dafny.ISequence<char> name)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((parts).Count)).Sign == 0) {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(true);
      } else if (((globals).dtor_names).Contains(((parts).Select(BigInteger.Zero)).dtor_name)) {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Compound beacon "), name), Dafny.Sequence<char>.FromString(" defines encrypted part ")), ((parts).Select(BigInteger.Zero)).dtor_name), Dafny.Sequence<char>.FromString(" which is already defined as a global part."))));
      } else if (((globals).dtor_prefixes).Contains(((parts).Select(BigInteger.Zero)).dtor_prefix)) {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Compound beacon "), name), Dafny.Sequence<char>.FromString(" defines encrypted part ")), ((parts).Select(BigInteger.Zero)).dtor_name), Dafny.Sequence<char>.FromString(" with prefix ")), ((parts).Select(BigInteger.Zero)).dtor_prefix), Dafny.Sequence<char>.FromString(" which is already defined as the prefix of a global part."))));
      } else {
        Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedPart> _in0 = (parts).Drop(BigInteger.One);
        SearchConfigToInfo_Compile._IPartSet _in1 = globals;
        Dafny.ISequence<char> _in2 = name;
        parts = _in0;
        globals = _in1;
        name = _in2;
        goto TAIL_CALL_START;
      }
    }
    public static Wrappers_Compile._IResult<CompoundBeacon_Compile._ICompoundBeacon, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> CreateCompoundBeacon(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICompoundBeacon beacon, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig outer, software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient client, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> virtualFields, Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon> converted, SearchConfigToInfo_Compile._IPartSet globalSignedParts, SearchConfigToInfo_Compile._IPartSet globalEncryptedParts)
    {
      Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart> _0_signedParts = ((((beacon).dtor_signed).is_Some) ? (((beacon).dtor_signed).dtor_value) : (Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ISignedPart>.FromElements()));
      Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedPart> _1_encryptedParts = ((((beacon).dtor_encrypted).is_Some) ? (((beacon).dtor_encrypted).dtor_value) : (Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IEncryptedPart>.FromElements()));
      Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructor> _2_constructors = ((((beacon).dtor_constructors).is_Some) ? (((beacon).dtor_constructors).dtor_value) : (Dafny.Sequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IConstructor>.FromElements()));
      Wrappers_Compile._IResult<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _3_valueOrError0 = (globalSignedParts).combine(globalEncryptedParts, Dafny.Sequence<char>.FromString("Global Signed Parts List"), Dafny.Sequence<char>.FromString("Global Encrypted Parts List"));
      if ((_3_valueOrError0).IsFailure()) {
        return (_3_valueOrError0).PropagateFailure<CompoundBeacon_Compile._ICompoundBeacon>();
      } else {
        SearchConfigToInfo_Compile._IPartSet _4_globalParts = (_3_valueOrError0).Extract();
        Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _5_valueOrError1 = SearchConfigToInfo_Compile.__default.CheckSignedParts(_0_signedParts, _4_globalParts, (beacon).dtor_name);
        if ((_5_valueOrError1).IsFailure()) {
          return (_5_valueOrError1).PropagateFailure<CompoundBeacon_Compile._ICompoundBeacon>();
        } else {
          bool _6___v3 = (_5_valueOrError1).Extract();
          Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _7_valueOrError2 = SearchConfigToInfo_Compile.__default.CheckEncryptedParts(_1_encryptedParts, _4_globalParts, (beacon).dtor_name);
          if ((_7_valueOrError2).IsFailure()) {
            return (_7_valueOrError2).PropagateFailure<CompoundBeacon_Compile._ICompoundBeacon>();
          } else {
            bool _8___v4 = (_7_valueOrError2).Extract();
            Wrappers_Compile._IResult<Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _9_valueOrError3 = SearchConfigToInfo_Compile.__default.GetAllSignedParts(_0_signedParts, _2_constructors, globalSignedParts, (beacon).dtor_name, outer);
            if ((_9_valueOrError3).IsFailure()) {
              return (_9_valueOrError3).PropagateFailure<CompoundBeacon_Compile._ICompoundBeacon>();
            } else {
              Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> _10_signed = (_9_valueOrError3).Extract();
              Wrappers_Compile._IResult<Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _11_valueOrError4 = SearchConfigToInfo_Compile.__default.GetAllEncryptedParts(_1_encryptedParts, _2_constructors, globalEncryptedParts, (beacon).dtor_name, converted);
              if ((_11_valueOrError4).IsFailure()) {
                return (_11_valueOrError4).PropagateFailure<CompoundBeacon_Compile._ICompoundBeacon>();
              } else {
                Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> _12_encrypted = (_11_valueOrError4).Extract();
                Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _13_valueOrError5 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(!(converted).Contains((beacon).dtor_name), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Duplicate CompoundBeacon name : "), (beacon).dtor_name)));
                if ((_13_valueOrError5).IsFailure()) {
                  return (_13_valueOrError5).PropagateFailure<CompoundBeacon_Compile._ICompoundBeacon>();
                } else {
                  Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _14_valueOrError6 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>((((beacon).dtor_constructors).is_None) || ((new BigInteger((((beacon).dtor_constructors).dtor_value).Count)).Sign == 1), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("For beacon "), (beacon).dtor_name), Dafny.Sequence<char>.FromString(" an empty constructor list was supplied."))));
                  if ((_14_valueOrError6).IsFailure()) {
                    return (_14_valueOrError6).PropagateFailure<CompoundBeacon_Compile._ICompoundBeacon>();
                  } else {
                    Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _15_valueOrError7 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(((((beacon).dtor_constructors).is_Some) || ((new BigInteger((_0_signedParts).Count)).Sign != 0)) || ((new BigInteger((_1_encryptedParts).Count)).Sign != 0), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Compound beacon "), (beacon).dtor_name), Dafny.Sequence<char>.FromString(" defines no constructors, and also no local parts. Cannot make a default constructor from global parts."))));
                    if ((_15_valueOrError7).IsFailure()) {
                      return (_15_valueOrError7).PropagateFailure<CompoundBeacon_Compile._ICompoundBeacon>();
                    } else {
                      BigInteger _16_numNon = new BigInteger((_10_signed).Count);
                      Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> _17_allParts = Dafny.Sequence<CompoundBeacon_Compile._IBeaconPart>.Concat(_10_signed, _12_encrypted);
                      bool _18_isSignedBeacon = (new BigInteger((_12_encrypted).Count)).Sign == 0;
                      Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _19_valueOrError8 = SearchConfigToInfo_Compile.__default.BeaconNameAllowed(outer, virtualFields, (beacon).dtor_name, Dafny.Sequence<char>.FromString("CompoundBeacon"), _18_isSignedBeacon);
                      if ((_19_valueOrError8).IsFailure()) {
                        return (_19_valueOrError8).PropagateFailure<CompoundBeacon_Compile._ICompoundBeacon>();
                      } else {
                        bool _20___v5 = (_19_valueOrError8).Extract();
                        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _21_valueOrError9 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>((new BigInteger((_17_allParts).Count)).Sign == 1, DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("For beacon "), (beacon).dtor_name), Dafny.Sequence<char>.FromString(" no parts were supplied."))));
                        if ((_21_valueOrError9).IsFailure()) {
                          return (_21_valueOrError9).PropagateFailure<CompoundBeacon_Compile._ICompoundBeacon>();
                        } else {
                          Wrappers_Compile._IResult<Dafny.ISequence<CompoundBeacon_Compile._IConstructor>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _22_valueOrError10 = SearchConfigToInfo_Compile.__default.AddConstructors((beacon).dtor_constructors, (beacon).dtor_name, _17_allParts);
                          if ((_22_valueOrError10).IsFailure()) {
                            return (_22_valueOrError10).PropagateFailure<CompoundBeacon_Compile._ICompoundBeacon>();
                          } else {
                            Dafny.ISequence<CompoundBeacon_Compile._IConstructor> _23_constructors = (_22_valueOrError10).Extract();
                            Dafny.ISequence<char> _24_beaconName = ((_18_isSignedBeacon) ? ((beacon).dtor_name) : (Dafny.Sequence<char>.Concat(DynamoDbEncryptionUtil_Compile.__default.BeaconPrefix, (beacon).dtor_name)));
                            Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _25_valueOrError11 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>(software.amazon.cryptography.services.dynamodb.internaldafny.types.__default.IsValid__AttributeName(_24_beaconName), DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(_24_beaconName, Dafny.Sequence<char>.FromString(" is not a valid attribute name."))));
                            if ((_25_valueOrError11).IsFailure()) {
                              return (_25_valueOrError11).PropagateFailure<CompoundBeacon_Compile._ICompoundBeacon>();
                            } else {
                              return CompoundBeacon_Compile.__default.MakeCompoundBeacon(BaseBeacon_Compile.BeaconBase.create(client, (beacon).dtor_name, _24_beaconName), ((beacon).dtor_split).Select(BigInteger.Zero), _17_allParts, _16_numNon, _23_constructors);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> AddCompoundBeacons(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._ICompoundBeacon> beacons, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig outer, software.amazon.cryptography.primitives.internaldafny.AtomicPrimitivesClient client, Dafny.IMap<Dafny.ISequence<char>,DdbVirtualFields_Compile._IVirtField> virtualFields, Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon> converted, SearchConfigToInfo_Compile._IPartSet globalSignedParts, SearchConfigToInfo_Compile._IPartSet globalEncryptedParts)
    {
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>);
      if ((new BigInteger((beacons).Count)).Sign == 0) {
        output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(converted);
        return output;
      }
      Wrappers_Compile._IResult<CompoundBeacon_Compile._ICompoundBeacon, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_valueOrError0 = default(Wrappers_Compile._IResult<CompoundBeacon_Compile._ICompoundBeacon, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>);
      _0_valueOrError0 = SearchConfigToInfo_Compile.__default.CreateCompoundBeacon((beacons).Select(BigInteger.Zero), outer, client, virtualFields, converted, globalSignedParts, globalEncryptedParts);
      if ((_0_valueOrError0).IsFailure()) {
        output = (_0_valueOrError0).PropagateFailure<Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon>>();
        return output;
      }
      CompoundBeacon_Compile._ICompoundBeacon _1_newBeacon;
      _1_newBeacon = (_0_valueOrError0).Extract();
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
      _out0 = SearchConfigToInfo_Compile.__default.AddCompoundBeacons((beacons).Drop(BigInteger.One), outer, client, virtualFields, Dafny.Map<Dafny.ISequence<char>, SearchableEncryptionInfo_Compile._IBeacon>.Update(converted, ((beacons).Select(BigInteger.Zero)).dtor_name, SearchableEncryptionInfo_Compile.Beacon.create_Compound(_1_newBeacon)), globalSignedParts, globalEncryptedParts);
      output = _out0;
      return output;
    }
    public static bool ExistsInCompound(Dafny.ISequence<Dafny.ISequence<char>> names, Dafny.ISequence<char> name, Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon> data)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((names).Count)).Sign == 0) {
        return false;
      } else {
        SearchableEncryptionInfo_Compile._IBeacon _0_b = Dafny.Map<Dafny.ISequence<char>, SearchableEncryptionInfo_Compile._IBeacon>.Select(data,(names).Select(BigInteger.Zero));
        if (((_0_b).is_Compound) && (((_0_b).dtor_cmp).HasBeacon(name))) {
          return true;
        } else {
          Dafny.ISequence<Dafny.ISequence<char>> _in0 = (names).Drop(BigInteger.One);
          Dafny.ISequence<char> _in1 = name;
          Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon> _in2 = data;
          names = _in0;
          name = _in1;
          data = _in2;
          goto TAIL_CALL_START;
        }
      }
    }
    public static Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> CheckAllBeacons(Dafny.ISequence<Dafny.ISequence<char>> names, Dafny.ISequence<Dafny.ISequence<char>> allNames, Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon> data)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((names).Count)).Sign == 0) {
        return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(true);
      } else {
        SearchableEncryptionInfo_Compile._IBeacon _0_b = Dafny.Map<Dafny.ISequence<char>, SearchableEncryptionInfo_Compile._IBeacon>.Select(data,(names).Select(BigInteger.Zero));
        if ((SearchableEncryptionInfo_Compile.__default.IsPartOnly(_0_b)) && (!(SearchConfigToInfo_Compile.__default.ExistsInCompound(allNames, (names).Select(BigInteger.Zero), data)))) {
          return Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("PartOnly beacon "), (names).Select(BigInteger.Zero)), Dafny.Sequence<char>.FromString(" MUST be used in a compound beacon."))));
        } else if (((_0_b).is_Standard) && ((((_0_b).dtor_std).dtor_share).is_Some)) {
          Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _1_valueOrError0 = SearchConfigToInfo_Compile.__default.IsValidShare(data, (names).Select(BigInteger.Zero), ((_0_b).dtor_std).dtor_length, (((_0_b).dtor_std).dtor_share).dtor_value);
          if ((_1_valueOrError0).IsFailure()) {
            return (_1_valueOrError0).PropagateFailure<bool>();
          } else {
            bool _2___v6 = (_1_valueOrError0).Extract();
            Dafny.ISequence<Dafny.ISequence<char>> _in0 = (names).Drop(BigInteger.One);
            Dafny.ISequence<Dafny.ISequence<char>> _in1 = allNames;
            Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon> _in2 = data;
            names = _in0;
            allNames = _in1;
            data = _in2;
            goto TAIL_CALL_START;
          }
        } else {
          Dafny.ISequence<Dafny.ISequence<char>> _in3 = (names).Drop(BigInteger.One);
          Dafny.ISequence<Dafny.ISequence<char>> _in4 = allNames;
          Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon> _in5 = data;
          names = _in3;
          allNames = _in4;
          data = _in5;
          goto TAIL_CALL_START;
        }
      }
    }
    public static Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> CheckBeacons(Dafny.IMap<Dafny.ISequence<char>,SearchableEncryptionInfo_Compile._IBeacon> data) {
      Dafny.ISequence<Dafny.ISequence<char>> _0_beaconNames = SortedSets.__default.SetToOrderedSequence2<char>((data).Keys, DynamoDbEncryptionUtil_Compile.__default.CharLess);
      return SearchConfigToInfo_Compile.__default.CheckAllBeacons(_0_beaconNames, _0_beaconNames, data);
    }
  }

  public interface _IPartSet {
    bool is_PartSet { get; }
    Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> dtor_parts { get; }
    Dafny.ISet<Dafny.ISequence<char>> dtor_names { get; }
    Dafny.ISet<Dafny.ISequence<char>> dtor_prefixes { get; }
    _IPartSet DowncastClone();
    Wrappers_Compile._IResult<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> @add(CompoundBeacon_Compile._IBeaconPart part, Dafny.ISequence<char> name);
    Dafny.ISequence<char> GetSetAsString(Dafny.ISet<Dafny.ISequence<char>> strings);
    Wrappers_Compile._IResult<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> combine(SearchConfigToInfo_Compile._IPartSet other, Dafny.ISequence<char> name, Dafny.ISequence<char> otherName);
  }
  public class PartSet : _IPartSet {
    public readonly Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> _parts;
    public readonly Dafny.ISet<Dafny.ISequence<char>> _names;
    public readonly Dafny.ISet<Dafny.ISequence<char>> _prefixes;
    public PartSet(Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> parts, Dafny.ISet<Dafny.ISequence<char>> names, Dafny.ISet<Dafny.ISequence<char>> prefixes) {
      this._parts = parts;
      this._names = names;
      this._prefixes = prefixes;
    }
    public _IPartSet DowncastClone() {
      if (this is _IPartSet dt) { return dt; }
      return new PartSet(_parts, _names, _prefixes);
    }
    public override bool Equals(object other) {
      var oth = other as SearchConfigToInfo_Compile.PartSet;
      return oth != null && object.Equals(this._parts, oth._parts) && object.Equals(this._names, oth._names) && object.Equals(this._prefixes, oth._prefixes);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._parts));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._names));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._prefixes));
      return (int) hash;
    }
    public override string ToString() {
      string s = "SearchConfigToInfo.PartSet.PartSet";
      s += "(";
      s += Dafny.Helpers.ToString(this._parts);
      s += ", ";
      s += Dafny.Helpers.ToString(this._names);
      s += ", ";
      s += Dafny.Helpers.ToString(this._prefixes);
      s += ")";
      return s;
    }
    private static readonly SearchConfigToInfo_Compile._IPartSet theDefault = create(Dafny.Sequence<CompoundBeacon_Compile._IBeaconPart>.Empty, Dafny.Set<Dafny.ISequence<char>>.Empty, Dafny.Set<Dafny.ISequence<char>>.Empty);
    public static SearchConfigToInfo_Compile._IPartSet Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<SearchConfigToInfo_Compile._IPartSet> _TYPE = new Dafny.TypeDescriptor<SearchConfigToInfo_Compile._IPartSet>(SearchConfigToInfo_Compile.PartSet.Default());
    public static Dafny.TypeDescriptor<SearchConfigToInfo_Compile._IPartSet> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IPartSet create(Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> parts, Dafny.ISet<Dafny.ISequence<char>> names, Dafny.ISet<Dafny.ISequence<char>> prefixes) {
      return new PartSet(parts, names, prefixes);
    }
    public static _IPartSet create_PartSet(Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> parts, Dafny.ISet<Dafny.ISequence<char>> names, Dafny.ISet<Dafny.ISequence<char>> prefixes) {
      return create(parts, names, prefixes);
    }
    public bool is_PartSet { get { return true; } }
    public Dafny.ISequence<CompoundBeacon_Compile._IBeaconPart> dtor_parts {
      get {
        return this._parts;
      }
    }
    public Dafny.ISet<Dafny.ISequence<char>> dtor_names {
      get {
        return this._names;
      }
    }
    public Dafny.ISet<Dafny.ISequence<char>> dtor_prefixes {
      get {
        return this._prefixes;
      }
    }
    public Wrappers_Compile._IResult<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> @add(CompoundBeacon_Compile._IBeaconPart part, Dafny.ISequence<char> name)
    {
      if (((this).dtor_names).Contains((part).getName())) {
        return Wrappers_Compile.Result<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Duplicate part name "), (part).getName()), Dafny.Sequence<char>.FromString(" in ")), name), Dafny.Sequence<char>.FromString("."))));
      } else if (((this).dtor_prefixes).Contains((part).getPrefix())) {
        return Wrappers_Compile.Result<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Duplicate prefix "), (part).getPrefix()), Dafny.Sequence<char>.FromString(" in ")), name), Dafny.Sequence<char>.FromString("."))));
      } else {
        return Wrappers_Compile.Result<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(SearchConfigToInfo_Compile.PartSet.create(Dafny.Sequence<CompoundBeacon_Compile._IBeaconPart>.Concat((this).dtor_parts, Dafny.Sequence<CompoundBeacon_Compile._IBeaconPart>.FromElements(part)), Dafny.Set<Dafny.ISequence<char>>.Union((this).dtor_names, Dafny.Set<Dafny.ISequence<char>>.FromElements((part).getName())), Dafny.Set<Dafny.ISequence<char>>.Union((this).dtor_prefixes, Dafny.Set<Dafny.ISequence<char>>.FromElements((part).getPrefix()))));
      }
    }
    public Dafny.ISequence<char> GetSetAsString(Dafny.ISet<Dafny.ISequence<char>> strings) {
      Dafny.ISequence<Dafny.ISequence<char>> _0_names = SortedSets.__default.SetToOrderedSequence2<char>(strings, DynamoDbEncryptionUtil_Compile.__default.CharLess);
      return StandardLibrary_Compile.__default.Join<char>(_0_names, Dafny.Sequence<char>.FromString(", "));
    }
    public Wrappers_Compile._IResult<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> combine(SearchConfigToInfo_Compile._IPartSet other, Dafny.ISequence<char> name, Dafny.ISequence<char> otherName)
    {
      if ((new BigInteger((Dafny.Set<Dafny.ISequence<char>>.Intersect((this).dtor_names, (other).dtor_names)).Count)).Sign != 0) {
        Dafny.ISequence<char> _0_tags = (this).GetSetAsString(Dafny.Set<Dafny.ISequence<char>>.Intersect((this).dtor_names, (other).dtor_names));
        return Wrappers_Compile.Result<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Duplicate part name(s) "), _0_tags), Dafny.Sequence<char>.FromString(" between ")), name), Dafny.Sequence<char>.FromString(" and ")), otherName), Dafny.Sequence<char>.FromString("."))));
      } else if ((new BigInteger((Dafny.Set<Dafny.ISequence<char>>.Intersect((this).dtor_prefixes, (other).dtor_prefixes)).Count)).Sign != 0) {
        Dafny.ISequence<char> _1_tags = (this).GetSetAsString(Dafny.Set<Dafny.ISequence<char>>.Intersect((this).dtor_prefixes, (other).dtor_prefixes));
        return Wrappers_Compile.Result<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Failure(DynamoDbEncryptionUtil_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Duplicate prefix(es) "), _1_tags), Dafny.Sequence<char>.FromString(" between ")), name), Dafny.Sequence<char>.FromString(" and ")), otherName), Dafny.Sequence<char>.FromString("."))));
      } else {
        return Wrappers_Compile.Result<SearchConfigToInfo_Compile._IPartSet, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.create_Success(SearchConfigToInfo_Compile.PartSet.create(Dafny.Sequence<CompoundBeacon_Compile._IBeaconPart>.Concat((this).dtor_parts, (other).dtor_parts), Dafny.Set<Dafny.ISequence<char>>.Union((this).dtor_names, (other).dtor_names), Dafny.Set<Dafny.ISequence<char>>.Union((this).dtor_prefixes, (other).dtor_prefixes)));
      }
    }
  }
} // end of namespace SearchConfigToInfo_Compile
namespace software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types {

  public partial class __default {
    public static bool IsDummySubsetType(BigInteger x) {
      return (x).Sign == 1;
    }
  }

  public interface _IDafnyCallEvent<I, O> {
    bool is_DafnyCallEvent { get; }
    I dtor_input { get; }
    O dtor_output { get; }
    _IDafnyCallEvent<__I, __O> DowncastClone<__I, __O>(Func<I, __I> converter0, Func<O, __O> converter1);
  }
  public class DafnyCallEvent<I, O> : _IDafnyCallEvent<I, O> {
    public readonly I _input;
    public readonly O _output;
    public DafnyCallEvent(I input, O output) {
      this._input = input;
      this._output = output;
    }
    public _IDafnyCallEvent<__I, __O> DowncastClone<__I, __O>(Func<I, __I> converter0, Func<O, __O> converter1) {
      if (this is _IDafnyCallEvent<__I, __O> dt) { return dt; }
      return new DafnyCallEvent<__I, __O>(converter0(_input), converter1(_output));
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.DafnyCallEvent<I, O>;
      return oth != null && object.Equals(this._input, oth._input) && object.Equals(this._output, oth._output);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._input));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._output));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.DafnyCallEvent.DafnyCallEvent";
      s += "(";
      s += Dafny.Helpers.ToString(this._input);
      s += ", ";
      s += Dafny.Helpers.ToString(this._output);
      s += ")";
      return s;
    }
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDafnyCallEvent<I, O> Default(I _default_I, O _default_O) {
      return create(_default_I, _default_O);
    }
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDafnyCallEvent<I, O>> _TypeDescriptor(Dafny.TypeDescriptor<I> _td_I, Dafny.TypeDescriptor<O> _td_O) {
      return new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDafnyCallEvent<I, O>>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.DafnyCallEvent<I, O>.Default(_td_I.Default(), _td_O.Default()));
    }
    public static _IDafnyCallEvent<I, O> create(I input, O output) {
      return new DafnyCallEvent<I, O>(input, output);
    }
    public static _IDafnyCallEvent<I, O> create_DafnyCallEvent(I input, O output) {
      return create(input, output);
    }
    public bool is_DafnyCallEvent { get { return true; } }
    public I dtor_input {
      get {
        return this._input;
      }
    }
    public O dtor_output {
      get {
        return this._output;
      }
    }
  }

  public interface _IBatchExecuteStatementInputTransformInput {
    bool is_BatchExecuteStatementInputTransformInput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchExecuteStatementInput dtor_sdkInput { get; }
    _IBatchExecuteStatementInputTransformInput DowncastClone();
  }
  public class BatchExecuteStatementInputTransformInput : _IBatchExecuteStatementInputTransformInput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchExecuteStatementInput _sdkInput;
    public BatchExecuteStatementInputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchExecuteStatementInput sdkInput) {
      this._sdkInput = sdkInput;
    }
    public _IBatchExecuteStatementInputTransformInput DowncastClone() {
      if (this is _IBatchExecuteStatementInputTransformInput dt) { return dt; }
      return new BatchExecuteStatementInputTransformInput(_sdkInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchExecuteStatementInputTransformInput;
      return oth != null && object.Equals(this._sdkInput, oth._sdkInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sdkInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.BatchExecuteStatementInputTransformInput.BatchExecuteStatementInputTransformInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._sdkInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementInputTransformInput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.BatchExecuteStatementInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementInputTransformInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementInputTransformInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementInputTransformInput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchExecuteStatementInputTransformInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementInputTransformInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IBatchExecuteStatementInputTransformInput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchExecuteStatementInput sdkInput) {
      return new BatchExecuteStatementInputTransformInput(sdkInput);
    }
    public static _IBatchExecuteStatementInputTransformInput create_BatchExecuteStatementInputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchExecuteStatementInput sdkInput) {
      return create(sdkInput);
    }
    public bool is_BatchExecuteStatementInputTransformInput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchExecuteStatementInput dtor_sdkInput {
      get {
        return this._sdkInput;
      }
    }
  }

  public interface _IBatchExecuteStatementInputTransformOutput {
    bool is_BatchExecuteStatementInputTransformOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchExecuteStatementInput dtor_transformedInput { get; }
    _IBatchExecuteStatementInputTransformOutput DowncastClone();
  }
  public class BatchExecuteStatementInputTransformOutput : _IBatchExecuteStatementInputTransformOutput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchExecuteStatementInput _transformedInput;
    public BatchExecuteStatementInputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchExecuteStatementInput transformedInput) {
      this._transformedInput = transformedInput;
    }
    public _IBatchExecuteStatementInputTransformOutput DowncastClone() {
      if (this is _IBatchExecuteStatementInputTransformOutput dt) { return dt; }
      return new BatchExecuteStatementInputTransformOutput(_transformedInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchExecuteStatementInputTransformOutput;
      return oth != null && object.Equals(this._transformedInput, oth._transformedInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._transformedInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.BatchExecuteStatementInputTransformOutput.BatchExecuteStatementInputTransformOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._transformedInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementInputTransformOutput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.BatchExecuteStatementInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementInputTransformOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementInputTransformOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementInputTransformOutput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchExecuteStatementInputTransformOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementInputTransformOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IBatchExecuteStatementInputTransformOutput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchExecuteStatementInput transformedInput) {
      return new BatchExecuteStatementInputTransformOutput(transformedInput);
    }
    public static _IBatchExecuteStatementInputTransformOutput create_BatchExecuteStatementInputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchExecuteStatementInput transformedInput) {
      return create(transformedInput);
    }
    public bool is_BatchExecuteStatementInputTransformOutput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchExecuteStatementInput dtor_transformedInput {
      get {
        return this._transformedInput;
      }
    }
  }

  public interface _IBatchExecuteStatementOutputTransformInput {
    bool is_BatchExecuteStatementOutputTransformInput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchExecuteStatementOutput dtor_sdkOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchExecuteStatementInput dtor_originalInput { get; }
    _IBatchExecuteStatementOutputTransformInput DowncastClone();
  }
  public class BatchExecuteStatementOutputTransformInput : _IBatchExecuteStatementOutputTransformInput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchExecuteStatementOutput _sdkOutput;
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchExecuteStatementInput _originalInput;
    public BatchExecuteStatementOutputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchExecuteStatementOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchExecuteStatementInput originalInput) {
      this._sdkOutput = sdkOutput;
      this._originalInput = originalInput;
    }
    public _IBatchExecuteStatementOutputTransformInput DowncastClone() {
      if (this is _IBatchExecuteStatementOutputTransformInput dt) { return dt; }
      return new BatchExecuteStatementOutputTransformInput(_sdkOutput, _originalInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchExecuteStatementOutputTransformInput;
      return oth != null && object.Equals(this._sdkOutput, oth._sdkOutput) && object.Equals(this._originalInput, oth._originalInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sdkOutput));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._originalInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.BatchExecuteStatementOutputTransformInput.BatchExecuteStatementOutputTransformInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._sdkOutput);
      s += ", ";
      s += Dafny.Helpers.ToString(this._originalInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementOutputTransformInput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.BatchExecuteStatementOutput.Default(), software.amazon.cryptography.services.dynamodb.internaldafny.types.BatchExecuteStatementInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementOutputTransformInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementOutputTransformInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementOutputTransformInput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchExecuteStatementOutputTransformInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementOutputTransformInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IBatchExecuteStatementOutputTransformInput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchExecuteStatementOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchExecuteStatementInput originalInput) {
      return new BatchExecuteStatementOutputTransformInput(sdkOutput, originalInput);
    }
    public static _IBatchExecuteStatementOutputTransformInput create_BatchExecuteStatementOutputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchExecuteStatementOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchExecuteStatementInput originalInput) {
      return create(sdkOutput, originalInput);
    }
    public bool is_BatchExecuteStatementOutputTransformInput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchExecuteStatementOutput dtor_sdkOutput {
      get {
        return this._sdkOutput;
      }
    }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchExecuteStatementInput dtor_originalInput {
      get {
        return this._originalInput;
      }
    }
  }

  public interface _IBatchExecuteStatementOutputTransformOutput {
    bool is_BatchExecuteStatementOutputTransformOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchExecuteStatementOutput dtor_transformedOutput { get; }
    _IBatchExecuteStatementOutputTransformOutput DowncastClone();
  }
  public class BatchExecuteStatementOutputTransformOutput : _IBatchExecuteStatementOutputTransformOutput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchExecuteStatementOutput _transformedOutput;
    public BatchExecuteStatementOutputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchExecuteStatementOutput transformedOutput) {
      this._transformedOutput = transformedOutput;
    }
    public _IBatchExecuteStatementOutputTransformOutput DowncastClone() {
      if (this is _IBatchExecuteStatementOutputTransformOutput dt) { return dt; }
      return new BatchExecuteStatementOutputTransformOutput(_transformedOutput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchExecuteStatementOutputTransformOutput;
      return oth != null && object.Equals(this._transformedOutput, oth._transformedOutput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._transformedOutput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.BatchExecuteStatementOutputTransformOutput.BatchExecuteStatementOutputTransformOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._transformedOutput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementOutputTransformOutput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.BatchExecuteStatementOutput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementOutputTransformOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementOutputTransformOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementOutputTransformOutput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchExecuteStatementOutputTransformOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementOutputTransformOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IBatchExecuteStatementOutputTransformOutput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchExecuteStatementOutput transformedOutput) {
      return new BatchExecuteStatementOutputTransformOutput(transformedOutput);
    }
    public static _IBatchExecuteStatementOutputTransformOutput create_BatchExecuteStatementOutputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchExecuteStatementOutput transformedOutput) {
      return create(transformedOutput);
    }
    public bool is_BatchExecuteStatementOutputTransformOutput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchExecuteStatementOutput dtor_transformedOutput {
      get {
        return this._transformedOutput;
      }
    }
  }

  public interface _IBatchGetItemInputTransformInput {
    bool is_BatchGetItemInputTransformInput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemInput dtor_sdkInput { get; }
    _IBatchGetItemInputTransformInput DowncastClone();
  }
  public class BatchGetItemInputTransformInput : _IBatchGetItemInputTransformInput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemInput _sdkInput;
    public BatchGetItemInputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemInput sdkInput) {
      this._sdkInput = sdkInput;
    }
    public _IBatchGetItemInputTransformInput DowncastClone() {
      if (this is _IBatchGetItemInputTransformInput dt) { return dt; }
      return new BatchGetItemInputTransformInput(_sdkInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchGetItemInputTransformInput;
      return oth != null && object.Equals(this._sdkInput, oth._sdkInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sdkInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.BatchGetItemInputTransformInput.BatchGetItemInputTransformInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._sdkInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemInputTransformInput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.BatchGetItemInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemInputTransformInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemInputTransformInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemInputTransformInput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchGetItemInputTransformInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemInputTransformInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IBatchGetItemInputTransformInput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemInput sdkInput) {
      return new BatchGetItemInputTransformInput(sdkInput);
    }
    public static _IBatchGetItemInputTransformInput create_BatchGetItemInputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemInput sdkInput) {
      return create(sdkInput);
    }
    public bool is_BatchGetItemInputTransformInput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemInput dtor_sdkInput {
      get {
        return this._sdkInput;
      }
    }
  }

  public interface _IBatchGetItemInputTransformOutput {
    bool is_BatchGetItemInputTransformOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemInput dtor_transformedInput { get; }
    _IBatchGetItemInputTransformOutput DowncastClone();
  }
  public class BatchGetItemInputTransformOutput : _IBatchGetItemInputTransformOutput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemInput _transformedInput;
    public BatchGetItemInputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemInput transformedInput) {
      this._transformedInput = transformedInput;
    }
    public _IBatchGetItemInputTransformOutput DowncastClone() {
      if (this is _IBatchGetItemInputTransformOutput dt) { return dt; }
      return new BatchGetItemInputTransformOutput(_transformedInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchGetItemInputTransformOutput;
      return oth != null && object.Equals(this._transformedInput, oth._transformedInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._transformedInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.BatchGetItemInputTransformOutput.BatchGetItemInputTransformOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._transformedInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemInputTransformOutput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.BatchGetItemInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemInputTransformOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemInputTransformOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemInputTransformOutput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchGetItemInputTransformOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemInputTransformOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IBatchGetItemInputTransformOutput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemInput transformedInput) {
      return new BatchGetItemInputTransformOutput(transformedInput);
    }
    public static _IBatchGetItemInputTransformOutput create_BatchGetItemInputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemInput transformedInput) {
      return create(transformedInput);
    }
    public bool is_BatchGetItemInputTransformOutput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemInput dtor_transformedInput {
      get {
        return this._transformedInput;
      }
    }
  }

  public interface _IBatchGetItemOutputTransformInput {
    bool is_BatchGetItemOutputTransformInput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemOutput dtor_sdkOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemInput dtor_originalInput { get; }
    _IBatchGetItemOutputTransformInput DowncastClone();
  }
  public class BatchGetItemOutputTransformInput : _IBatchGetItemOutputTransformInput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemOutput _sdkOutput;
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemInput _originalInput;
    public BatchGetItemOutputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemInput originalInput) {
      this._sdkOutput = sdkOutput;
      this._originalInput = originalInput;
    }
    public _IBatchGetItemOutputTransformInput DowncastClone() {
      if (this is _IBatchGetItemOutputTransformInput dt) { return dt; }
      return new BatchGetItemOutputTransformInput(_sdkOutput, _originalInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchGetItemOutputTransformInput;
      return oth != null && object.Equals(this._sdkOutput, oth._sdkOutput) && object.Equals(this._originalInput, oth._originalInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sdkOutput));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._originalInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.BatchGetItemOutputTransformInput.BatchGetItemOutputTransformInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._sdkOutput);
      s += ", ";
      s += Dafny.Helpers.ToString(this._originalInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemOutputTransformInput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.BatchGetItemOutput.Default(), software.amazon.cryptography.services.dynamodb.internaldafny.types.BatchGetItemInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemOutputTransformInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemOutputTransformInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemOutputTransformInput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchGetItemOutputTransformInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemOutputTransformInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IBatchGetItemOutputTransformInput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemInput originalInput) {
      return new BatchGetItemOutputTransformInput(sdkOutput, originalInput);
    }
    public static _IBatchGetItemOutputTransformInput create_BatchGetItemOutputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemInput originalInput) {
      return create(sdkOutput, originalInput);
    }
    public bool is_BatchGetItemOutputTransformInput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemOutput dtor_sdkOutput {
      get {
        return this._sdkOutput;
      }
    }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemInput dtor_originalInput {
      get {
        return this._originalInput;
      }
    }
  }

  public interface _IBatchGetItemOutputTransformOutput {
    bool is_BatchGetItemOutputTransformOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemOutput dtor_transformedOutput { get; }
    _IBatchGetItemOutputTransformOutput DowncastClone();
  }
  public class BatchGetItemOutputTransformOutput : _IBatchGetItemOutputTransformOutput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemOutput _transformedOutput;
    public BatchGetItemOutputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemOutput transformedOutput) {
      this._transformedOutput = transformedOutput;
    }
    public _IBatchGetItemOutputTransformOutput DowncastClone() {
      if (this is _IBatchGetItemOutputTransformOutput dt) { return dt; }
      return new BatchGetItemOutputTransformOutput(_transformedOutput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchGetItemOutputTransformOutput;
      return oth != null && object.Equals(this._transformedOutput, oth._transformedOutput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._transformedOutput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.BatchGetItemOutputTransformOutput.BatchGetItemOutputTransformOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._transformedOutput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemOutputTransformOutput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.BatchGetItemOutput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemOutputTransformOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemOutputTransformOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemOutputTransformOutput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchGetItemOutputTransformOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemOutputTransformOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IBatchGetItemOutputTransformOutput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemOutput transformedOutput) {
      return new BatchGetItemOutputTransformOutput(transformedOutput);
    }
    public static _IBatchGetItemOutputTransformOutput create_BatchGetItemOutputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemOutput transformedOutput) {
      return create(transformedOutput);
    }
    public bool is_BatchGetItemOutputTransformOutput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemOutput dtor_transformedOutput {
      get {
        return this._transformedOutput;
      }
    }
  }

  public interface _IBatchWriteItemInputTransformInput {
    bool is_BatchWriteItemInputTransformInput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemInput dtor_sdkInput { get; }
    _IBatchWriteItemInputTransformInput DowncastClone();
  }
  public class BatchWriteItemInputTransformInput : _IBatchWriteItemInputTransformInput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemInput _sdkInput;
    public BatchWriteItemInputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemInput sdkInput) {
      this._sdkInput = sdkInput;
    }
    public _IBatchWriteItemInputTransformInput DowncastClone() {
      if (this is _IBatchWriteItemInputTransformInput dt) { return dt; }
      return new BatchWriteItemInputTransformInput(_sdkInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchWriteItemInputTransformInput;
      return oth != null && object.Equals(this._sdkInput, oth._sdkInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sdkInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.BatchWriteItemInputTransformInput.BatchWriteItemInputTransformInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._sdkInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemInputTransformInput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.BatchWriteItemInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemInputTransformInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemInputTransformInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemInputTransformInput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchWriteItemInputTransformInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemInputTransformInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IBatchWriteItemInputTransformInput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemInput sdkInput) {
      return new BatchWriteItemInputTransformInput(sdkInput);
    }
    public static _IBatchWriteItemInputTransformInput create_BatchWriteItemInputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemInput sdkInput) {
      return create(sdkInput);
    }
    public bool is_BatchWriteItemInputTransformInput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemInput dtor_sdkInput {
      get {
        return this._sdkInput;
      }
    }
  }

  public interface _IBatchWriteItemInputTransformOutput {
    bool is_BatchWriteItemInputTransformOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemInput dtor_transformedInput { get; }
    _IBatchWriteItemInputTransformOutput DowncastClone();
  }
  public class BatchWriteItemInputTransformOutput : _IBatchWriteItemInputTransformOutput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemInput _transformedInput;
    public BatchWriteItemInputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemInput transformedInput) {
      this._transformedInput = transformedInput;
    }
    public _IBatchWriteItemInputTransformOutput DowncastClone() {
      if (this is _IBatchWriteItemInputTransformOutput dt) { return dt; }
      return new BatchWriteItemInputTransformOutput(_transformedInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchWriteItemInputTransformOutput;
      return oth != null && object.Equals(this._transformedInput, oth._transformedInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._transformedInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.BatchWriteItemInputTransformOutput.BatchWriteItemInputTransformOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._transformedInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemInputTransformOutput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.BatchWriteItemInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemInputTransformOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemInputTransformOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemInputTransformOutput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchWriteItemInputTransformOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemInputTransformOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IBatchWriteItemInputTransformOutput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemInput transformedInput) {
      return new BatchWriteItemInputTransformOutput(transformedInput);
    }
    public static _IBatchWriteItemInputTransformOutput create_BatchWriteItemInputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemInput transformedInput) {
      return create(transformedInput);
    }
    public bool is_BatchWriteItemInputTransformOutput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemInput dtor_transformedInput {
      get {
        return this._transformedInput;
      }
    }
  }

  public interface _IBatchWriteItemOutputTransformInput {
    bool is_BatchWriteItemOutputTransformInput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemOutput dtor_sdkOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemInput dtor_originalInput { get; }
    _IBatchWriteItemOutputTransformInput DowncastClone();
  }
  public class BatchWriteItemOutputTransformInput : _IBatchWriteItemOutputTransformInput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemOutput _sdkOutput;
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemInput _originalInput;
    public BatchWriteItemOutputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemInput originalInput) {
      this._sdkOutput = sdkOutput;
      this._originalInput = originalInput;
    }
    public _IBatchWriteItemOutputTransformInput DowncastClone() {
      if (this is _IBatchWriteItemOutputTransformInput dt) { return dt; }
      return new BatchWriteItemOutputTransformInput(_sdkOutput, _originalInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchWriteItemOutputTransformInput;
      return oth != null && object.Equals(this._sdkOutput, oth._sdkOutput) && object.Equals(this._originalInput, oth._originalInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sdkOutput));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._originalInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.BatchWriteItemOutputTransformInput.BatchWriteItemOutputTransformInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._sdkOutput);
      s += ", ";
      s += Dafny.Helpers.ToString(this._originalInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemOutputTransformInput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.BatchWriteItemOutput.Default(), software.amazon.cryptography.services.dynamodb.internaldafny.types.BatchWriteItemInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemOutputTransformInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemOutputTransformInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemOutputTransformInput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchWriteItemOutputTransformInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemOutputTransformInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IBatchWriteItemOutputTransformInput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemInput originalInput) {
      return new BatchWriteItemOutputTransformInput(sdkOutput, originalInput);
    }
    public static _IBatchWriteItemOutputTransformInput create_BatchWriteItemOutputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemInput originalInput) {
      return create(sdkOutput, originalInput);
    }
    public bool is_BatchWriteItemOutputTransformInput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemOutput dtor_sdkOutput {
      get {
        return this._sdkOutput;
      }
    }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemInput dtor_originalInput {
      get {
        return this._originalInput;
      }
    }
  }

  public interface _IBatchWriteItemOutputTransformOutput {
    bool is_BatchWriteItemOutputTransformOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemOutput dtor_transformedOutput { get; }
    _IBatchWriteItemOutputTransformOutput DowncastClone();
  }
  public class BatchWriteItemOutputTransformOutput : _IBatchWriteItemOutputTransformOutput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemOutput _transformedOutput;
    public BatchWriteItemOutputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemOutput transformedOutput) {
      this._transformedOutput = transformedOutput;
    }
    public _IBatchWriteItemOutputTransformOutput DowncastClone() {
      if (this is _IBatchWriteItemOutputTransformOutput dt) { return dt; }
      return new BatchWriteItemOutputTransformOutput(_transformedOutput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchWriteItemOutputTransformOutput;
      return oth != null && object.Equals(this._transformedOutput, oth._transformedOutput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._transformedOutput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.BatchWriteItemOutputTransformOutput.BatchWriteItemOutputTransformOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._transformedOutput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemOutputTransformOutput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.BatchWriteItemOutput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemOutputTransformOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemOutputTransformOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemOutputTransformOutput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchWriteItemOutputTransformOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemOutputTransformOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IBatchWriteItemOutputTransformOutput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemOutput transformedOutput) {
      return new BatchWriteItemOutputTransformOutput(transformedOutput);
    }
    public static _IBatchWriteItemOutputTransformOutput create_BatchWriteItemOutputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemOutput transformedOutput) {
      return create(transformedOutput);
    }
    public bool is_BatchWriteItemOutputTransformOutput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemOutput dtor_transformedOutput {
      get {
        return this._transformedOutput;
      }
    }
  }

  public interface _IDeleteItemInputTransformInput {
    bool is_DeleteItemInputTransformInput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemInput dtor_sdkInput { get; }
    _IDeleteItemInputTransformInput DowncastClone();
  }
  public class DeleteItemInputTransformInput : _IDeleteItemInputTransformInput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemInput _sdkInput;
    public DeleteItemInputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemInput sdkInput) {
      this._sdkInput = sdkInput;
    }
    public _IDeleteItemInputTransformInput DowncastClone() {
      if (this is _IDeleteItemInputTransformInput dt) { return dt; }
      return new DeleteItemInputTransformInput(_sdkInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.DeleteItemInputTransformInput;
      return oth != null && object.Equals(this._sdkInput, oth._sdkInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sdkInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.DeleteItemInputTransformInput.DeleteItemInputTransformInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._sdkInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemInputTransformInput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.DeleteItemInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemInputTransformInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemInputTransformInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemInputTransformInput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.DeleteItemInputTransformInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemInputTransformInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IDeleteItemInputTransformInput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemInput sdkInput) {
      return new DeleteItemInputTransformInput(sdkInput);
    }
    public static _IDeleteItemInputTransformInput create_DeleteItemInputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemInput sdkInput) {
      return create(sdkInput);
    }
    public bool is_DeleteItemInputTransformInput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemInput dtor_sdkInput {
      get {
        return this._sdkInput;
      }
    }
  }

  public interface _IDeleteItemInputTransformOutput {
    bool is_DeleteItemInputTransformOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemInput dtor_transformedInput { get; }
    _IDeleteItemInputTransformOutput DowncastClone();
  }
  public class DeleteItemInputTransformOutput : _IDeleteItemInputTransformOutput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemInput _transformedInput;
    public DeleteItemInputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemInput transformedInput) {
      this._transformedInput = transformedInput;
    }
    public _IDeleteItemInputTransformOutput DowncastClone() {
      if (this is _IDeleteItemInputTransformOutput dt) { return dt; }
      return new DeleteItemInputTransformOutput(_transformedInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.DeleteItemInputTransformOutput;
      return oth != null && object.Equals(this._transformedInput, oth._transformedInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._transformedInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.DeleteItemInputTransformOutput.DeleteItemInputTransformOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._transformedInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemInputTransformOutput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.DeleteItemInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemInputTransformOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemInputTransformOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemInputTransformOutput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.DeleteItemInputTransformOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemInputTransformOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IDeleteItemInputTransformOutput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemInput transformedInput) {
      return new DeleteItemInputTransformOutput(transformedInput);
    }
    public static _IDeleteItemInputTransformOutput create_DeleteItemInputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemInput transformedInput) {
      return create(transformedInput);
    }
    public bool is_DeleteItemInputTransformOutput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemInput dtor_transformedInput {
      get {
        return this._transformedInput;
      }
    }
  }

  public interface _IDeleteItemOutputTransformInput {
    bool is_DeleteItemOutputTransformInput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemOutput dtor_sdkOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemInput dtor_originalInput { get; }
    _IDeleteItemOutputTransformInput DowncastClone();
  }
  public class DeleteItemOutputTransformInput : _IDeleteItemOutputTransformInput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemOutput _sdkOutput;
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemInput _originalInput;
    public DeleteItemOutputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemInput originalInput) {
      this._sdkOutput = sdkOutput;
      this._originalInput = originalInput;
    }
    public _IDeleteItemOutputTransformInput DowncastClone() {
      if (this is _IDeleteItemOutputTransformInput dt) { return dt; }
      return new DeleteItemOutputTransformInput(_sdkOutput, _originalInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.DeleteItemOutputTransformInput;
      return oth != null && object.Equals(this._sdkOutput, oth._sdkOutput) && object.Equals(this._originalInput, oth._originalInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sdkOutput));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._originalInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.DeleteItemOutputTransformInput.DeleteItemOutputTransformInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._sdkOutput);
      s += ", ";
      s += Dafny.Helpers.ToString(this._originalInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemOutputTransformInput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.DeleteItemOutput.Default(), software.amazon.cryptography.services.dynamodb.internaldafny.types.DeleteItemInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemOutputTransformInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemOutputTransformInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemOutputTransformInput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.DeleteItemOutputTransformInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemOutputTransformInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IDeleteItemOutputTransformInput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemInput originalInput) {
      return new DeleteItemOutputTransformInput(sdkOutput, originalInput);
    }
    public static _IDeleteItemOutputTransformInput create_DeleteItemOutputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemInput originalInput) {
      return create(sdkOutput, originalInput);
    }
    public bool is_DeleteItemOutputTransformInput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemOutput dtor_sdkOutput {
      get {
        return this._sdkOutput;
      }
    }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemInput dtor_originalInput {
      get {
        return this._originalInput;
      }
    }
  }

  public interface _IDeleteItemOutputTransformOutput {
    bool is_DeleteItemOutputTransformOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemOutput dtor_transformedOutput { get; }
    _IDeleteItemOutputTransformOutput DowncastClone();
  }
  public class DeleteItemOutputTransformOutput : _IDeleteItemOutputTransformOutput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemOutput _transformedOutput;
    public DeleteItemOutputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemOutput transformedOutput) {
      this._transformedOutput = transformedOutput;
    }
    public _IDeleteItemOutputTransformOutput DowncastClone() {
      if (this is _IDeleteItemOutputTransformOutput dt) { return dt; }
      return new DeleteItemOutputTransformOutput(_transformedOutput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.DeleteItemOutputTransformOutput;
      return oth != null && object.Equals(this._transformedOutput, oth._transformedOutput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._transformedOutput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.DeleteItemOutputTransformOutput.DeleteItemOutputTransformOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._transformedOutput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemOutputTransformOutput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.DeleteItemOutput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemOutputTransformOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemOutputTransformOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemOutputTransformOutput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.DeleteItemOutputTransformOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemOutputTransformOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IDeleteItemOutputTransformOutput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemOutput transformedOutput) {
      return new DeleteItemOutputTransformOutput(transformedOutput);
    }
    public static _IDeleteItemOutputTransformOutput create_DeleteItemOutputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemOutput transformedOutput) {
      return create(transformedOutput);
    }
    public bool is_DeleteItemOutputTransformOutput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemOutput dtor_transformedOutput {
      get {
        return this._transformedOutput;
      }
    }
  }

  public partial class IDynamoDbEncryptionTransformsClientCallHistory {
    public IDynamoDbEncryptionTransformsClientCallHistory() {
    }
  }

  public interface IDynamoDbEncryptionTransformsClient {
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> PutItemInputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> PutItemOutputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemOutputTransformInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> GetItemInputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemInputTransformInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> GetItemOutputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemOutputTransformInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> BatchWriteItemInputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemInputTransformInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> BatchWriteItemOutputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemOutputTransformInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> BatchGetItemInputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemInputTransformInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> BatchGetItemOutputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemOutputTransformInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> ScanInputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanInputTransformInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> ScanOutputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanOutputTransformInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> QueryInputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryInputTransformInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> QueryOutputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryOutputTransformInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> TransactWriteItemsInputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> TransactWriteItemsOutputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsOutputTransformInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> UpdateItemInputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemInputTransformInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> UpdateItemOutputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemOutputTransformInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> DeleteItemInputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemInputTransformInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> DeleteItemOutputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemOutputTransformInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> TransactGetItemsInputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsInputTransformInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> TransactGetItemsOutputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsOutputTransformInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> ExecuteStatementInputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementInputTransformInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> ExecuteStatementOutputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementOutputTransformInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> BatchExecuteStatementInputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementInputTransformInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> BatchExecuteStatementOutputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementOutputTransformInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> ExecuteTransactionInputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionInputTransformInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> ExecuteTransactionOutputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionOutputTransformInput input);
    Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IResolveAttributesOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> ResolveAttributes(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IResolveAttributesInput input);
  }
  public class _Companion_IDynamoDbEncryptionTransformsClient {
  }

  public interface _IExecuteStatementInputTransformInput {
    bool is_ExecuteStatementInputTransformInput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteStatementInput dtor_sdkInput { get; }
    _IExecuteStatementInputTransformInput DowncastClone();
  }
  public class ExecuteStatementInputTransformInput : _IExecuteStatementInputTransformInput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteStatementInput _sdkInput;
    public ExecuteStatementInputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteStatementInput sdkInput) {
      this._sdkInput = sdkInput;
    }
    public _IExecuteStatementInputTransformInput DowncastClone() {
      if (this is _IExecuteStatementInputTransformInput dt) { return dt; }
      return new ExecuteStatementInputTransformInput(_sdkInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ExecuteStatementInputTransformInput;
      return oth != null && object.Equals(this._sdkInput, oth._sdkInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sdkInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.ExecuteStatementInputTransformInput.ExecuteStatementInputTransformInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._sdkInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementInputTransformInput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.ExecuteStatementInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementInputTransformInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementInputTransformInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementInputTransformInput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ExecuteStatementInputTransformInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementInputTransformInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IExecuteStatementInputTransformInput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteStatementInput sdkInput) {
      return new ExecuteStatementInputTransformInput(sdkInput);
    }
    public static _IExecuteStatementInputTransformInput create_ExecuteStatementInputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteStatementInput sdkInput) {
      return create(sdkInput);
    }
    public bool is_ExecuteStatementInputTransformInput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteStatementInput dtor_sdkInput {
      get {
        return this._sdkInput;
      }
    }
  }

  public interface _IExecuteStatementInputTransformOutput {
    bool is_ExecuteStatementInputTransformOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteStatementInput dtor_transformedInput { get; }
    _IExecuteStatementInputTransformOutput DowncastClone();
  }
  public class ExecuteStatementInputTransformOutput : _IExecuteStatementInputTransformOutput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteStatementInput _transformedInput;
    public ExecuteStatementInputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteStatementInput transformedInput) {
      this._transformedInput = transformedInput;
    }
    public _IExecuteStatementInputTransformOutput DowncastClone() {
      if (this is _IExecuteStatementInputTransformOutput dt) { return dt; }
      return new ExecuteStatementInputTransformOutput(_transformedInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ExecuteStatementInputTransformOutput;
      return oth != null && object.Equals(this._transformedInput, oth._transformedInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._transformedInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.ExecuteStatementInputTransformOutput.ExecuteStatementInputTransformOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._transformedInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementInputTransformOutput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.ExecuteStatementInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementInputTransformOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementInputTransformOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementInputTransformOutput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ExecuteStatementInputTransformOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementInputTransformOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IExecuteStatementInputTransformOutput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteStatementInput transformedInput) {
      return new ExecuteStatementInputTransformOutput(transformedInput);
    }
    public static _IExecuteStatementInputTransformOutput create_ExecuteStatementInputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteStatementInput transformedInput) {
      return create(transformedInput);
    }
    public bool is_ExecuteStatementInputTransformOutput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteStatementInput dtor_transformedInput {
      get {
        return this._transformedInput;
      }
    }
  }

  public interface _IExecuteStatementOutputTransformInput {
    bool is_ExecuteStatementOutputTransformInput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteStatementOutput dtor_sdkOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteStatementInput dtor_originalInput { get; }
    _IExecuteStatementOutputTransformInput DowncastClone();
  }
  public class ExecuteStatementOutputTransformInput : _IExecuteStatementOutputTransformInput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteStatementOutput _sdkOutput;
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteStatementInput _originalInput;
    public ExecuteStatementOutputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteStatementOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteStatementInput originalInput) {
      this._sdkOutput = sdkOutput;
      this._originalInput = originalInput;
    }
    public _IExecuteStatementOutputTransformInput DowncastClone() {
      if (this is _IExecuteStatementOutputTransformInput dt) { return dt; }
      return new ExecuteStatementOutputTransformInput(_sdkOutput, _originalInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ExecuteStatementOutputTransformInput;
      return oth != null && object.Equals(this._sdkOutput, oth._sdkOutput) && object.Equals(this._originalInput, oth._originalInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sdkOutput));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._originalInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.ExecuteStatementOutputTransformInput.ExecuteStatementOutputTransformInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._sdkOutput);
      s += ", ";
      s += Dafny.Helpers.ToString(this._originalInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementOutputTransformInput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.ExecuteStatementOutput.Default(), software.amazon.cryptography.services.dynamodb.internaldafny.types.ExecuteStatementInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementOutputTransformInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementOutputTransformInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementOutputTransformInput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ExecuteStatementOutputTransformInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementOutputTransformInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IExecuteStatementOutputTransformInput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteStatementOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteStatementInput originalInput) {
      return new ExecuteStatementOutputTransformInput(sdkOutput, originalInput);
    }
    public static _IExecuteStatementOutputTransformInput create_ExecuteStatementOutputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteStatementOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteStatementInput originalInput) {
      return create(sdkOutput, originalInput);
    }
    public bool is_ExecuteStatementOutputTransformInput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteStatementOutput dtor_sdkOutput {
      get {
        return this._sdkOutput;
      }
    }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteStatementInput dtor_originalInput {
      get {
        return this._originalInput;
      }
    }
  }

  public interface _IExecuteStatementOutputTransformOutput {
    bool is_ExecuteStatementOutputTransformOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteStatementOutput dtor_transformedOutput { get; }
    _IExecuteStatementOutputTransformOutput DowncastClone();
  }
  public class ExecuteStatementOutputTransformOutput : _IExecuteStatementOutputTransformOutput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteStatementOutput _transformedOutput;
    public ExecuteStatementOutputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteStatementOutput transformedOutput) {
      this._transformedOutput = transformedOutput;
    }
    public _IExecuteStatementOutputTransformOutput DowncastClone() {
      if (this is _IExecuteStatementOutputTransformOutput dt) { return dt; }
      return new ExecuteStatementOutputTransformOutput(_transformedOutput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ExecuteStatementOutputTransformOutput;
      return oth != null && object.Equals(this._transformedOutput, oth._transformedOutput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._transformedOutput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.ExecuteStatementOutputTransformOutput.ExecuteStatementOutputTransformOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._transformedOutput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementOutputTransformOutput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.ExecuteStatementOutput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementOutputTransformOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementOutputTransformOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementOutputTransformOutput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ExecuteStatementOutputTransformOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementOutputTransformOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IExecuteStatementOutputTransformOutput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteStatementOutput transformedOutput) {
      return new ExecuteStatementOutputTransformOutput(transformedOutput);
    }
    public static _IExecuteStatementOutputTransformOutput create_ExecuteStatementOutputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteStatementOutput transformedOutput) {
      return create(transformedOutput);
    }
    public bool is_ExecuteStatementOutputTransformOutput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteStatementOutput dtor_transformedOutput {
      get {
        return this._transformedOutput;
      }
    }
  }

  public interface _IExecuteTransactionInputTransformInput {
    bool is_ExecuteTransactionInputTransformInput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteTransactionInput dtor_sdkInput { get; }
    _IExecuteTransactionInputTransformInput DowncastClone();
  }
  public class ExecuteTransactionInputTransformInput : _IExecuteTransactionInputTransformInput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteTransactionInput _sdkInput;
    public ExecuteTransactionInputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteTransactionInput sdkInput) {
      this._sdkInput = sdkInput;
    }
    public _IExecuteTransactionInputTransformInput DowncastClone() {
      if (this is _IExecuteTransactionInputTransformInput dt) { return dt; }
      return new ExecuteTransactionInputTransformInput(_sdkInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ExecuteTransactionInputTransformInput;
      return oth != null && object.Equals(this._sdkInput, oth._sdkInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sdkInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.ExecuteTransactionInputTransformInput.ExecuteTransactionInputTransformInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._sdkInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionInputTransformInput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.ExecuteTransactionInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionInputTransformInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionInputTransformInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionInputTransformInput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ExecuteTransactionInputTransformInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionInputTransformInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IExecuteTransactionInputTransformInput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteTransactionInput sdkInput) {
      return new ExecuteTransactionInputTransformInput(sdkInput);
    }
    public static _IExecuteTransactionInputTransformInput create_ExecuteTransactionInputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteTransactionInput sdkInput) {
      return create(sdkInput);
    }
    public bool is_ExecuteTransactionInputTransformInput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteTransactionInput dtor_sdkInput {
      get {
        return this._sdkInput;
      }
    }
  }

  public interface _IExecuteTransactionInputTransformOutput {
    bool is_ExecuteTransactionInputTransformOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteTransactionInput dtor_transformedInput { get; }
    _IExecuteTransactionInputTransformOutput DowncastClone();
  }
  public class ExecuteTransactionInputTransformOutput : _IExecuteTransactionInputTransformOutput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteTransactionInput _transformedInput;
    public ExecuteTransactionInputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteTransactionInput transformedInput) {
      this._transformedInput = transformedInput;
    }
    public _IExecuteTransactionInputTransformOutput DowncastClone() {
      if (this is _IExecuteTransactionInputTransformOutput dt) { return dt; }
      return new ExecuteTransactionInputTransformOutput(_transformedInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ExecuteTransactionInputTransformOutput;
      return oth != null && object.Equals(this._transformedInput, oth._transformedInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._transformedInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.ExecuteTransactionInputTransformOutput.ExecuteTransactionInputTransformOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._transformedInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionInputTransformOutput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.ExecuteTransactionInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionInputTransformOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionInputTransformOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionInputTransformOutput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ExecuteTransactionInputTransformOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionInputTransformOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IExecuteTransactionInputTransformOutput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteTransactionInput transformedInput) {
      return new ExecuteTransactionInputTransformOutput(transformedInput);
    }
    public static _IExecuteTransactionInputTransformOutput create_ExecuteTransactionInputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteTransactionInput transformedInput) {
      return create(transformedInput);
    }
    public bool is_ExecuteTransactionInputTransformOutput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteTransactionInput dtor_transformedInput {
      get {
        return this._transformedInput;
      }
    }
  }

  public interface _IExecuteTransactionOutputTransformInput {
    bool is_ExecuteTransactionOutputTransformInput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteTransactionOutput dtor_sdkOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteTransactionInput dtor_originalInput { get; }
    _IExecuteTransactionOutputTransformInput DowncastClone();
  }
  public class ExecuteTransactionOutputTransformInput : _IExecuteTransactionOutputTransformInput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteTransactionOutput _sdkOutput;
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteTransactionInput _originalInput;
    public ExecuteTransactionOutputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteTransactionOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteTransactionInput originalInput) {
      this._sdkOutput = sdkOutput;
      this._originalInput = originalInput;
    }
    public _IExecuteTransactionOutputTransformInput DowncastClone() {
      if (this is _IExecuteTransactionOutputTransformInput dt) { return dt; }
      return new ExecuteTransactionOutputTransformInput(_sdkOutput, _originalInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ExecuteTransactionOutputTransformInput;
      return oth != null && object.Equals(this._sdkOutput, oth._sdkOutput) && object.Equals(this._originalInput, oth._originalInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sdkOutput));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._originalInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.ExecuteTransactionOutputTransformInput.ExecuteTransactionOutputTransformInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._sdkOutput);
      s += ", ";
      s += Dafny.Helpers.ToString(this._originalInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionOutputTransformInput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.ExecuteTransactionOutput.Default(), software.amazon.cryptography.services.dynamodb.internaldafny.types.ExecuteTransactionInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionOutputTransformInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionOutputTransformInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionOutputTransformInput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ExecuteTransactionOutputTransformInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionOutputTransformInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IExecuteTransactionOutputTransformInput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteTransactionOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteTransactionInput originalInput) {
      return new ExecuteTransactionOutputTransformInput(sdkOutput, originalInput);
    }
    public static _IExecuteTransactionOutputTransformInput create_ExecuteTransactionOutputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteTransactionOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteTransactionInput originalInput) {
      return create(sdkOutput, originalInput);
    }
    public bool is_ExecuteTransactionOutputTransformInput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteTransactionOutput dtor_sdkOutput {
      get {
        return this._sdkOutput;
      }
    }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteTransactionInput dtor_originalInput {
      get {
        return this._originalInput;
      }
    }
  }

  public interface _IExecuteTransactionOutputTransformOutput {
    bool is_ExecuteTransactionOutputTransformOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteTransactionOutput dtor_transformedOutput { get; }
    _IExecuteTransactionOutputTransformOutput DowncastClone();
  }
  public class ExecuteTransactionOutputTransformOutput : _IExecuteTransactionOutputTransformOutput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteTransactionOutput _transformedOutput;
    public ExecuteTransactionOutputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteTransactionOutput transformedOutput) {
      this._transformedOutput = transformedOutput;
    }
    public _IExecuteTransactionOutputTransformOutput DowncastClone() {
      if (this is _IExecuteTransactionOutputTransformOutput dt) { return dt; }
      return new ExecuteTransactionOutputTransformOutput(_transformedOutput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ExecuteTransactionOutputTransformOutput;
      return oth != null && object.Equals(this._transformedOutput, oth._transformedOutput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._transformedOutput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.ExecuteTransactionOutputTransformOutput.ExecuteTransactionOutputTransformOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._transformedOutput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionOutputTransformOutput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.ExecuteTransactionOutput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionOutputTransformOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionOutputTransformOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionOutputTransformOutput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ExecuteTransactionOutputTransformOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionOutputTransformOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IExecuteTransactionOutputTransformOutput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteTransactionOutput transformedOutput) {
      return new ExecuteTransactionOutputTransformOutput(transformedOutput);
    }
    public static _IExecuteTransactionOutputTransformOutput create_ExecuteTransactionOutputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteTransactionOutput transformedOutput) {
      return create(transformedOutput);
    }
    public bool is_ExecuteTransactionOutputTransformOutput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IExecuteTransactionOutput dtor_transformedOutput {
      get {
        return this._transformedOutput;
      }
    }
  }

  public interface _IGetItemInputTransformInput {
    bool is_GetItemInputTransformInput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemInput dtor_sdkInput { get; }
    _IGetItemInputTransformInput DowncastClone();
  }
  public class GetItemInputTransformInput : _IGetItemInputTransformInput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemInput _sdkInput;
    public GetItemInputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemInput sdkInput) {
      this._sdkInput = sdkInput;
    }
    public _IGetItemInputTransformInput DowncastClone() {
      if (this is _IGetItemInputTransformInput dt) { return dt; }
      return new GetItemInputTransformInput(_sdkInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.GetItemInputTransformInput;
      return oth != null && object.Equals(this._sdkInput, oth._sdkInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sdkInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.GetItemInputTransformInput.GetItemInputTransformInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._sdkInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemInputTransformInput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.GetItemInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemInputTransformInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemInputTransformInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemInputTransformInput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.GetItemInputTransformInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemInputTransformInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IGetItemInputTransformInput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemInput sdkInput) {
      return new GetItemInputTransformInput(sdkInput);
    }
    public static _IGetItemInputTransformInput create_GetItemInputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemInput sdkInput) {
      return create(sdkInput);
    }
    public bool is_GetItemInputTransformInput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemInput dtor_sdkInput {
      get {
        return this._sdkInput;
      }
    }
  }

  public interface _IGetItemInputTransformOutput {
    bool is_GetItemInputTransformOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemInput dtor_transformedInput { get; }
    _IGetItemInputTransformOutput DowncastClone();
  }
  public class GetItemInputTransformOutput : _IGetItemInputTransformOutput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemInput _transformedInput;
    public GetItemInputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemInput transformedInput) {
      this._transformedInput = transformedInput;
    }
    public _IGetItemInputTransformOutput DowncastClone() {
      if (this is _IGetItemInputTransformOutput dt) { return dt; }
      return new GetItemInputTransformOutput(_transformedInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.GetItemInputTransformOutput;
      return oth != null && object.Equals(this._transformedInput, oth._transformedInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._transformedInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.GetItemInputTransformOutput.GetItemInputTransformOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._transformedInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemInputTransformOutput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.GetItemInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemInputTransformOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemInputTransformOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemInputTransformOutput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.GetItemInputTransformOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemInputTransformOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IGetItemInputTransformOutput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemInput transformedInput) {
      return new GetItemInputTransformOutput(transformedInput);
    }
    public static _IGetItemInputTransformOutput create_GetItemInputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemInput transformedInput) {
      return create(transformedInput);
    }
    public bool is_GetItemInputTransformOutput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemInput dtor_transformedInput {
      get {
        return this._transformedInput;
      }
    }
  }

  public interface _IGetItemOutputTransformInput {
    bool is_GetItemOutputTransformInput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput dtor_sdkOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemInput dtor_originalInput { get; }
    _IGetItemOutputTransformInput DowncastClone();
  }
  public class GetItemOutputTransformInput : _IGetItemOutputTransformInput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput _sdkOutput;
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemInput _originalInput;
    public GetItemOutputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemInput originalInput) {
      this._sdkOutput = sdkOutput;
      this._originalInput = originalInput;
    }
    public _IGetItemOutputTransformInput DowncastClone() {
      if (this is _IGetItemOutputTransformInput dt) { return dt; }
      return new GetItemOutputTransformInput(_sdkOutput, _originalInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.GetItemOutputTransformInput;
      return oth != null && object.Equals(this._sdkOutput, oth._sdkOutput) && object.Equals(this._originalInput, oth._originalInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sdkOutput));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._originalInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.GetItemOutputTransformInput.GetItemOutputTransformInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._sdkOutput);
      s += ", ";
      s += Dafny.Helpers.ToString(this._originalInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemOutputTransformInput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.GetItemOutput.Default(), software.amazon.cryptography.services.dynamodb.internaldafny.types.GetItemInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemOutputTransformInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemOutputTransformInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemOutputTransformInput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.GetItemOutputTransformInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemOutputTransformInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IGetItemOutputTransformInput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemInput originalInput) {
      return new GetItemOutputTransformInput(sdkOutput, originalInput);
    }
    public static _IGetItemOutputTransformInput create_GetItemOutputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemInput originalInput) {
      return create(sdkOutput, originalInput);
    }
    public bool is_GetItemOutputTransformInput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput dtor_sdkOutput {
      get {
        return this._sdkOutput;
      }
    }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemInput dtor_originalInput {
      get {
        return this._originalInput;
      }
    }
  }

  public interface _IGetItemOutputTransformOutput {
    bool is_GetItemOutputTransformOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput dtor_transformedOutput { get; }
    _IGetItemOutputTransformOutput DowncastClone();
  }
  public class GetItemOutputTransformOutput : _IGetItemOutputTransformOutput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput _transformedOutput;
    public GetItemOutputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput transformedOutput) {
      this._transformedOutput = transformedOutput;
    }
    public _IGetItemOutputTransformOutput DowncastClone() {
      if (this is _IGetItemOutputTransformOutput dt) { return dt; }
      return new GetItemOutputTransformOutput(_transformedOutput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.GetItemOutputTransformOutput;
      return oth != null && object.Equals(this._transformedOutput, oth._transformedOutput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._transformedOutput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.GetItemOutputTransformOutput.GetItemOutputTransformOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._transformedOutput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemOutputTransformOutput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.GetItemOutput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemOutputTransformOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemOutputTransformOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemOutputTransformOutput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.GetItemOutputTransformOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemOutputTransformOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IGetItemOutputTransformOutput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput transformedOutput) {
      return new GetItemOutputTransformOutput(transformedOutput);
    }
    public static _IGetItemOutputTransformOutput create_GetItemOutputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput transformedOutput) {
      return create(transformedOutput);
    }
    public bool is_GetItemOutputTransformOutput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput dtor_transformedOutput {
      get {
        return this._transformedOutput;
      }
    }
  }

  public interface _IPutItemInputTransformInput {
    bool is_PutItemInputTransformInput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemInput dtor_sdkInput { get; }
    _IPutItemInputTransformInput DowncastClone();
  }
  public class PutItemInputTransformInput : _IPutItemInputTransformInput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemInput _sdkInput;
    public PutItemInputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemInput sdkInput) {
      this._sdkInput = sdkInput;
    }
    public _IPutItemInputTransformInput DowncastClone() {
      if (this is _IPutItemInputTransformInput dt) { return dt; }
      return new PutItemInputTransformInput(_sdkInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.PutItemInputTransformInput;
      return oth != null && object.Equals(this._sdkInput, oth._sdkInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sdkInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.PutItemInputTransformInput.PutItemInputTransformInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._sdkInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformInput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.PutItemInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformInput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.PutItemInputTransformInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IPutItemInputTransformInput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemInput sdkInput) {
      return new PutItemInputTransformInput(sdkInput);
    }
    public static _IPutItemInputTransformInput create_PutItemInputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemInput sdkInput) {
      return create(sdkInput);
    }
    public bool is_PutItemInputTransformInput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemInput dtor_sdkInput {
      get {
        return this._sdkInput;
      }
    }
  }

  public interface _IPutItemInputTransformOutput {
    bool is_PutItemInputTransformOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemInput dtor_transformedInput { get; }
    _IPutItemInputTransformOutput DowncastClone();
  }
  public class PutItemInputTransformOutput : _IPutItemInputTransformOutput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemInput _transformedInput;
    public PutItemInputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemInput transformedInput) {
      this._transformedInput = transformedInput;
    }
    public _IPutItemInputTransformOutput DowncastClone() {
      if (this is _IPutItemInputTransformOutput dt) { return dt; }
      return new PutItemInputTransformOutput(_transformedInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.PutItemInputTransformOutput;
      return oth != null && object.Equals(this._transformedInput, oth._transformedInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._transformedInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.PutItemInputTransformOutput.PutItemInputTransformOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._transformedInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformOutput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.PutItemInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformOutput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.PutItemInputTransformOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IPutItemInputTransformOutput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemInput transformedInput) {
      return new PutItemInputTransformOutput(transformedInput);
    }
    public static _IPutItemInputTransformOutput create_PutItemInputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemInput transformedInput) {
      return create(transformedInput);
    }
    public bool is_PutItemInputTransformOutput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemInput dtor_transformedInput {
      get {
        return this._transformedInput;
      }
    }
  }

  public interface _IPutItemOutputTransformInput {
    bool is_PutItemOutputTransformInput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemOutput dtor_sdkOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemInput dtor_originalInput { get; }
    _IPutItemOutputTransformInput DowncastClone();
  }
  public class PutItemOutputTransformInput : _IPutItemOutputTransformInput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemOutput _sdkOutput;
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemInput _originalInput;
    public PutItemOutputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemInput originalInput) {
      this._sdkOutput = sdkOutput;
      this._originalInput = originalInput;
    }
    public _IPutItemOutputTransformInput DowncastClone() {
      if (this is _IPutItemOutputTransformInput dt) { return dt; }
      return new PutItemOutputTransformInput(_sdkOutput, _originalInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.PutItemOutputTransformInput;
      return oth != null && object.Equals(this._sdkOutput, oth._sdkOutput) && object.Equals(this._originalInput, oth._originalInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sdkOutput));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._originalInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.PutItemOutputTransformInput.PutItemOutputTransformInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._sdkOutput);
      s += ", ";
      s += Dafny.Helpers.ToString(this._originalInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemOutputTransformInput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.PutItemOutput.Default(), software.amazon.cryptography.services.dynamodb.internaldafny.types.PutItemInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemOutputTransformInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemOutputTransformInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemOutputTransformInput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.PutItemOutputTransformInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemOutputTransformInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IPutItemOutputTransformInput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemInput originalInput) {
      return new PutItemOutputTransformInput(sdkOutput, originalInput);
    }
    public static _IPutItemOutputTransformInput create_PutItemOutputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemInput originalInput) {
      return create(sdkOutput, originalInput);
    }
    public bool is_PutItemOutputTransformInput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemOutput dtor_sdkOutput {
      get {
        return this._sdkOutput;
      }
    }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemInput dtor_originalInput {
      get {
        return this._originalInput;
      }
    }
  }

  public interface _IPutItemOutputTransformOutput {
    bool is_PutItemOutputTransformOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemOutput dtor_transformedOutput { get; }
    _IPutItemOutputTransformOutput DowncastClone();
  }
  public class PutItemOutputTransformOutput : _IPutItemOutputTransformOutput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemOutput _transformedOutput;
    public PutItemOutputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemOutput transformedOutput) {
      this._transformedOutput = transformedOutput;
    }
    public _IPutItemOutputTransformOutput DowncastClone() {
      if (this is _IPutItemOutputTransformOutput dt) { return dt; }
      return new PutItemOutputTransformOutput(_transformedOutput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.PutItemOutputTransformOutput;
      return oth != null && object.Equals(this._transformedOutput, oth._transformedOutput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._transformedOutput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.PutItemOutputTransformOutput.PutItemOutputTransformOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._transformedOutput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemOutputTransformOutput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.PutItemOutput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemOutputTransformOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemOutputTransformOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemOutputTransformOutput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.PutItemOutputTransformOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemOutputTransformOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IPutItemOutputTransformOutput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemOutput transformedOutput) {
      return new PutItemOutputTransformOutput(transformedOutput);
    }
    public static _IPutItemOutputTransformOutput create_PutItemOutputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemOutput transformedOutput) {
      return create(transformedOutput);
    }
    public bool is_PutItemOutputTransformOutput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemOutput dtor_transformedOutput {
      get {
        return this._transformedOutput;
      }
    }
  }

  public interface _IQueryInputTransformInput {
    bool is_QueryInputTransformInput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput dtor_sdkInput { get; }
    _IQueryInputTransformInput DowncastClone();
  }
  public class QueryInputTransformInput : _IQueryInputTransformInput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput _sdkInput;
    public QueryInputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput sdkInput) {
      this._sdkInput = sdkInput;
    }
    public _IQueryInputTransformInput DowncastClone() {
      if (this is _IQueryInputTransformInput dt) { return dt; }
      return new QueryInputTransformInput(_sdkInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.QueryInputTransformInput;
      return oth != null && object.Equals(this._sdkInput, oth._sdkInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sdkInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.QueryInputTransformInput.QueryInputTransformInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._sdkInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryInputTransformInput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.QueryInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryInputTransformInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryInputTransformInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryInputTransformInput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.QueryInputTransformInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryInputTransformInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IQueryInputTransformInput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput sdkInput) {
      return new QueryInputTransformInput(sdkInput);
    }
    public static _IQueryInputTransformInput create_QueryInputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput sdkInput) {
      return create(sdkInput);
    }
    public bool is_QueryInputTransformInput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput dtor_sdkInput {
      get {
        return this._sdkInput;
      }
    }
  }

  public interface _IQueryInputTransformOutput {
    bool is_QueryInputTransformOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput dtor_transformedInput { get; }
    _IQueryInputTransformOutput DowncastClone();
  }
  public class QueryInputTransformOutput : _IQueryInputTransformOutput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput _transformedInput;
    public QueryInputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput transformedInput) {
      this._transformedInput = transformedInput;
    }
    public _IQueryInputTransformOutput DowncastClone() {
      if (this is _IQueryInputTransformOutput dt) { return dt; }
      return new QueryInputTransformOutput(_transformedInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.QueryInputTransformOutput;
      return oth != null && object.Equals(this._transformedInput, oth._transformedInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._transformedInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.QueryInputTransformOutput.QueryInputTransformOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._transformedInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryInputTransformOutput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.QueryInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryInputTransformOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryInputTransformOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryInputTransformOutput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.QueryInputTransformOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryInputTransformOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IQueryInputTransformOutput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput transformedInput) {
      return new QueryInputTransformOutput(transformedInput);
    }
    public static _IQueryInputTransformOutput create_QueryInputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput transformedInput) {
      return create(transformedInput);
    }
    public bool is_QueryInputTransformOutput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput dtor_transformedInput {
      get {
        return this._transformedInput;
      }
    }
  }

  public interface _IQueryOutputTransformInput {
    bool is_QueryOutputTransformInput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput dtor_sdkOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput dtor_originalInput { get; }
    _IQueryOutputTransformInput DowncastClone();
  }
  public class QueryOutputTransformInput : _IQueryOutputTransformInput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput _sdkOutput;
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput _originalInput;
    public QueryOutputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput originalInput) {
      this._sdkOutput = sdkOutput;
      this._originalInput = originalInput;
    }
    public _IQueryOutputTransformInput DowncastClone() {
      if (this is _IQueryOutputTransformInput dt) { return dt; }
      return new QueryOutputTransformInput(_sdkOutput, _originalInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.QueryOutputTransformInput;
      return oth != null && object.Equals(this._sdkOutput, oth._sdkOutput) && object.Equals(this._originalInput, oth._originalInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sdkOutput));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._originalInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.QueryOutputTransformInput.QueryOutputTransformInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._sdkOutput);
      s += ", ";
      s += Dafny.Helpers.ToString(this._originalInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryOutputTransformInput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.QueryOutput.Default(), software.amazon.cryptography.services.dynamodb.internaldafny.types.QueryInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryOutputTransformInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryOutputTransformInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryOutputTransformInput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.QueryOutputTransformInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryOutputTransformInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IQueryOutputTransformInput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput originalInput) {
      return new QueryOutputTransformInput(sdkOutput, originalInput);
    }
    public static _IQueryOutputTransformInput create_QueryOutputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput originalInput) {
      return create(sdkOutput, originalInput);
    }
    public bool is_QueryOutputTransformInput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput dtor_sdkOutput {
      get {
        return this._sdkOutput;
      }
    }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput dtor_originalInput {
      get {
        return this._originalInput;
      }
    }
  }

  public interface _IQueryOutputTransformOutput {
    bool is_QueryOutputTransformOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput dtor_transformedOutput { get; }
    _IQueryOutputTransformOutput DowncastClone();
  }
  public class QueryOutputTransformOutput : _IQueryOutputTransformOutput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput _transformedOutput;
    public QueryOutputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput transformedOutput) {
      this._transformedOutput = transformedOutput;
    }
    public _IQueryOutputTransformOutput DowncastClone() {
      if (this is _IQueryOutputTransformOutput dt) { return dt; }
      return new QueryOutputTransformOutput(_transformedOutput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.QueryOutputTransformOutput;
      return oth != null && object.Equals(this._transformedOutput, oth._transformedOutput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._transformedOutput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.QueryOutputTransformOutput.QueryOutputTransformOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._transformedOutput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryOutputTransformOutput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.QueryOutput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryOutputTransformOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryOutputTransformOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryOutputTransformOutput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.QueryOutputTransformOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryOutputTransformOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IQueryOutputTransformOutput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput transformedOutput) {
      return new QueryOutputTransformOutput(transformedOutput);
    }
    public static _IQueryOutputTransformOutput create_QueryOutputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput transformedOutput) {
      return create(transformedOutput);
    }
    public bool is_QueryOutputTransformOutput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput dtor_transformedOutput {
      get {
        return this._transformedOutput;
      }
    }
  }

  public interface _IResolveAttributesInput {
    bool is_ResolveAttributesInput { get; }
    Dafny.ISequence<char> dtor_TableName { get; }
    Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> dtor_Item { get; }
    Wrappers_Compile._IOption<int> dtor_Version { get; }
    _IResolveAttributesInput DowncastClone();
  }
  public class ResolveAttributesInput : _IResolveAttributesInput {
    public readonly Dafny.ISequence<char> _TableName;
    public readonly Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _Item;
    public readonly Wrappers_Compile._IOption<int> _Version;
    public ResolveAttributesInput(Dafny.ISequence<char> TableName, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> Item, Wrappers_Compile._IOption<int> Version) {
      this._TableName = TableName;
      this._Item = Item;
      this._Version = Version;
    }
    public _IResolveAttributesInput DowncastClone() {
      if (this is _IResolveAttributesInput dt) { return dt; }
      return new ResolveAttributesInput(_TableName, _Item, _Version);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ResolveAttributesInput;
      return oth != null && object.Equals(this._TableName, oth._TableName) && object.Equals(this._Item, oth._Item) && object.Equals(this._Version, oth._Version);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._TableName));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._Item));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._Version));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.ResolveAttributesInput.ResolveAttributesInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._TableName);
      s += ", ";
      s += Dafny.Helpers.ToString(this._Item);
      s += ", ";
      s += Dafny.Helpers.ToString(this._Version);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IResolveAttributesInput theDefault = create(Dafny.Sequence<char>.Empty, Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty, Wrappers_Compile.Option<int>.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IResolveAttributesInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IResolveAttributesInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IResolveAttributesInput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ResolveAttributesInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IResolveAttributesInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IResolveAttributesInput create(Dafny.ISequence<char> TableName, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> Item, Wrappers_Compile._IOption<int> Version) {
      return new ResolveAttributesInput(TableName, Item, Version);
    }
    public static _IResolveAttributesInput create_ResolveAttributesInput(Dafny.ISequence<char> TableName, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> Item, Wrappers_Compile._IOption<int> Version) {
      return create(TableName, Item, Version);
    }
    public bool is_ResolveAttributesInput { get { return true; } }
    public Dafny.ISequence<char> dtor_TableName {
      get {
        return this._TableName;
      }
    }
    public Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> dtor_Item {
      get {
        return this._Item;
      }
    }
    public Wrappers_Compile._IOption<int> dtor_Version {
      get {
        return this._Version;
      }
    }
  }

  public interface _IResolveAttributesOutput {
    bool is_ResolveAttributesOutput { get; }
    Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> dtor_VirtualFields { get; }
    Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> dtor_CompoundBeacons { get; }
    _IResolveAttributesOutput DowncastClone();
  }
  public class ResolveAttributesOutput : _IResolveAttributesOutput {
    public readonly Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> _VirtualFields;
    public readonly Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> _CompoundBeacons;
    public ResolveAttributesOutput(Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> VirtualFields, Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> CompoundBeacons) {
      this._VirtualFields = VirtualFields;
      this._CompoundBeacons = CompoundBeacons;
    }
    public _IResolveAttributesOutput DowncastClone() {
      if (this is _IResolveAttributesOutput dt) { return dt; }
      return new ResolveAttributesOutput(_VirtualFields, _CompoundBeacons);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ResolveAttributesOutput;
      return oth != null && object.Equals(this._VirtualFields, oth._VirtualFields) && object.Equals(this._CompoundBeacons, oth._CompoundBeacons);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._VirtualFields));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._CompoundBeacons));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.ResolveAttributesOutput.ResolveAttributesOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._VirtualFields);
      s += ", ";
      s += Dafny.Helpers.ToString(this._CompoundBeacons);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IResolveAttributesOutput theDefault = create(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Empty, Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Empty);
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IResolveAttributesOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IResolveAttributesOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IResolveAttributesOutput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ResolveAttributesOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IResolveAttributesOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IResolveAttributesOutput create(Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> VirtualFields, Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> CompoundBeacons) {
      return new ResolveAttributesOutput(VirtualFields, CompoundBeacons);
    }
    public static _IResolveAttributesOutput create_ResolveAttributesOutput(Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> VirtualFields, Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> CompoundBeacons) {
      return create(VirtualFields, CompoundBeacons);
    }
    public bool is_ResolveAttributesOutput { get { return true; } }
    public Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> dtor_VirtualFields {
      get {
        return this._VirtualFields;
      }
    }
    public Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> dtor_CompoundBeacons {
      get {
        return this._CompoundBeacons;
      }
    }
  }

  public interface _IScanInputTransformInput {
    bool is_ScanInputTransformInput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput dtor_sdkInput { get; }
    _IScanInputTransformInput DowncastClone();
  }
  public class ScanInputTransformInput : _IScanInputTransformInput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput _sdkInput;
    public ScanInputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput sdkInput) {
      this._sdkInput = sdkInput;
    }
    public _IScanInputTransformInput DowncastClone() {
      if (this is _IScanInputTransformInput dt) { return dt; }
      return new ScanInputTransformInput(_sdkInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ScanInputTransformInput;
      return oth != null && object.Equals(this._sdkInput, oth._sdkInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sdkInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.ScanInputTransformInput.ScanInputTransformInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._sdkInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanInputTransformInput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.ScanInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanInputTransformInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanInputTransformInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanInputTransformInput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ScanInputTransformInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanInputTransformInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IScanInputTransformInput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput sdkInput) {
      return new ScanInputTransformInput(sdkInput);
    }
    public static _IScanInputTransformInput create_ScanInputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput sdkInput) {
      return create(sdkInput);
    }
    public bool is_ScanInputTransformInput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput dtor_sdkInput {
      get {
        return this._sdkInput;
      }
    }
  }

  public interface _IScanInputTransformOutput {
    bool is_ScanInputTransformOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput dtor_transformedInput { get; }
    _IScanInputTransformOutput DowncastClone();
  }
  public class ScanInputTransformOutput : _IScanInputTransformOutput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput _transformedInput;
    public ScanInputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput transformedInput) {
      this._transformedInput = transformedInput;
    }
    public _IScanInputTransformOutput DowncastClone() {
      if (this is _IScanInputTransformOutput dt) { return dt; }
      return new ScanInputTransformOutput(_transformedInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ScanInputTransformOutput;
      return oth != null && object.Equals(this._transformedInput, oth._transformedInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._transformedInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.ScanInputTransformOutput.ScanInputTransformOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._transformedInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanInputTransformOutput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.ScanInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanInputTransformOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanInputTransformOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanInputTransformOutput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ScanInputTransformOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanInputTransformOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IScanInputTransformOutput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput transformedInput) {
      return new ScanInputTransformOutput(transformedInput);
    }
    public static _IScanInputTransformOutput create_ScanInputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput transformedInput) {
      return create(transformedInput);
    }
    public bool is_ScanInputTransformOutput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput dtor_transformedInput {
      get {
        return this._transformedInput;
      }
    }
  }

  public interface _IScanOutputTransformInput {
    bool is_ScanOutputTransformInput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput dtor_sdkOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput dtor_originalInput { get; }
    _IScanOutputTransformInput DowncastClone();
  }
  public class ScanOutputTransformInput : _IScanOutputTransformInput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput _sdkOutput;
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput _originalInput;
    public ScanOutputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput originalInput) {
      this._sdkOutput = sdkOutput;
      this._originalInput = originalInput;
    }
    public _IScanOutputTransformInput DowncastClone() {
      if (this is _IScanOutputTransformInput dt) { return dt; }
      return new ScanOutputTransformInput(_sdkOutput, _originalInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ScanOutputTransformInput;
      return oth != null && object.Equals(this._sdkOutput, oth._sdkOutput) && object.Equals(this._originalInput, oth._originalInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sdkOutput));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._originalInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.ScanOutputTransformInput.ScanOutputTransformInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._sdkOutput);
      s += ", ";
      s += Dafny.Helpers.ToString(this._originalInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanOutputTransformInput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.ScanOutput.Default(), software.amazon.cryptography.services.dynamodb.internaldafny.types.ScanInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanOutputTransformInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanOutputTransformInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanOutputTransformInput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ScanOutputTransformInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanOutputTransformInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IScanOutputTransformInput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput originalInput) {
      return new ScanOutputTransformInput(sdkOutput, originalInput);
    }
    public static _IScanOutputTransformInput create_ScanOutputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput originalInput) {
      return create(sdkOutput, originalInput);
    }
    public bool is_ScanOutputTransformInput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput dtor_sdkOutput {
      get {
        return this._sdkOutput;
      }
    }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput dtor_originalInput {
      get {
        return this._originalInput;
      }
    }
  }

  public interface _IScanOutputTransformOutput {
    bool is_ScanOutputTransformOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput dtor_transformedOutput { get; }
    _IScanOutputTransformOutput DowncastClone();
  }
  public class ScanOutputTransformOutput : _IScanOutputTransformOutput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput _transformedOutput;
    public ScanOutputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput transformedOutput) {
      this._transformedOutput = transformedOutput;
    }
    public _IScanOutputTransformOutput DowncastClone() {
      if (this is _IScanOutputTransformOutput dt) { return dt; }
      return new ScanOutputTransformOutput(_transformedOutput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ScanOutputTransformOutput;
      return oth != null && object.Equals(this._transformedOutput, oth._transformedOutput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._transformedOutput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.ScanOutputTransformOutput.ScanOutputTransformOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._transformedOutput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanOutputTransformOutput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.ScanOutput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanOutputTransformOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanOutputTransformOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanOutputTransformOutput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ScanOutputTransformOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanOutputTransformOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IScanOutputTransformOutput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput transformedOutput) {
      return new ScanOutputTransformOutput(transformedOutput);
    }
    public static _IScanOutputTransformOutput create_ScanOutputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput transformedOutput) {
      return create(transformedOutput);
    }
    public bool is_ScanOutputTransformOutput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput dtor_transformedOutput {
      get {
        return this._transformedOutput;
      }
    }
  }

  public interface _ITransactGetItemsInputTransformInput {
    bool is_TransactGetItemsInputTransformInput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsInput dtor_sdkInput { get; }
    _ITransactGetItemsInputTransformInput DowncastClone();
  }
  public class TransactGetItemsInputTransformInput : _ITransactGetItemsInputTransformInput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsInput _sdkInput;
    public TransactGetItemsInputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsInput sdkInput) {
      this._sdkInput = sdkInput;
    }
    public _ITransactGetItemsInputTransformInput DowncastClone() {
      if (this is _ITransactGetItemsInputTransformInput dt) { return dt; }
      return new TransactGetItemsInputTransformInput(_sdkInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.TransactGetItemsInputTransformInput;
      return oth != null && object.Equals(this._sdkInput, oth._sdkInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sdkInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.TransactGetItemsInputTransformInput.TransactGetItemsInputTransformInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._sdkInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsInputTransformInput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.TransactGetItemsInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsInputTransformInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsInputTransformInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsInputTransformInput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.TransactGetItemsInputTransformInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsInputTransformInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ITransactGetItemsInputTransformInput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsInput sdkInput) {
      return new TransactGetItemsInputTransformInput(sdkInput);
    }
    public static _ITransactGetItemsInputTransformInput create_TransactGetItemsInputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsInput sdkInput) {
      return create(sdkInput);
    }
    public bool is_TransactGetItemsInputTransformInput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsInput dtor_sdkInput {
      get {
        return this._sdkInput;
      }
    }
  }

  public interface _ITransactGetItemsInputTransformOutput {
    bool is_TransactGetItemsInputTransformOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsInput dtor_transformedInput { get; }
    _ITransactGetItemsInputTransformOutput DowncastClone();
  }
  public class TransactGetItemsInputTransformOutput : _ITransactGetItemsInputTransformOutput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsInput _transformedInput;
    public TransactGetItemsInputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsInput transformedInput) {
      this._transformedInput = transformedInput;
    }
    public _ITransactGetItemsInputTransformOutput DowncastClone() {
      if (this is _ITransactGetItemsInputTransformOutput dt) { return dt; }
      return new TransactGetItemsInputTransformOutput(_transformedInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.TransactGetItemsInputTransformOutput;
      return oth != null && object.Equals(this._transformedInput, oth._transformedInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._transformedInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.TransactGetItemsInputTransformOutput.TransactGetItemsInputTransformOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._transformedInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsInputTransformOutput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.TransactGetItemsInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsInputTransformOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsInputTransformOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsInputTransformOutput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.TransactGetItemsInputTransformOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsInputTransformOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ITransactGetItemsInputTransformOutput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsInput transformedInput) {
      return new TransactGetItemsInputTransformOutput(transformedInput);
    }
    public static _ITransactGetItemsInputTransformOutput create_TransactGetItemsInputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsInput transformedInput) {
      return create(transformedInput);
    }
    public bool is_TransactGetItemsInputTransformOutput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsInput dtor_transformedInput {
      get {
        return this._transformedInput;
      }
    }
  }

  public interface _ITransactGetItemsOutputTransformInput {
    bool is_TransactGetItemsOutputTransformInput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsOutput dtor_sdkOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsInput dtor_originalInput { get; }
    _ITransactGetItemsOutputTransformInput DowncastClone();
  }
  public class TransactGetItemsOutputTransformInput : _ITransactGetItemsOutputTransformInput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsOutput _sdkOutput;
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsInput _originalInput;
    public TransactGetItemsOutputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsInput originalInput) {
      this._sdkOutput = sdkOutput;
      this._originalInput = originalInput;
    }
    public _ITransactGetItemsOutputTransformInput DowncastClone() {
      if (this is _ITransactGetItemsOutputTransformInput dt) { return dt; }
      return new TransactGetItemsOutputTransformInput(_sdkOutput, _originalInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.TransactGetItemsOutputTransformInput;
      return oth != null && object.Equals(this._sdkOutput, oth._sdkOutput) && object.Equals(this._originalInput, oth._originalInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sdkOutput));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._originalInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.TransactGetItemsOutputTransformInput.TransactGetItemsOutputTransformInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._sdkOutput);
      s += ", ";
      s += Dafny.Helpers.ToString(this._originalInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsOutputTransformInput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.TransactGetItemsOutput.Default(), software.amazon.cryptography.services.dynamodb.internaldafny.types.TransactGetItemsInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsOutputTransformInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsOutputTransformInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsOutputTransformInput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.TransactGetItemsOutputTransformInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsOutputTransformInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ITransactGetItemsOutputTransformInput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsInput originalInput) {
      return new TransactGetItemsOutputTransformInput(sdkOutput, originalInput);
    }
    public static _ITransactGetItemsOutputTransformInput create_TransactGetItemsOutputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsInput originalInput) {
      return create(sdkOutput, originalInput);
    }
    public bool is_TransactGetItemsOutputTransformInput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsOutput dtor_sdkOutput {
      get {
        return this._sdkOutput;
      }
    }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsInput dtor_originalInput {
      get {
        return this._originalInput;
      }
    }
  }

  public interface _ITransactGetItemsOutputTransformOutput {
    bool is_TransactGetItemsOutputTransformOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsOutput dtor_transformedOutput { get; }
    _ITransactGetItemsOutputTransformOutput DowncastClone();
  }
  public class TransactGetItemsOutputTransformOutput : _ITransactGetItemsOutputTransformOutput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsOutput _transformedOutput;
    public TransactGetItemsOutputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsOutput transformedOutput) {
      this._transformedOutput = transformedOutput;
    }
    public _ITransactGetItemsOutputTransformOutput DowncastClone() {
      if (this is _ITransactGetItemsOutputTransformOutput dt) { return dt; }
      return new TransactGetItemsOutputTransformOutput(_transformedOutput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.TransactGetItemsOutputTransformOutput;
      return oth != null && object.Equals(this._transformedOutput, oth._transformedOutput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._transformedOutput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.TransactGetItemsOutputTransformOutput.TransactGetItemsOutputTransformOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._transformedOutput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsOutputTransformOutput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.TransactGetItemsOutput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsOutputTransformOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsOutputTransformOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsOutputTransformOutput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.TransactGetItemsOutputTransformOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsOutputTransformOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ITransactGetItemsOutputTransformOutput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsOutput transformedOutput) {
      return new TransactGetItemsOutputTransformOutput(transformedOutput);
    }
    public static _ITransactGetItemsOutputTransformOutput create_TransactGetItemsOutputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsOutput transformedOutput) {
      return create(transformedOutput);
    }
    public bool is_TransactGetItemsOutputTransformOutput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsOutput dtor_transformedOutput {
      get {
        return this._transformedOutput;
      }
    }
  }

  public interface _ITransactWriteItemsInputTransformInput {
    bool is_TransactWriteItemsInputTransformInput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsInput dtor_sdkInput { get; }
    _ITransactWriteItemsInputTransformInput DowncastClone();
  }
  public class TransactWriteItemsInputTransformInput : _ITransactWriteItemsInputTransformInput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsInput _sdkInput;
    public TransactWriteItemsInputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsInput sdkInput) {
      this._sdkInput = sdkInput;
    }
    public _ITransactWriteItemsInputTransformInput DowncastClone() {
      if (this is _ITransactWriteItemsInputTransformInput dt) { return dt; }
      return new TransactWriteItemsInputTransformInput(_sdkInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.TransactWriteItemsInputTransformInput;
      return oth != null && object.Equals(this._sdkInput, oth._sdkInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sdkInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.TransactWriteItemsInputTransformInput.TransactWriteItemsInputTransformInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._sdkInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformInput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.TransactWriteItemsInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformInput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.TransactWriteItemsInputTransformInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ITransactWriteItemsInputTransformInput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsInput sdkInput) {
      return new TransactWriteItemsInputTransformInput(sdkInput);
    }
    public static _ITransactWriteItemsInputTransformInput create_TransactWriteItemsInputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsInput sdkInput) {
      return create(sdkInput);
    }
    public bool is_TransactWriteItemsInputTransformInput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsInput dtor_sdkInput {
      get {
        return this._sdkInput;
      }
    }
  }

  public interface _ITransactWriteItemsInputTransformOutput {
    bool is_TransactWriteItemsInputTransformOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsInput dtor_transformedInput { get; }
    _ITransactWriteItemsInputTransformOutput DowncastClone();
  }
  public class TransactWriteItemsInputTransformOutput : _ITransactWriteItemsInputTransformOutput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsInput _transformedInput;
    public TransactWriteItemsInputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsInput transformedInput) {
      this._transformedInput = transformedInput;
    }
    public _ITransactWriteItemsInputTransformOutput DowncastClone() {
      if (this is _ITransactWriteItemsInputTransformOutput dt) { return dt; }
      return new TransactWriteItemsInputTransformOutput(_transformedInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.TransactWriteItemsInputTransformOutput;
      return oth != null && object.Equals(this._transformedInput, oth._transformedInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._transformedInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.TransactWriteItemsInputTransformOutput.TransactWriteItemsInputTransformOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._transformedInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformOutput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.TransactWriteItemsInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformOutput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.TransactWriteItemsInputTransformOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ITransactWriteItemsInputTransformOutput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsInput transformedInput) {
      return new TransactWriteItemsInputTransformOutput(transformedInput);
    }
    public static _ITransactWriteItemsInputTransformOutput create_TransactWriteItemsInputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsInput transformedInput) {
      return create(transformedInput);
    }
    public bool is_TransactWriteItemsInputTransformOutput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsInput dtor_transformedInput {
      get {
        return this._transformedInput;
      }
    }
  }

  public interface _ITransactWriteItemsOutputTransformInput {
    bool is_TransactWriteItemsOutputTransformInput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput dtor_sdkOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsInput dtor_originalInput { get; }
    _ITransactWriteItemsOutputTransformInput DowncastClone();
  }
  public class TransactWriteItemsOutputTransformInput : _ITransactWriteItemsOutputTransformInput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput _sdkOutput;
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsInput _originalInput;
    public TransactWriteItemsOutputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsInput originalInput) {
      this._sdkOutput = sdkOutput;
      this._originalInput = originalInput;
    }
    public _ITransactWriteItemsOutputTransformInput DowncastClone() {
      if (this is _ITransactWriteItemsOutputTransformInput dt) { return dt; }
      return new TransactWriteItemsOutputTransformInput(_sdkOutput, _originalInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.TransactWriteItemsOutputTransformInput;
      return oth != null && object.Equals(this._sdkOutput, oth._sdkOutput) && object.Equals(this._originalInput, oth._originalInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sdkOutput));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._originalInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.TransactWriteItemsOutputTransformInput.TransactWriteItemsOutputTransformInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._sdkOutput);
      s += ", ";
      s += Dafny.Helpers.ToString(this._originalInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsOutputTransformInput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.TransactWriteItemsOutput.Default(), software.amazon.cryptography.services.dynamodb.internaldafny.types.TransactWriteItemsInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsOutputTransformInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsOutputTransformInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsOutputTransformInput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.TransactWriteItemsOutputTransformInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsOutputTransformInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ITransactWriteItemsOutputTransformInput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsInput originalInput) {
      return new TransactWriteItemsOutputTransformInput(sdkOutput, originalInput);
    }
    public static _ITransactWriteItemsOutputTransformInput create_TransactWriteItemsOutputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsInput originalInput) {
      return create(sdkOutput, originalInput);
    }
    public bool is_TransactWriteItemsOutputTransformInput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput dtor_sdkOutput {
      get {
        return this._sdkOutput;
      }
    }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsInput dtor_originalInput {
      get {
        return this._originalInput;
      }
    }
  }

  public interface _ITransactWriteItemsOutputTransformOutput {
    bool is_TransactWriteItemsOutputTransformOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput dtor_transformedOutput { get; }
    _ITransactWriteItemsOutputTransformOutput DowncastClone();
  }
  public class TransactWriteItemsOutputTransformOutput : _ITransactWriteItemsOutputTransformOutput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput _transformedOutput;
    public TransactWriteItemsOutputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput transformedOutput) {
      this._transformedOutput = transformedOutput;
    }
    public _ITransactWriteItemsOutputTransformOutput DowncastClone() {
      if (this is _ITransactWriteItemsOutputTransformOutput dt) { return dt; }
      return new TransactWriteItemsOutputTransformOutput(_transformedOutput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.TransactWriteItemsOutputTransformOutput;
      return oth != null && object.Equals(this._transformedOutput, oth._transformedOutput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._transformedOutput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.TransactWriteItemsOutputTransformOutput.TransactWriteItemsOutputTransformOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._transformedOutput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsOutputTransformOutput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.TransactWriteItemsOutput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsOutputTransformOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsOutputTransformOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsOutputTransformOutput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.TransactWriteItemsOutputTransformOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsOutputTransformOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ITransactWriteItemsOutputTransformOutput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput transformedOutput) {
      return new TransactWriteItemsOutputTransformOutput(transformedOutput);
    }
    public static _ITransactWriteItemsOutputTransformOutput create_TransactWriteItemsOutputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput transformedOutput) {
      return create(transformedOutput);
    }
    public bool is_TransactWriteItemsOutputTransformOutput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput dtor_transformedOutput {
      get {
        return this._transformedOutput;
      }
    }
  }

  public interface _IUpdateItemInputTransformInput {
    bool is_UpdateItemInputTransformInput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemInput dtor_sdkInput { get; }
    _IUpdateItemInputTransformInput DowncastClone();
  }
  public class UpdateItemInputTransformInput : _IUpdateItemInputTransformInput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemInput _sdkInput;
    public UpdateItemInputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemInput sdkInput) {
      this._sdkInput = sdkInput;
    }
    public _IUpdateItemInputTransformInput DowncastClone() {
      if (this is _IUpdateItemInputTransformInput dt) { return dt; }
      return new UpdateItemInputTransformInput(_sdkInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.UpdateItemInputTransformInput;
      return oth != null && object.Equals(this._sdkInput, oth._sdkInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sdkInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.UpdateItemInputTransformInput.UpdateItemInputTransformInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._sdkInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemInputTransformInput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.UpdateItemInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemInputTransformInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemInputTransformInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemInputTransformInput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.UpdateItemInputTransformInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemInputTransformInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IUpdateItemInputTransformInput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemInput sdkInput) {
      return new UpdateItemInputTransformInput(sdkInput);
    }
    public static _IUpdateItemInputTransformInput create_UpdateItemInputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemInput sdkInput) {
      return create(sdkInput);
    }
    public bool is_UpdateItemInputTransformInput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemInput dtor_sdkInput {
      get {
        return this._sdkInput;
      }
    }
  }

  public interface _IUpdateItemInputTransformOutput {
    bool is_UpdateItemInputTransformOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemInput dtor_transformedInput { get; }
    _IUpdateItemInputTransformOutput DowncastClone();
  }
  public class UpdateItemInputTransformOutput : _IUpdateItemInputTransformOutput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemInput _transformedInput;
    public UpdateItemInputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemInput transformedInput) {
      this._transformedInput = transformedInput;
    }
    public _IUpdateItemInputTransformOutput DowncastClone() {
      if (this is _IUpdateItemInputTransformOutput dt) { return dt; }
      return new UpdateItemInputTransformOutput(_transformedInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.UpdateItemInputTransformOutput;
      return oth != null && object.Equals(this._transformedInput, oth._transformedInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._transformedInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.UpdateItemInputTransformOutput.UpdateItemInputTransformOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._transformedInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemInputTransformOutput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.UpdateItemInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemInputTransformOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemInputTransformOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemInputTransformOutput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.UpdateItemInputTransformOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemInputTransformOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IUpdateItemInputTransformOutput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemInput transformedInput) {
      return new UpdateItemInputTransformOutput(transformedInput);
    }
    public static _IUpdateItemInputTransformOutput create_UpdateItemInputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemInput transformedInput) {
      return create(transformedInput);
    }
    public bool is_UpdateItemInputTransformOutput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemInput dtor_transformedInput {
      get {
        return this._transformedInput;
      }
    }
  }

  public interface _IUpdateItemOutputTransformInput {
    bool is_UpdateItemOutputTransformInput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemOutput dtor_sdkOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemInput dtor_originalInput { get; }
    _IUpdateItemOutputTransformInput DowncastClone();
  }
  public class UpdateItemOutputTransformInput : _IUpdateItemOutputTransformInput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemOutput _sdkOutput;
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemInput _originalInput;
    public UpdateItemOutputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemInput originalInput) {
      this._sdkOutput = sdkOutput;
      this._originalInput = originalInput;
    }
    public _IUpdateItemOutputTransformInput DowncastClone() {
      if (this is _IUpdateItemOutputTransformInput dt) { return dt; }
      return new UpdateItemOutputTransformInput(_sdkOutput, _originalInput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.UpdateItemOutputTransformInput;
      return oth != null && object.Equals(this._sdkOutput, oth._sdkOutput) && object.Equals(this._originalInput, oth._originalInput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sdkOutput));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._originalInput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.UpdateItemOutputTransformInput.UpdateItemOutputTransformInput";
      s += "(";
      s += Dafny.Helpers.ToString(this._sdkOutput);
      s += ", ";
      s += Dafny.Helpers.ToString(this._originalInput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemOutputTransformInput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.UpdateItemOutput.Default(), software.amazon.cryptography.services.dynamodb.internaldafny.types.UpdateItemInput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemOutputTransformInput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemOutputTransformInput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemOutputTransformInput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.UpdateItemOutputTransformInput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemOutputTransformInput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IUpdateItemOutputTransformInput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemInput originalInput) {
      return new UpdateItemOutputTransformInput(sdkOutput, originalInput);
    }
    public static _IUpdateItemOutputTransformInput create_UpdateItemOutputTransformInput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemOutput sdkOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemInput originalInput) {
      return create(sdkOutput, originalInput);
    }
    public bool is_UpdateItemOutputTransformInput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemOutput dtor_sdkOutput {
      get {
        return this._sdkOutput;
      }
    }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemInput dtor_originalInput {
      get {
        return this._originalInput;
      }
    }
  }

  public interface _IUpdateItemOutputTransformOutput {
    bool is_UpdateItemOutputTransformOutput { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemOutput dtor_transformedOutput { get; }
    _IUpdateItemOutputTransformOutput DowncastClone();
  }
  public class UpdateItemOutputTransformOutput : _IUpdateItemOutputTransformOutput {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemOutput _transformedOutput;
    public UpdateItemOutputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemOutput transformedOutput) {
      this._transformedOutput = transformedOutput;
    }
    public _IUpdateItemOutputTransformOutput DowncastClone() {
      if (this is _IUpdateItemOutputTransformOutput dt) { return dt; }
      return new UpdateItemOutputTransformOutput(_transformedOutput);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.UpdateItemOutputTransformOutput;
      return oth != null && object.Equals(this._transformedOutput, oth._transformedOutput);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._transformedOutput));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.UpdateItemOutputTransformOutput.UpdateItemOutputTransformOutput";
      s += "(";
      s += Dafny.Helpers.ToString(this._transformedOutput);
      s += ")";
      return s;
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemOutputTransformOutput theDefault = create(software.amazon.cryptography.services.dynamodb.internaldafny.types.UpdateItemOutput.Default());
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemOutputTransformOutput Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemOutputTransformOutput> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemOutputTransformOutput>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.UpdateItemOutputTransformOutput.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemOutputTransformOutput> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IUpdateItemOutputTransformOutput create(software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemOutput transformedOutput) {
      return new UpdateItemOutputTransformOutput(transformedOutput);
    }
    public static _IUpdateItemOutputTransformOutput create_UpdateItemOutputTransformOutput(software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemOutput transformedOutput) {
      return create(transformedOutput);
    }
    public bool is_UpdateItemOutputTransformOutput { get { return true; } }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemOutput dtor_transformedOutput {
      get {
        return this._transformedOutput;
      }
    }
  }

  public interface _IError {
    bool is_DynamoDbEncryptionTransformsException { get; }
    bool is_AwsCryptographyDbEncryptionSdkDynamoDb { get; }
    bool is_AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptor { get; }
    bool is_AwsCryptographyDbEncryptionSdkStructuredEncryption { get; }
    bool is_AwsCryptographyMaterialProviders { get; }
    bool is_ComAmazonawsDynamodb { get; }
    bool is_CollectionOfErrors { get; }
    bool is_Opaque { get; }
    bool is_OpaqueWithText { get; }
    Dafny.ISequence<char> dtor_message { get; }
    software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError dtor_AwsCryptographyDbEncryptionSdkDynamoDb { get; }
    software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError dtor_AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptor { get; }
    software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError dtor_AwsCryptographyDbEncryptionSdkStructuredEncryption { get; }
    software.amazon.cryptography.materialproviders.internaldafny.types._IError dtor_AwsCryptographyMaterialProviders { get; }
    software.amazon.cryptography.services.dynamodb.internaldafny.types._IError dtor_ComAmazonawsDynamodb { get; }
    Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> dtor_list { get; }
    object dtor_obj { get; }
    Dafny.ISequence<char> dtor_objMessage { get; }
    _IError DowncastClone();
  }
  public abstract class Error : _IError {
    public Error() {
    }
    private static readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError theDefault = create_DynamoDbEncryptionTransformsException(Dafny.Sequence<char>.Empty);
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.Error.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IError create_DynamoDbEncryptionTransformsException(Dafny.ISequence<char> message) {
      return new Error_DynamoDbEncryptionTransformsException(message);
    }
    public static _IError create_AwsCryptographyDbEncryptionSdkDynamoDb(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError AwsCryptographyDbEncryptionSdkDynamoDb) {
      return new Error_AwsCryptographyDbEncryptionSdkDynamoDb(AwsCryptographyDbEncryptionSdkDynamoDb);
    }
    public static _IError create_AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptor(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptor) {
      return new Error_AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptor(AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptor);
    }
    public static _IError create_AwsCryptographyDbEncryptionSdkStructuredEncryption(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError AwsCryptographyDbEncryptionSdkStructuredEncryption) {
      return new Error_AwsCryptographyDbEncryptionSdkStructuredEncryption(AwsCryptographyDbEncryptionSdkStructuredEncryption);
    }
    public static _IError create_AwsCryptographyMaterialProviders(software.amazon.cryptography.materialproviders.internaldafny.types._IError AwsCryptographyMaterialProviders) {
      return new Error_AwsCryptographyMaterialProviders(AwsCryptographyMaterialProviders);
    }
    public static _IError create_ComAmazonawsDynamodb(software.amazon.cryptography.services.dynamodb.internaldafny.types._IError ComAmazonawsDynamodb) {
      return new Error_ComAmazonawsDynamodb(ComAmazonawsDynamodb);
    }
    public static _IError create_CollectionOfErrors(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> list, Dafny.ISequence<char> message) {
      return new Error_CollectionOfErrors(list, message);
    }
    public static _IError create_Opaque(object obj) {
      return new Error_Opaque(obj);
    }
    public static _IError create_OpaqueWithText(object obj, Dafny.ISequence<char> objMessage) {
      return new Error_OpaqueWithText(obj, objMessage);
    }
    public bool is_DynamoDbEncryptionTransformsException { get { return this is Error_DynamoDbEncryptionTransformsException; } }
    public bool is_AwsCryptographyDbEncryptionSdkDynamoDb { get { return this is Error_AwsCryptographyDbEncryptionSdkDynamoDb; } }
    public bool is_AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptor { get { return this is Error_AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptor; } }
    public bool is_AwsCryptographyDbEncryptionSdkStructuredEncryption { get { return this is Error_AwsCryptographyDbEncryptionSdkStructuredEncryption; } }
    public bool is_AwsCryptographyMaterialProviders { get { return this is Error_AwsCryptographyMaterialProviders; } }
    public bool is_ComAmazonawsDynamodb { get { return this is Error_ComAmazonawsDynamodb; } }
    public bool is_CollectionOfErrors { get { return this is Error_CollectionOfErrors; } }
    public bool is_Opaque { get { return this is Error_Opaque; } }
    public bool is_OpaqueWithText { get { return this is Error_OpaqueWithText; } }
    public Dafny.ISequence<char> dtor_message {
      get {
        var d = this;
        if (d is Error_DynamoDbEncryptionTransformsException) { return ((Error_DynamoDbEncryptionTransformsException)d)._message; }
        return ((Error_CollectionOfErrors)d)._message;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError dtor_AwsCryptographyDbEncryptionSdkDynamoDb {
      get {
        var d = this;
        return ((Error_AwsCryptographyDbEncryptionSdkDynamoDb)d)._AwsCryptographyDbEncryptionSdkDynamoDb;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError dtor_AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptor {
      get {
        var d = this;
        return ((Error_AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptor)d)._AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptor;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError dtor_AwsCryptographyDbEncryptionSdkStructuredEncryption {
      get {
        var d = this;
        return ((Error_AwsCryptographyDbEncryptionSdkStructuredEncryption)d)._AwsCryptographyDbEncryptionSdkStructuredEncryption;
      }
    }
    public software.amazon.cryptography.materialproviders.internaldafny.types._IError dtor_AwsCryptographyMaterialProviders {
      get {
        var d = this;
        return ((Error_AwsCryptographyMaterialProviders)d)._AwsCryptographyMaterialProviders;
      }
    }
    public software.amazon.cryptography.services.dynamodb.internaldafny.types._IError dtor_ComAmazonawsDynamodb {
      get {
        var d = this;
        return ((Error_ComAmazonawsDynamodb)d)._ComAmazonawsDynamodb;
      }
    }
    public Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> dtor_list {
      get {
        var d = this;
        return ((Error_CollectionOfErrors)d)._list;
      }
    }
    public object dtor_obj {
      get {
        var d = this;
        if (d is Error_Opaque) { return ((Error_Opaque)d)._obj; }
        return ((Error_OpaqueWithText)d)._obj;
      }
    }
    public Dafny.ISequence<char> dtor_objMessage {
      get {
        var d = this;
        return ((Error_OpaqueWithText)d)._objMessage;
      }
    }
    public abstract _IError DowncastClone();
  }
  public class Error_DynamoDbEncryptionTransformsException : Error {
    public readonly Dafny.ISequence<char> _message;
    public Error_DynamoDbEncryptionTransformsException(Dafny.ISequence<char> message) : base() {
      this._message = message;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_DynamoDbEncryptionTransformsException(_message);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.Error_DynamoDbEncryptionTransformsException;
      return oth != null && object.Equals(this._message, oth._message);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._message));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.Error.DynamoDbEncryptionTransformsException";
      s += "(";
      s += Dafny.Helpers.ToString(this._message);
      s += ")";
      return s;
    }
  }
  public class Error_AwsCryptographyDbEncryptionSdkDynamoDb : Error {
    public readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError _AwsCryptographyDbEncryptionSdkDynamoDb;
    public Error_AwsCryptographyDbEncryptionSdkDynamoDb(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError AwsCryptographyDbEncryptionSdkDynamoDb) : base() {
      this._AwsCryptographyDbEncryptionSdkDynamoDb = AwsCryptographyDbEncryptionSdkDynamoDb;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_AwsCryptographyDbEncryptionSdkDynamoDb(_AwsCryptographyDbEncryptionSdkDynamoDb);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.Error_AwsCryptographyDbEncryptionSdkDynamoDb;
      return oth != null && object.Equals(this._AwsCryptographyDbEncryptionSdkDynamoDb, oth._AwsCryptographyDbEncryptionSdkDynamoDb);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 1;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._AwsCryptographyDbEncryptionSdkDynamoDb));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.Error.AwsCryptographyDbEncryptionSdkDynamoDb";
      s += "(";
      s += Dafny.Helpers.ToString(this._AwsCryptographyDbEncryptionSdkDynamoDb);
      s += ")";
      return s;
    }
  }
  public class Error_AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptor : Error {
    public readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError _AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptor;
    public Error_AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptor(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptor) : base() {
      this._AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptor = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptor;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptor(_AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptor);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.Error_AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptor;
      return oth != null && object.Equals(this._AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptor, oth._AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptor);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 2;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptor));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.Error.AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptor";
      s += "(";
      s += Dafny.Helpers.ToString(this._AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptor);
      s += ")";
      return s;
    }
  }
  public class Error_AwsCryptographyDbEncryptionSdkStructuredEncryption : Error {
    public readonly software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError _AwsCryptographyDbEncryptionSdkStructuredEncryption;
    public Error_AwsCryptographyDbEncryptionSdkStructuredEncryption(software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._IError AwsCryptographyDbEncryptionSdkStructuredEncryption) : base() {
      this._AwsCryptographyDbEncryptionSdkStructuredEncryption = AwsCryptographyDbEncryptionSdkStructuredEncryption;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_AwsCryptographyDbEncryptionSdkStructuredEncryption(_AwsCryptographyDbEncryptionSdkStructuredEncryption);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.Error_AwsCryptographyDbEncryptionSdkStructuredEncryption;
      return oth != null && object.Equals(this._AwsCryptographyDbEncryptionSdkStructuredEncryption, oth._AwsCryptographyDbEncryptionSdkStructuredEncryption);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 3;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._AwsCryptographyDbEncryptionSdkStructuredEncryption));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.Error.AwsCryptographyDbEncryptionSdkStructuredEncryption";
      s += "(";
      s += Dafny.Helpers.ToString(this._AwsCryptographyDbEncryptionSdkStructuredEncryption);
      s += ")";
      return s;
    }
  }
  public class Error_AwsCryptographyMaterialProviders : Error {
    public readonly software.amazon.cryptography.materialproviders.internaldafny.types._IError _AwsCryptographyMaterialProviders;
    public Error_AwsCryptographyMaterialProviders(software.amazon.cryptography.materialproviders.internaldafny.types._IError AwsCryptographyMaterialProviders) : base() {
      this._AwsCryptographyMaterialProviders = AwsCryptographyMaterialProviders;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_AwsCryptographyMaterialProviders(_AwsCryptographyMaterialProviders);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.Error_AwsCryptographyMaterialProviders;
      return oth != null && object.Equals(this._AwsCryptographyMaterialProviders, oth._AwsCryptographyMaterialProviders);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 4;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._AwsCryptographyMaterialProviders));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.Error.AwsCryptographyMaterialProviders";
      s += "(";
      s += Dafny.Helpers.ToString(this._AwsCryptographyMaterialProviders);
      s += ")";
      return s;
    }
  }
  public class Error_ComAmazonawsDynamodb : Error {
    public readonly software.amazon.cryptography.services.dynamodb.internaldafny.types._IError _ComAmazonawsDynamodb;
    public Error_ComAmazonawsDynamodb(software.amazon.cryptography.services.dynamodb.internaldafny.types._IError ComAmazonawsDynamodb) : base() {
      this._ComAmazonawsDynamodb = ComAmazonawsDynamodb;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_ComAmazonawsDynamodb(_ComAmazonawsDynamodb);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.Error_ComAmazonawsDynamodb;
      return oth != null && object.Equals(this._ComAmazonawsDynamodb, oth._ComAmazonawsDynamodb);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 5;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._ComAmazonawsDynamodb));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.Error.ComAmazonawsDynamodb";
      s += "(";
      s += Dafny.Helpers.ToString(this._ComAmazonawsDynamodb);
      s += ")";
      return s;
    }
  }
  public class Error_CollectionOfErrors : Error {
    public readonly Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _list;
    public readonly Dafny.ISequence<char> _message;
    public Error_CollectionOfErrors(Dafny.ISequence<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> list, Dafny.ISequence<char> message) : base() {
      this._list = list;
      this._message = message;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_CollectionOfErrors(_list, _message);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.Error_CollectionOfErrors;
      return oth != null && object.Equals(this._list, oth._list) && object.Equals(this._message, oth._message);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 6;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._list));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._message));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.Error.CollectionOfErrors";
      s += "(";
      s += Dafny.Helpers.ToString(this._list);
      s += ", ";
      s += Dafny.Helpers.ToString(this._message);
      s += ")";
      return s;
    }
  }
  public class Error_Opaque : Error {
    public readonly object _obj;
    public Error_Opaque(object obj) : base() {
      this._obj = obj;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_Opaque(_obj);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.Error_Opaque;
      return oth != null && this._obj == oth._obj;
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 7;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._obj));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.Error.Opaque";
      s += "(";
      s += Dafny.Helpers.ToString(this._obj);
      s += ")";
      return s;
    }
  }
  public class Error_OpaqueWithText : Error {
    public readonly object _obj;
    public readonly Dafny.ISequence<char> _objMessage;
    public Error_OpaqueWithText(object obj, Dafny.ISequence<char> objMessage) : base() {
      this._obj = obj;
      this._objMessage = objMessage;
    }
    public override _IError DowncastClone() {
      if (this is _IError dt) { return dt; }
      return new Error_OpaqueWithText(_obj, _objMessage);
    }
    public override bool Equals(object other) {
      var oth = other as software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.Error_OpaqueWithText;
      return oth != null && this._obj == oth._obj && object.Equals(this._objMessage, oth._objMessage);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 8;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._obj));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._objMessage));
      return (int) hash;
    }
    public override string ToString() {
      string s = "AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes.Error.OpaqueWithText";
      s += "(";
      s += Dafny.Helpers.ToString(this._obj);
      s += ", ";
      s += Dafny.Helpers.ToString(this._objMessage);
      s += ")";
      return s;
    }
  }

  public partial class OpaqueError {
    private static readonly Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _TYPE = new Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.Error.Default());
    public static Dafny.TypeDescriptor<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError __source) {
      software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError _0_e = __source;
      return ((_0_e).is_Opaque) || ((_0_e).is_OpaqueWithText);
    }
  }

  public partial class DummySubsetType {
    private static readonly BigInteger Witness = BigInteger.One;
    public static BigInteger Default() {
      return Witness;
    }
    private static readonly Dafny.TypeDescriptor<BigInteger> _TYPE = new Dafny.TypeDescriptor<BigInteger>(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.DummySubsetType.Default());
    public static Dafny.TypeDescriptor<BigInteger> _TypeDescriptor() {
      return _TYPE;
    }
    public static bool _Is(BigInteger __source) {
      BigInteger _1_x = __source;
      return software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.__default.IsDummySubsetType(_1_x);
    }
  }
} // end of namespace software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types
namespace DdbMiddlewareConfig_Compile {

  public partial class __default {
    public static bool IsPlainWrite(DdbMiddlewareConfig_Compile._IConfig config, Dafny.ISequence<char> tableName)
    {
      return (!((config).dtor_tableEncryptionConfigs).Contains(tableName)) || (object.Equals((Dafny.Map<Dafny.ISequence<char>, DdbMiddlewareConfig_Compile._ITableConfig>.Select((config).dtor_tableEncryptionConfigs,tableName)).dtor_plaintextOverride, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.PlaintextOverride.create_FORCE__PLAINTEXT__WRITE__ALLOW__PLAINTEXT__READ()));
    }
    public static Dafny.ISequence<char> AttrToString(software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue attr) {
      if ((attr).is_S) {
        return (attr).dtor_S;
      } else if ((attr).is_N) {
        return (attr).dtor_N;
      } else if ((attr).is_B) {
        return HexStrings_Compile.__default.ToHexString((attr).dtor_B);
      } else {
        return Dafny.Sequence<char>.FromString("unexpected key type");
      }
    }
    public static Dafny.ISequence<char> KeyString(DdbMiddlewareConfig_Compile._ITableConfig config, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item)
    {
      Dafny.ISequence<char> _0_partition = (((item).Contains((config).dtor_partitionKeyName)) ? (Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat((config).dtor_partitionKeyName, Dafny.Sequence<char>.FromString(" = ")), DdbMiddlewareConfig_Compile.__default.AttrToString(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(item,(config).dtor_partitionKeyName)))) : (Dafny.Sequence<char>.FromString("")));
      Dafny.ISequence<char> _1_sort = (((((config).dtor_sortKeyName).is_Some) && ((item).Contains(((config).dtor_sortKeyName).dtor_value))) ? (Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("; "), ((config).dtor_sortKeyName).dtor_value), Dafny.Sequence<char>.FromString(" = ")), DdbMiddlewareConfig_Compile.__default.AttrToString(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Select(item,((config).dtor_sortKeyName).dtor_value)))) : (Dafny.Sequence<char>.FromString("")));
      return Dafny.Sequence<char>.Concat(_0_partition, _1_sort);
    }
    public static Wrappers_Compile._IResult<__T, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> MapError<__T>(Wrappers_Compile._IResult<__T, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> r) {
      return Wrappers_Compile.Result<__T, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(r, ((System.Func<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>)((_0_e) => {
        return software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.Error.create_AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptor(_0_e);
      })));
    }
    public static Wrappers_Compile._IResult<__T, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> MapString<__T>(Wrappers_Compile._IResult<__T, Dafny.ISequence<char>> r) {
      return Wrappers_Compile.Result<__T, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(r, ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>)((_0_e) => {
        return software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.Error.create_DynamoDbEncryptionTransformsException(_0_e);
      })));
    }
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError E(Dafny.ISequence<char> s) {
      return software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.Error.create_DynamoDbEncryptionTransformsException(s);
    }
    public static Wrappers_Compile._IResult<__X, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> MakeError<__X>(Dafny.ISequence<char> s) {
      return Wrappers_Compile.Result<__X, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Failure(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.Error.create_DynamoDbEncryptionTransformsException(s));
    }
  }

  public interface _ITableConfig {
    bool is_TableConfig { get; }
    Dafny.ISequence<char> dtor_physicalTableName { get; }
    Dafny.ISequence<char> dtor_logicalTableName { get; }
    Dafny.ISequence<char> dtor_partitionKeyName { get; }
    Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_sortKeyName { get; }
    software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.DynamoDbItemEncryptorClient dtor_itemEncryptor { get; }
    Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._ISearchInfo> dtor_search { get; }
    software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride dtor_plaintextOverride { get; }
    _ITableConfig DowncastClone();
  }
  public class TableConfig : _ITableConfig {
    public readonly Dafny.ISequence<char> _physicalTableName;
    public readonly Dafny.ISequence<char> _logicalTableName;
    public readonly Dafny.ISequence<char> _partitionKeyName;
    public readonly Wrappers_Compile._IOption<Dafny.ISequence<char>> _sortKeyName;
    public readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.DynamoDbItemEncryptorClient _itemEncryptor;
    public readonly Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._ISearchInfo> _search;
    public readonly software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride _plaintextOverride;
    public TableConfig(Dafny.ISequence<char> physicalTableName, Dafny.ISequence<char> logicalTableName, Dafny.ISequence<char> partitionKeyName, Wrappers_Compile._IOption<Dafny.ISequence<char>> sortKeyName, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.DynamoDbItemEncryptorClient itemEncryptor, Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._ISearchInfo> search, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride plaintextOverride) {
      this._physicalTableName = physicalTableName;
      this._logicalTableName = logicalTableName;
      this._partitionKeyName = partitionKeyName;
      this._sortKeyName = sortKeyName;
      this._itemEncryptor = itemEncryptor;
      this._search = search;
      this._plaintextOverride = plaintextOverride;
    }
    public _ITableConfig DowncastClone() {
      if (this is _ITableConfig dt) { return dt; }
      return new TableConfig(_physicalTableName, _logicalTableName, _partitionKeyName, _sortKeyName, _itemEncryptor, _search, _plaintextOverride);
    }
    public override bool Equals(object other) {
      var oth = other as DdbMiddlewareConfig_Compile.TableConfig;
      return oth != null && object.Equals(this._physicalTableName, oth._physicalTableName) && object.Equals(this._logicalTableName, oth._logicalTableName) && object.Equals(this._partitionKeyName, oth._partitionKeyName) && object.Equals(this._sortKeyName, oth._sortKeyName) && this._itemEncryptor == oth._itemEncryptor && object.Equals(this._search, oth._search) && object.Equals(this._plaintextOverride, oth._plaintextOverride);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._physicalTableName));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._logicalTableName));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._partitionKeyName));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._sortKeyName));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._itemEncryptor));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._search));
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._plaintextOverride));
      return (int) hash;
    }
    public override string ToString() {
      string s = "DdbMiddlewareConfig.TableConfig.TableConfig";
      s += "(";
      s += Dafny.Helpers.ToString(this._physicalTableName);
      s += ", ";
      s += Dafny.Helpers.ToString(this._logicalTableName);
      s += ", ";
      s += Dafny.Helpers.ToString(this._partitionKeyName);
      s += ", ";
      s += Dafny.Helpers.ToString(this._sortKeyName);
      s += ", ";
      s += Dafny.Helpers.ToString(this._itemEncryptor);
      s += ", ";
      s += Dafny.Helpers.ToString(this._search);
      s += ", ";
      s += Dafny.Helpers.ToString(this._plaintextOverride);
      s += ")";
      return s;
    }
    private static readonly DdbMiddlewareConfig_Compile._ITableConfig theDefault = create(Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty, Dafny.Sequence<char>.Empty, Wrappers_Compile.Option<Dafny.ISequence<char>>.Default(), default(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.DynamoDbItemEncryptorClient), Wrappers_Compile.Option<SearchableEncryptionInfo_Compile._ISearchInfo>.Default(), software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.PlaintextOverride.Default());
    public static DdbMiddlewareConfig_Compile._ITableConfig Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<DdbMiddlewareConfig_Compile._ITableConfig> _TYPE = new Dafny.TypeDescriptor<DdbMiddlewareConfig_Compile._ITableConfig>(DdbMiddlewareConfig_Compile.TableConfig.Default());
    public static Dafny.TypeDescriptor<DdbMiddlewareConfig_Compile._ITableConfig> _TypeDescriptor() {
      return _TYPE;
    }
    public static _ITableConfig create(Dafny.ISequence<char> physicalTableName, Dafny.ISequence<char> logicalTableName, Dafny.ISequence<char> partitionKeyName, Wrappers_Compile._IOption<Dafny.ISequence<char>> sortKeyName, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.DynamoDbItemEncryptorClient itemEncryptor, Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._ISearchInfo> search, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride plaintextOverride) {
      return new TableConfig(physicalTableName, logicalTableName, partitionKeyName, sortKeyName, itemEncryptor, search, plaintextOverride);
    }
    public static _ITableConfig create_TableConfig(Dafny.ISequence<char> physicalTableName, Dafny.ISequence<char> logicalTableName, Dafny.ISequence<char> partitionKeyName, Wrappers_Compile._IOption<Dafny.ISequence<char>> sortKeyName, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.DynamoDbItemEncryptorClient itemEncryptor, Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._ISearchInfo> search, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride plaintextOverride) {
      return create(physicalTableName, logicalTableName, partitionKeyName, sortKeyName, itemEncryptor, search, plaintextOverride);
    }
    public bool is_TableConfig { get { return true; } }
    public Dafny.ISequence<char> dtor_physicalTableName {
      get {
        return this._physicalTableName;
      }
    }
    public Dafny.ISequence<char> dtor_logicalTableName {
      get {
        return this._logicalTableName;
      }
    }
    public Dafny.ISequence<char> dtor_partitionKeyName {
      get {
        return this._partitionKeyName;
      }
    }
    public Wrappers_Compile._IOption<Dafny.ISequence<char>> dtor_sortKeyName {
      get {
        return this._sortKeyName;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.DynamoDbItemEncryptorClient dtor_itemEncryptor {
      get {
        return this._itemEncryptor;
      }
    }
    public Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._ISearchInfo> dtor_search {
      get {
        return this._search;
      }
    }
    public software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride dtor_plaintextOverride {
      get {
        return this._plaintextOverride;
      }
    }
  }

  public partial class ValidTableConfig {
    private static readonly Dafny.TypeDescriptor<DdbMiddlewareConfig_Compile._ITableConfig> _TYPE = new Dafny.TypeDescriptor<DdbMiddlewareConfig_Compile._ITableConfig>(DdbMiddlewareConfig_Compile.TableConfig.Default());
    public static Dafny.TypeDescriptor<DdbMiddlewareConfig_Compile._ITableConfig> _TypeDescriptor() {
      return _TYPE;
    }
  }

  public interface _IConfig {
    bool is_Config { get; }
    Dafny.IMap<Dafny.ISequence<char>,DdbMiddlewareConfig_Compile._ITableConfig> dtor_tableEncryptionConfigs { get; }
    _IConfig DowncastClone();
  }
  public class Config : _IConfig {
    public readonly Dafny.IMap<Dafny.ISequence<char>,DdbMiddlewareConfig_Compile._ITableConfig> _tableEncryptionConfigs;
    public Config(Dafny.IMap<Dafny.ISequence<char>,DdbMiddlewareConfig_Compile._ITableConfig> tableEncryptionConfigs) {
      this._tableEncryptionConfigs = tableEncryptionConfigs;
    }
    public _IConfig DowncastClone() {
      if (this is _IConfig dt) { return dt; }
      return new Config(_tableEncryptionConfigs);
    }
    public override bool Equals(object other) {
      var oth = other as DdbMiddlewareConfig_Compile.Config;
      return oth != null && object.Equals(this._tableEncryptionConfigs, oth._tableEncryptionConfigs);
    }
    public override int GetHashCode() {
      ulong hash = 5381;
      hash = ((hash << 5) + hash) + 0;
      hash = ((hash << 5) + hash) + ((ulong)Dafny.Helpers.GetHashCode(this._tableEncryptionConfigs));
      return (int) hash;
    }
    public override string ToString() {
      string s = "DdbMiddlewareConfig.Config.Config";
      s += "(";
      s += Dafny.Helpers.ToString(this._tableEncryptionConfigs);
      s += ")";
      return s;
    }
    private static readonly DdbMiddlewareConfig_Compile._IConfig theDefault = create(Dafny.Map<Dafny.ISequence<char>, DdbMiddlewareConfig_Compile._ITableConfig>.Empty);
    public static DdbMiddlewareConfig_Compile._IConfig Default() {
      return theDefault;
    }
    private static readonly Dafny.TypeDescriptor<DdbMiddlewareConfig_Compile._IConfig> _TYPE = new Dafny.TypeDescriptor<DdbMiddlewareConfig_Compile._IConfig>(DdbMiddlewareConfig_Compile.Config.Default());
    public static Dafny.TypeDescriptor<DdbMiddlewareConfig_Compile._IConfig> _TypeDescriptor() {
      return _TYPE;
    }
    public static _IConfig create(Dafny.IMap<Dafny.ISequence<char>,DdbMiddlewareConfig_Compile._ITableConfig> tableEncryptionConfigs) {
      return new Config(tableEncryptionConfigs);
    }
    public static _IConfig create_Config(Dafny.IMap<Dafny.ISequence<char>,DdbMiddlewareConfig_Compile._ITableConfig> tableEncryptionConfigs) {
      return create(tableEncryptionConfigs);
    }
    public bool is_Config { get { return true; } }
    public Dafny.IMap<Dafny.ISequence<char>,DdbMiddlewareConfig_Compile._ITableConfig> dtor_tableEncryptionConfigs {
      get {
        return this._tableEncryptionConfigs;
      }
    }
  }
} // end of namespace DdbMiddlewareConfig_Compile
namespace DdbStatement_Compile {

  public partial class __default {
    public static Dafny.ISequence<char> UnQuote(Dafny.ISequence<char> s) {
      Dafny.ISequence<char> _0_s = ((((new BigInteger((s).Count)).Sign == 1) && (((s).Select(BigInteger.Zero)) == ('"'))) ? ((s).Drop(BigInteger.One)) : (s));
      if (((new BigInteger((_0_s).Count)).Sign == 1) && (((_0_s).Select((new BigInteger((_0_s).Count)) - (BigInteger.One))) == ('"'))) {
        return (_0_s).Subsequence(BigInteger.Zero, (new BigInteger((_0_s).Count)) - (BigInteger.One));
      } else {
        return _0_s;
      }
    }
    public static Wrappers_Compile._IOption<Dafny.ISequence<char>> GetTableName(Dafny.ISequence<char> s) {
      Dafny.ISequence<char> _0_s = DdbStatement_Compile.__default.UnQuote(s);
      if (software.amazon.cryptography.services.dynamodb.internaldafny.types.__default.IsValid__TableName(_0_s)) {
        return Wrappers_Compile.Option<Dafny.ISequence<char>>.create_Some(_0_s);
      } else {
        return Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None();
      }
    }
    public static Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> TableFromStatement(Dafny.ISequence<char> s) {
      Wrappers_Compile._IOption<Dafny.ISequence<char>> _0_ret = DdbStatement_Compile.__default.TableFromStatementInner(s);
      if ((_0_ret).is_Some) {
        return Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.create_Success((_0_ret).dtor_value);
      } else {
        return Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.create_Failure(Dafny.Sequence<char>.FromString("Unable to extract table name from PartiQL statement."));
      }
    }
    public static Wrappers_Compile._IOption<Dafny.ISequence<char>> TableFromStatementInner(Dafny.ISequence<char> s) {
      Dafny.ISequence<char> _0_s = DdbStatement_Compile.__default.StripLeadingWhitespace(s);
      if (((new BigInteger((_0_s).Count)) > (new BigInteger(6))) && ((DdbStatement_Compile.__default.AsciiLower((_0_s).Subsequence(BigInteger.Zero, new BigInteger(6)))).Equals(Dafny.Sequence<char>.FromString("exists")))) {
        return DdbStatement_Compile.__default.TableFromExistsStatement((_0_s).Drop(new BigInteger(6)));
      } else {
        BigInteger _1_len = DdbStatement_Compile.__default.FindTokenLen(_0_s);
        Dafny.ISequence<char> _2_cmd = DdbStatement_Compile.__default.AsciiLower((_0_s).Take(_1_len));
        if ((_2_cmd).Equals(Dafny.Sequence<char>.FromString("select"))) {
          return DdbStatement_Compile.__default.TableFromSelectStatement((_0_s).Drop(_1_len));
        } else if ((_2_cmd).Equals(Dafny.Sequence<char>.FromString("update"))) {
          return DdbStatement_Compile.__default.TableFromUpdateStatement((_0_s).Drop(_1_len));
        } else if ((_2_cmd).Equals(Dafny.Sequence<char>.FromString("delete"))) {
          return DdbStatement_Compile.__default.TableFromDeleteStatement((_0_s).Drop(_1_len));
        } else if ((_2_cmd).Equals(Dafny.Sequence<char>.FromString("insert"))) {
          return DdbStatement_Compile.__default.TableFromInsertStatement((_0_s).Drop(_1_len));
        } else {
          return Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None();
        }
      }
    }
    public static Wrappers_Compile._IOption<Dafny.ISequence<char>> TableFromSelectStatementInner(Dafny.ISequence<char> s) {
    TAIL_CALL_START: ;
      if ((new BigInteger((s).Count)).Sign == 0) {
        return Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None();
      } else {
        Dafny.ISequence<char> _0_t = DdbStatement_Compile.__default.StripLeadingWhitespace(s);
        BigInteger _1_len = DdbStatement_Compile.__default.FindTokenLen(_0_t);
        if ((DdbStatement_Compile.__default.AsciiLower((_0_t).Take(_1_len))).Equals(Dafny.Sequence<char>.FromString("from"))) {
          Dafny.ISequence<char> _2_t = DdbStatement_Compile.__default.StripLeadingWhitespace((_0_t).Drop(_1_len));
          BigInteger _3_len = DdbStatement_Compile.__default.FindTokenLen(_2_t);
          return Wrappers_Compile.Option<Dafny.ISequence<char>>.create_Some((_2_t).Take(_3_len));
        } else if ((_1_len).Sign == 0) {
          return Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None();
        } else {
          Dafny.ISequence<char> _in0 = (_0_t).Drop(_1_len);
          s = _in0;
          goto TAIL_CALL_START;
        }
      }
    }
    public static Wrappers_Compile._IOption<Dafny.ISequence<char>> TableFromExistsStatement(Dafny.ISequence<char> s) {
      Dafny.ISequence<char> _0_s = DdbStatement_Compile.__default.StripLeadingWhitespace(s);
      if (((new BigInteger((_0_s).Count)).Sign == 0) || (((_0_s).Select(BigInteger.Zero)) != ('('))) {
        return Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None();
      } else {
        Dafny.ISequence<char> _1_s = DdbStatement_Compile.__default.StripLeadingWhitespace((_0_s).Drop(BigInteger.One));
        BigInteger _2_len = DdbStatement_Compile.__default.FindTokenLen(_1_s);
        if ((DdbStatement_Compile.__default.AsciiLower((_1_s).Take(_2_len))).Equals(Dafny.Sequence<char>.FromString("select"))) {
          return DdbStatement_Compile.__default.TableFromSelectStatement((_1_s).Drop(_2_len));
        } else {
          return Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None();
        }
      }
    }
    public static Wrappers_Compile._IOption<Dafny.ISequence<char>> TableFromSelectStatement(Dafny.ISequence<char> s) {
      Wrappers_Compile._IOption<Dafny.ISequence<char>> _0_valueOrError0 = DdbStatement_Compile.__default.TableFromSelectStatementInner(s);
      if ((_0_valueOrError0).IsFailure()) {
        return (_0_valueOrError0).PropagateFailure<Dafny.ISequence<char>>();
      } else {
        Dafny.ISequence<char> _1_name = (_0_valueOrError0).Extract();
        if ((_1_name).Contains('.')) {
          _System._ITuple2<Dafny.ISequence<char>, Dafny.ISequence<char>> _2_x = StandardLibrary_Compile.__default.SplitOnce<char>(_1_name, '.');
          return DdbStatement_Compile.__default.GetTableName((_2_x).dtor__0);
        } else {
          return DdbStatement_Compile.__default.GetTableName(_1_name);
        }
      }
    }
    public static Wrappers_Compile._IOption<Dafny.ISequence<char>> TableFromUpdateStatement(Dafny.ISequence<char> s) {
      Dafny.ISequence<char> _0_s = DdbStatement_Compile.__default.StripLeadingWhitespace(s);
      BigInteger _1_len = DdbStatement_Compile.__default.FindTokenLen(_0_s);
      if ((_1_len).Sign == 0) {
        return Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None();
      } else {
        return DdbStatement_Compile.__default.GetTableName((_0_s).Take(_1_len));
      }
    }
    public static Wrappers_Compile._IOption<Dafny.ISequence<char>> TableFromDeleteStatement(Dafny.ISequence<char> s) {
      Dafny.ISequence<char> _0_s = DdbStatement_Compile.__default.StripLeadingWhitespace(s);
      BigInteger _1_len = DdbStatement_Compile.__default.FindTokenLen(_0_s);
      if (!(DdbStatement_Compile.__default.AsciiLower((_0_s).Take(_1_len))).Equals(Dafny.Sequence<char>.FromString("from"))) {
        return Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None();
      } else {
        Dafny.ISequence<char> _2_s = DdbStatement_Compile.__default.StripLeadingWhitespace((_0_s).Drop(_1_len));
        BigInteger _3_len = DdbStatement_Compile.__default.FindTokenLen(_2_s);
        if ((_3_len).Sign == 0) {
          return Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None();
        } else {
          return DdbStatement_Compile.__default.GetTableName((_2_s).Take(_3_len));
        }
      }
    }
    public static Wrappers_Compile._IOption<Dafny.ISequence<char>> TableFromInsertStatement(Dafny.ISequence<char> s) {
      Dafny.ISequence<char> _0_s = DdbStatement_Compile.__default.StripLeadingWhitespace(s);
      BigInteger _1_len = DdbStatement_Compile.__default.FindTokenLen(_0_s);
      if (!(DdbStatement_Compile.__default.AsciiLower((_0_s).Take(_1_len))).Equals(Dafny.Sequence<char>.FromString("into"))) {
        return Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None();
      } else {
        Dafny.ISequence<char> _2_s = DdbStatement_Compile.__default.StripLeadingWhitespace((_0_s).Drop(_1_len));
        BigInteger _3_len = DdbStatement_Compile.__default.FindTokenLen(_2_s);
        if ((_3_len).Sign == 0) {
          return Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None();
        } else {
          return DdbStatement_Compile.__default.GetTableName((_2_s).Take(_3_len));
        }
      }
    }
    public static bool IsWhitespace(char ch) {
      return (ch) <= (' ');
    }
    public static Dafny.ISequence<char> StripLeadingWhitespace(Dafny.ISequence<char> s) {
    TAIL_CALL_START: ;
      if (((new BigInteger((s).Count)).Sign == 0) || (!(DdbStatement_Compile.__default.IsWhitespace((s).Select(BigInteger.Zero))))) {
        return s;
      } else {
        Dafny.ISequence<char> _in0 = (s).Drop(BigInteger.One);
        s = _in0;
        goto TAIL_CALL_START;
      }
    }
    public static char AsciiLowerChar(char ch) {
      if ((('A') <= (ch)) && ((ch) <= ('Z'))) {
        return (char)(((char)((ch) - ('A'))) + ('a'));
      } else {
        return ch;
      }
    }
    public static Dafny.ISequence<char> AsciiLower(Dafny.ISequence<char> s) {
      Dafny.ISequence<char> _0___accumulator = Dafny.Sequence<char>.FromElements();
    TAIL_CALL_START: ;
      if ((new BigInteger((s).Count)).Sign == 0) {
        return Dafny.Sequence<char>.Concat(_0___accumulator, s);
      } else {
        _0___accumulator = Dafny.Sequence<char>.Concat(_0___accumulator, Dafny.Sequence<char>.FromElements(DdbStatement_Compile.__default.AsciiLowerChar((s).Select(BigInteger.Zero))));
        Dafny.ISequence<char> _in0 = (s).Drop(BigInteger.One);
        s = _in0;
        goto TAIL_CALL_START;
      }
    }
    public static BigInteger FindTokenLen(Dafny.ISequence<char> s) {
      if (((new BigInteger((s).Count)).Sign == 0) || (DdbStatement_Compile.__default.IsWhitespace((s).Select(BigInteger.Zero)))) {
        return BigInteger.Zero;
      } else if (((s).Select(BigInteger.Zero)) == ('"')) {
        return (BigInteger.One) + (DdbStatement_Compile.__default.FindTokenLenQuoted((s).Drop(BigInteger.One)));
      } else {
        return DdbStatement_Compile.__default.FindTokenLenPlain(s);
      }
    }
    public static BigInteger FindTokenLenPlain(Dafny.ISequence<char> s) {
      BigInteger _0___accumulator = BigInteger.Zero;
    TAIL_CALL_START: ;
      if (((new BigInteger((s).Count)).Sign == 0) || (DdbStatement_Compile.__default.IsWhitespace((s).Select(BigInteger.Zero)))) {
        return (BigInteger.Zero) + (_0___accumulator);
      } else {
        _0___accumulator = (_0___accumulator) + (BigInteger.One);
        Dafny.ISequence<char> _in0 = (s).Drop(BigInteger.One);
        s = _in0;
        goto TAIL_CALL_START;
      }
    }
    public static BigInteger FindTokenLenQuoted(Dafny.ISequence<char> s) {
      BigInteger _0___accumulator = BigInteger.Zero;
    TAIL_CALL_START: ;
      if ((new BigInteger((s).Count)).Sign == 0) {
        return (BigInteger.Zero) + (_0___accumulator);
      } else if (((s).Select(BigInteger.Zero)) == ('"')) {
        return (BigInteger.One) + (_0___accumulator);
      } else {
        _0___accumulator = (_0___accumulator) + (BigInteger.One);
        Dafny.ISequence<char> _in0 = (s).Drop(BigInteger.One);
        s = _in0;
        goto TAIL_CALL_START;
      }
    }
  }
} // end of namespace DdbStatement_Compile
namespace DynamoDbMiddlewareSupport_Compile {

  public partial class __default {
    public static bool NoMap<__X, __Y>(Wrappers_Compile._IOption<Dafny.IMap<__X,__Y>> m) {
      return ((m).is_None) || ((new BigInteger(((m).dtor_value).Count)).Sign == 0);
    }
    public static bool NoList<__X>(Wrappers_Compile._IOption<Dafny.ISequence<__X>> m) {
      return ((m).is_None) || ((new BigInteger(((m).dtor_value).Count)).Sign == 0);
    }
    public static Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> IsWriteable(DdbMiddlewareConfig_Compile._ITableConfig config, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item)
    {
      return Wrappers_Compile.Result<bool, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(DynamoDBSupport_Compile.__default.IsWriteable(item), ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>)((_0_e) => {
        return DdbMiddlewareConfig_Compile.__default.E(_0_e);
      })));
    }
    public static bool IsSigned(DdbMiddlewareConfig_Compile._ITableConfig config, Dafny.ISequence<char> attr)
    {
      return DynamoDBSupport_Compile.__default.IsSigned((((config).dtor_itemEncryptor).config).dtor_attributeActionsOnEncrypt, attr);
    }
    public static Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> TestConditionExpression(DdbMiddlewareConfig_Compile._ITableConfig config, Wrappers_Compile._IOption<Dafny.ISequence<char>> expr, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> attrNames, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> attrValues)
    {
      return Wrappers_Compile.Result<bool, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(DynamoDBSupport_Compile.__default.TestConditionExpression((((config).dtor_itemEncryptor).config).dtor_attributeActionsOnEncrypt, expr, attrNames, attrValues), ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>)((_0_e) => {
        return DdbMiddlewareConfig_Compile.__default.E(_0_e);
      })));
    }
    public static Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> TestUpdateExpression(DdbMiddlewareConfig_Compile._ITableConfig config, Wrappers_Compile._IOption<Dafny.ISequence<char>> expr, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> attrNames, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> attrValues)
    {
      return Wrappers_Compile.Result<bool, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(DynamoDBSupport_Compile.__default.TestUpdateExpression((((config).dtor_itemEncryptor).config).dtor_attributeActionsOnEncrypt, expr, attrNames, attrValues), ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>)((_0_e) => {
        return DdbMiddlewareConfig_Compile.__default.E(_0_e);
      })));
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> AddSignedBeacons(DdbMiddlewareConfig_Compile._ITableConfig config, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item)
    {
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_ret;
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
      _out0 = DynamoDBSupport_Compile.__default.AddSignedBeacons((config).dtor_search, item);
      _0_ret = _out0;
      output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(_0_ret, ((System.Func<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>)((_1_e) => {
        return software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.Error.create_AwsCryptographyDbEncryptionSdkDynamoDb(_1_e);
      })));
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> GetEncryptedBeacons(DdbMiddlewareConfig_Compile._ITableConfig config, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, DynamoDbEncryptionUtil_Compile._IMaybeKeyId keyId)
    {
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_ret;
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
      _out0 = DynamoDBSupport_Compile.__default.GetEncryptedBeacons((config).dtor_search, item, keyId);
      _0_ret = _out0;
      output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(_0_ret, ((System.Func<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>)((_1_e) => {
        return software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.Error.create_AwsCryptographyDbEncryptionSdkDynamoDb(_1_e);
      })));
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<DynamoDbEncryptionUtil_Compile._IMaybeKeyId, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> GetBeaconKeyId(DdbMiddlewareConfig_Compile._ITableConfig config, Wrappers_Compile._IOption<Dafny.ISequence<char>> keyExpr, Wrappers_Compile._IOption<Dafny.ISequence<char>> filterExpr, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> values, Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>> names)
    {
      return Wrappers_Compile.Result<DynamoDbEncryptionUtil_Compile._IMaybeKeyId, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(DynamoDBSupport_Compile.__default.GetBeaconKeyId((config).dtor_search, keyExpr, filterExpr, values, names), ((System.Func<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>)((_0_e) => {
        return software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.Error.create_AwsCryptographyDbEncryptionSdkDynamoDb(_0_e);
      })));
    }
    public static Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> GetKeyIdFromHeader(DdbMiddlewareConfig_Compile._ITableConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput output)
    {
      if ((((config).dtor_search).is_Some) && (((((((config).dtor_search).dtor_value).curr()).dtor_keySource).dtor_keyLoc).is_MultiLoc)) {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(((output).dtor_parsedHeader).is_Some, DdbMiddlewareConfig_Compile.__default.E(Dafny.Sequence<char>.FromString("In multi-tenant mode, the parsed header is required.")));
        if ((_0_valueOrError0).IsFailure()) {
          return (_0_valueOrError0).PropagateFailure<Wrappers_Compile._IOption<Dafny.ISequence<char>>>();
        } else {
          Dafny.ISequence<software.amazon.cryptography.materialproviders.internaldafny.types._IEncryptedDataKey> _1_keys = (((output).dtor_parsedHeader).dtor_value).dtor_encryptedDataKeys;
          Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _2_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>((new BigInteger((_1_keys).Count)) == (BigInteger.One), DdbMiddlewareConfig_Compile.__default.E(Dafny.Sequence<char>.FromString("Encrypt header has more than one Encrypted Data Key")));
          if ((_2_valueOrError1).IsFailure()) {
            return (_2_valueOrError1).PropagateFailure<Wrappers_Compile._IOption<Dafny.ISequence<char>>>();
          } else {
            Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _3_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>((((_1_keys).Select(BigInteger.Zero)).dtor_keyProviderId).Equals(DynamoDbMiddlewareSupport_Compile.__default.HierarchicalKeyringId), DdbMiddlewareConfig_Compile.__default.E(Dafny.Sequence<char>.FromString("In multi-tenant mode, keyProviderId must be aws-kms-hierarchy")));
            if ((_3_valueOrError2).IsFailure()) {
              return (_3_valueOrError2).PropagateFailure<Wrappers_Compile._IOption<Dafny.ISequence<char>>>();
            } else {
              Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _4_valueOrError3 = Wrappers_Compile.Result<Dafny.ISequence<char>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(UTF8.__default.Decode(((_1_keys).Select(BigInteger.Zero)).dtor_keyProviderInfo), ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>)((_5_e) => {
                return DdbMiddlewareConfig_Compile.__default.E(_5_e);
              })));
              if ((_4_valueOrError3).IsFailure()) {
                return (_4_valueOrError3).PropagateFailure<Wrappers_Compile._IOption<Dafny.ISequence<char>>>();
              } else {
                Dafny.ISequence<char> _6_keyId = (_4_valueOrError3).Extract();
                return Wrappers_Compile.Result<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(Wrappers_Compile.Option<Dafny.ISequence<char>>.create_Some(_6_keyId));
              }
            }
          }
        }
      } else {
        return Wrappers_Compile.Result<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None());
      }
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> RemoveBeacons(DdbMiddlewareConfig_Compile._ITableConfig config, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item)
    {
      return Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(DynamoDBSupport_Compile.__default.RemoveBeacons((config).dtor_search, item), ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>)((_0_e) => {
        return DdbMiddlewareConfig_Compile.__default.E(_0_e);
      })));
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> QueryInputForBeacons(DdbMiddlewareConfig_Compile._ITableConfig config, software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput req)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_ret;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
      _out0 = DynamoDBSupport_Compile.__default.QueryInputForBeacons((config).dtor_search, (((config).dtor_itemEncryptor).config).dtor_attributeActionsOnEncrypt, req);
      _0_ret = _out0;
      output = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(_0_ret, ((System.Func<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>)((_1_e) => {
        return software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.Error.create_AwsCryptographyDbEncryptionSdkDynamoDb(_1_e);
      })));
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> QueryOutputForBeacons(DdbMiddlewareConfig_Compile._ITableConfig config, software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput req, software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput resp)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.services.dynamodb.internaldafny.types.QueryOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_ret;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
      _out0 = DynamoDBSupport_Compile.__default.QueryOutputForBeacons((config).dtor_search, req, resp);
      _0_ret = _out0;
      output = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(_0_ret, ((System.Func<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>)((_1_e) => {
        return software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.Error.create_AwsCryptographyDbEncryptionSdkDynamoDb(_1_e);
      })));
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> ScanInputForBeacons(DdbMiddlewareConfig_Compile._ITableConfig config, software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput req)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_ret;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
      _out0 = DynamoDBSupport_Compile.__default.ScanInputForBeacons((config).dtor_search, (((config).dtor_itemEncryptor).config).dtor_attributeActionsOnEncrypt, req);
      _0_ret = _out0;
      output = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(_0_ret, ((System.Func<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>)((_1_e) => {
        return software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.Error.create_AwsCryptographyDbEncryptionSdkDynamoDb(_1_e);
      })));
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> ScanOutputForBeacons(DdbMiddlewareConfig_Compile._ITableConfig config, software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput req, software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput resp)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.services.dynamodb.internaldafny.types.ScanOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_ret;
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
      _out0 = DynamoDBSupport_Compile.__default.ScanOutputForBeacons((config).dtor_search, req, resp);
      _0_ret = _out0;
      output = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(_0_ret, ((System.Func<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>)((_1_e) => {
        return software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.Error.create_AwsCryptographyDbEncryptionSdkDynamoDb(_1_e);
      })));
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> GetVirtualFields(SearchableEncryptionInfo_Compile._ISearchInfo search, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Wrappers_Compile._IOption<int> version)
    {
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Empty);
      if (((version).is_Some) && (((version).dtor_value) != (1))) {
        output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Failure(DdbMiddlewareConfig_Compile.__default.E(Dafny.Sequence<char>.FromString("Beacon Version Number must be '1'")));
        return output;
      }
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_ret;
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
      _out0 = DynamoDBSupport_Compile.__default.GetVirtualFields((search).curr(), item);
      _0_ret = _out0;
      output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(_0_ret, ((System.Func<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>)((_1_e) => {
        return software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.Error.create_AwsCryptographyDbEncryptionSdkDynamoDb(_1_e);
      })));
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> GetCompoundBeacons(SearchableEncryptionInfo_Compile._ISearchInfo search, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> item, Wrappers_Compile._IOption<int> version)
    {
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Empty);
      if (((version).is_Some) && (((version).dtor_value) != (1))) {
        output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Failure(DdbMiddlewareConfig_Compile.__default.E(Dafny.Sequence<char>.FromString("Beacon Version Number must be '1'")));
        return output;
      }
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _0_ret;
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out0;
      _out0 = DynamoDBSupport_Compile.__default.GetCompoundBeacons((search).curr(), item);
      _0_ret = _out0;
      output = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(_0_ret, ((System.Func<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>)((_1_e) => {
        return software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.Error.create_AwsCryptographyDbEncryptionSdkDynamoDb(_1_e);
      })));
      return output;
      return output;
    }
    public static Dafny.ISequence<byte> HierarchicalKeyringId { get {
      return UTF8.__default.EncodeAscii(Dafny.Sequence<char>.FromString("aws-kms-hierarchy"));
    } }
  }
} // end of namespace DynamoDbMiddlewareSupport_Compile
namespace PutItemTransform_Compile {

  public partial class __default {
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> Input(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      if (DdbMiddlewareConfig_Compile.__default.IsPlainWrite(config, ((input).dtor_sdkInput).dtor_TableName)) {
        output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.PutItemInputTransformOutput.create((input).dtor_sdkInput));
        return output;
      }
      DdbMiddlewareConfig_Compile._ITableConfig _0_tableConfig;
      _0_tableConfig = Dafny.Map<Dafny.ISequence<char>, DdbMiddlewareConfig_Compile._ITableConfig>.Select((config).dtor_tableEncryptionConfigs,((input).dtor_sdkInput).dtor_TableName);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _1_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default();
      _1_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(DynamoDbMiddlewareSupport_Compile.__default.NoMap<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IExpectedAttributeValue>(((input).dtor_sdkInput).dtor_Expected), DdbMiddlewareConfig_Compile.__default.E(Dafny.Sequence<char>.FromString("Legacy parameter 'Expected' not supported in PutItem with Encryption.")));
      if ((_1_valueOrError0).IsFailure()) {
        output = (_1_valueOrError0).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformOutput>();
        return output;
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _2_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default();
      _2_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>((((input).dtor_sdkInput).dtor_ConditionalOperator).is_None, DdbMiddlewareConfig_Compile.__default.E(Dafny.Sequence<char>.FromString("Legacy parameter 'ConditionalOperator' not supported in PutItem with Encryption.")));
      if ((_2_valueOrError1).IsFailure()) {
        output = (_2_valueOrError1).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformOutput>();
        return output;
      }
      Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _3_valueOrError2 = Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(false);
      _3_valueOrError2 = DynamoDbMiddlewareSupport_Compile.__default.IsWriteable(_0_tableConfig, ((input).dtor_sdkInput).dtor_Item);
      if ((_3_valueOrError2).IsFailure()) {
        output = (_3_valueOrError2).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformOutput>();
        return output;
      }
      bool _4___v0;
      _4___v0 = (_3_valueOrError2).Extract();
      Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _5_valueOrError3 = Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(false);
      _5_valueOrError3 = DynamoDbMiddlewareSupport_Compile.__default.TestConditionExpression(_0_tableConfig, ((input).dtor_sdkInput).dtor_ConditionExpression, ((input).dtor_sdkInput).dtor_ExpressionAttributeNames, ((input).dtor_sdkInput).dtor_ExpressionAttributeValues);
      if ((_5_valueOrError3).IsFailure()) {
        output = (_5_valueOrError3).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformOutput>();
        return output;
      }
      bool _6___v1;
      _6___v1 = (_5_valueOrError3).Extract();
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _7_valueOrError4 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = DynamoDbMiddlewareSupport_Compile.__default.AddSignedBeacons(_0_tableConfig, ((input).dtor_sdkInput).dtor_Item);
      _7_valueOrError4 = _out0;
      if ((_7_valueOrError4).IsFailure()) {
        output = (_7_valueOrError4).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformOutput>();
        return output;
      }
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _8_item;
      _8_item = (_7_valueOrError4).Extract();
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _9_encryptRes;
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _out1;
      _out1 = ((_0_tableConfig).dtor_itemEncryptor).EncryptItem(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.EncryptItemInput.create(_8_item));
      _9_encryptRes = _out1;
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _10_valueOrError5 = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.EncryptItemOutput.Default());
      _10_valueOrError5 = DdbMiddlewareConfig_Compile.__default.MapError<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput>(_9_encryptRes);
      if ((_10_valueOrError5).IsFailure()) {
        output = (_10_valueOrError5).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformOutput>();
        return output;
      }
      software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput _11_encrypted;
      _11_encrypted = (_10_valueOrError5).Extract();
      Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _12_valueOrError6 = Wrappers_Compile.Result<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(Wrappers_Compile.Option<Dafny.ISequence<char>>.Default());
      _12_valueOrError6 = DynamoDbMiddlewareSupport_Compile.__default.GetKeyIdFromHeader(_0_tableConfig, _11_encrypted);
      if ((_12_valueOrError6).IsFailure()) {
        output = (_12_valueOrError6).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformOutput>();
        return output;
      }
      Wrappers_Compile._IOption<Dafny.ISequence<char>> _13_keyId;
      _13_keyId = (_12_valueOrError6).Extract();
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _14_valueOrError7 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out2;
      _out2 = DynamoDbMiddlewareSupport_Compile.__default.GetEncryptedBeacons(_0_tableConfig, ((input).dtor_sdkInput).dtor_Item, DynamoDbEncryptionUtil_Compile.__default.MaybeFromOptionKeyId(_13_keyId));
      _14_valueOrError7 = _out2;
      if ((_14_valueOrError7).IsFailure()) {
        output = (_14_valueOrError7).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformOutput>();
        return output;
      }
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _15_beacons;
      _15_beacons = (_14_valueOrError7).Extract();
      var _pat_let_tv0 = _11_encrypted;
      var _pat_let_tv1 = _15_beacons;
      output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.PutItemInputTransformOutput.create(Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemInput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemInput>((input).dtor_sdkInput, _pat_let23_0 => Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemInput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemInput>(_pat_let23_0, _16_dt__update__tmp_h0 => Dafny.Helpers.Let<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemInput>(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Merge((_pat_let_tv0).dtor_encryptedItem, _pat_let_tv1), _pat_let24_0 => Dafny.Helpers.Let<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemInput>(_pat_let24_0, _17_dt__update_hItem_h0 => software.amazon.cryptography.services.dynamodb.internaldafny.types.PutItemInput.create((_16_dt__update__tmp_h0).dtor_TableName, _17_dt__update_hItem_h0, (_16_dt__update__tmp_h0).dtor_Expected, (_16_dt__update__tmp_h0).dtor_ReturnValues, (_16_dt__update__tmp_h0).dtor_ReturnConsumedCapacity, (_16_dt__update__tmp_h0).dtor_ReturnItemCollectionMetrics, (_16_dt__update__tmp_h0).dtor_ConditionalOperator, (_16_dt__update__tmp_h0).dtor_ConditionExpression, (_16_dt__update__tmp_h0).dtor_ExpressionAttributeNames, (_16_dt__update__tmp_h0).dtor_ExpressionAttributeValues)))))));
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> Output(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.PutItemOutputTransformOutput.Default());
      Dafny.ISequence<char> _0_tableName;
      _0_tableName = ((input).dtor_originalInput).dtor_TableName;
      if ((!((config).dtor_tableEncryptionConfigs).Contains(_0_tableName)) || (DynamoDbMiddlewareSupport_Compile.__default.NoMap<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>(((input).dtor_sdkOutput).dtor_Attributes))) {
        output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.PutItemOutputTransformOutput.create((input).dtor_sdkOutput));
        return output;
      }
      DdbMiddlewareConfig_Compile._ITableConfig _1_tableConfig;
      _1_tableConfig = Dafny.Map<Dafny.ISequence<char>, DdbMiddlewareConfig_Compile._ITableConfig>.Select((config).dtor_tableEncryptionConfigs,_0_tableName);
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _2_decryptRes;
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _out0;
      _out0 = ((_1_tableConfig).dtor_itemEncryptor).DecryptItem(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.DecryptItemInput.create((((input).dtor_sdkOutput).dtor_Attributes).dtor_value));
      _2_decryptRes = _out0;
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _3_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.DecryptItemOutput.Default());
      _3_valueOrError0 = DdbMiddlewareConfig_Compile.__default.MapError<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput>(_2_decryptRes);
      if ((_3_valueOrError0).IsFailure()) {
        output = (_3_valueOrError0).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemOutputTransformOutput>();
        return output;
      }
      software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput _4_decrypted;
      _4_decrypted = (_3_valueOrError0).Extract();
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _5_valueOrError1 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
      _5_valueOrError1 = DynamoDbMiddlewareSupport_Compile.__default.RemoveBeacons(_1_tableConfig, (_4_decrypted).dtor_plaintextItem);
      if ((_5_valueOrError1).IsFailure()) {
        output = (_5_valueOrError1).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemOutputTransformOutput>();
        return output;
      }
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _6_item;
      _6_item = (_5_valueOrError1).Extract();
      var _pat_let_tv0 = _6_item;
      output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.PutItemOutputTransformOutput.create(Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemOutput>((input).dtor_sdkOutput, _pat_let25_0 => Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemOutput>(_pat_let25_0, _7_dt__update__tmp_h0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemOutput>(Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.create_Some(_pat_let_tv0), _pat_let26_0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutItemOutput>(_pat_let26_0, _8_dt__update_hAttributes_h0 => software.amazon.cryptography.services.dynamodb.internaldafny.types.PutItemOutput.create(_8_dt__update_hAttributes_h0, (_7_dt__update__tmp_h0).dtor_ConsumedCapacity, (_7_dt__update__tmp_h0).dtor_ItemCollectionMetrics)))))));
      return output;
      return output;
    }
  }
} // end of namespace PutItemTransform_Compile
namespace GetItemTransform_Compile {

  public partial class __default {
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> Input(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.GetItemInputTransformOutput.create((input).dtor_sdkInput));
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> Output(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.GetItemOutputTransformOutput.Default());
      Dafny.ISequence<char> _0_tableName;
      _0_tableName = ((input).dtor_originalInput).dtor_TableName;
      if ((!((config).dtor_tableEncryptionConfigs).Contains(_0_tableName)) || (DynamoDbMiddlewareSupport_Compile.__default.NoMap<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>(((input).dtor_sdkOutput).dtor_Item))) {
        output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.GetItemOutputTransformOutput.create((input).dtor_sdkOutput));
        return output;
      }
      DdbMiddlewareConfig_Compile._ITableConfig _1_tableConfig;
      _1_tableConfig = Dafny.Map<Dafny.ISequence<char>, DdbMiddlewareConfig_Compile._ITableConfig>.Select((config).dtor_tableEncryptionConfigs,_0_tableName);
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _2_decryptRes;
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _out0;
      _out0 = ((_1_tableConfig).dtor_itemEncryptor).DecryptItem(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.DecryptItemInput.create((((input).dtor_sdkOutput).dtor_Item).dtor_value));
      _2_decryptRes = _out0;
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _3_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.DecryptItemOutput.Default());
      _3_valueOrError0 = DdbMiddlewareConfig_Compile.__default.MapError<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput>(_2_decryptRes);
      if ((_3_valueOrError0).IsFailure()) {
        output = (_3_valueOrError0).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemOutputTransformOutput>();
        return output;
      }
      software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput _4_decrypted;
      _4_decrypted = (_3_valueOrError0).Extract();
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _5_valueOrError1 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
      _5_valueOrError1 = DynamoDbMiddlewareSupport_Compile.__default.RemoveBeacons(_1_tableConfig, (_4_decrypted).dtor_plaintextItem);
      if ((_5_valueOrError1).IsFailure()) {
        output = (_5_valueOrError1).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemOutputTransformOutput>();
        return output;
      }
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _6_item;
      _6_item = (_5_valueOrError1).Extract();
      var _pat_let_tv0 = _6_item;
      output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.GetItemOutputTransformOutput.create(Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput>((input).dtor_sdkOutput, _pat_let27_0 => Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput>(_pat_let27_0, _7_dt__update__tmp_h0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput>(Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.create_Some(_pat_let_tv0), _pat_let28_0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IGetItemOutput>(_pat_let28_0, _8_dt__update_hItem_h0 => software.amazon.cryptography.services.dynamodb.internaldafny.types.GetItemOutput.create(_8_dt__update_hItem_h0, (_7_dt__update__tmp_h0).dtor_ConsumedCapacity)))))));
      return output;
      return output;
    }
  }
} // end of namespace GetItemTransform_Compile
namespace UpdateItemTransform_Compile {

  public partial class __default {
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> Input(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      if (((config).dtor_tableEncryptionConfigs).Contains(((input).dtor_sdkInput).dtor_TableName)) {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default();
        _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(DynamoDbMiddlewareSupport_Compile.__default.NoMap<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IExpectedAttributeValue>(((input).dtor_sdkInput).dtor_Expected), DdbMiddlewareConfig_Compile.__default.E(Dafny.Sequence<char>.FromString("Legacy parameter 'Expected' not supported in UpdateItem with Encryption")));
        if ((_0_valueOrError0).IsFailure()) {
          output = (_0_valueOrError0).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemInputTransformOutput>();
          return output;
        }
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _1_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default();
        _1_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(DynamoDbMiddlewareSupport_Compile.__default.NoMap<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValueUpdate>(((input).dtor_sdkInput).dtor_AttributeUpdates), DdbMiddlewareConfig_Compile.__default.E(Dafny.Sequence<char>.FromString("Legacy parameter 'AttributeUpdates' not supported in UpdateItem with Encryption")));
        if ((_1_valueOrError1).IsFailure()) {
          output = (_1_valueOrError1).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemInputTransformOutput>();
          return output;
        }
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _2_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default();
        _2_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>((((input).dtor_sdkInput).dtor_ConditionalOperator).is_None, DdbMiddlewareConfig_Compile.__default.E(Dafny.Sequence<char>.FromString("Legacy parameter 'ConditionalOperator' not supported in UpdateItem with Encryption")));
        if ((_2_valueOrError2).IsFailure()) {
          output = (_2_valueOrError2).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemInputTransformOutput>();
          return output;
        }
        DdbMiddlewareConfig_Compile._ITableConfig _3_tableConfig;
        _3_tableConfig = Dafny.Map<Dafny.ISequence<char>, DdbMiddlewareConfig_Compile._ITableConfig>.Select((config).dtor_tableEncryptionConfigs,((input).dtor_sdkInput).dtor_TableName);
        Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _4_valueOrError3 = Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(false);
        _4_valueOrError3 = DynamoDbMiddlewareSupport_Compile.__default.TestUpdateExpression(_3_tableConfig, ((input).dtor_sdkInput).dtor_UpdateExpression, ((input).dtor_sdkInput).dtor_ExpressionAttributeNames, ((input).dtor_sdkInput).dtor_ExpressionAttributeValues);
        if ((_4_valueOrError3).IsFailure()) {
          output = (_4_valueOrError3).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemInputTransformOutput>();
          return output;
        }
        bool _5___v0;
        _5___v0 = (_4_valueOrError3).Extract();
      }
      output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.UpdateItemInputTransformOutput.create((input).dtor_sdkInput));
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> Output(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.UpdateItemOutputTransformOutput.Default());
      Dafny.ISequence<char> _0_tableName;
      _0_tableName = ((input).dtor_originalInput).dtor_TableName;
      if ((!((config).dtor_tableEncryptionConfigs).Contains(_0_tableName)) || (DynamoDbMiddlewareSupport_Compile.__default.NoMap<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>(((input).dtor_sdkOutput).dtor_Attributes))) {
        output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.UpdateItemOutputTransformOutput.create((input).dtor_sdkOutput));
        return output;
      }
      DdbMiddlewareConfig_Compile._ITableConfig _1_tableConfig;
      _1_tableConfig = Dafny.Map<Dafny.ISequence<char>, DdbMiddlewareConfig_Compile._ITableConfig>.Select((config).dtor_tableEncryptionConfigs,_0_tableName);
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _2_attributes;
      _2_attributes = (((input).dtor_sdkOutput).dtor_Attributes).dtor_value;
      if (!(((((input).dtor_originalInput).dtor_ReturnValues).is_Some) && ((((((input).dtor_originalInput).dtor_ReturnValues).dtor_value).is_ALL__NEW) || (((((input).dtor_originalInput).dtor_ReturnValues).dtor_value).is_ALL__OLD)))) {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _3_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default();
        _3_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(Dafny.Helpers.Id<Func<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, DdbMiddlewareConfig_Compile._ITableConfig, bool>>((_4_attributes, _5_tableConfig) => Dafny.Helpers.Quantifier<Dafny.ISequence<char>>(((_4_attributes).Keys).Elements, true, (((_forall_var_0) => {
          Dafny.ISequence<char> _6_k = (Dafny.ISequence<char>)_forall_var_0;
          return !(((_4_attributes).Keys).Contains(_6_k)) || (!(DynamoDbMiddlewareSupport_Compile.__default.IsSigned(_5_tableConfig, _6_k)));
        }))))(_2_attributes, _1_tableConfig), DdbMiddlewareConfig_Compile.__default.E(Dafny.Sequence<char>.FromString("UpdateItems response contains signed attributes, but does not include the entire item which is required for verification.")));
        if ((_3_valueOrError0).IsFailure()) {
          output = (_3_valueOrError0).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemOutputTransformOutput>();
          return output;
        }
        output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.UpdateItemOutputTransformOutput.create((input).dtor_sdkOutput));
        return output;
      }
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _7_decryptRes;
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _out0;
      _out0 = ((_1_tableConfig).dtor_itemEncryptor).DecryptItem(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.DecryptItemInput.create(_2_attributes));
      _7_decryptRes = _out0;
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _8_valueOrError1 = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.DecryptItemOutput.Default());
      _8_valueOrError1 = DdbMiddlewareConfig_Compile.__default.MapError<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput>(_7_decryptRes);
      if ((_8_valueOrError1).IsFailure()) {
        output = (_8_valueOrError1).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemOutputTransformOutput>();
        return output;
      }
      software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput _9_decrypted;
      _9_decrypted = (_8_valueOrError1).Extract();
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _10_valueOrError2 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
      _10_valueOrError2 = DynamoDbMiddlewareSupport_Compile.__default.RemoveBeacons(_1_tableConfig, (_9_decrypted).dtor_plaintextItem);
      if ((_10_valueOrError2).IsFailure()) {
        output = (_10_valueOrError2).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemOutputTransformOutput>();
        return output;
      }
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _11_item;
      _11_item = (_10_valueOrError2).Extract();
      var _pat_let_tv0 = _11_item;
      output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.UpdateItemOutputTransformOutput.create(Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemOutput>((input).dtor_sdkOutput, _pat_let29_0 => Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemOutput>(_pat_let29_0, _12_dt__update__tmp_h0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemOutput>(Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.create_Some(_pat_let_tv0), _pat_let30_0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IUpdateItemOutput>(_pat_let30_0, _13_dt__update_hAttributes_h0 => software.amazon.cryptography.services.dynamodb.internaldafny.types.UpdateItemOutput.create(_13_dt__update_hAttributes_h0, (_12_dt__update__tmp_h0).dtor_ConsumedCapacity, (_12_dt__update__tmp_h0).dtor_ItemCollectionMetrics)))))));
      return output;
      return output;
    }
  }
} // end of namespace UpdateItemTransform_Compile
namespace BatchWriteItemTransform_Compile {

  public partial class __default {
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> Input(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      Dafny.ISet<Dafny.ISequence<char>> _0_tableNames;
      _0_tableNames = (((input).dtor_sdkInput).dtor_RequestItems).Keys;
      Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IWriteRequest>> _1_result;
      _1_result = Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IWriteRequest>>.FromElements();
      Dafny.ISequence<Dafny.ISequence<char>> _2_tableNamesSeq;
      Dafny.ISequence<Dafny.ISequence<char>> _out0;
      _out0 = SortedSets.__default.SetToSequence<Dafny.ISequence<char>>(_0_tableNames);
      _2_tableNamesSeq = _out0;
      BigInteger _3_i;
      _3_i = BigInteger.Zero;
      while ((_3_i) < (new BigInteger((_2_tableNamesSeq).Count))) {
        Dafny.ISequence<char> _4_tableName;
        _4_tableName = (_2_tableNamesSeq).Select(_3_i);
        Dafny.ISequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IWriteRequest> _5_writeRequests;
        _5_writeRequests = Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IWriteRequest>>.Select(((input).dtor_sdkInput).dtor_RequestItems,_4_tableName);
        if (!(DdbMiddlewareConfig_Compile.__default.IsPlainWrite(config, _4_tableName))) {
          DdbMiddlewareConfig_Compile._ITableConfig _6_tableConfig;
          _6_tableConfig = Dafny.Map<Dafny.ISequence<char>, DdbMiddlewareConfig_Compile._ITableConfig>.Select((config).dtor_tableEncryptionConfigs,_4_tableName);
          Dafny.ISequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IWriteRequest> _7_encryptedItems;
          _7_encryptedItems = Dafny.Sequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IWriteRequest>.FromElements();
          BigInteger _hi0 = new BigInteger((_5_writeRequests).Count);
          for (BigInteger _8_x = BigInteger.Zero; _8_x < _hi0; _8_x++) {
            software.amazon.cryptography.services.dynamodb.internaldafny.types._IWriteRequest _9_req;
            _9_req = (_5_writeRequests).Select(_8_x);
            if (((_9_req).dtor_PutRequest).is_None) {
              _7_encryptedItems = Dafny.Sequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IWriteRequest>.Concat(_7_encryptedItems, Dafny.Sequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IWriteRequest>.FromElements(_9_req));
            } else {
              Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _10_valueOrError0 = Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(false);
              _10_valueOrError0 = DynamoDbMiddlewareSupport_Compile.__default.IsWriteable(_6_tableConfig, (((_9_req).dtor_PutRequest).dtor_value).dtor_Item);
              if ((_10_valueOrError0).IsFailure()) {
                output = (_10_valueOrError0).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemInputTransformOutput>();
                return output;
              }
              bool _11___v0;
              _11___v0 = (_10_valueOrError0).Extract();
              Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _12_valueOrError1 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
              Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out1;
              _out1 = DynamoDbMiddlewareSupport_Compile.__default.AddSignedBeacons(_6_tableConfig, (((_9_req).dtor_PutRequest).dtor_value).dtor_Item);
              _12_valueOrError1 = _out1;
              if ((_12_valueOrError1).IsFailure()) {
                output = (_12_valueOrError1).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemInputTransformOutput>();
                return output;
              }
              Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _13_item;
              _13_item = (_12_valueOrError1).Extract();
              Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _14_encryptRes;
              Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _out2;
              _out2 = ((_6_tableConfig).dtor_itemEncryptor).EncryptItem(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.EncryptItemInput.create(_13_item));
              _14_encryptRes = _out2;
              Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _15_valueOrError2 = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.EncryptItemOutput.Default());
              _15_valueOrError2 = DdbMiddlewareConfig_Compile.__default.MapError<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput>(_14_encryptRes);
              if ((_15_valueOrError2).IsFailure()) {
                output = (_15_valueOrError2).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemInputTransformOutput>();
                return output;
              }
              software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput _16_encrypted;
              _16_encrypted = (_15_valueOrError2).Extract();
              Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _17_valueOrError3 = Wrappers_Compile.Result<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(Wrappers_Compile.Option<Dafny.ISequence<char>>.Default());
              _17_valueOrError3 = DynamoDbMiddlewareSupport_Compile.__default.GetKeyIdFromHeader(_6_tableConfig, _16_encrypted);
              if ((_17_valueOrError3).IsFailure()) {
                output = (_17_valueOrError3).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemInputTransformOutput>();
                return output;
              }
              Wrappers_Compile._IOption<Dafny.ISequence<char>> _18_keyId;
              _18_keyId = (_17_valueOrError3).Extract();
              Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _19_valueOrError4 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
              Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out3;
              _out3 = DynamoDbMiddlewareSupport_Compile.__default.GetEncryptedBeacons(_6_tableConfig, (((_9_req).dtor_PutRequest).dtor_value).dtor_Item, DynamoDbEncryptionUtil_Compile.__default.MaybeFromOptionKeyId(_18_keyId));
              _19_valueOrError4 = _out3;
              if ((_19_valueOrError4).IsFailure()) {
                output = (_19_valueOrError4).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemInputTransformOutput>();
                return output;
              }
              Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _20_beaconAttrs;
              _20_beaconAttrs = (_19_valueOrError4).Extract();
              var _pat_let_tv0 = _16_encrypted;
              var _pat_let_tv1 = _20_beaconAttrs;
              _7_encryptedItems = Dafny.Sequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IWriteRequest>.Concat(_7_encryptedItems, Dafny.Sequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IWriteRequest>.FromElements(Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._IWriteRequest, software.amazon.cryptography.services.dynamodb.internaldafny.types._IWriteRequest>(_9_req, _pat_let31_0 => Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._IWriteRequest, software.amazon.cryptography.services.dynamodb.internaldafny.types._IWriteRequest>(_pat_let31_0, _21_dt__update__tmp_h0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutRequest>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IWriteRequest>(Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutRequest>.create_Some(software.amazon.cryptography.services.dynamodb.internaldafny.types.PutRequest.create(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Merge((_pat_let_tv0).dtor_encryptedItem, _pat_let_tv1))), _pat_let32_0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IPutRequest>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IWriteRequest>(_pat_let32_0, _22_dt__update_hPutRequest_h0 => software.amazon.cryptography.services.dynamodb.internaldafny.types.WriteRequest.create(_22_dt__update_hPutRequest_h0, (_21_dt__update__tmp_h0).dtor_DeleteRequest)))))));
            }
          }
          _5_writeRequests = _7_encryptedItems;
        }
        _3_i = (_3_i) + (BigInteger.One);
        _1_result = Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IWriteRequest>>.Update(_1_result, _4_tableName, _5_writeRequests);
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _23_valueOrError5 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default();
      _23_valueOrError5 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>((new BigInteger((_1_result).Count)) == (new BigInteger((((input).dtor_sdkInput).dtor_RequestItems).Count)), DdbMiddlewareConfig_Compile.__default.E(Dafny.Sequence<char>.FromString("Internal Error")));
      if ((_23_valueOrError5).IsFailure()) {
        output = (_23_valueOrError5).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemInputTransformOutput>();
        return output;
      }
      var _pat_let_tv2 = _1_result;
      output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchWriteItemInputTransformOutput.create(Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemInput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemInput>((input).dtor_sdkInput, _pat_let33_0 => Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemInput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemInput>(_pat_let33_0, _24_dt__update__tmp_h1 => Dafny.Helpers.Let<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IWriteRequest>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemInput>(_pat_let_tv2, _pat_let34_0 => Dafny.Helpers.Let<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IWriteRequest>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchWriteItemInput>(_pat_let34_0, _25_dt__update_hRequestItems_h0 => software.amazon.cryptography.services.dynamodb.internaldafny.types.BatchWriteItemInput.create(_25_dt__update_hRequestItems_h0, (_24_dt__update__tmp_h1).dtor_ReturnConsumedCapacity, (_24_dt__update__tmp_h1).dtor_ReturnItemCollectionMetrics)))))));
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> Output(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchWriteItemOutputTransformOutput.Default());
      output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchWriteItemOutputTransformOutput.create((input).dtor_sdkOutput));
      return output;
      return output;
    }
  }
} // end of namespace BatchWriteItemTransform_Compile
namespace TransactWriteItemsTransform_Compile {

  public partial class __default {
    public static bool IsValid(software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItem item) {
      return (((((item).dtor_Put).is_Some) || (((item).dtor_Update).is_Some)) || (((item).dtor_Delete).is_Some)) || (((item).dtor_ConditionCheck).is_Some);
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> Input(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default();
      _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(Dafny.Helpers.Id<Func<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformInput, bool>>((_1_input) => Dafny.Helpers.Quantifier<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItem>((((_1_input).dtor_sdkInput).dtor_TransactItems).UniqueElements, true, (((_forall_var_0) => {
        software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItem _2_item = (software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItem)_forall_var_0;
        return !((((_1_input).dtor_sdkInput).dtor_TransactItems).Contains(_2_item)) || (TransactWriteItemsTransform_Compile.__default.IsValid(_2_item));
      }))))(input), DdbMiddlewareConfig_Compile.__default.E(Dafny.Sequence<char>.FromString("Each item in TransactWriteItems must specify at least one supported operation")));
      if ((_0_valueOrError0).IsFailure()) {
        output = (_0_valueOrError0).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformOutput>();
        return output;
      }
      Dafny.ISequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItem> _3_result;
      _3_result = Dafny.Sequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItem>.FromElements();
      BigInteger _hi0 = new BigInteger((((input).dtor_sdkInput).dtor_TransactItems).Count);
      for (BigInteger _4_x = BigInteger.Zero; _4_x < _hi0; _4_x++) {
        software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItem _5_item;
        _5_item = (((input).dtor_sdkInput).dtor_TransactItems).Select(_4_x);
        if ((((_5_item).dtor_ConditionCheck).is_Some) && (((config).dtor_tableEncryptionConfigs).Contains((((_5_item).dtor_ConditionCheck).dtor_value).dtor_TableName))) {
          DdbMiddlewareConfig_Compile._ITableConfig _6_tableConfig;
          _6_tableConfig = Dafny.Map<Dafny.ISequence<char>, DdbMiddlewareConfig_Compile._ITableConfig>.Select((config).dtor_tableEncryptionConfigs,(((_5_item).dtor_ConditionCheck).dtor_value).dtor_TableName);
          Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _7_valueOrError1 = Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(false);
          _7_valueOrError1 = DynamoDbMiddlewareSupport_Compile.__default.TestConditionExpression(_6_tableConfig, Wrappers_Compile.Option<Dafny.ISequence<char>>.create_Some((((_5_item).dtor_ConditionCheck).dtor_value).dtor_ConditionExpression), (((_5_item).dtor_ConditionCheck).dtor_value).dtor_ExpressionAttributeNames, (((_5_item).dtor_ConditionCheck).dtor_value).dtor_ExpressionAttributeValues);
          if ((_7_valueOrError1).IsFailure()) {
            output = (_7_valueOrError1).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformOutput>();
            return output;
          }
          bool _8___v0;
          _8___v0 = (_7_valueOrError1).Extract();
        }
        if ((((_5_item).dtor_Delete).is_Some) && (((config).dtor_tableEncryptionConfigs).Contains((((_5_item).dtor_Delete).dtor_value).dtor_TableName))) {
          DdbMiddlewareConfig_Compile._ITableConfig _9_tableConfig;
          _9_tableConfig = Dafny.Map<Dafny.ISequence<char>, DdbMiddlewareConfig_Compile._ITableConfig>.Select((config).dtor_tableEncryptionConfigs,(((_5_item).dtor_Delete).dtor_value).dtor_TableName);
          Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _10_valueOrError2 = Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(false);
          _10_valueOrError2 = DynamoDbMiddlewareSupport_Compile.__default.TestConditionExpression(_9_tableConfig, (((_5_item).dtor_Delete).dtor_value).dtor_ConditionExpression, (((_5_item).dtor_Delete).dtor_value).dtor_ExpressionAttributeNames, (((_5_item).dtor_Delete).dtor_value).dtor_ExpressionAttributeValues);
          if ((_10_valueOrError2).IsFailure()) {
            output = (_10_valueOrError2).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformOutput>();
            return output;
          }
          bool _11___v1;
          _11___v1 = (_10_valueOrError2).Extract();
        }
        if ((((_5_item).dtor_Update).is_Some) && (((config).dtor_tableEncryptionConfigs).Contains((((_5_item).dtor_Update).dtor_value).dtor_TableName))) {
          DdbMiddlewareConfig_Compile._ITableConfig _12_tableConfig;
          _12_tableConfig = Dafny.Map<Dafny.ISequence<char>, DdbMiddlewareConfig_Compile._ITableConfig>.Select((config).dtor_tableEncryptionConfigs,(((_5_item).dtor_Update).dtor_value).dtor_TableName);
          Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _13_valueOrError3 = Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(false);
          _13_valueOrError3 = DynamoDbMiddlewareSupport_Compile.__default.TestUpdateExpression(_12_tableConfig, Wrappers_Compile.Option<Dafny.ISequence<char>>.create_Some((((_5_item).dtor_Update).dtor_value).dtor_UpdateExpression), (((_5_item).dtor_Update).dtor_value).dtor_ExpressionAttributeNames, (((_5_item).dtor_Update).dtor_value).dtor_ExpressionAttributeValues);
          if ((_13_valueOrError3).IsFailure()) {
            output = (_13_valueOrError3).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformOutput>();
            return output;
          }
          bool _14___v2;
          _14___v2 = (_13_valueOrError3).Extract();
          Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _15_valueOrError4 = Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(false);
          _15_valueOrError4 = DynamoDbMiddlewareSupport_Compile.__default.TestConditionExpression(_12_tableConfig, (((_5_item).dtor_Update).dtor_value).dtor_ConditionExpression, (((_5_item).dtor_Update).dtor_value).dtor_ExpressionAttributeNames, (((_5_item).dtor_Update).dtor_value).dtor_ExpressionAttributeValues);
          if ((_15_valueOrError4).IsFailure()) {
            output = (_15_valueOrError4).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformOutput>();
            return output;
          }
          bool _16___v3;
          _16___v3 = (_15_valueOrError4).Extract();
        }
        if ((((_5_item).dtor_Put).is_Some) && (!(DdbMiddlewareConfig_Compile.__default.IsPlainWrite(config, (((_5_item).dtor_Put).dtor_value).dtor_TableName)))) {
          DdbMiddlewareConfig_Compile._ITableConfig _17_tableConfig;
          _17_tableConfig = Dafny.Map<Dafny.ISequence<char>, DdbMiddlewareConfig_Compile._ITableConfig>.Select((config).dtor_tableEncryptionConfigs,(((_5_item).dtor_Put).dtor_value).dtor_TableName);
          Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _18_valueOrError5 = Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(false);
          _18_valueOrError5 = DynamoDbMiddlewareSupport_Compile.__default.IsWriteable(_17_tableConfig, (((_5_item).dtor_Put).dtor_value).dtor_Item);
          if ((_18_valueOrError5).IsFailure()) {
            output = (_18_valueOrError5).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformOutput>();
            return output;
          }
          bool _19___v4;
          _19___v4 = (_18_valueOrError5).Extract();
          Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _20_valueOrError6 = Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(false);
          _20_valueOrError6 = DynamoDbMiddlewareSupport_Compile.__default.TestConditionExpression(_17_tableConfig, (((_5_item).dtor_Put).dtor_value).dtor_ConditionExpression, (((_5_item).dtor_Put).dtor_value).dtor_ExpressionAttributeNames, (((_5_item).dtor_Put).dtor_value).dtor_ExpressionAttributeValues);
          if ((_20_valueOrError6).IsFailure()) {
            output = (_20_valueOrError6).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformOutput>();
            return output;
          }
          bool _21___v5;
          _21___v5 = (_20_valueOrError6).Extract();
          Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _22_valueOrError7 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
          Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
          _out0 = DynamoDbMiddlewareSupport_Compile.__default.AddSignedBeacons(_17_tableConfig, (((_5_item).dtor_Put).dtor_value).dtor_Item);
          _22_valueOrError7 = _out0;
          if ((_22_valueOrError7).IsFailure()) {
            output = (_22_valueOrError7).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformOutput>();
            return output;
          }
          Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _23_beaconItem;
          _23_beaconItem = (_22_valueOrError7).Extract();
          Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _24_encryptRes;
          Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _out1;
          _out1 = ((_17_tableConfig).dtor_itemEncryptor).EncryptItem(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.EncryptItemInput.create(_23_beaconItem));
          _24_encryptRes = _out1;
          Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _25_valueOrError8 = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.EncryptItemOutput.Default());
          _25_valueOrError8 = DdbMiddlewareConfig_Compile.__default.MapError<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput>(_24_encryptRes);
          if ((_25_valueOrError8).IsFailure()) {
            output = (_25_valueOrError8).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformOutput>();
            return output;
          }
          software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IEncryptItemOutput _26_encrypted;
          _26_encrypted = (_25_valueOrError8).Extract();
          Wrappers_Compile._IResult<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _27_valueOrError9 = Wrappers_Compile.Result<Wrappers_Compile._IOption<Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(Wrappers_Compile.Option<Dafny.ISequence<char>>.Default());
          _27_valueOrError9 = DynamoDbMiddlewareSupport_Compile.__default.GetKeyIdFromHeader(_17_tableConfig, _26_encrypted);
          if ((_27_valueOrError9).IsFailure()) {
            output = (_27_valueOrError9).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformOutput>();
            return output;
          }
          Wrappers_Compile._IOption<Dafny.ISequence<char>> _28_keyId;
          _28_keyId = (_27_valueOrError9).Extract();
          Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _29_valueOrError10 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
          Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out2;
          _out2 = DynamoDbMiddlewareSupport_Compile.__default.GetEncryptedBeacons(_17_tableConfig, (((_5_item).dtor_Put).dtor_value).dtor_Item, DynamoDbEncryptionUtil_Compile.__default.MaybeFromOptionKeyId(_28_keyId));
          _29_valueOrError10 = _out2;
          if ((_29_valueOrError10).IsFailure()) {
            output = (_29_valueOrError10).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformOutput>();
            return output;
          }
          Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _30_beaconAttrs;
          _30_beaconAttrs = (_29_valueOrError10).Extract();
          var _pat_let_tv0 = _26_encrypted;
          var _pat_let_tv1 = _30_beaconAttrs;
          Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IPut> _31_put;
          _31_put = Wrappers_Compile.Option<software.amazon.cryptography.services.dynamodb.internaldafny.types._IPut>.create_Some(Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._IPut, software.amazon.cryptography.services.dynamodb.internaldafny.types._IPut>(((_5_item).dtor_Put).dtor_value, _pat_let35_0 => Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._IPut, software.amazon.cryptography.services.dynamodb.internaldafny.types._IPut>(_pat_let35_0, _32_dt__update__tmp_h0 => Dafny.Helpers.Let<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IPut>(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Merge((_pat_let_tv0).dtor_encryptedItem, _pat_let_tv1), _pat_let36_0 => Dafny.Helpers.Let<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IPut>(_pat_let36_0, _33_dt__update_hItem_h0 => software.amazon.cryptography.services.dynamodb.internaldafny.types.Put.create(_33_dt__update_hItem_h0, (_32_dt__update__tmp_h0).dtor_TableName, (_32_dt__update__tmp_h0).dtor_ConditionExpression, (_32_dt__update__tmp_h0).dtor_ExpressionAttributeNames, (_32_dt__update__tmp_h0).dtor_ExpressionAttributeValues, (_32_dt__update__tmp_h0).dtor_ReturnValuesOnConditionCheckFailure))))));
          software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItem _34_newItem;
          software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItem _35_dt__update__tmp_h1 = _5_item;
          Wrappers_Compile._IOption<software.amazon.cryptography.services.dynamodb.internaldafny.types._IPut> _36_dt__update_hPut_h0 = _31_put;
          _34_newItem = software.amazon.cryptography.services.dynamodb.internaldafny.types.TransactWriteItem.create((_35_dt__update__tmp_h1).dtor_ConditionCheck, _36_dt__update_hPut_h0, (_35_dt__update__tmp_h1).dtor_Delete, (_35_dt__update__tmp_h1).dtor_Update);
          _3_result = Dafny.Sequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItem>.Concat(_3_result, Dafny.Sequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItem>.FromElements(_34_newItem));
        } else {
          _3_result = Dafny.Sequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItem>.Concat(_3_result, Dafny.Sequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItem>.FromElements(_5_item));
        }
      }
      Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _37_valueOrError11 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default();
      _37_valueOrError11 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>((new BigInteger((((input).dtor_sdkInput).dtor_TransactItems).Count)) == (new BigInteger((_3_result).Count)), DdbMiddlewareConfig_Compile.__default.E(Dafny.Sequence<char>.FromString("")));
      if ((_37_valueOrError11).IsFailure()) {
        output = (_37_valueOrError11).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformOutput>();
        return output;
      }
      var _pat_let_tv2 = _3_result;
      output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.TransactWriteItemsInputTransformOutput.create(Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsInput, software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsInput>((input).dtor_sdkInput, _pat_let37_0 => Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsInput, software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsInput>(_pat_let37_0, _38_dt__update__tmp_h2 => Dafny.Helpers.Let<Dafny.ISequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItem>, software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsInput>(_pat_let_tv2, _pat_let38_0 => Dafny.Helpers.Let<Dafny.ISequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItem>, software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsInput>(_pat_let38_0, _39_dt__update_hTransactItems_h0 => software.amazon.cryptography.services.dynamodb.internaldafny.types.TransactWriteItemsInput.create(_39_dt__update_hTransactItems_h0, (_38_dt__update__tmp_h2).dtor_ReturnConsumedCapacity, (_38_dt__update__tmp_h2).dtor_ReturnItemCollectionMetrics, (_38_dt__update__tmp_h2).dtor_ClientRequestToken)))))));
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> Output(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.TransactWriteItemsOutputTransformOutput.Default());
      software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactWriteItemsOutput _0_finalResult;
      _0_finalResult = (input).dtor_sdkOutput;
      output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.TransactWriteItemsOutputTransformOutput.create(_0_finalResult));
      return output;
      return output;
    }
  }
} // end of namespace TransactWriteItemsTransform_Compile
namespace BatchGetItemTransform_Compile {

  public partial class __default {
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> Input(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchGetItemInputTransformOutput.create((input).dtor_sdkInput));
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> Output(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchGetItemOutputTransformOutput.Default());
      if (DynamoDbMiddlewareSupport_Compile.__default.NoMap<Dafny.ISequence<char>, Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>(((input).dtor_sdkOutput).dtor_Responses)) {
        output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchGetItemOutputTransformOutput.create((input).dtor_sdkOutput));
        return output;
      }
      Dafny.ISet<Dafny.ISequence<char>> _0_tableNames;
      _0_tableNames = ((((input).dtor_sdkOutput).dtor_Responses).dtor_value).Keys;
      Dafny.ISequence<Dafny.ISequence<char>> _1_tableNamesSeq;
      Dafny.ISequence<Dafny.ISequence<char>> _out0;
      _out0 = SortedSets.__default.SetToSequence<Dafny.ISequence<char>>(_0_tableNames);
      _1_tableNamesSeq = _out0;
      BigInteger _2_i;
      _2_i = BigInteger.Zero;
      Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>> _3_result;
      _3_result = Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>.FromElements();
      while ((_2_i) < (new BigInteger((_1_tableNamesSeq).Count))) {
        Dafny.ISequence<char> _4_tableName;
        _4_tableName = (_1_tableNamesSeq).Select(_2_i);
        Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> _5_responses;
        _5_responses = Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>.Select((((input).dtor_sdkOutput).dtor_Responses).dtor_value,_4_tableName);
        if (((config).dtor_tableEncryptionConfigs).Contains(_4_tableName)) {
          DdbMiddlewareConfig_Compile._ITableConfig _6_tableConfig;
          _6_tableConfig = Dafny.Map<Dafny.ISequence<char>, DdbMiddlewareConfig_Compile._ITableConfig>.Select((config).dtor_tableEncryptionConfigs,_4_tableName);
          Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> _7_decryptedItem;
          _7_decryptedItem = Dafny.Sequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.FromElements();
          BigInteger _hi0 = new BigInteger((_5_responses).Count);
          for (BigInteger _8_x = BigInteger.Zero; _8_x < _hi0; _8_x++) {
            Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _9_decryptRes;
            Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _out1;
            _out1 = ((_6_tableConfig).dtor_itemEncryptor).DecryptItem(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.DecryptItemInput.create((_5_responses).Select(_8_x)));
            _9_decryptRes = _out1;
            Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _10_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.DecryptItemOutput.Default());
            _10_valueOrError0 = DdbMiddlewareConfig_Compile.__default.MapError<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput>(_9_decryptRes);
            if ((_10_valueOrError0).IsFailure()) {
              output = (_10_valueOrError0).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemOutputTransformOutput>();
              return output;
            }
            software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput _11_decrypted;
            _11_decrypted = (_10_valueOrError0).Extract();
            Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _12_valueOrError1 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
            _12_valueOrError1 = DynamoDbMiddlewareSupport_Compile.__default.RemoveBeacons(_6_tableConfig, (_11_decrypted).dtor_plaintextItem);
            if ((_12_valueOrError1).IsFailure()) {
              output = (_12_valueOrError1).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemOutputTransformOutput>();
              return output;
            }
            Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _13_item;
            _13_item = (_12_valueOrError1).Extract();
            _7_decryptedItem = Dafny.Sequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.Concat(_7_decryptedItem, Dafny.Sequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.FromElements(_13_item));
          }
          _3_result = Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>.Merge(_3_result, Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>.FromElements(new Dafny.Pair<Dafny.ISequence<char>, Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>(_4_tableName, _7_decryptedItem)));
        } else {
          _3_result = Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>.Merge(_3_result, Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>.FromElements(new Dafny.Pair<Dafny.ISequence<char>, Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>(_4_tableName, _5_responses)));
        }
        _2_i = (_2_i) + (BigInteger.One);
      }
      var _pat_let_tv0 = _3_result;
      output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchGetItemOutputTransformOutput.create(Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemOutput>((input).dtor_sdkOutput, _pat_let39_0 => Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemOutput>(_pat_let39_0, _14_dt__update__tmp_h0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemOutput>(Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>>.create_Some(_pat_let_tv0), _pat_let40_0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IBatchGetItemOutput>(_pat_let40_0, _15_dt__update_hResponses_h0 => software.amazon.cryptography.services.dynamodb.internaldafny.types.BatchGetItemOutput.create(_15_dt__update_hResponses_h0, (_14_dt__update__tmp_h0).dtor_UnprocessedKeys, (_14_dt__update__tmp_h0).dtor_ConsumedCapacity)))))));
      return output;
      return output;
    }
  }
} // end of namespace BatchGetItemTransform_Compile
namespace ScanTransform_Compile {

  public partial class __default {
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> Input(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      if (!((config).dtor_tableEncryptionConfigs).Contains(((input).dtor_sdkInput).dtor_TableName)) {
        output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ScanInputTransformOutput.create((input).dtor_sdkInput));
        return output;
      } else {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default();
        _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(DynamoDbMiddlewareSupport_Compile.__default.NoList<Dafny.ISequence<char>>(((input).dtor_sdkInput).dtor_AttributesToGet), DdbMiddlewareConfig_Compile.__default.E(Dafny.Sequence<char>.FromString("Legacy parameter 'AttributesToGet' not supported in UpdateItem with Encryption")));
        if ((_0_valueOrError0).IsFailure()) {
          output = (_0_valueOrError0).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanInputTransformOutput>();
          return output;
        }
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _1_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default();
        _1_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(DynamoDbMiddlewareSupport_Compile.__default.NoMap<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._ICondition>(((input).dtor_sdkInput).dtor_ScanFilter), DdbMiddlewareConfig_Compile.__default.E(Dafny.Sequence<char>.FromString("Legacy parameter 'ScanFilter' not supported in UpdateItem with Encryption")));
        if ((_1_valueOrError1).IsFailure()) {
          output = (_1_valueOrError1).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanInputTransformOutput>();
          return output;
        }
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _2_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default();
        _2_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>((((input).dtor_sdkInput).dtor_ConditionalOperator).is_None, DdbMiddlewareConfig_Compile.__default.E(Dafny.Sequence<char>.FromString("Legacy parameter 'ConditionalOperator' not supported in UpdateItem with Encryption")));
        if ((_2_valueOrError2).IsFailure()) {
          output = (_2_valueOrError2).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanInputTransformOutput>();
          return output;
        }
        DdbMiddlewareConfig_Compile._ITableConfig _3_tableConfig;
        _3_tableConfig = Dafny.Map<Dafny.ISequence<char>, DdbMiddlewareConfig_Compile._ITableConfig>.Select((config).dtor_tableEncryptionConfigs,((input).dtor_sdkInput).dtor_TableName);
        Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _4_valueOrError3 = default(Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
        Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
        _out0 = DynamoDbMiddlewareSupport_Compile.__default.ScanInputForBeacons(_3_tableConfig, (input).dtor_sdkInput);
        _4_valueOrError3 = _out0;
        if ((_4_valueOrError3).IsFailure()) {
          output = (_4_valueOrError3).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanInputTransformOutput>();
          return output;
        }
        software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanInput _5_finalResult;
        _5_finalResult = (_4_valueOrError3).Extract();
        output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ScanInputTransformOutput.create(_5_finalResult));
        return output;
      }
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> Output(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ScanOutputTransformOutput.Default());
      Dafny.ISequence<char> _0_tableName;
      _0_tableName = ((input).dtor_originalInput).dtor_TableName;
      if ((!((config).dtor_tableEncryptionConfigs).Contains(_0_tableName)) || (DynamoDbMiddlewareSupport_Compile.__default.NoList<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>(((input).dtor_sdkOutput).dtor_Items))) {
        output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ScanOutputTransformOutput.create((input).dtor_sdkOutput));
        return output;
      }
      DdbMiddlewareConfig_Compile._ITableConfig _1_tableConfig;
      _1_tableConfig = Dafny.Map<Dafny.ISequence<char>, DdbMiddlewareConfig_Compile._ITableConfig>.Select((config).dtor_tableEncryptionConfigs,_0_tableName);
      Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> _2_decryptedItems;
      _2_decryptedItems = Dafny.Sequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.FromElements();
      Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> _3_encryptedItems;
      _3_encryptedItems = (((input).dtor_sdkOutput).dtor_Items).dtor_value;
      Wrappers_Compile._IResult<DynamoDbEncryptionUtil_Compile._IMaybeKeyId, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _4_valueOrError0 = Wrappers_Compile.Result<DynamoDbEncryptionUtil_Compile._IMaybeKeyId, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(DynamoDbEncryptionUtil_Compile.MaybeKeyId.Default());
      _4_valueOrError0 = DynamoDbMiddlewareSupport_Compile.__default.GetBeaconKeyId(_1_tableConfig, Wrappers_Compile.Option<Dafny.ISequence<char>>.create_None(), ((input).dtor_originalInput).dtor_FilterExpression, ((input).dtor_originalInput).dtor_ExpressionAttributeValues, ((input).dtor_originalInput).dtor_ExpressionAttributeNames);
      if ((_4_valueOrError0).IsFailure()) {
        output = (_4_valueOrError0).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanOutputTransformOutput>();
        return output;
      }
      DynamoDbEncryptionUtil_Compile._IMaybeKeyId _5_keyId;
      _5_keyId = (_4_valueOrError0).Extract();
      Dafny.ISequence<byte> _6_keyIdUtf8;
      _6_keyIdUtf8 = Dafny.Sequence<byte>.FromElements();
      if ((_5_keyId).is_KeyId) {
        Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _7_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(UTF8.ValidUTF8Bytes.Default());
        _7_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(UTF8.__default.Encode((_5_keyId).dtor_value), ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>)((_8_e) => {
          return DdbMiddlewareConfig_Compile.__default.E(_8_e);
        })));
        if ((_7_valueOrError1).IsFailure()) {
          output = (_7_valueOrError1).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanOutputTransformOutput>();
          return output;
        }
        _6_keyIdUtf8 = (_7_valueOrError1).Extract();
      }
      BigInteger _hi0 = new BigInteger((_3_encryptedItems).Count);
      for (BigInteger _9_x = BigInteger.Zero; _9_x < _hi0; _9_x++) {
        software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemInput _10_decryptInput;
        _10_decryptInput = software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.DecryptItemInput.create((_3_encryptedItems).Select(_9_x));
        Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _11_decryptRes;
        Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _out0;
        _out0 = ((_1_tableConfig).dtor_itemEncryptor).DecryptItem(_10_decryptInput);
        _11_decryptRes = _out0;
        Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _12_valueOrError2 = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.DecryptItemOutput.Default());
        _12_valueOrError2 = DdbMiddlewareConfig_Compile.__default.MapError<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput>(_11_decryptRes);
        if ((_12_valueOrError2).IsFailure()) {
          output = (_12_valueOrError2).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanOutputTransformOutput>();
          return output;
        }
        software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput _13_decrypted;
        _13_decrypted = (_12_valueOrError2).Extract();
        if (((_5_keyId).is_KeyId) && (((_13_decrypted).dtor_parsedHeader).is_Some)) {
          Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _14_valueOrError3 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default();
          _14_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>((new BigInteger(((((_13_decrypted).dtor_parsedHeader).dtor_value).dtor_encryptedDataKeys).Count)) == (BigInteger.One), DdbMiddlewareConfig_Compile.__default.E(Dafny.Sequence<char>.FromString("Scan result has more than one Encrypted Data Key")));
          if ((_14_valueOrError3).IsFailure()) {
            output = (_14_valueOrError3).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanOutputTransformOutput>();
            return output;
          }
          if (((((((_13_decrypted).dtor_parsedHeader).dtor_value).dtor_encryptedDataKeys).Select(BigInteger.Zero)).dtor_keyProviderInfo).Equals(_6_keyIdUtf8)) {
            _2_decryptedItems = Dafny.Sequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.Concat(_2_decryptedItems, Dafny.Sequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.FromElements((_13_decrypted).dtor_plaintextItem));
          }
        } else {
          _2_decryptedItems = Dafny.Sequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.Concat(_2_decryptedItems, Dafny.Sequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.FromElements((_13_decrypted).dtor_plaintextItem));
        }
      }
      software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput _15_decryptedOutput;
      software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput _16_dt__update__tmp_h0 = (input).dtor_sdkOutput;
      Wrappers_Compile._IOption<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>> _17_dt__update_hItems_h0 = Wrappers_Compile.Option<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>.create_Some(_2_decryptedItems);
      _15_decryptedOutput = software.amazon.cryptography.services.dynamodb.internaldafny.types.ScanOutput.create(_17_dt__update_hItems_h0, (_16_dt__update__tmp_h0).dtor_Count, (_16_dt__update__tmp_h0).dtor_ScannedCount, (_16_dt__update__tmp_h0).dtor_LastEvaluatedKey, (_16_dt__update__tmp_h0).dtor_ConsumedCapacity);
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _18_valueOrError4 = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.services.dynamodb.internaldafny.types.ScanOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out1;
      _out1 = DynamoDbMiddlewareSupport_Compile.__default.ScanOutputForBeacons(_1_tableConfig, (input).dtor_originalInput, _15_decryptedOutput);
      _18_valueOrError4 = _out1;
      if ((_18_valueOrError4).IsFailure()) {
        output = (_18_valueOrError4).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanOutputTransformOutput>();
        return output;
      }
      software.amazon.cryptography.services.dynamodb.internaldafny.types._IScanOutput _19_finalResult;
      _19_finalResult = (_18_valueOrError4).Extract();
      output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ScanOutputTransformOutput.create(_19_finalResult));
      return output;
      return output;
    }
  }
} // end of namespace ScanTransform_Compile
namespace QueryTransform_Compile {

  public partial class __default {
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> Input(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      if (!((config).dtor_tableEncryptionConfigs).Contains(((input).dtor_sdkInput).dtor_TableName)) {
        output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.QueryInputTransformOutput.create((input).dtor_sdkInput));
        return output;
      } else {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default();
        _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(DynamoDbMiddlewareSupport_Compile.__default.NoList<Dafny.ISequence<char>>(((input).dtor_sdkInput).dtor_AttributesToGet), DdbMiddlewareConfig_Compile.__default.E(Dafny.Sequence<char>.FromString("Legacy parameter 'AttributesToGet' not supported in Query with Encryption")));
        if ((_0_valueOrError0).IsFailure()) {
          output = (_0_valueOrError0).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryInputTransformOutput>();
          return output;
        }
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _1_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default();
        _1_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(DynamoDbMiddlewareSupport_Compile.__default.NoMap<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._ICondition>(((input).dtor_sdkInput).dtor_KeyConditions), DdbMiddlewareConfig_Compile.__default.E(Dafny.Sequence<char>.FromString("Legacy parameter 'KeyConditions' not supported in Query with Encryption")));
        if ((_1_valueOrError1).IsFailure()) {
          output = (_1_valueOrError1).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryInputTransformOutput>();
          return output;
        }
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _2_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default();
        _2_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(DynamoDbMiddlewareSupport_Compile.__default.NoMap<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._ICondition>(((input).dtor_sdkInput).dtor_QueryFilter), DdbMiddlewareConfig_Compile.__default.E(Dafny.Sequence<char>.FromString("Legacy parameter 'QueryFilter' not supported in Query with Encryption")));
        if ((_2_valueOrError2).IsFailure()) {
          output = (_2_valueOrError2).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryInputTransformOutput>();
          return output;
        }
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _3_valueOrError3 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default();
        _3_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>((((input).dtor_sdkInput).dtor_ConditionalOperator).is_None, DdbMiddlewareConfig_Compile.__default.E(Dafny.Sequence<char>.FromString("Legacy parameter 'ConditionalOperator' not supported in Query with Encryption")));
        if ((_3_valueOrError3).IsFailure()) {
          output = (_3_valueOrError3).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryInputTransformOutput>();
          return output;
        }
        DdbMiddlewareConfig_Compile._ITableConfig _4_tableConfig;
        _4_tableConfig = Dafny.Map<Dafny.ISequence<char>, DdbMiddlewareConfig_Compile._ITableConfig>.Select((config).dtor_tableEncryptionConfigs,((input).dtor_sdkInput).dtor_TableName);
        Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _5_valueOrError4 = default(Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
        Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
        _out0 = DynamoDbMiddlewareSupport_Compile.__default.QueryInputForBeacons(_4_tableConfig, (input).dtor_sdkInput);
        _5_valueOrError4 = _out0;
        if ((_5_valueOrError4).IsFailure()) {
          output = (_5_valueOrError4).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryInputTransformOutput>();
          return output;
        }
        software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryInput _6_finalResult;
        _6_finalResult = (_5_valueOrError4).Extract();
        output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.QueryInputTransformOutput.create(_6_finalResult));
        return output;
      }
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> Output(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.QueryOutputTransformOutput.Default());
      Dafny.ISequence<char> _0_tableName;
      _0_tableName = ((input).dtor_originalInput).dtor_TableName;
      if ((!((config).dtor_tableEncryptionConfigs).Contains(_0_tableName)) || (DynamoDbMiddlewareSupport_Compile.__default.NoList<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>(((input).dtor_sdkOutput).dtor_Items))) {
        output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.QueryOutputTransformOutput.create((input).dtor_sdkOutput));
        return output;
      }
      DdbMiddlewareConfig_Compile._ITableConfig _1_tableConfig;
      _1_tableConfig = Dafny.Map<Dafny.ISequence<char>, DdbMiddlewareConfig_Compile._ITableConfig>.Select((config).dtor_tableEncryptionConfigs,_0_tableName);
      Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> _2_decryptedItems;
      _2_decryptedItems = Dafny.Sequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.FromElements();
      Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>> _3_encryptedItems;
      _3_encryptedItems = (((input).dtor_sdkOutput).dtor_Items).dtor_value;
      Wrappers_Compile._IResult<DynamoDbEncryptionUtil_Compile._IMaybeKeyId, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _4_valueOrError0 = Wrappers_Compile.Result<DynamoDbEncryptionUtil_Compile._IMaybeKeyId, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(DynamoDbEncryptionUtil_Compile.MaybeKeyId.Default());
      _4_valueOrError0 = DynamoDbMiddlewareSupport_Compile.__default.GetBeaconKeyId(_1_tableConfig, ((input).dtor_originalInput).dtor_KeyConditionExpression, ((input).dtor_originalInput).dtor_FilterExpression, ((input).dtor_originalInput).dtor_ExpressionAttributeValues, ((input).dtor_originalInput).dtor_ExpressionAttributeNames);
      if ((_4_valueOrError0).IsFailure()) {
        output = (_4_valueOrError0).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryOutputTransformOutput>();
        return output;
      }
      DynamoDbEncryptionUtil_Compile._IMaybeKeyId _5_keyId;
      _5_keyId = (_4_valueOrError0).Extract();
      Dafny.ISequence<byte> _6_keyIdUtf8;
      _6_keyIdUtf8 = Dafny.Sequence<byte>.FromElements();
      if ((_5_keyId).is_KeyId) {
        Wrappers_Compile._IResult<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _7_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(UTF8.ValidUTF8Bytes.Default());
        _7_valueOrError1 = Wrappers_Compile.Result<Dafny.ISequence<byte>, Dafny.ISequence<char>>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(UTF8.__default.Encode((_5_keyId).dtor_value), ((System.Func<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>)((_8_e) => {
          return DdbMiddlewareConfig_Compile.__default.E(_8_e);
        })));
        if ((_7_valueOrError1).IsFailure()) {
          output = (_7_valueOrError1).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryOutputTransformOutput>();
          return output;
        }
        _6_keyIdUtf8 = (_7_valueOrError1).Extract();
      }
      BigInteger _hi0 = new BigInteger((_3_encryptedItems).Count);
      for (BigInteger _9_x = BigInteger.Zero; _9_x < _hi0; _9_x++) {
        software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemInput _10_decryptInput;
        _10_decryptInput = software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.DecryptItemInput.create((_3_encryptedItems).Select(_9_x));
        Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _11_decryptRes;
        Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _out0;
        _out0 = ((_1_tableConfig).dtor_itemEncryptor).DecryptItem(_10_decryptInput);
        _11_decryptRes = _out0;
        Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _12_valueOrError2 = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.DecryptItemOutput.Default());
        _12_valueOrError2 = DdbMiddlewareConfig_Compile.__default.MapError<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput>(_11_decryptRes);
        if ((_12_valueOrError2).IsFailure()) {
          output = (_12_valueOrError2).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryOutputTransformOutput>();
          return output;
        }
        software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput _13_decrypted;
        _13_decrypted = (_12_valueOrError2).Extract();
        if (((_5_keyId).is_KeyId) && (((_13_decrypted).dtor_parsedHeader).is_Some)) {
          Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _14_valueOrError3 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default();
          _14_valueOrError3 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>((new BigInteger(((((_13_decrypted).dtor_parsedHeader).dtor_value).dtor_encryptedDataKeys).Count)) == (BigInteger.One), DdbMiddlewareConfig_Compile.__default.E(Dafny.Sequence<char>.FromString("Query result has more than one Encrypted Data Key")));
          if ((_14_valueOrError3).IsFailure()) {
            output = (_14_valueOrError3).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryOutputTransformOutput>();
            return output;
          }
          if (((((((_13_decrypted).dtor_parsedHeader).dtor_value).dtor_encryptedDataKeys).Select(BigInteger.Zero)).dtor_keyProviderInfo).Equals(_6_keyIdUtf8)) {
            _2_decryptedItems = Dafny.Sequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.Concat(_2_decryptedItems, Dafny.Sequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.FromElements((_13_decrypted).dtor_plaintextItem));
          }
        } else {
          _2_decryptedItems = Dafny.Sequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.Concat(_2_decryptedItems, Dafny.Sequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.FromElements((_13_decrypted).dtor_plaintextItem));
        }
      }
      software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput _15_decryptedOutput;
      software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput _16_dt__update__tmp_h0 = (input).dtor_sdkOutput;
      Wrappers_Compile._IOption<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>> _17_dt__update_hItems_h0 = Wrappers_Compile.Option<Dafny.ISequence<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>>.create_Some(_2_decryptedItems);
      _15_decryptedOutput = software.amazon.cryptography.services.dynamodb.internaldafny.types.QueryOutput.create(_17_dt__update_hItems_h0, (_16_dt__update__tmp_h0).dtor_Count, (_16_dt__update__tmp_h0).dtor_ScannedCount, (_16_dt__update__tmp_h0).dtor_LastEvaluatedKey, (_16_dt__update__tmp_h0).dtor_ConsumedCapacity);
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _18_valueOrError4 = Wrappers_Compile.Result<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.services.dynamodb.internaldafny.types.QueryOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out1;
      _out1 = DynamoDbMiddlewareSupport_Compile.__default.QueryOutputForBeacons(_1_tableConfig, (input).dtor_originalInput, _15_decryptedOutput);
      _18_valueOrError4 = _out1;
      if ((_18_valueOrError4).IsFailure()) {
        output = (_18_valueOrError4).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryOutputTransformOutput>();
        return output;
      }
      software.amazon.cryptography.services.dynamodb.internaldafny.types._IQueryOutput _19_finalResult;
      _19_finalResult = (_18_valueOrError4).Extract();
      output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.QueryOutputTransformOutput.create(_19_finalResult));
      return output;
      return output;
    }
  }
} // end of namespace QueryTransform_Compile
namespace TransactGetItemsTransform_Compile {

  public partial class __default {
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> Input(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.TransactGetItemsInputTransformOutput.create((input).dtor_sdkInput));
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> Output(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.TransactGetItemsOutputTransformOutput.Default());
      if (DynamoDbMiddlewareSupport_Compile.__default.NoList<software.amazon.cryptography.services.dynamodb.internaldafny.types._IItemResponse>(((input).dtor_sdkOutput).dtor_Responses)) {
        output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.TransactGetItemsOutputTransformOutput.create((input).dtor_sdkOutput));
        return output;
      }
      if ((new BigInteger(((((input).dtor_sdkOutput).dtor_Responses).dtor_value).Count)) != (new BigInteger((((input).dtor_originalInput).dtor_TransactItems).Count))) {
        output = DdbMiddlewareConfig_Compile.__default.MakeError<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsOutputTransformOutput>(Dafny.Sequence<char>.FromString("Invalid TransactGetItems response for original request: Number of items returned must equal number of items requested."));
        return output;
      }
      Dafny.ISequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IItemResponse> _0_decryptedItems;
      _0_decryptedItems = Dafny.Sequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IItemResponse>.FromElements();
      Dafny.ISequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IItemResponse> _1_encryptedItems;
      _1_encryptedItems = (((input).dtor_sdkOutput).dtor_Responses).dtor_value;
      BigInteger _hi0 = new BigInteger((_1_encryptedItems).Count);
      for (BigInteger _2_x = BigInteger.Zero; _2_x < _hi0; _2_x++) {
        Dafny.ISequence<char> _3_tableName;
        _3_tableName = (((((input).dtor_originalInput).dtor_TransactItems).Select(_2_x)).dtor_Get).dtor_TableName;
        if (!((config).dtor_tableEncryptionConfigs).Contains(_3_tableName)) {
          _0_decryptedItems = Dafny.Sequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IItemResponse>.Concat(_0_decryptedItems, Dafny.Sequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IItemResponse>.FromElements((_1_encryptedItems).Select(_2_x)));
        } else {
          DdbMiddlewareConfig_Compile._ITableConfig _4_tableConfig;
          _4_tableConfig = Dafny.Map<Dafny.ISequence<char>, DdbMiddlewareConfig_Compile._ITableConfig>.Select((config).dtor_tableEncryptionConfigs,_3_tableName);
          if (DynamoDbMiddlewareSupport_Compile.__default.NoMap<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>(((_1_encryptedItems).Select(_2_x)).dtor_Item)) {
            _0_decryptedItems = Dafny.Sequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IItemResponse>.Concat(_0_decryptedItems, Dafny.Sequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IItemResponse>.FromElements(software.amazon.cryptography.services.dynamodb.internaldafny.types.ItemResponse.create(Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.create_None())));
          } else {
            Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _5_decryptRes;
            Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _out0;
            _out0 = ((_4_tableConfig).dtor_itemEncryptor).DecryptItem(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.DecryptItemInput.create((((_1_encryptedItems).Select(_2_x)).dtor_Item).dtor_value));
            _5_decryptRes = _out0;
            Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _6_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.DecryptItemOutput.Default());
            _6_valueOrError0 = DdbMiddlewareConfig_Compile.__default.MapError<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput>(_5_decryptRes);
            if ((_6_valueOrError0).IsFailure()) {
              output = (_6_valueOrError0).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsOutputTransformOutput>();
              return output;
            }
            software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput _7_decrypted;
            _7_decrypted = (_6_valueOrError0).Extract();
            Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _8_valueOrError1 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
            _8_valueOrError1 = DynamoDbMiddlewareSupport_Compile.__default.RemoveBeacons(_4_tableConfig, (_7_decrypted).dtor_plaintextItem);
            if ((_8_valueOrError1).IsFailure()) {
              output = (_8_valueOrError1).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsOutputTransformOutput>();
              return output;
            }
            Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _9_item;
            _9_item = (_8_valueOrError1).Extract();
            _0_decryptedItems = Dafny.Sequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IItemResponse>.Concat(_0_decryptedItems, Dafny.Sequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IItemResponse>.FromElements(software.amazon.cryptography.services.dynamodb.internaldafny.types.ItemResponse.create(Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.create_Some(_9_item))));
          }
        }
      }
      var _pat_let_tv0 = _0_decryptedItems;
      output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.TransactGetItemsOutputTransformOutput.create(Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsOutput>((input).dtor_sdkOutput, _pat_let41_0 => Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsOutput>(_pat_let41_0, _10_dt__update__tmp_h0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IItemResponse>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsOutput>(Wrappers_Compile.Option<Dafny.ISequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IItemResponse>>.create_Some(_pat_let_tv0), _pat_let42_0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.ISequence<software.amazon.cryptography.services.dynamodb.internaldafny.types._IItemResponse>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._ITransactGetItemsOutput>(_pat_let42_0, _11_dt__update_hResponses_h0 => software.amazon.cryptography.services.dynamodb.internaldafny.types.TransactGetItemsOutput.create((_10_dt__update__tmp_h0).dtor_ConsumedCapacity, _11_dt__update_hResponses_h0)))))));
      return output;
      return output;
    }
  }
} // end of namespace TransactGetItemsTransform_Compile
namespace DeleteItemTransform_Compile {

  public partial class __default {
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> Input(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      if (((config).dtor_tableEncryptionConfigs).Contains(((input).dtor_sdkInput).dtor_TableName)) {
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _0_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default();
        _0_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(DynamoDbMiddlewareSupport_Compile.__default.NoMap<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IExpectedAttributeValue>(((input).dtor_sdkInput).dtor_Expected), DdbMiddlewareConfig_Compile.__default.E(Dafny.Sequence<char>.FromString("Legacy parameter 'Expected' not supported in UpdateItem with Encryption")));
        if ((_0_valueOrError0).IsFailure()) {
          output = (_0_valueOrError0).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemInputTransformOutput>();
          return output;
        }
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _1_valueOrError1 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default();
        _1_valueOrError1 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>((((input).dtor_sdkInput).dtor_ConditionalOperator).is_None, DdbMiddlewareConfig_Compile.__default.E(Dafny.Sequence<char>.FromString("Legacy parameter 'ConditionalOperator' not supported in UpdateItem with Encryption")));
        if ((_1_valueOrError1).IsFailure()) {
          output = (_1_valueOrError1).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemInputTransformOutput>();
          return output;
        }
        DdbMiddlewareConfig_Compile._ITableConfig _2_tableConfig;
        _2_tableConfig = Dafny.Map<Dafny.ISequence<char>, DdbMiddlewareConfig_Compile._ITableConfig>.Select((config).dtor_tableEncryptionConfigs,((input).dtor_sdkInput).dtor_TableName);
        Wrappers_Compile._IResult<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _3_valueOrError2 = Wrappers_Compile.Result<bool, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(false);
        _3_valueOrError2 = DynamoDbMiddlewareSupport_Compile.__default.TestConditionExpression(_2_tableConfig, ((input).dtor_sdkInput).dtor_ConditionExpression, ((input).dtor_sdkInput).dtor_ExpressionAttributeNames, ((input).dtor_sdkInput).dtor_ExpressionAttributeValues);
        if ((_3_valueOrError2).IsFailure()) {
          output = (_3_valueOrError2).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemInputTransformOutput>();
          return output;
        }
        bool _4___v0;
        _4___v0 = (_3_valueOrError2).Extract();
      }
      output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.DeleteItemInputTransformOutput.create((input).dtor_sdkInput));
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> Output(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.DeleteItemOutputTransformOutput.Default());
      Dafny.ISequence<char> _0_tableName;
      _0_tableName = ((input).dtor_originalInput).dtor_TableName;
      if ((!((config).dtor_tableEncryptionConfigs).Contains(_0_tableName)) || (DynamoDbMiddlewareSupport_Compile.__default.NoMap<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>(((input).dtor_sdkOutput).dtor_Attributes))) {
        output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.DeleteItemOutputTransformOutput.create((input).dtor_sdkOutput));
        return output;
      }
      DdbMiddlewareConfig_Compile._ITableConfig _1_tableConfig;
      _1_tableConfig = Dafny.Map<Dafny.ISequence<char>, DdbMiddlewareConfig_Compile._ITableConfig>.Select((config).dtor_tableEncryptionConfigs,_0_tableName);
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _2_decryptRes;
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _out0;
      _out0 = ((_1_tableConfig).dtor_itemEncryptor).DecryptItem(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.DecryptItemInput.create((((input).dtor_sdkOutput).dtor_Attributes).dtor_value));
      _2_decryptRes = _out0;
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _3_valueOrError0 = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.DecryptItemOutput.Default());
      _3_valueOrError0 = DdbMiddlewareConfig_Compile.__default.MapError<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput>(_2_decryptRes);
      if ((_3_valueOrError0).IsFailure()) {
        output = (_3_valueOrError0).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemOutputTransformOutput>();
        return output;
      }
      software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDecryptItemOutput _4_decrypted;
      _4_decrypted = (_3_valueOrError0).Extract();
      Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _5_valueOrError1 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>.Empty);
      _5_valueOrError1 = DynamoDbMiddlewareSupport_Compile.__default.RemoveBeacons(_1_tableConfig, (_4_decrypted).dtor_plaintextItem);
      if ((_5_valueOrError1).IsFailure()) {
        output = (_5_valueOrError1).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemOutputTransformOutput>();
        return output;
      }
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue> _6_item;
      _6_item = (_5_valueOrError1).Extract();
      var _pat_let_tv0 = _6_item;
      output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.DeleteItemOutputTransformOutput.create(Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemOutput>((input).dtor_sdkOutput, _pat_let43_0 => Dafny.Helpers.Let<software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemOutput, software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemOutput>(_pat_let43_0, _7_dt__update__tmp_h0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemOutput>(Wrappers_Compile.Option<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>.create_Some(_pat_let_tv0), _pat_let44_0 => Dafny.Helpers.Let<Wrappers_Compile._IOption<Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.services.dynamodb.internaldafny.types._IAttributeValue>>, software.amazon.cryptography.services.dynamodb.internaldafny.types._IDeleteItemOutput>(_pat_let44_0, _8_dt__update_hAttributes_h0 => software.amazon.cryptography.services.dynamodb.internaldafny.types.DeleteItemOutput.create(_8_dt__update_hAttributes_h0, (_7_dt__update__tmp_h0).dtor_ConsumedCapacity, (_7_dt__update__tmp_h0).dtor_ItemCollectionMetrics)))))));
      return output;
      return output;
    }
  }
} // end of namespace DeleteItemTransform_Compile
namespace ExecuteStatementTransform_Compile {

  public partial class __default {
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> Input(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _0_valueOrError0 = default(Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      _0_valueOrError0 = DdbMiddlewareConfig_Compile.__default.MapString<Dafny.ISequence<char>>(DdbStatement_Compile.__default.TableFromStatement(((input).dtor_sdkInput).dtor_Statement));
      if ((_0_valueOrError0).IsFailure()) {
        output = (_0_valueOrError0).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementInputTransformOutput>();
        return output;
      }
      Dafny.ISequence<char> _1_tableName;
      _1_tableName = (_0_valueOrError0).Extract();
      if (((config).dtor_tableEncryptionConfigs).Contains(_1_tableName)) {
        output = DdbMiddlewareConfig_Compile.__default.MakeError<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementInputTransformOutput>(Dafny.Sequence<char>.FromString("ExecuteStatement not Supported on encrypted tables."));
        return output;
      } else {
        output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ExecuteStatementInputTransformOutput.create((input).dtor_sdkInput));
        return output;
      }
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> Output(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ExecuteStatementOutputTransformOutput.Default());
      output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ExecuteStatementOutputTransformOutput.create((input).dtor_sdkOutput));
      return output;
      return output;
    }
  }
} // end of namespace ExecuteStatementTransform_Compile
namespace BatchExecuteStatementTransform_Compile {

  public partial class __default {
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> Input(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      BigInteger _hi0 = new BigInteger((((input).dtor_sdkInput).dtor_Statements).Count);
      for (BigInteger _0_i = BigInteger.Zero; _0_i < _hi0; _0_i++) {
        Dafny.ISequence<char> _1_statement;
        _1_statement = ((((input).dtor_sdkInput).dtor_Statements).Select(_0_i)).dtor_Statement;
        Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _2_valueOrError0 = default(Wrappers_Compile._IResult<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
        _2_valueOrError0 = DdbMiddlewareConfig_Compile.__default.MapString<Dafny.ISequence<char>>(DdbStatement_Compile.__default.TableFromStatement(_1_statement));
        if ((_2_valueOrError0).IsFailure()) {
          output = (_2_valueOrError0).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementInputTransformOutput>();
          return output;
        }
        Dafny.ISequence<char> _3_tableName;
        _3_tableName = (_2_valueOrError0).Extract();
        if (((config).dtor_tableEncryptionConfigs).Contains(_3_tableName)) {
          output = DdbMiddlewareConfig_Compile.__default.MakeError<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementInputTransformOutput>(Dafny.Sequence<char>.FromString("BatchExecuteStatement not Supported on encrypted tables."));
          return output;
        }
      }
      output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchExecuteStatementInputTransformOutput.create((input).dtor_sdkInput));
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> Output(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchExecuteStatementOutputTransformOutput.Default());
      output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchExecuteStatementOutputTransformOutput.create((input).dtor_sdkOutput));
      return output;
      return output;
    }
  }
} // end of namespace BatchExecuteStatementTransform_Compile
namespace ExecuteTransactionTransform_Compile {

  public partial class __default {
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> Input(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      BigInteger _hi0 = new BigInteger((((input).dtor_sdkInput).dtor_TransactStatements).Count);
      for (BigInteger _0_i = BigInteger.Zero; _0_i < _hi0; _0_i++) {
        Dafny.ISequence<char> _1_statement;
        _1_statement = ((((input).dtor_sdkInput).dtor_TransactStatements).Select(_0_i)).dtor_Statement;
        Wrappers_Compile._IResult<Dafny.ISequence<char>, Dafny.ISequence<char>> _2_tableName;
        _2_tableName = DdbStatement_Compile.__default.TableFromStatement(_1_statement);
        if ((_2_tableName).is_Failure) {
          output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Failure(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.Error.create_DynamoDbEncryptionTransformsException((_2_tableName).dtor_error));
          return output;
        }
        if (((config).dtor_tableEncryptionConfigs).Contains((_2_tableName).dtor_value)) {
          output = DdbMiddlewareConfig_Compile.__default.MakeError<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionInputTransformOutput>(Dafny.Sequence<char>.FromString("ExecuteTransaction not Supported on encrypted tables."));
          return output;
        }
      }
      output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ExecuteTransactionInputTransformOutput.create((input).dtor_sdkInput));
      return output;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> Output(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ExecuteTransactionOutputTransformOutput.Default());
      output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ExecuteTransactionOutputTransformOutput.create((input).dtor_sdkOutput));
      return output;
      return output;
    }
  }
} // end of namespace ExecuteTransactionTransform_Compile
namespace AttributeResolver_Compile {

  public partial class __default {
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IResolveAttributesOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> Resolve(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IResolveAttributesInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IResolveAttributesOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IResolveAttributesOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ResolveAttributesOutput.Default());
      if ((!((config).dtor_tableEncryptionConfigs).Contains((input).dtor_TableName)) || (((Dafny.Map<Dafny.ISequence<char>, DdbMiddlewareConfig_Compile._ITableConfig>.Select((config).dtor_tableEncryptionConfigs,(input).dtor_TableName)).dtor_search).is_None)) {
        output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IResolveAttributesOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ResolveAttributesOutput.create(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.FromElements(), Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.FromElements()));
        return output;
      } else {
        DdbMiddlewareConfig_Compile._ITableConfig _0_tableConfig;
        _0_tableConfig = Dafny.Map<Dafny.ISequence<char>, DdbMiddlewareConfig_Compile._ITableConfig>.Select((config).dtor_tableEncryptionConfigs,(input).dtor_TableName);
        Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _1_valueOrError0 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Empty);
        Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
        _out0 = DynamoDbMiddlewareSupport_Compile.__default.GetVirtualFields(((_0_tableConfig).dtor_search).dtor_value, (input).dtor_Item, (input).dtor_Version);
        _1_valueOrError0 = _out0;
        if ((_1_valueOrError0).IsFailure()) {
          output = (_1_valueOrError0).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IResolveAttributesOutput>();
          return output;
        }
        Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> _2_vf;
        _2_vf = (_1_valueOrError0).Extract();
        Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _3_valueOrError1 = Wrappers_Compile.Result<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(Dafny.Map<Dafny.ISequence<char>, Dafny.ISequence<char>>.Empty);
        Wrappers_Compile._IResult<Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out1;
        _out1 = DynamoDbMiddlewareSupport_Compile.__default.GetCompoundBeacons(((_0_tableConfig).dtor_search).dtor_value, (input).dtor_Item, (input).dtor_Version);
        _3_valueOrError1 = _out1;
        if ((_3_valueOrError1).IsFailure()) {
          output = (_3_valueOrError1).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IResolveAttributesOutput>();
          return output;
        }
        Dafny.IMap<Dafny.ISequence<char>,Dafny.ISequence<char>> _4_cb;
        _4_cb = (_3_valueOrError1).Extract();
        output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IResolveAttributesOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ResolveAttributesOutput.create(_2_vf, _4_cb));
        return output;
      }
      return output;
    }
  }
} // end of namespace AttributeResolver_Compile
namespace AwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations_Compile {

  public partial class __default {
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> PutItemInputTransform(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = PutItemTransform_Compile.__default.Input(config, input);
      output = _out0;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> PutItemOutputTransform(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.PutItemOutputTransformOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = PutItemTransform_Compile.__default.Output(config, input);
      output = _out0;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> GetItemInputTransform(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = GetItemTransform_Compile.__default.Input(config, input);
      output = _out0;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> GetItemOutputTransform(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.GetItemOutputTransformOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = GetItemTransform_Compile.__default.Output(config, input);
      output = _out0;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> UpdateItemInputTransform(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = UpdateItemTransform_Compile.__default.Input(config, input);
      output = _out0;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> UpdateItemOutputTransform(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.UpdateItemOutputTransformOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = UpdateItemTransform_Compile.__default.Output(config, input);
      output = _out0;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> BatchWriteItemInputTransform(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = BatchWriteItemTransform_Compile.__default.Input(config, input);
      output = _out0;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> BatchWriteItemOutputTransform(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchWriteItemOutputTransformOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = BatchWriteItemTransform_Compile.__default.Output(config, input);
      output = _out0;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> TransactWriteItemsInputTransform(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = TransactWriteItemsTransform_Compile.__default.Input(config, input);
      output = _out0;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> TransactWriteItemsOutputTransform(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.TransactWriteItemsOutputTransformOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = TransactWriteItemsTransform_Compile.__default.Output(config, input);
      output = _out0;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> BatchGetItemInputTransform(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = BatchGetItemTransform_Compile.__default.Input(config, input);
      output = _out0;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> BatchGetItemOutputTransform(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchGetItemOutputTransformOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = BatchGetItemTransform_Compile.__default.Output(config, input);
      output = _out0;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> ScanInputTransform(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = ScanTransform_Compile.__default.Input(config, input);
      output = _out0;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> ScanOutputTransform(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ScanOutputTransformOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = ScanTransform_Compile.__default.Output(config, input);
      output = _out0;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> QueryInputTransform(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = QueryTransform_Compile.__default.Input(config, input);
      output = _out0;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> QueryOutputTransform(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.QueryOutputTransformOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = QueryTransform_Compile.__default.Output(config, input);
      output = _out0;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> TransactGetItemsInputTransform(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = TransactGetItemsTransform_Compile.__default.Input(config, input);
      output = _out0;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> TransactGetItemsOutputTransform(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.TransactGetItemsOutputTransformOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = TransactGetItemsTransform_Compile.__default.Output(config, input);
      output = _out0;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> DeleteItemInputTransform(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = DeleteItemTransform_Compile.__default.Input(config, input);
      output = _out0;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> DeleteItemOutputTransform(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.DeleteItemOutputTransformOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = DeleteItemTransform_Compile.__default.Output(config, input);
      output = _out0;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> ExecuteStatementInputTransform(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = ExecuteStatementTransform_Compile.__default.Input(config, input);
      output = _out0;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> ExecuteStatementOutputTransform(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ExecuteStatementOutputTransformOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = ExecuteStatementTransform_Compile.__default.Output(config, input);
      output = _out0;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> BatchExecuteStatementInputTransform(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = BatchExecuteStatementTransform_Compile.__default.Input(config, input);
      output = _out0;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> BatchExecuteStatementOutputTransform(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchExecuteStatementOutputTransformOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = BatchExecuteStatementTransform_Compile.__default.Output(config, input);
      output = _out0;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> ExecuteTransactionInputTransform(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = ExecuteTransactionTransform_Compile.__default.Input(config, input);
      output = _out0;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> ExecuteTransactionOutputTransform(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ExecuteTransactionOutputTransformOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = ExecuteTransactionTransform_Compile.__default.Output(config, input);
      output = _out0;
      return output;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IResolveAttributesOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> ResolveAttributes(DdbMiddlewareConfig_Compile._IConfig config, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IResolveAttributesInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IResolveAttributesOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IResolveAttributesOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ResolveAttributesOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IResolveAttributesOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = AttributeResolver_Compile.__default.Resolve(config, input);
      output = _out0;
      return output;
    }
  }
} // end of namespace AwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations_Compile
namespace software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny {

  public partial class __default {
    public static software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTablesEncryptionConfig DefaultDynamoDbTablesEncryptionConfig() {
      return software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.DynamoDbTablesEncryptionConfig.create(Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig>.FromElements());
    }
    public static Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> AddSignedBeaconActions(Dafny.ISequence<Dafny.ISequence<char>> names, Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> actions)
    {
    TAIL_CALL_START: ;
      if ((new BigInteger((names).Count)).Sign == 0) {
        return actions;
      } else {
        Dafny.ISequence<Dafny.ISequence<char>> _in0 = (names).Drop(BigInteger.One);
        Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> _in1 = Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction>.Update(actions, (names).Select(BigInteger.Zero), software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types.CryptoAction.create_SIGN__ONLY());
        names = _in0;
        actions = _in1;
        goto TAIL_CALL_START;
      }
    }
    public static bool IsConfigured(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig config, Dafny.ISequence<char> name)
    {
      return ((((config).dtor_attributeActionsOnEncrypt).Contains(name)) || ((((config).dtor_allowedUnsignedAttributes).is_Some) && ((((config).dtor_allowedUnsignedAttributes).dtor_value).Contains(name)))) || ((((config).dtor_allowedUnsignedAttributePrefix).is_Some) && (Dafny.Sequence<char>.IsPrefixOf(((config).dtor_allowedUnsignedAttributePrefix).dtor_value, name)));
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.DynamoDbEncryptionTransformsClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> DynamoDbEncryptionTransforms(software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTablesEncryptionConfig config)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.DynamoDbEncryptionTransformsClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> res = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.DynamoDbEncryptionTransformsClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      Dafny.IMap<Dafny.ISequence<char>,DdbMiddlewareConfig_Compile._ITableConfig> _0_internalConfigs;
      _0_internalConfigs = Dafny.Map<Dafny.ISequence<char>, DdbMiddlewareConfig_Compile._ITableConfig>.FromElements();
      Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig> _1_m_k;
      _1_m_k = (config).dtor_tableEncryptionConfigs;
      Dafny.ISet<Dafny.ISequence<char>> _2_mKeys;
      _2_mKeys = (_1_m_k).Keys;
      Dafny.ISequence<Dafny.ISequence<char>> _3_tableNamesSeq;
      Dafny.ISequence<Dafny.ISequence<char>> _out0;
      _out0 = SortedSets.__default.SetToSequence<Dafny.ISequence<char>>(_2_mKeys);
      _3_tableNamesSeq = _out0;
      Dafny.ISet<Dafny.ISequence<char>> _4_allLogicalTableNames;
      _4_allLogicalTableNames = Dafny.Set<Dafny.ISequence<char>>.FromElements();
      BigInteger _5_i;
      _5_i = BigInteger.Zero;
      while ((_5_i) < (new BigInteger((_3_tableNamesSeq).Count))) {
        Dafny.ISequence<char> _6_tableName;
        _6_tableName = (_3_tableNamesSeq).Select(_5_i);
        software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig _7_inputConfig;
        _7_inputConfig = Dafny.Map<Dafny.ISequence<char>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig>.Select((config).dtor_tableEncryptionConfigs,_6_tableName);
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _8_valueOrError0 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default();
        _8_valueOrError0 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(!(_4_allLogicalTableNames).Contains((_7_inputConfig).dtor_logicalTableName), DdbMiddlewareConfig_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Duplicate logical table maped to multipule physical tables: "), (_7_inputConfig).dtor_logicalTableName)));
        if ((_8_valueOrError0).IsFailure()) {
          res = (_8_valueOrError0).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.DynamoDbEncryptionTransformsClient>();
          return res;
        }
        Wrappers_Compile._IResult<Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._ISearchInfo>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _9_searchR;
        Wrappers_Compile._IResult<Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._ISearchInfo>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError> _out1;
        _out1 = SearchConfigToInfo_Compile.__default.Convert(_7_inputConfig);
        _9_searchR = _out1;
        Wrappers_Compile._IResult<Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._ISearchInfo>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _10_valueOrError1 = Wrappers_Compile.Result<Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._ISearchInfo>, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(Wrappers_Compile.Option<SearchableEncryptionInfo_Compile._ISearchInfo>.Default());
        _10_valueOrError1 = Wrappers_Compile.Result<Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._ISearchInfo>, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(_9_searchR, ((System.Func<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>)((_11_e) => {
          return software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.Error.create_AwsCryptographyDbEncryptionSdkDynamoDb(_11_e);
        })));
        if ((_10_valueOrError1).IsFailure()) {
          res = (_10_valueOrError1).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.DynamoDbEncryptionTransformsClient>();
          return res;
        }
        Wrappers_Compile._IOption<SearchableEncryptionInfo_Compile._ISearchInfo> _12_search;
        _12_search = (_10_valueOrError1).Extract();
        Dafny.ISequence<Dafny.ISequence<char>> _13_signedBeacons;
        if ((_12_search).is_None) {
          _13_signedBeacons = Dafny.Sequence<Dafny.ISequence<char>>.FromElements();
        } else {
          _13_signedBeacons = (((_12_search).dtor_value).curr()).ListSignedBeacons();
        }
        Dafny.ISequence<Dafny.ISequence<char>> _14_badBeacons;
        _14_badBeacons = Seq_Compile.__default.Filter<Dafny.ISequence<char>>(Dafny.Helpers.Id<Func<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IDynamoDbTableEncryptionConfig, Func<Dafny.ISequence<char>, bool>>>((_15_inputConfig) => ((System.Func<Dafny.ISequence<char>, bool>)((_16_s) => {
          return software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.__default.IsConfigured(_15_inputConfig, _16_s);
        })))(_7_inputConfig), _13_signedBeacons);
        if ((new BigInteger((_14_badBeacons).Count)).Sign == 1) {
          res = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.DynamoDbEncryptionTransformsClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Failure(DdbMiddlewareConfig_Compile.__default.E(Dafny.Sequence<char>.Concat(Dafny.Sequence<char>.FromString("Signed beacons cannot be configured with CryptoActions or as unauthenticated : "), StandardLibrary_Compile.__default.Join<char>(_14_badBeacons, Dafny.Sequence<char>.FromString(", ")))));
          return res;
        }
        Wrappers_Compile._IOutcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _17_valueOrError2 = Wrappers_Compile.Outcome<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default();
        _17_valueOrError2 = Wrappers_Compile.__default.Need<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(Dafny.Helpers.Id<Func<Dafny.ISequence<Dafny.ISequence<char>>, bool>>((_18_signedBeacons) => Dafny.Helpers.Quantifier<Dafny.ISequence<char>>((_18_signedBeacons).UniqueElements, true, (((_forall_var_0) => {
          Dafny.ISequence<char> _19_k = (Dafny.ISequence<char>)_forall_var_0;
          return !((_18_signedBeacons).Contains(_19_k)) || (software.amazon.cryptography.services.dynamodb.internaldafny.types.__default.IsValid__AttributeName(_19_k));
        }))))(_13_signedBeacons), DdbMiddlewareConfig_Compile.__default.E(Dafny.Sequence<char>.FromString("Beacon configured with bad name")));
        if ((_17_valueOrError2).IsFailure()) {
          res = (_17_valueOrError2).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.DynamoDbEncryptionTransformsClient>();
          return res;
        }
        Dafny.IMap<Dafny.ISequence<char>,software.amazon.cryptography.dbencryptionsdk.structuredencryption.internaldafny.types._ICryptoAction> _20_newActions;
        _20_newActions = software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.__default.AddSignedBeaconActions(_13_signedBeacons, (_7_inputConfig).dtor_attributeActionsOnEncrypt);
        software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IDynamoDbItemEncryptorConfig _21_encryptorConfig;
        _21_encryptorConfig = software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.DynamoDbItemEncryptorConfig.create((_7_inputConfig).dtor_logicalTableName, (_7_inputConfig).dtor_partitionKeyName, (_7_inputConfig).dtor_sortKeyName, _20_newActions, (_7_inputConfig).dtor_allowedUnsignedAttributes, (_7_inputConfig).dtor_allowedUnsignedAttributePrefix, (_7_inputConfig).dtor_algorithmSuiteId, (_7_inputConfig).dtor_keyring, (_7_inputConfig).dtor_cmm, (_7_inputConfig).dtor_legacyOverride, (_7_inputConfig).dtor_plaintextOverride);
        Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.DynamoDbItemEncryptorClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _22_itemEncryptorRes;
        Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.DynamoDbItemEncryptorClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError> _out2;
        _out2 = software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.__default.DynamoDbItemEncryptor(_21_encryptorConfig);
        _22_itemEncryptorRes = _out2;
        Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.DynamoDbItemEncryptorClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _23_valueOrError3 = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.DynamoDbItemEncryptorClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
        _23_valueOrError3 = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.DynamoDbItemEncryptorClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError>.MapFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>(_22_itemEncryptorRes, ((System.Func<software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types._IError, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>)((_24_e) => {
          return software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.Error.create_AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptor(_24_e);
        })));
        if ((_23_valueOrError3).IsFailure()) {
          res = (_23_valueOrError3).PropagateFailure<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.DynamoDbEncryptionTransformsClient>();
          return res;
        }
        software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.types.IDynamoDbItemEncryptorClient _25_itemEncryptorX;
        _25_itemEncryptorX = (_23_valueOrError3).Extract();
        software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.DynamoDbItemEncryptorClient _26_itemEncryptor;
        _26_itemEncryptor = ((software.amazon.cryptography.dbencryptionsdk.dynamodb.itemencryptor.internaldafny.DynamoDbItemEncryptorClient)(_25_itemEncryptorX));
        AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations_Compile._IConfig _27_encConfig;
        _27_encConfig = (_26_itemEncryptor).config;
        DdbMiddlewareConfig_Compile._ITableConfig _28_internalConfig;
        _28_internalConfig = DdbMiddlewareConfig_Compile.TableConfig.create(_6_tableName, (_7_inputConfig).dtor_logicalTableName, (_7_inputConfig).dtor_partitionKeyName, (_7_inputConfig).dtor_sortKeyName, _26_itemEncryptor, _12_search, Wrappers_Compile.Option<software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types._IPlaintextOverride>.UnwrapOr((_7_inputConfig).dtor_plaintextOverride, software.amazon.cryptography.dbencryptionsdk.dynamodb.internaldafny.types.PlaintextOverride.create_FORBID__PLAINTEXT__WRITE__FORBID__PLAINTEXT__READ()));
        _0_internalConfigs = Dafny.Map<Dafny.ISequence<char>, DdbMiddlewareConfig_Compile._ITableConfig>.Update(_0_internalConfigs, _6_tableName, _28_internalConfig);
        _4_allLogicalTableNames = Dafny.Set<Dafny.ISequence<char>>.Union(_4_allLogicalTableNames, Dafny.Set<Dafny.ISequence<char>>.FromElements((_28_internalConfig).dtor_logicalTableName));
        _5_i = (_5_i) + (BigInteger.One);
      }
      DdbMiddlewareConfig_Compile._IConfig _29_newConfig;
      _29_newConfig = DdbMiddlewareConfig_Compile.Config.create(_0_internalConfigs);
      software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.DynamoDbEncryptionTransformsClient _30_client;
      software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.DynamoDbEncryptionTransformsClient _nw0 = new software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.DynamoDbEncryptionTransformsClient();
      _nw0.__ctor(_29_newConfig);
      _30_client = _nw0;
      res = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.DynamoDbEncryptionTransformsClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(_30_client);
      return res;
      return res;
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.IDynamoDbEncryptionTransformsClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> CreateSuccessOfClient(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.IDynamoDbEncryptionTransformsClient client) {
      return Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.IDynamoDbEncryptionTransformsClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Success(client);
    }
    public static Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.IDynamoDbEncryptionTransformsClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> CreateFailureOfError(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError error) {
      return Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.IDynamoDbEncryptionTransformsClient, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.create_Failure(error);
    }
  }

  public partial class DynamoDbEncryptionTransformsClient : software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.IDynamoDbEncryptionTransformsClient {
    public DynamoDbEncryptionTransformsClient() {
      this._config = DdbMiddlewareConfig_Compile.Config.Default();
    }
    public void __ctor(DdbMiddlewareConfig_Compile._IConfig config)
    {
      (this)._config = config;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> PutItemInputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations_Compile.__default.PutItemInputTransform((this).config, input);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> PutItemOutputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.PutItemOutputTransformOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IPutItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations_Compile.__default.PutItemOutputTransform((this).config, input);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> GetItemInputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations_Compile.__default.GetItemInputTransform((this).config, input);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> GetItemOutputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.GetItemOutputTransformOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IGetItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations_Compile.__default.GetItemOutputTransform((this).config, input);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> BatchWriteItemInputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations_Compile.__default.BatchWriteItemInputTransform((this).config, input);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> BatchWriteItemOutputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchWriteItemOutputTransformOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchWriteItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations_Compile.__default.BatchWriteItemOutputTransform((this).config, input);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> BatchGetItemInputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations_Compile.__default.BatchGetItemInputTransform((this).config, input);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> BatchGetItemOutputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchGetItemOutputTransformOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchGetItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations_Compile.__default.BatchGetItemOutputTransform((this).config, input);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> ScanInputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations_Compile.__default.ScanInputTransform((this).config, input);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> ScanOutputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ScanOutputTransformOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IScanOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations_Compile.__default.ScanOutputTransform((this).config, input);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> QueryInputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations_Compile.__default.QueryInputTransform((this).config, input);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> QueryOutputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.QueryOutputTransformOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IQueryOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations_Compile.__default.QueryOutputTransform((this).config, input);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> TransactWriteItemsInputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations_Compile.__default.TransactWriteItemsInputTransform((this).config, input);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> TransactWriteItemsOutputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.TransactWriteItemsOutputTransformOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactWriteItemsOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations_Compile.__default.TransactWriteItemsOutputTransform((this).config, input);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> UpdateItemInputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations_Compile.__default.UpdateItemInputTransform((this).config, input);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> UpdateItemOutputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.UpdateItemOutputTransformOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IUpdateItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations_Compile.__default.UpdateItemOutputTransform((this).config, input);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> DeleteItemInputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations_Compile.__default.DeleteItemInputTransform((this).config, input);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> DeleteItemOutputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.DeleteItemOutputTransformOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IDeleteItemOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations_Compile.__default.DeleteItemOutputTransform((this).config, input);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> TransactGetItemsInputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations_Compile.__default.TransactGetItemsInputTransform((this).config, input);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> TransactGetItemsOutputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.TransactGetItemsOutputTransformOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._ITransactGetItemsOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations_Compile.__default.TransactGetItemsOutputTransform((this).config, input);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> ExecuteStatementInputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations_Compile.__default.ExecuteStatementInputTransform((this).config, input);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> ExecuteStatementOutputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ExecuteStatementOutputTransformOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteStatementOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations_Compile.__default.ExecuteStatementOutputTransform((this).config, input);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> BatchExecuteStatementInputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations_Compile.__default.BatchExecuteStatementInputTransform((this).config, input);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> BatchExecuteStatementOutputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.BatchExecuteStatementOutputTransformOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IBatchExecuteStatementOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations_Compile.__default.BatchExecuteStatementOutputTransform((this).config, input);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> ExecuteTransactionInputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionInputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = default(Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>);
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionInputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations_Compile.__default.ExecuteTransactionInputTransform((this).config, input);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> ExecuteTransactionOutputTransform(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionOutputTransformInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ExecuteTransactionOutputTransformOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IExecuteTransactionOutputTransformOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations_Compile.__default.ExecuteTransactionOutputTransform((this).config, input);
      output = _out0;
      return output;
    }
    public Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IResolveAttributesOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> ResolveAttributes(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IResolveAttributesInput input)
    {
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IResolveAttributesOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> output = Wrappers_Compile.Result<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IResolveAttributesOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError>.Default(software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types.ResolveAttributesOutput.Default());
      Wrappers_Compile._IResult<software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IResolveAttributesOutput, software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny.types._IError> _out0;
      _out0 = AwsCryptographyDbEncryptionSdkDynamoDbTransformsOperations_Compile.__default.ResolveAttributes((this).config, input);
      output = _out0;
      return output;
    }
    public DdbMiddlewareConfig_Compile._IConfig _config {get; set;}
    public DdbMiddlewareConfig_Compile._IConfig config { get {
      return this._config;
    } }
  }
} // end of namespace software.amazon.cryptography.dbencryptionsdk.dynamodb.transforms.internaldafny
namespace _module {

} // end of namespace _module
