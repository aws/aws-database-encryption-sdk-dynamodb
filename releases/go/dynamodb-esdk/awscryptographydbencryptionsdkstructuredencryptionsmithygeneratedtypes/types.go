// Code generated by smithy-go-codegen DO NOT EDIT.

package awscryptographydbencryptionsdkstructuredencryptionsmithygeneratedtypes

import (
	"fmt"
	"unicode/utf8"

	"github.com/aws/aws-cryptographic-material-providers-library/releases/go/mpl/awscryptographymaterialproviderssmithygeneratedtypes"
)

type StructuredDataTerminal struct {
	TypeId []byte

	Value []byte
}

func (input StructuredDataTerminal) Validate() error {
	if len(input.TypeId) < 2 {
		return fmt.Errorf("TerminalTypeId has a minimum length of 2 but has the length of %d.", len(input.TypeId))
	}
	if len(input.TypeId) > 2 {
		return fmt.Errorf("TerminalTypeId has a maximum length of 2 but has the length of %d.", len(input.TypeId))
	}

	return nil
}

type StructureSegment struct {
	Key string
}

func (input StructureSegment) Validate() error {

	return nil
}

type AuthItem struct {
	Action AuthenticateAction

	Data StructuredDataTerminal

	Key []PathSegment
}

func (input AuthItem) Validate() error {
	if input.Data.Validate() != nil {
		return input.Data.Validate()
	}
	if input.Key == nil {
		return fmt.Errorf("input.Key is required but has a nil value.")
	}
	if input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_AuthItem_key_Validate() != nil {
		return input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_AuthItem_key_Validate()
	}

	return nil
}

func (input AuthItem) Aws_cryptography_dbEncryptionSdk_structuredEncryption_Path_member_Validate(Value PathSegment) error {
	if Value == nil {
		return nil
	}
	switch unionType := Value.(type) {
	case *PathSegmentMembermember:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}
func (input AuthItem) Aws_cryptography_dbEncryptionSdk_structuredEncryption_AuthItem_key_Validate() error {
	for _, item := range input.Key {
		if input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_Path_member_Validate(item) != nil {
			return input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_Path_member_Validate(item)
		}
	}

	return nil
}

type CryptoItem struct {
	Action CryptoAction

	Data StructuredDataTerminal

	Key []PathSegment
}

func (input CryptoItem) Validate() error {
	if input.Data.Validate() != nil {
		return input.Data.Validate()
	}
	if input.Key == nil {
		return fmt.Errorf("input.Key is required but has a nil value.")
	}
	if input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_CryptoItem_key_Validate() != nil {
		return input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_CryptoItem_key_Validate()
	}

	return nil
}

func (input CryptoItem) Aws_cryptography_dbEncryptionSdk_structuredEncryption_Path_member_Validate(Value PathSegment) error {
	if Value == nil {
		return nil
	}
	switch unionType := Value.(type) {
	case *PathSegmentMembermember:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}
func (input CryptoItem) Aws_cryptography_dbEncryptionSdk_structuredEncryption_CryptoItem_key_Validate() error {
	for _, item := range input.Key {
		if input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_Path_member_Validate(item) != nil {
			return input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_Path_member_Validate(item)
		}
	}

	return nil
}

type DecryptPathStructureInput struct {
	Cmm awscryptographymaterialproviderssmithygeneratedtypes.ICryptographicMaterialsManager

	EncryptedStructure []AuthItem

	TableName string

	EncryptionContext map[string]string
}

func (input DecryptPathStructureInput) Validate() error {
	if input.EncryptedStructure == nil {
		return fmt.Errorf("input.EncryptedStructure is required but has a nil value.")
	}
	if input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_DecryptPathStructureInput_encryptedStructure_Validate() != nil {
		return input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_DecryptPathStructureInput_encryptedStructure_Validate()
	}
	if input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_DecryptPathStructureInput_encryptionContext_Validate() != nil {
		return input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_DecryptPathStructureInput_encryptionContext_Validate()
	}

	return nil
}

func (input DecryptPathStructureInput) Aws_cryptography_dbEncryptionSdk_structuredEncryption_DecryptPathStructureInput_encryptedStructure_Validate() error {
	for _, item := range input.EncryptedStructure {
		if item.Validate() != nil {
			return item.Validate()
		}
	}

	return nil
}
func (input DecryptPathStructureInput) Aws_cryptography_dbEncryptionSdk_structuredEncryption_DecryptPathStructureInput_encryptionContext_Validate() error {
	for key, value := range input.EncryptionContext {
		if !utf8.ValidString(key) {
			return fmt.Errorf("Invalid UTF bytes %s ", key)
		}
		if !utf8.ValidString(value) {
			return fmt.Errorf("Invalid UTF bytes %s ", value)
		}
	}

	return nil
}

type ParsedHeader struct {
	AlgorithmSuiteId awscryptographymaterialproviderssmithygeneratedtypes.DBEAlgorithmSuiteId

	EncryptedDataKeys []awscryptographymaterialproviderssmithygeneratedtypes.EncryptedDataKey

	EncryptionContext map[string]string

	StoredEncryptionContext map[string]string
}

func (input ParsedHeader) Validate() error {
	if input.EncryptedDataKeys == nil {
		return fmt.Errorf("input.EncryptedDataKeys is required but has a nil value.")
	}
	if input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_ParsedHeader_encryptedDataKeys_Validate() != nil {
		return input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_ParsedHeader_encryptedDataKeys_Validate()
	}
	if input.EncryptionContext == nil {
		return fmt.Errorf("input.EncryptionContext is required but has a nil value.")
	}
	if input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_ParsedHeader_encryptionContext_Validate() != nil {
		return input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_ParsedHeader_encryptionContext_Validate()
	}
	if input.StoredEncryptionContext == nil {
		return fmt.Errorf("input.StoredEncryptionContext is required but has a nil value.")
	}
	if input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_ParsedHeader_storedEncryptionContext_Validate() != nil {
		return input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_ParsedHeader_storedEncryptionContext_Validate()
	}

	return nil
}

func (input ParsedHeader) Aws_cryptography_dbEncryptionSdk_structuredEncryption_ParsedHeader_encryptedDataKeys_Validate() error {
	for _, item := range input.EncryptedDataKeys {
		if item.Validate() != nil {
			return item.Validate()
		}
	}

	return nil
}
func (input ParsedHeader) Aws_cryptography_dbEncryptionSdk_structuredEncryption_ParsedHeader_encryptionContext_Validate() error {
	for key, value := range input.EncryptionContext {
		if !utf8.ValidString(key) {
			return fmt.Errorf("Invalid UTF bytes %s ", key)
		}
		if !utf8.ValidString(value) {
			return fmt.Errorf("Invalid UTF bytes %s ", value)
		}
	}

	return nil
}
func (input ParsedHeader) Aws_cryptography_dbEncryptionSdk_structuredEncryption_ParsedHeader_storedEncryptionContext_Validate() error {
	for key, value := range input.StoredEncryptionContext {
		if !utf8.ValidString(key) {
			return fmt.Errorf("Invalid UTF bytes %s ", key)
		}
		if !utf8.ValidString(value) {
			return fmt.Errorf("Invalid UTF bytes %s ", value)
		}
	}

	return nil
}

type DecryptPathStructureOutput struct {
	ParsedHeader ParsedHeader

	PlaintextStructure []CryptoItem
}

func (input DecryptPathStructureOutput) Validate() error {
	if input.ParsedHeader.Validate() != nil {
		return input.ParsedHeader.Validate()
	}
	if input.PlaintextStructure == nil {
		return fmt.Errorf("input.PlaintextStructure is required but has a nil value.")
	}
	if input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_DecryptPathStructureOutput_plaintextStructure_Validate() != nil {
		return input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_DecryptPathStructureOutput_plaintextStructure_Validate()
	}

	return nil
}

func (input DecryptPathStructureOutput) Aws_cryptography_dbEncryptionSdk_structuredEncryption_DecryptPathStructureOutput_plaintextStructure_Validate() error {
	for _, item := range input.PlaintextStructure {
		if item.Validate() != nil {
			return item.Validate()
		}
	}

	return nil
}

type DecryptStructureInput struct {
	AuthenticateSchema map[string]AuthenticateAction

	Cmm awscryptographymaterialproviderssmithygeneratedtypes.ICryptographicMaterialsManager

	EncryptedStructure map[string]StructuredDataTerminal

	TableName string

	EncryptionContext map[string]string
}

func (input DecryptStructureInput) Validate() error {
	if input.AuthenticateSchema == nil {
		return fmt.Errorf("input.AuthenticateSchema is required but has a nil value.")
	}
	if input.EncryptedStructure == nil {
		return fmt.Errorf("input.EncryptedStructure is required but has a nil value.")
	}
	if input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_DecryptStructureInput_encryptedStructure_Validate() != nil {
		return input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_DecryptStructureInput_encryptedStructure_Validate()
	}
	if input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_DecryptStructureInput_encryptionContext_Validate() != nil {
		return input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_DecryptStructureInput_encryptionContext_Validate()
	}

	return nil
}

func (input DecryptStructureInput) Aws_cryptography_dbEncryptionSdk_structuredEncryption_DecryptStructureInput_encryptedStructure_Validate() error {
	for _, value := range input.EncryptedStructure {
		if value.Validate() != nil {
			return value.Validate()
		}
	}

	return nil
}
func (input DecryptStructureInput) Aws_cryptography_dbEncryptionSdk_structuredEncryption_DecryptStructureInput_encryptionContext_Validate() error {
	for key, value := range input.EncryptionContext {
		if !utf8.ValidString(key) {
			return fmt.Errorf("Invalid UTF bytes %s ", key)
		}
		if !utf8.ValidString(value) {
			return fmt.Errorf("Invalid UTF bytes %s ", value)
		}
	}

	return nil
}

type DecryptStructureOutput struct {
	CryptoSchema map[string]CryptoAction

	ParsedHeader ParsedHeader

	PlaintextStructure map[string]StructuredDataTerminal
}

func (input DecryptStructureOutput) Validate() error {
	if input.CryptoSchema == nil {
		return fmt.Errorf("input.CryptoSchema is required but has a nil value.")
	}
	if input.ParsedHeader.Validate() != nil {
		return input.ParsedHeader.Validate()
	}
	if input.PlaintextStructure == nil {
		return fmt.Errorf("input.PlaintextStructure is required but has a nil value.")
	}
	if input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_DecryptStructureOutput_plaintextStructure_Validate() != nil {
		return input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_DecryptStructureOutput_plaintextStructure_Validate()
	}

	return nil
}

func (input DecryptStructureOutput) Aws_cryptography_dbEncryptionSdk_structuredEncryption_DecryptStructureOutput_plaintextStructure_Validate() error {
	for _, value := range input.PlaintextStructure {
		if value.Validate() != nil {
			return value.Validate()
		}
	}

	return nil
}

type EncryptPathStructureInput struct {
	Cmm awscryptographymaterialproviderssmithygeneratedtypes.ICryptographicMaterialsManager

	PlaintextStructure []CryptoItem

	TableName string

	AlgorithmSuiteId *awscryptographymaterialproviderssmithygeneratedtypes.DBEAlgorithmSuiteId

	EncryptionContext map[string]string
}

func (input EncryptPathStructureInput) Validate() error {
	if input.PlaintextStructure == nil {
		return fmt.Errorf("input.PlaintextStructure is required but has a nil value.")
	}
	if input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_EncryptPathStructureInput_plaintextStructure_Validate() != nil {
		return input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_EncryptPathStructureInput_plaintextStructure_Validate()
	}
	if input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_EncryptPathStructureInput_encryptionContext_Validate() != nil {
		return input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_EncryptPathStructureInput_encryptionContext_Validate()
	}

	return nil
}

func (input EncryptPathStructureInput) Aws_cryptography_dbEncryptionSdk_structuredEncryption_EncryptPathStructureInput_plaintextStructure_Validate() error {
	for _, item := range input.PlaintextStructure {
		if item.Validate() != nil {
			return item.Validate()
		}
	}

	return nil
}
func (input EncryptPathStructureInput) Aws_cryptography_dbEncryptionSdk_structuredEncryption_EncryptPathStructureInput_encryptionContext_Validate() error {
	for key, value := range input.EncryptionContext {
		if !utf8.ValidString(key) {
			return fmt.Errorf("Invalid UTF bytes %s ", key)
		}
		if !utf8.ValidString(value) {
			return fmt.Errorf("Invalid UTF bytes %s ", value)
		}
	}

	return nil
}

type EncryptPathStructureOutput struct {
	EncryptedStructure []CryptoItem

	ParsedHeader ParsedHeader
}

func (input EncryptPathStructureOutput) Validate() error {
	if input.EncryptedStructure == nil {
		return fmt.Errorf("input.EncryptedStructure is required but has a nil value.")
	}
	if input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_EncryptPathStructureOutput_encryptedStructure_Validate() != nil {
		return input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_EncryptPathStructureOutput_encryptedStructure_Validate()
	}
	if input.ParsedHeader.Validate() != nil {
		return input.ParsedHeader.Validate()
	}

	return nil
}

func (input EncryptPathStructureOutput) Aws_cryptography_dbEncryptionSdk_structuredEncryption_EncryptPathStructureOutput_encryptedStructure_Validate() error {
	for _, item := range input.EncryptedStructure {
		if item.Validate() != nil {
			return item.Validate()
		}
	}

	return nil
}

type EncryptStructureInput struct {
	Cmm awscryptographymaterialproviderssmithygeneratedtypes.ICryptographicMaterialsManager

	CryptoSchema map[string]CryptoAction

	PlaintextStructure map[string]StructuredDataTerminal

	TableName string

	AlgorithmSuiteId *awscryptographymaterialproviderssmithygeneratedtypes.DBEAlgorithmSuiteId

	EncryptionContext map[string]string
}

func (input EncryptStructureInput) Validate() error {
	if input.CryptoSchema == nil {
		return fmt.Errorf("input.CryptoSchema is required but has a nil value.")
	}
	if input.PlaintextStructure == nil {
		return fmt.Errorf("input.PlaintextStructure is required but has a nil value.")
	}
	if input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_EncryptStructureInput_plaintextStructure_Validate() != nil {
		return input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_EncryptStructureInput_plaintextStructure_Validate()
	}
	if input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_EncryptStructureInput_encryptionContext_Validate() != nil {
		return input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_EncryptStructureInput_encryptionContext_Validate()
	}

	return nil
}

func (input EncryptStructureInput) Aws_cryptography_dbEncryptionSdk_structuredEncryption_EncryptStructureInput_plaintextStructure_Validate() error {
	for _, value := range input.PlaintextStructure {
		if value.Validate() != nil {
			return value.Validate()
		}
	}

	return nil
}
func (input EncryptStructureInput) Aws_cryptography_dbEncryptionSdk_structuredEncryption_EncryptStructureInput_encryptionContext_Validate() error {
	for key, value := range input.EncryptionContext {
		if !utf8.ValidString(key) {
			return fmt.Errorf("Invalid UTF bytes %s ", key)
		}
		if !utf8.ValidString(value) {
			return fmt.Errorf("Invalid UTF bytes %s ", value)
		}
	}

	return nil
}

type EncryptStructureOutput struct {
	CryptoSchema map[string]CryptoAction

	EncryptedStructure map[string]StructuredDataTerminal

	ParsedHeader ParsedHeader
}

func (input EncryptStructureOutput) Validate() error {
	if input.CryptoSchema == nil {
		return fmt.Errorf("input.CryptoSchema is required but has a nil value.")
	}
	if input.EncryptedStructure == nil {
		return fmt.Errorf("input.EncryptedStructure is required but has a nil value.")
	}
	if input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_EncryptStructureOutput_encryptedStructure_Validate() != nil {
		return input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_EncryptStructureOutput_encryptedStructure_Validate()
	}
	if input.ParsedHeader.Validate() != nil {
		return input.ParsedHeader.Validate()
	}

	return nil
}

func (input EncryptStructureOutput) Aws_cryptography_dbEncryptionSdk_structuredEncryption_EncryptStructureOutput_encryptedStructure_Validate() error {
	for _, value := range input.EncryptedStructure {
		if value.Validate() != nil {
			return value.Validate()
		}
	}

	return nil
}

type ResolveAuthActionsInput struct {
	AuthActions []AuthItem

	HeaderBytes []byte

	TableName string
}

func (input ResolveAuthActionsInput) Validate() error {
	if input.AuthActions == nil {
		return fmt.Errorf("input.AuthActions is required but has a nil value.")
	}
	if input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_ResolveAuthActionsInput_authActions_Validate() != nil {
		return input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_ResolveAuthActionsInput_authActions_Validate()
	}

	return nil
}

func (input ResolveAuthActionsInput) Aws_cryptography_dbEncryptionSdk_structuredEncryption_ResolveAuthActionsInput_authActions_Validate() error {
	for _, item := range input.AuthActions {
		if item.Validate() != nil {
			return item.Validate()
		}
	}

	return nil
}

type ResolveAuthActionsOutput struct {
	CryptoActions []CryptoItem
}

func (input ResolveAuthActionsOutput) Validate() error {
	if input.CryptoActions == nil {
		return fmt.Errorf("input.CryptoActions is required but has a nil value.")
	}
	if input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_ResolveAuthActionsOutput_cryptoActions_Validate() != nil {
		return input.Aws_cryptography_dbEncryptionSdk_structuredEncryption_ResolveAuthActionsOutput_cryptoActions_Validate()
	}

	return nil
}

func (input ResolveAuthActionsOutput) Aws_cryptography_dbEncryptionSdk_structuredEncryption_ResolveAuthActionsOutput_cryptoActions_Validate() error {
	for _, item := range input.CryptoActions {
		if item.Validate() != nil {
			return item.Validate()
		}
	}

	return nil
}

type AtomicPrimitivesReference struct {
}

func (input AtomicPrimitivesReference) Validate() error {

	return nil
}

type StructuredEncryptionConfig struct {
}

func (input StructuredEncryptionConfig) Validate() error {

	return nil
}

// PathSegmentMembermember
type PathSegment interface {
	isPathSegment()
}

type PathSegmentMembermember struct {
	Value StructureSegment
}

func (*PathSegmentMembermember) isPathSegment() {}

type StructuredEncryptionBaseException interface {
	// This is a dummy method to allow type assertion since Go empty interfaces
	// aren't useful for type assertion checks. No concrete class is expected to implement
	// this method. This is also not exported.
	interfaceBindingMethod()
}
