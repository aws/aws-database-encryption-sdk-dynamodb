// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0



/*

===================================================================================

This test was run with the faulty DB-ESDK 3.1 package,
which generated some items which could be decrypted 
(tested with GoodGet below)
which generated and some items which could not be decrypted 
(tested with BadGet below)

These items were all written to the `SetTests` table,
where they are successfully decrypted with the AltDecryptItem
from provided in this DecryptWithPermute service.

This test MUST NOT be run with newer correctly functioning versions
of the DB_ESDK, lest these items be overwritten with normal undamaged versions.

===================================================================================

*/




include "../../DynamoDbEncryption/src/Index.dfy"
include "../../DynamoDbEncryptionTransforms/test/TestFixtures.dfy"

module MakeSetsTest {
  import opened Wrappers
  import opened StandardLibrary.UInt
  import opened DynamoDbItemEncryptorUtil
  import opened AwsCryptographyDbEncryptionSdkDynamoDbTransformsTypes
  import opened AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes
  import opened AwsCryptographyDbEncryptionSdkDynamoDbTypes

  import MaterialProviders
  import opened DynamoDbItemEncryptor
  import AwsCryptographyMaterialProvidersTypes
  import Types = AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorTypes
  import UTF8
  import DDB = ComAmazonawsDynamodbTypes
  import TestFixtures
  import AwsCryptographyDbEncryptionSdkDynamoDbItemEncryptorOperations
  import CSE = AwsCryptographyDbEncryptionSdkStructuredEncryptionTypes
  import SE = StructuredEncryptionUtil
  import DDBE = AwsCryptographyDbEncryptionSdkDynamoDbTypes
  import AlgorithmSuites
  import StandardLibrary.String
  import opened Com.Amazonaws.Dynamodb

  // round trip
  // encrypt => encrypted fields changed, others did not
  // various errors

  function method DDBS(x : string) : DDB.AttributeValue {
    DDB.AttributeValue.S(x)
  }

  method GetEncryptorConfig() returns (output : DynamoDbItemEncryptorConfig) {
    var keyring := TestFixtures.GetKmsKeyring();
    var logicalTableName := TestFixtures.GetTableName("SetTests");
    output := DynamoDbItemEncryptorConfig(
      logicalTableName := logicalTableName,
      partitionKeyName := "Name",
      sortKeyName := None(),
      attributeActionsOnEncrypt := map[
        "Name" := CSE.SIGN_ONLY,
        "Encrypted" := CSE.ENCRYPT_AND_SIGN,
        "TheSet" := CSE.SIGN_ONLY,
        "Set2" := CSE.SIGN_ONLY,
        "Set3" := CSE.SIGN_ONLY,
        "TheMap" := CSE.SIGN_ONLY,
        "TheList" := CSE.SIGN_ONLY
        ],
      allowedUnsignedAttributes := None(),
      allowedUnsignedAttributePrefix := None(),
      keyring := Some(keyring),
      cmm := None(),
      algorithmSuiteId := None(),
      plaintextOverride := None(),
      legacyOverride := None()
    );
  }

  method GetDynamoDbItemEncryptor()
      returns (encryptor: DynamoDbItemEncryptorClient)
    ensures encryptor.ValidState()
    ensures fresh(encryptor)
    ensures fresh(encryptor.Modifies)
  {
    var config := GetEncryptorConfig();
    encryptor := TestFixtures.GetDynamoDbItemEncryptorFrom(config);
  }

  function method MakePutInput(item : DDB.PutItemInputAttributeMap) : DDB.PutItemInput
  {
    DDB.PutItemInput(
      TableName := "SetTests",
      Item := item,
      Expected := None,
      ReturnValues := None,
      ReturnConsumedCapacity := None,
      ReturnItemCollectionMetrics := None,
      ConditionalOperator := None,
      ConditionExpression := None,
      ExpressionAttributeNames := None,
      ExpressionAttributeValues := None
    )
  }

  function method MakeGetInput(name : string) : DDB.GetItemInput
  {
    DDB.GetItemInput(
      TableName := "SetTests",
      Key := map["Name" := DDB.AttributeValue.S(name)],
      AttributesToGet := None,
      ConsistentRead := Some(true),
      ReturnConsumedCapacity := None,
      ProjectionExpression := None,
      ExpressionAttributeNames := None
    )
  }

  method DoPutItemSS(
    client : DDB.IDynamoDBClient,
    encryptor : DynamoDbItemEncryptorClient,
    setParts : map<string, string>,
    tag : string,
    parts : seq<string>
  )
    requires client.ValidState()
    ensures client.ValidState()
    modifies client.Modifies
    requires encryptor.ValidState()
    ensures encryptor.ValidState()
    modifies encryptor.Modifies
  {
    var name : string := tag;
    var setVal : seq<string> := [];
    for i := 0 to |parts| {
      expect parts[i] in setParts;
      name := name + parts[i];
      setVal := setVal + [setParts[parts[i]]];
    }

    var inputItem : DDB.AttributeMap := map[
      "Name" := DDB.AttributeValue.S(name),
      "TheSet" := DDB.AttributeValue.SS(setVal)
    ];

    var encryptRes :- expect encryptor.EncryptItem(
      Types.EncryptItemInput(
        plaintextItem:=inputItem
      )
    );

    var resp :- expect client.PutItem(MakePutInput(encryptRes.encryptedItem));
  }

  method DoPutItemNS(
    client : DDB.IDynamoDBClient,
    encryptor : DynamoDbItemEncryptorClient,
    setParts : map<string, string>,
    tag : string,
    parts : seq<string>
  )
    requires client.ValidState()
    ensures client.ValidState()
    modifies client.Modifies
    requires encryptor.ValidState()
    ensures encryptor.ValidState()
    modifies encryptor.Modifies
  {
    var name : string := tag;
    var setVal : seq<string> := [];
    for i := 0 to |parts| {
      expect parts[i] in setParts;
      name := name + parts[i];
      setVal := setVal + [setParts[parts[i]]];
    }

    var inputItem : DDB.AttributeMap := map[
      "Name" := DDB.AttributeValue.S(name),
      "TheSet" := DDB.AttributeValue.NS(setVal)
    ];

    var encryptRes :- expect encryptor.EncryptItem(
      Types.EncryptItemInput(
        plaintextItem:=inputItem
      )
    );

    var resp :- expect client.PutItem(MakePutInput(encryptRes.encryptedItem));
  }

  method DoPutItemBS(
    client : DDB.IDynamoDBClient,
    encryptor : DynamoDbItemEncryptorClient,
    setParts : map<string, seq<uint8>>,
    tag : string,
    parts : seq<string>
  )
    requires client.ValidState()
    ensures client.ValidState()
    modifies client.Modifies
    requires encryptor.ValidState()
    ensures encryptor.ValidState()
    modifies encryptor.Modifies
  {
    var name : string := tag;
    var setVal : seq<seq<uint8>> := [];
    for i := 0 to |parts| {
      expect parts[i] in setParts;
      name := name + parts[i];
      setVal := setVal + [setParts[parts[i]]];
    }

    var inputItem : DDB.AttributeMap := map[
      "Name" := DDB.AttributeValue.S(name),
      "TheSet" := DDB.AttributeValue.BS(setVal)
    ];

    var encryptRes :- expect encryptor.EncryptItem(Types.EncryptItemInput(plaintextItem:=inputItem));
    var resp :- expect client.PutItem(MakePutInput(encryptRes.encryptedItem));
  }

  method GoodGet(
    client : DDB.IDynamoDBClient,
    encryptor : DynamoDbItemEncryptorClient,
    name : string
  )
    requires client.ValidState()
    ensures client.ValidState()
    modifies client.Modifies
    requires encryptor.ValidState()
    ensures encryptor.ValidState()
    modifies encryptor.Modifies
{
  var resp :- expect client.GetItem(MakeGetInput(name));
  expect resp.Item.Some?;

   var decryptRes := encryptor.DecryptItem(
      Types.DecryptItemInput(
        encryptedItem:=resp.Item.value
      )
    );

    if decryptRes.Failure? {
      print("Accidental Failure with " + name + "\n");
      print "\n\n",decryptRes,"\n\n";
    }
    expect decryptRes.Success?;
}

  method BadGet(
    client : DDB.IDynamoDBClient,
    encryptor : DynamoDbItemEncryptorClient,
    name : string
  )
    requires client.ValidState()
    ensures client.ValidState()
    modifies client.Modifies
    requires encryptor.ValidState()
    ensures encryptor.ValidState()
    modifies encryptor.Modifies
{
  var resp :- expect client.GetItem(MakeGetInput(name));
  expect resp.Item.Some?;

   var decryptRes := encryptor.DecryptItem(
      Types.DecryptItemInput(
        encryptedItem:=resp.Item.value
      )
    );

    if decryptRes.Success? {
      print("Accidental Success with " + name + "\n");
    }
    expect decryptRes.Failure?;
}

  method {:test} TestWriteSets() {
    var encryptor := GetDynamoDbItemEncryptor();
    var client :- expect DDBClientForRegion("us-west-2");
    var setParts : map<string, string> := map[
      "E" := "",
      "X" := "abc",
      "Y" := "beaucoup de text",
      "Z" := "cheers",
      "1" := "1",
      "2" := "2",
      "2a" := "0002",
      "3" := "3"
    ];
    DoPutItemSS(client, encryptor, setParts, "Basic", ["X"]);
    DoPutItemSS(client, encryptor, setParts, "Basic", ["X", "Y"]);
    DoPutItemSS(client, encryptor, setParts, "Basic", ["Y", "X"]);
    DoPutItemSS(client, encryptor, setParts, "Basic", ["X", "Y", "Z"]);
    DoPutItemSS(client, encryptor, setParts, "Basic", ["X", "Z", "Y"]);
    DoPutItemSS(client, encryptor, setParts, "Basic", ["Y", "X", "Z"]);
    DoPutItemSS(client, encryptor, setParts, "Basic", ["Y", "Z", "X"]);
    DoPutItemSS(client, encryptor, setParts, "Basic", ["Z", "X", "Y"]);
    DoPutItemSS(client, encryptor, setParts, "Basic", ["Z", "Y", "X"]);

    DoPutItemNS(client, encryptor, setParts, "Num", ["1"]);
    DoPutItemNS(client, encryptor, setParts, "Num", ["1", "2"]);
    DoPutItemNS(client, encryptor, setParts, "Num", ["2", "1"]);
    DoPutItemNS(client, encryptor, setParts, "Num", ["1", "2", "3"]);
    DoPutItemNS(client, encryptor, setParts, "Num", ["1", "3", "2"]);
    DoPutItemNS(client, encryptor, setParts, "Num", ["2", "1", "3"]);
    DoPutItemNS(client, encryptor, setParts, "Num", ["2", "3", "1"]);
    DoPutItemNS(client, encryptor, setParts, "Num", ["3", "1", "2"]);
    DoPutItemNS(client, encryptor, setParts, "Num", ["3", "2", "1"]);
    DoPutItemNS(client, encryptor, setParts, "Num", ["3", "2a", "1"]);

    var binParts : map<string, seq<uint8>> := map[
      "A" := [0, 255, 1, 254, 2, 253, 10, 13, 127, 128],
      "B" := [1],
      "C" := [2,3,4],
      "E" := []
    ];
    DoPutItemBS(client, encryptor, binParts, "Bin", ["A"]);
    DoPutItemBS(client, encryptor, binParts, "Bin", ["A", "B"]);
    DoPutItemBS(client, encryptor, binParts, "Bin", ["B", "A"]);
    DoPutItemBS(client, encryptor, binParts, "Bin", ["A", "B", "C"]);
    DoPutItemBS(client, encryptor, binParts, "Bin", ["A", "C", "B"]);
    DoPutItemBS(client, encryptor, binParts, "Bin", ["B", "A", "C"]);
    DoPutItemBS(client, encryptor, binParts, "Bin", ["B", "C", "A"]);
    DoPutItemBS(client, encryptor, binParts, "Bin", ["C", "A", "B"]);
    DoPutItemBS(client, encryptor, binParts, "Bin", ["C", "B", "A"]);

    DoPutItemSS(client, encryptor, setParts, "Basic", ["E"]);
    DoPutItemSS(client, encryptor, setParts, "Basic", ["X", "E"]);
    DoPutItemSS(client, encryptor, setParts, "Basic", ["E", "X"]);
    DoPutItemBS(client, encryptor, binParts, "Bin", ["E"]);
    DoPutItemBS(client, encryptor, binParts, "Bin", ["C", "E"]);
    DoPutItemBS(client, encryptor, binParts, "Bin", ["E", "C"]);

    var inputItem : DDB.AttributeMap := map[
      "Name" := DDB.AttributeValue.S("SetInList1"),
      "TheList" := DDB.AttributeValue.L([
        DDB.AttributeValue.S("aaa"),
        DDB.AttributeValue.SS(["aaa", "bbb", "ccc"]),
        DDB.AttributeValue.S("zzz")
      ])
    ];
    var encryptRes :- expect encryptor.EncryptItem(Types.EncryptItemInput(plaintextItem:=inputItem));
    var resp :- expect client.PutItem(MakePutInput(encryptRes.encryptedItem));

    inputItem := map[
      "Name" := DDB.AttributeValue.S("SetInList2"),
      "TheList" := DDB.AttributeValue.L([
        DDB.AttributeValue.S("aaa"),
        DDB.AttributeValue.SS(["ccc", "aaa", "bbb"]),
        DDB.AttributeValue.S("zzz")
      ])
    ];
    encryptRes :- expect encryptor.EncryptItem(Types.EncryptItemInput(plaintextItem:=inputItem));
    resp :- expect client.PutItem(MakePutInput(encryptRes.encryptedItem));

    inputItem := map[
      "Name" := DDB.AttributeValue.S("SetInList3"),
      "TheList" := DDB.AttributeValue.L([
        DDB.AttributeValue.SS(["ccc", "aaa", "bbb"]),
        DDB.AttributeValue.S("aaa"),
        DDB.AttributeValue.S("zzz")
      ])
    ];
    encryptRes :- expect encryptor.EncryptItem(Types.EncryptItemInput(plaintextItem:=inputItem));
    resp :- expect client.PutItem(MakePutInput(encryptRes.encryptedItem));

    inputItem := map[
      "Name" := DDB.AttributeValue.S("SetInList4"),
      "TheList" := DDB.AttributeValue.L([
        DDB.AttributeValue.S("aaa"),
        DDB.AttributeValue.S("zzz"),
        DDB.AttributeValue.SS(["ccc", "aaa", "bbb"])
      ])
    ];
    encryptRes :- expect encryptor.EncryptItem(Types.EncryptItemInput(plaintextItem:=inputItem));
    resp :- expect client.PutItem(MakePutInput(encryptRes.encryptedItem));

    inputItem := map[
      "Name" := DDB.AttributeValue.S("SetInMap1"),
      "TheMap" := DDB.AttributeValue.M(map[
        "aaa" := DDB.AttributeValue.SS(["ccc", "aaa", "bbb"]),
        "bbb" := DDB.AttributeValue.S("zzz")
      ])
    ];
    encryptRes :- expect encryptor.EncryptItem(Types.EncryptItemInput(plaintextItem:=inputItem));
    resp :- expect client.PutItem(MakePutInput(encryptRes.encryptedItem));

    inputItem := map[
      "Name" := DDB.AttributeValue.S("SetInMapInList1"),
      "TheList" := DDB.AttributeValue.L([
        DDB.AttributeValue.S("aaa"),
        DDB.AttributeValue.M(map[
          "aaa" := DDB.AttributeValue.SS(["ccc", "aaa", "bbb"]),
          "bbb" := DDB.AttributeValue.S("zzz")
        ])
      ])
    ];
    encryptRes :- expect encryptor.EncryptItem(Types.EncryptItemInput(plaintextItem:=inputItem));
    resp :- expect client.PutItem(MakePutInput(encryptRes.encryptedItem));

    inputItem := map[
      "Name" := DDB.AttributeValue.S("SetInListInMap1"),
      "TheMap" := DDB.AttributeValue.M(map[
        "aaa" := DDB.AttributeValue.L([
          DDB.AttributeValue.S("aaa"),
          DDB.AttributeValue.SS(["ccc", "aaa", "bbb"]),
          DDB.AttributeValue.S("xxx")
        ]),
        "bbb" := DDB.AttributeValue.S("zzz")
      ])
    ];
    encryptRes :- expect encryptor.EncryptItem(Types.EncryptItemInput(plaintextItem:=inputItem));
    resp :- expect client.PutItem(MakePutInput(encryptRes.encryptedItem));

    inputItem := map[
      "Name" := DDB.AttributeValue.S("TwoSetsGood"),
      "TheSet" := DDB.AttributeValue.SS(["aaa", "bbb", "ccc"]),
      "TheSet" := DDB.AttributeValue.SS(["ddd", "eee"])
    ];
    encryptRes :- expect encryptor.EncryptItem(Types.EncryptItemInput(plaintextItem:=inputItem));
    resp :- expect client.PutItem(MakePutInput(encryptRes.encryptedItem));

    inputItem := map[
      "Name" := DDB.AttributeValue.S("TwoSets"),
      "TheSet" := DDB.AttributeValue.SS(["ccc", "aaa", "bbb"]),
      "Set2" := DDB.AttributeValue.NS(["3", "1", "2", "5"])
    ];
    encryptRes :- expect encryptor.EncryptItem(Types.EncryptItemInput(plaintextItem:=inputItem));
    resp :- expect client.PutItem(MakePutInput(encryptRes.encryptedItem));

    inputItem := map[
      "Name" := DDB.AttributeValue.S("ThreeSets"),
      "TheSet" := DDB.AttributeValue.SS(["ccc", "aaa", "bbb"]),
      "Set2" := DDB.AttributeValue.NS(["3", "1", "2", "5"]),
      "Set3" := DDB.AttributeValue.BS([[3,2,1], [1,2,3,4]])
    ];
    encryptRes :- expect encryptor.EncryptItem(Types.EncryptItemInput(plaintextItem:=inputItem));
    resp :- expect client.PutItem(MakePutInput(encryptRes.encryptedItem));

    GoodGet(client, encryptor, "BasicX");
    GoodGet(client, encryptor, "BasicXY");
    GoodGet(client, encryptor, "BasicXYZ");
    GoodGet(client, encryptor, "Num1");
    GoodGet(client, encryptor, "BinA");
    GoodGet(client, encryptor, "BinAB");
    GoodGet(client, encryptor, "BinABC");
    GoodGet(client, encryptor, "BasicE");
    GoodGet(client, encryptor, "BasicEX");
    GoodGet(client, encryptor, "BinE");
    GoodGet(client, encryptor, "BinEC");
    GoodGet(client, encryptor, "TwoSetsGood");
    GoodGet(client, encryptor, "SetInList1");

    BadGet(client, encryptor, "BasicYX");
    BadGet(client, encryptor, "BasicXZY");
    BadGet(client, encryptor, "BasicZXY");
    BadGet(client, encryptor, "BasicZYX");
    BadGet(client, encryptor, "BasicYXZ");
    BadGet(client, encryptor, "BasicYZX");

    BadGet(client, encryptor, "BinBA");
    BadGet(client, encryptor, "BinACB");
    BadGet(client, encryptor, "BinBAC");
    BadGet(client, encryptor, "BinBCA");
    BadGet(client, encryptor, "BinCAB");
    BadGet(client, encryptor, "BinCBA");
    BadGet(client, encryptor, "Num32a1");
    BadGet(client, encryptor, "SetInList2");
    BadGet(client, encryptor, "SetInList3");
    BadGet(client, encryptor, "SetInList4");
    BadGet(client, encryptor, "SetInMap1");
    BadGet(client, encryptor, "SetInListInMap1");
    BadGet(client, encryptor, "SetInMapInList1");
    BadGet(client, encryptor, "TwoSets");
    BadGet(client, encryptor, "ThreeSets");

  }
}
