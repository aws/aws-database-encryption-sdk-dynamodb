[//]: # "Copyright Amazon.com Inc. or its affiliates. All Rights Reserved."
[//]: # "SPDX-License-Identifier: CC-BY-SA-4.0"

# Scan Beacons as used with DynamoDB

## Version

0.1.0

### Changelog

## Definitions

 * source field : an encrypted DynamoDB attribute
 * scan beacon field : an attribute holding the truncated HMAC of a source field,
as defined [here](scan-beacons.md)
 * gazelle prefix : `aws-ddbec-`
 * scan beacon prefix : `aws-ddbec-sb-`
 * modified scan beacon : a scan beacon with a "previously" section.

### Conventions used in this document

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL"
in this document are to be interpreted as described in [RFC 2119](https://tools.ietf.org/html/rfc2119).

### Overview

A `DynamoDBTableEncryptionConfig` object provides the list of Scan Beacons for the table associated with an operation,
and other necessary configuration information.

Various Request and Response objects are transformed, based on this configuration.

It should be noted that primary keys cannot be scan beacons,
both because primary keys are not encrypted
and because scan becaons are designed to create false duplicates.

The basic user experience is this 
1. User constructs a client object, registering Gazelle intercepts
2. User calls client methods as normal*
3. Gazelle interceptors might call one of the below functions to transform a request, then encrypts the request as necessary.
4. Gazelle interceptors decrypt the response as necessary, then might call one of the functions below to transform the response.
5. User recieves the reposnse.

* Except for query; where instead of client.query(request) the user must call DynamoDBEncryptionInterceptor.query(client, request)

#### Indexing

When a request is made to create a Index for a source field,
instead the index must be created on the scan beacon field.

When the projection contains a source field, the scan beacon field is also included in the projection.

It can be dangerous to specify a projection other than ALL,
because decryption requires the presense of all signed fields
that were present when the record was written.

#### Writing

Whenever a record is written, if the source field is written then the scan beacon field must also be written.
That is, for every encrypted attribute with a scan beacon, an additonal attribute is written.

It is a error to attempt to write a source attribute starting with the gazelle prefix.

#### Reading

To retrieve a record based on the value of an encrypted source field,
search instead for the hash of the value in the scan beacon field.

Note that only exact matches can be supported. No ranged queries or inequalities.
It is an error to attempt such a query.

This might return false positive results. After retrieving records in this way,
you examine the decrypted record and compare the source field value to the query value,
and discard any records where they don't match.

It is an error to attempt to search on an encrypted attribute that has no scan beacon.

## Operations

#### Note : The object types below are referred to by the Dafny names generated by Polymorph

### transformCreateTableInput

 * This operation MUST take a CreateTableInput object as input.
 * This operation MUST return a CreateTableInput object.
 * If no Global Secondary Index is being created, the CreateTableInput object MUST be returned unaltered.
 * If the Global Secondary Index being created includes no source fields, that is,
if the KeySchema does not mention a source field, the CreateTableInput object MUST be returned unaltered.
 * If the Global Secondary Index being created includes a source field,
the returned CreateTableInput object MUST replace the source field names
with the corresponding scan beacon field names in the KeySchema.

### transformUpdateTableInput

 * This operation MUST take as input an UpdateTableInput object.
 * This operation MUST return an UpdateTableInput object.
 * If no Global Secondary Index is being created, the UpdateTableInput object MUST be returned unaltered.
 * If the Global Secondary Index being created includes no source fields, that is,
if the KeySchema does not mention a source field, the UpdateTableInput object MUST be returned unaltered.
 * If the Global Secondary Index being created includes a source field,
the returned UpdateTableInput object MUST replace the source field names with the corresponding scan beacon field names in the KeySchema.

### transformPutItemInput
 * This operation MUST take as input an PutItemInput object.
 * This operation MUST return an PutItemInput object.
 * For each element in the `Item` map that specifes a source field,
 the returned `Item` map MUST also include the scan beacon field.
The name of this field MUST be the concatenation of the `scan beacon prefix` and the source field name.
The value of ths field MUST be the truncated HMAC as defined by the scan beacon.
 * An error MUST be returned if the name of an Item in the input `Item` map begins with the `Gazelle prefix`

### transformBatchWriteItemInput
 * This operation MUST take as input a BatchWriteItemInput object.
 * This operation MUST return a BatchWriteItemInput object.
 * For each element in the `Item` maps that specify a source field,
the returned `Item` maps MUST also include the scan beacon field.
The name of this field MUST be the concatenation of the `scan beacon prefix` and the source field name.
The value of ths field MUST be the truncated HMAC as defined by the scan beacon.
 * An error MUST be returned if the name of an Item in an input `Item` map begins with the `Gazelle prefix`

### transformTransactWriteItemsInput
 * This operation MUST take as input a TransactWriteItemsInput object.
 * This operation MUST return a TransactWriteItemsInput object.
 * For each element in the `Item` maps that specify a source field,
the returned `Item` maps MUST also include the scan beacon field.
The name of this field MUST be the concatenation of the `scan beacon prefix` and the source field name.
The value of ths field MUST be the truncated HMAC as defined by the scan beacon.
 * An error MUST be returned if the name of an Item in an input `Item` map begins with the `Gazelle prefix`

#### Note : GetItem, BatchGetItem and TransactGetItems work only on Primary Keys, and therefore are not affected by scan beacons

#### Note PartiQL based methods (executeStatement, batchExecuteStatement, executeTransaction) are beyond the scope of this document.

#### Note : UpdateItem is not allowed in the encryption client, and so can be ignored for scan beacons

### transformQueryInput
 * This operation MUST take as input a QueryInput object.
 * This operation MUST return a list of QueryInput objects
 * If no source fields are mentioned, this operstion MUST return a single QueryInput object,
which is the unaltered input object.
 * This operation MUST fail if the keyConditionExpression compares a source field with anything but equality.
 * This operation MUST fail if the FilterExpressions uses a source field with anything but `=`, `IN`,
 `attribute_exists`, `attribute_not_exists` or `size`.
 * This operation MUST fail if the input FilterExpression or keyConditionExpression directly mention
 an attribute name beginning with the `Gazelle Prefix`
 * If the FilterExpression refers to no source fields, the FilterExpression MUST remain unchanged.
 * If the FilterExpression refers to source fields only with `attribute_exists`, `attribute_not_exists` or `size`,
the FilterExpression MUST be returned unchanged.
 * For each source field in the Filter Expression that is not a modified scan beacon,
and is used with the `=` or `IN` operators,
this operation MUST replace source fields and values with scan beacon fields and HMACs
 * For each source field in the FilterExpression are modified scan beacons, this operation MUST replace `(field EQ value)` with `((beacon_field EQ prev_beacon_value) OR (beacon_field EQ beacon_value))` and replace `field IN(A, B)` with `beacon_field IN (beacon_A, beacon_B) OR beacon_field in (prev_beacon_A, prev_beacon_B)`.

The particulatrs of the keyConditionExpression determine the number of QueryInput objects returned.

 * If the keyConditionExpression refers to no modifed scan beacons,
this opertion must return exactly one QueryInput object.
 * If the keyConditionExpression refers to one modifed scan beacon,
this opertion MUST return two QueryInput objects;
one with the keyConditionExpression's field and value replaced with the current scan beacon settings
and one with the keyConditionExpression's field and value replaced with the previous scan beacon settings
 * If the keyConditionExpression refers to two modifed scan beacons,
this opertion MUST return between two and four QueryInput objects, replacing the keyConditionExpression's field and value with
 *
    1. previous partition pey, previous sort key
    2. previous partition pey, current sort key
    3. current partition pey, previous sort key
    4. current partition pey, current sort key
 * If either scan beacon lacks a version number,
this operation MUST return all four QueryInput objects
 * If the two version numbers are equal,
this operation MUST return only the first and last QueryInput objects
 * If the partition key version is less than the sort key version,
this operation MUST return only QueryInput objects 1, 2 and 4
 * If the partition key version is greater than the sort key version,
this operation MUST return only QueryInput objects 1, 3 and 4


#### Note : transformQueryOutput needs a QueryInput object, becase we need to check the result records against the values searched in the QueryInput object, which are not directly available in the QueryOutput object.

### transformQueryOutput
 * This operation MUST take as input a QueryOutput object and a QueryInput object
 * The QueryInput object MUST be assumed to be the origial query, not one of the results of transformQueryInput
 * This operation MUST return an QueryOutput object.
 * This operation MUST remove any records for which the original QueryInput does not match, that is,
if the original FilterExpression included `Src EQ "foo"` (where `Src` is a source field)
then this operation must remove any record in which the  `Src` field contains something other than "foo".
 * This operation MUST return all records that match the original QueryInput.

### mergeQueryOutput
 * This operation MUST take as input two QueryOutput objects
 * This operation MUST return a single QueryOutput object
 * The ConsumedCapacity of the result must contain the sum of the corresponding numbers in the two sources.
 * The Count and ScannedCount fields of the result must contain the sum of the corresponding numbers in the two sources.
 * The Items of the result must be the concatenation of the lists in the two sources

### transformScanInput
 * This operation MUST take as input a ScanInput object.
 * This operation MUST return a ScanInput object.
 * This operation MUST fail if a source field is compared with anything but equality
 * If no source fields are mentioned in the FilterExpression, the ScanInput object MUST be returned unchanged.

 * For beacons in the FilterExpression that have no "previous" entry,
this operation MUST replace source fields and values with scan beacon fields and HMACs
 * For beacons in the FilterExpression that do have a "previous" entry,
this operation MUST replace `field EQ value` with `(prev_beacon_field EQ prev_beacon_value) OR (beacon_field EQ beacon_value)`

#### Note : transformScanOutput needs a ScanInput object, becase we need to check the result records against the values searched in the ScanInput object, which are not directly available in the QueryOutput object.

### transformScanOutput
 * This operation MUST take as input a ScanOutput object and a ScanInput object.
 * This operation MUST return an ScanOutput object.
 * This operation MUST remove any records for which the original QueryInput does not match, that is,
if the original FilterExpression included `Src EQ "foo"` (where `Src` is a source field)
then we might get results where the `Src` field contains something other than "foo" (because false positives are expected).
Those results must be removed. 


## Operational Considerations
Fully supporting FilterExpressions, will require a complete parsing of the FilterExpression,
which is sensitive to any updates that the DynamoDB team makes to the expression language.
