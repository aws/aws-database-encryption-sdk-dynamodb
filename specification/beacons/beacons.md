[//]: # "Copyright Amazon.com Inc. or its affiliates. All Rights Reserved."
[//]: # "SPDX-License-Identifier: CC-BY-SA-4.0"

# Beacons

## Version

1.0.0

### Changelog

## Overview

Beacons use stable hashes of the plaintext values of encrypted fields to allow searches on client-side encrypted records.

### Beacon Length

The `Beacon Length` is the number of bits of the hash value that is kept.

If any given beacon value maps back to a unique plaintext value,
attackers can be given some insight into your plaintext.

An extreme example of this would be a boolean field representing
"this person is over 7 feet tall". The resulting beacon would have value
`X` 99.9% of the time and value `Y` 0.1% of the time, making it trivial to determine which value maps to which plaintext.

To avoid this, we truncate the hash to ensure some collisions.

For a field with `X` distinct values, you should choose a beacon length `N`
such that `2^N < X/2` to guarantee collisions.

On the other side of the spectrum, if the beacon length is too short,
then there are too many collisions and query performance begins to 
approach a simple scan of all the data. A reasonable lower bound is
ensure that `2^N` is greater than the square root of X.

For example, a well distributed 5-digit zip code has 100,000 distinct values.
To properly anonymize this, one would use a beacon length between 9 and 15 bits.

A beacon length MUST be an integer between 1 and 63 inclusive.


### Standard Beacon

The simplest form of beacon is a plain beacon.
To produce a plain beacon from a sequence of bytes :
1. Compute the HMAC
1. Truncate the HMAC, to the [beacon length](#beacon-length)
1. Turn the result into a hex string, with leading zeros removed.

For example, the beacon for `banana` might be `4f`.

Standard Beacons can only be compared for equality.
It makes no sense to say that one standard beacon is less than another,
or one is a substring of another.

Standard beacons are strings, because compound beacons need to be strings,
and customers need to be able to switch from standard to compound beacons easily.

### Compound Beacon

Compound Beacons are computed from strings,
and consist of [standard beacons](#standard-beacon)
interleaved with plain text.
The following are different kinds of compound beacons,
with examples of why customers need this functionality.

#### Prefix Beacon

One way to define a Compound Beacon is with prefix character.
The text before the prefix character is unchanged, and a standard beacon
is computed for the rest.

For example, with a prefix character of `:`, the beacon for `2022-11-07:banana` might be `2022-11-07:4f`

Prefix Beacons allow comparisons such as `less than`, `begins with` and `between` and `contains`
on the nonsensitive prefix.

#### Split Beacon

Another way to define a Compound Beacon is with a split character.

A string is split on this character, into a list of items,
and a separate standard beacon is generated for each item.

For example, with a split character of `:`, the beacon for `apple:banana:pear` might be `:a9:4f:42:`

The delimiter is included at the start and end so that you can search for `:4f:` as a substring, no matter its position in the list.

Split Beacons allow comparisons such as `begins with` and `contains`, but not `less than` or `between`.

If the different items in the list have different numbers of unique values,
it might be necessary to have a different [beacon length](#beacon-length)
for each item in the resulting list.

Thus one can optionally configure a list of
<a name="split-lengths">split lengths</a>
such that the first string in the list generated by the split uses
the first [beacon length](#beacon-length) in `split lengths`.

If split lengths are used, then the first length must be equal
to the [beacon length](#beacon-length) of the beacon, so that
there is no difference between a list of length one and a plain value.

If there are more items in the split list than in the split lengths,
the final entry in split lengths is used for all following items.

Optional flags are provided, to fail if the number of items
in the input string is less or greater than then number of
entries in `split lengths`

#### Inner Split

Imagine a field consisting of building/floor/room, e.g. `SEA17:14:905`
with a split character of `:` this might become a beacon of `.86.99.86.`
because sometimes collisions occur. Thus a search for contains("SEA17")
and a search for contains("905") would both search for contains(".86.")
and so would return the same records.

So we introduce the `inner` character, which acts like a 
[prefix character](#prefix-beacon) for each part of a split.

If the field value is `B-SEA17:F-14:R-905` with a [split character](#split-beacon)
of `:` and an inner character of `-`, then the beacon might become
`.B-86.F-99.R-86.` making it possible to distinguish `building=SEA17` (B-86)
from `Room=905` (R-86)

#### Combined Beacon

Prefix and Split characters can be defined on the same beacon,
so that `2022-11-07:B-SEA17.F-14.R-905` might map to 
`2022-11-07:.B-86.F-99.R-86.`

#### Ignore Character

At query time, one might need to refer one part in the middle of a beacon value.
If [split lengths](#split-lengths) are used, this is even more necessary,
because the [beacon length](#beacon-length) of each part might be different.

The ignore character designates a place holder, so the query engine
can know what it's parsing.

For example, in our `Combined Beacon` example, to refer to anything
on the 14th floor, one could use an ignore character of `_` and
specify `_:_.F-14`

## Definitions

### Conventions used in this document

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL"
in this document are to be interpreted as described in [RFC 2119](https://tools.ietf.org/html/rfc2119).


## Beacon Configuration

### Beacon Record 

A beacon definition MUST provide the following:
 * A name -- a sequence of characters
 * A plain text HMAC key -- a sequence of bytes
 * A `length` -- a [beacon length](#beacon-length)
 * An OPTIONAL `prefix` character, defining a [prefix beacon](#prefix-beacon)
 * An OPTIONAL [Split Record](#split-record) defining a [split beacon](#split-beacon)
 * An OPTIONAL `ignore` character, defining the [ignore character](#ignore-character)

### Split Record

A Split Record must provide the following
 * A `split` character, to designate a [split beacon](#split-beacon)
 * `split-lengths`, a sequence of [beacon length](#beacon-length),
for use with a [split beacon](#split-beacon)
 * An OPTIONAL `inner` character to designate an [inner split](#inner-split)
 * A boolean fail_if_short -- if true, fail if the input string has fewer parts than `split-lengths`
 * A boolean fail_if_long -- if true, fail if the input string has more parts than `split-lengths`

---

 * Construction MUST fail if a [Split Record](#split-record) is specified,
and it specifies a non-empty `split-lengths`,
and the first element of `split-lengths` is not equal to
the `length` in the beacon record.


## Beacon Operations

The two Operations defined on a Beacon Record are defined in terms of functionality
defined in the following section, [Beacon Helpers](#beacon-helpers).

### plainHash
 * plainHash MUST take a sequence of bytes as input.
 * plainHash MUST take an unsigned integer `position` as input.
 * plainHash MUST produce a non-empty string as output.
 * plainHash MUST calculate a hash length by calling [hashLength](#hashLength) with the supplied `position`.
 * plainHash MUST must calculate the [baseHash](#baseHash) of the input bytes and the returned [hashLength](#hashLength) length.
 * plainHash MUST return this value formatted as lowercase hexadecimal,
with leading zeros removed, except that 0 is returned as "0".

### compoundHash

 * compoundHash MUST take a string as input.
 * compoundHash MUST produce a non-empty string as output.
 * If the [Beacon Record](#beacon-record) does not contain a [prefix character](#prefix-beacon),
compoundHash MUST return the [splitHash](#splitHash) of the input string
 * compoundHash MUST fail if the input string does not contain the prefix character.
 * compoundHash MUST split the input string into two pieces,
based on the first occurrence of the prefix character in the input string.
 * If the first piece is the [ignore character](#ignore-character),
compoundHash MUST return the [splitHash](#splitHash) of the second piece
 * otherwise, compoundHash MUST return the concatenation of
 * * the first piece,
 * * the prefix character,
 * * and the [splitHash](#splitHash) of the second piece.


## Beacon Helpers

### splitHash

 * splitHash MUST take a string as input.
 * splitHash MUST produce a non-empty string as output.
 * If the [Beacon Record](#beacon-record) does not specify a [Split Record](#split-record) 
splitHash MUST return the [plainHash](#plainHash) of the input string and zero
 * splitHash MUST split the input string into pieces based on the [split](#split-beacon) character.
 * splitHash MUST fail if `fail_if_short` in the [Split Record](#split-record) is `true`
and the number of pieces in the input string is less than the number of lengths in `split-lengths`
 * splitHash MUST fail if `fail_if_long` in the [Split Record](#split-record) is `true`
and the number of pieces in the input string is greater than the number of lengths in `split-lengths`
 * splitHash must return the concatenation of,
 * * the split character
 * * for each part that is not the [ignore](#ignore-character) character,
 the [innerHash](#innerHash) of the part and its position, followed by the split character
 * If the input string does not contain the split character,
splitting the string results in a single piece.
This is not, in and of itself, an error.

### innerHash
 * innerHash MUST take a string and an unsigned integer, `position`, as input.
 * innerHash MUST produce a non-empty string as output.
 * If the configuration does not specify an [inner](#inner-split) character,
innerHash MUST return the [plainHash](#plainHash) of the input string and the supplied position
 * innerHash MUST fail if the input string does not contain the [inner](#inner-split) character.
 * innerHash MUST split the input string into two pieces, on the
first occurrence on the [inner](#inner-split) character.
 * innerHash MUST return the concatenation of
 * * the first part of the input string
 * * the inner character
 * * the [plainHash](#plainHash) of the second part of the string and the supplied position.

### baseHash
 * baseHash MUST take a sequence of bytes as input.
 * baseHash MUST take a [beacon length](#beacon-length) as input
 * baseHash MUST return a 64 bit integer
 * baseHash MUST must take the 
[HmacSha384](https://www.ietf.org/rfc/rfc2104.txt)
of the input and the configured key, interpret the first 8 bytes
as a big endian unsigned 64-bit integer, and 
and return the least significant [beacon length](#beacon-length) bits.

### hashLength
 * hashLength MUST take an unsigned integer `position` as input
 * hashLength MUST return a [beacon length](#beacon-length)
 * If the input is zero, hashLength MUST return the beacons's `length`.
 * If `split-lengths` is empty, hashLength MUST return the beacons's `length`.
 * If the input number is less than the number of values in `split-lengths`,
hashLength MUST return the (zero-based) Nth number in the list;
otherwise, hashLength MUST return the last number in `split-lengths`






