[//]: # "Copyright Amazon.com Inc. or its affiliates. All Rights Reserved."
[//]: # "SPDX-License-Identifier: CC-BY-SA-4.0"

# DynamoDB Beacons

## Version

1.0.0

### Changelog

## Definitions

 * See the definitions for [beacons](./beacons.md).
 * **non-beaconed field** : an encrypted field without an associated beacon
 * **gazelle prefix** : `gZ_`
 * **beacon prefix** : `gZ_b_`
 * **source field** : an encrypted DynamoDB attribute with an associated beacon
 * **beacon field** : the attribute holding the truncated HMAC of a source field

The name of the beacon field is the concatenation of
the beacon prefix and the source field name.

### Conventions used in this document

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL"
in this document are to be interpreted as described in [RFC 2119](https://tools.ietf.org/html/rfc2119).

### Overview

A `DynamoDBTableEncryptionConfig` object provides the list of Beacons
for the table associated with an operation,
and other necessary configuration information.

Various Request and Response objects are transformed, based on this configuration.

Primary keys cannot be beacons,
both because primary keys are not encrypted
and because beacons are designed to create false duplicates.

The basic user experience is this 
1. User constructs a client object, registering Gazelle intercepts
2. User calls client methods as normal
3. Gazelle interceptors might call one of the below functions to transform a request, then encrypts the request as necessary.
4. Gazelle interceptors decrypt the response as necessary, then might call one of the functions below to transform the response.
5. User receives the response.

#### Indexing

When a request is made to create a Index for a source field,
instead the index must be created on the beacon field.

When the projection contains a source field, the beacon field is also included in the projection.

It can be dangerous to specify a projection other than ALL,
because decryption requires the presence of all signed fields
that were present when the record was written.

Users might create tables and/or indexes in the console. In this case,
they must be well educated to perform these same transformations by hand.

#### Writing

Whenever a record is written, if the source field is written then the beacon field must also be written.
That is, for every encrypted attribute with a beacon, an additional attribute is written.

It is an error to attempt to write a source attribute starting with the gazelle prefix.

#### Reading

To retrieve a record based on the value of an encrypted source field,
search instead for the hash of the value in the beacon field.

 * With no beacon, and encrypted attribute cannot be searched.
 * With plain beacons, only exact matches can be supported.
 * compound beacons with a prefix can support ranged queries such as `<`, `between` and `begins_with`.
 * compound beacons with a split can support these ranged queries as well as `contains`

It is an error to attempt a query with an unsupported operation.

Because beacons might be truncated, these queries might return false positive results.
After retrieving records in this way,
the library must  examine the decrypted record and compare the source field values to the query values,
and discard any records where they don't match.

### Configuration

The DynamoBeacons object MUST contain

 * A list of table configs

*DynamoBeacons is actually a Gazelle thing, and this should be a pointer into the Gazelle spec*

A table config MUST contain

 * A name
 * A list of attributes, defining each as `ENCRYPT_AND_SIGN`, `SIGN_ONLY`, or `DO_NOTHING`.
 * A list of beacon version configurations

*A table config is actually a Gazelle thing, and this should be a pointer into the Gazelle spec*


A beacon version configuration MUST contain
 
 * A version number
 * A `magic thingy` to indicate how to get keys from the hierarchy keyring
 * A boolean `write` flag.
 * A list of [beacon configuration](./beacons.md#beacon-configuration)
 * An OPTIONAL Primary Key Definition : The name of the primary key for the table,
the partition and optional sort key to be used to create this key.
 * A list of LSI Styles : A Local Secondary Index name, along with WIDE or NARROW.

Construction of a `table config` MUST fail if
 * There is at least one `beacon version` and the number of `beacon version`s with the `write` flag set is not exactly one.

## Operations

*Note* : The object types below are referred to by the Dafny names generated by Polymorph

*Note* : When the text below says "alter the input" this should be read as
"the output should be equal to the input, but altered in this way".

No customer input should ever refer to forbidden field
### forbiddenField
 * forbiddenField MUST take a string as input
 * forbiddenField MUST return a boolean
 * if the input string begins with gZ_v_ forbiddenField MUST return false
 * if the input string begins with gZ_ forbiddenField MUST return true
 * forbiddenField MUST return false

### transformPrimaryKeySchema
 * transformKeySchema MUST take a KeySchema as input
 * transformKeySchema MUST return a KeySchema
 * if no Primary Key Parts are configured, transformKeySchema MUST return the unaltered input
 * transformKeySchema  MUST fail if the input KeySchema is not empty.
 * transformKeySchema MUST return a KeySchema
with the name given in the Primary Key Parts and type `HASH`

### serializeAttributeValue
 * serializeAttributeValue MUST take an AttributeValue as input
 * serializeAttributeValue return a seq<uint8>
 * the implementation MUST be taken from Gazelle, in a manner TBD.

### calculatePrimaryKeyValue
 * calculatePrimaryKeyValue MUST take a PutItemInputAttributeMap as input
 * calculatePrimaryKeyValue MUST return seq<uint8> of length 48.
 * calculatePrimaryKeyValue MUST fail if the partition key is missing from the input attributes.
 * calculatePrimaryKeyValue MUST fail if the sort key is specified, yet missing from the input attributes.
 * The data key used for the HMACs below MUST be the HKDF (pointer to hierarchy keychain needed) of the table's key and the primary key name.
 * If only a primary key is specified, then an HMAC384 must be generated from
the `serializeAttributeValue` of that value. 
 * Otherwise, an HMAC384 must be generated from the concatenation of the `serializeAttributeValue` of the partition key value,
a literal `_` character, and the `serializeAttributeValue`  of the sort key value.


### transformKeySchemaElement
 * transformKeySchemaElement MUST take a KeySchemaElement as input
 * transformKeySchemaElement MUST return a KeySchemaElement
 * transformKeySchemaElement MUST fail if the input AttributeName is a `forbidden field`
 * transformKeySchemaElement MUST fail if the input AttributeName refers to a non-beaconed field.
 * If the input AttributeName refers to a source field, the AttributeName 
of the returned KeySchemaElement must be the name of the associated beacon field.
 * Otherwise, the returned KeySchemaElement MUST be returned unchanged.

### transformGSI
 * transformGSI MUST take a GlobalSecondaryIndex as input
 * transformGSI MUST return a GlobalSecondaryIndex
 * The returned GlobalSecondaryIndex MUST have a KeySchema generated by
mapping each element of the input KeySchema through transformKeySchemaElement
 * transformGSI MUST fail if the projection includes a `forbiddenField`.
 * transformGSI MUST return a Projection with NonKeyAttributes equal to
all input NonKeyAttributes, plus the associated `beacon field` for any
`source field` in the NonKeyAttributes.

### transformLSI
 * transformGSI MUST take a LocalSecondaryIndex as input
 * transformGSI MUST return a LocalSecondaryIndex
 * The returned LocalSecondaryIndex MUST have a KeySchema generated by
mapping each element of the input KeySchema through transformKeySchemaElement
 * transformGSI MUST fail if the Projection includes a `forbiddenField`.
 * If this index is configured as NARROW, transformLSI MUST return
a Projection with NonKeyAttributes equal to the input NonKeyAttributes,
with any `source field` replaced with its associated `beacon field`.
 * If this index is not configured as NARROW,
transformLSI MUST return a Projection with NonKeyAttributes equal to
all input NonKeyAttributes, plus the associated `beacon field` for any
`source field` in the NonKeyAttributes.

### transformCreateTableInput

 * transformCreateTableInput MUST take a CreateTableInput object as input.
 * transformCreateTableInput MUST return a CreateTableInput object.
 * if Primary Key Parts are not configured, ehe returned value
MUST have a KeySchema equal to the result of calling
transformPrimaryKeySchema on the input KeySchema
 * if Primary Key Parts are configured, transformCreateTableInput MUST fail
if the input KeySchema is not a single entry, with the
configured name and type `HASH`.
 * if Primary Key Parts are configured, the returned AttributeDefinitions
must include an attribute with the name of the primary, and type "B" binary.
 * The returned GlobalSecondaryIndexes MUST be a sequence generated by
mapping each element of the input GlobalSecondaryIndexes through transformGSI
 * The returned LocalSecondaryIndexes MUST be a sequence generated by
mapping each element of the input LocalSecondaryIndexes through transformLSI
 * The returned AttributeDefinitions MUST be equal to the input AttributeDefinitions,
plus, for each `beacon field` used in an index, an AttributeDefinition with the
AttributeName equal to the `beacon field` and the AttributeType equal to "S" String.


### transformUpdateTableInput

 * transformUpdateTableInput MUST take as input an UpdateTableInput object.
 * transformUpdateTableInput MUST return an UpdateTableInput object.
 * CreateGlobalSecondaryIndexAction
 * If a Global Secondary Index being created, the CreateGlobalSecondaryIndexAction
must be modified as per `transformGSI`

### testConditionExpression
 * testConditionExpression MUST take as input
an Option<ConditionExpression>,
and an Option<ExpressionAttributeNameMap>
 * testConditionExpression MUST return a boolean
 * testConditionExpression MUST fail if the ConditionExpression refers to an encrypted field.
 * testConditionExpression MUST fail if the ConditionExpression refers to a `forbiddenField`.
 * testConditionExpression MUST return true

### transformPutItemInput
 * transformPutItemInput MUST take as input an PutItemInput object.
 * transformPutItemInput MUST return an PutItemInput object.
 * The input conditionExpression MUST be tested with `testConditionExpression`
 * transformPutItemInput MUST fail if the name of any input `Item` begins
with the `gazelle prefix`. 
 * transformPutItemInput MUST use the `beacon version` with the write flag set.
 * The returned `Item` must include an attribute with name gZ_v_N, where `N`
is the version number of the `beacon version` with the write flag set, and a
value of type String with value or a single space.
 * For each element in the `Item` map that specifies a source field,
 the returned `Item` map MUST also include the beacon field.
 * The name of this field MUST be the concatenation of the `beacon prefix` and the source field name.
 * The value of this field MUST be the defined [beacon](./beacons.md)
 * If the Primary Key Parts are configured, and the primary key name
already exists in `Item`, transformPutItemInput MUST fail.
 * If the Primary Key Parts are configured, an additional `Item` MUST be returned
with the configured name, type "B" Binary, and a value as calculated with `calculatePrimaryKeyValue`. 

### transformUpdateItemInput
 * transformUpdateItemInput MUST take as input an UpdateItemInput
 * transformUpdateItemInput MUST return the unmodified input object
 * transformUpdateItemInput MUST fail if any part of the input
object mentions an attribute name starting with the `gazelle prefix`.
 * transformUpdateItemInput MUST fail if the input object attempts to modify a signed attribute.
 * transformUpdateItemInput MUST fail if `testConditionExpression` fails

### transformBatchWriteItemInput
 * transformBatchWriteItemInput MUST take as input a BatchWriteItemInput object.
 * transformBatchWriteItemInput MUST return a BatchWriteItemInput object.
 * Each PutRequest MUST be handled as outlined above in transformPutItemInput

### transformTransactWriteItemsInput
 * transformTransactWriteItemsInput MUST take as input a TransactWriteItemsInput object.
 * transformTransactWriteItemsInput MUST return a TransactWriteItemsInput object.
 * Each `Put` MUST be handled as outlined above in transformPutItemInput
 * Each Condition Expression must be tested with `testConditionExpression`
 * Each Update must be handled as outlined above in `transformUpdateItemInput`
 * The ConditionExpression of each Delete must be tested with `testConditionExpression`
 

*note* GetItem, BatchGetItem and TransactGetItems operate only on primary keys,
which can never be encrypted, and so are not affected by beacons.

*note* ExecuteStatement, BatchExecuteStatement and ExecuteTransaction operate
on SQL statements, which are not supported by beacons at this time


### transformationFilterExpression
 * transformationFilterExpression MUST take as input
a BeaconVersion
an Option<ConditionExpression>,
an Option<ExpressionAttributeNameMap>,
and an Option<ExpressionAttributeValueMap>
 * transformationFilterExpression MUST return
an Option<ConditionExpression>,
an Option<ExpressionAttributeNameMap>,
and an Option<ExpressionAttributeValueMap>
 * This operation MUST fail if an attribute name that starts with the `gazelle prefix` is mentioned.
 * This operation MUST fail if any source field is used with a document path.
 * If no encrypted field is mentioned, the Expression MUST be returned unmodified.
 * The operations `attribute_exists`, `attribute_not_exists` and `size` are permitted on any field, and their arguments MUST not be modified.
 * All operations are permitted on unencrypted fields.
 * The operations `=`, `IN`, `attribute_exists`, `attribute_not_exists` and `size`;
as well as the boolean `AND`, `OR` and `NOT` are permitted for any type of beacon.
 * All comparators, and the `BETWEEN` and `begins_with` operations are permitted on
beacons configured with `prefix` or `split`.
 * The operation `contains` is permitted on beacons configured with `split`.
 * This operation MUST fail if a field is used with an operation that is not permitted.
 * Each reference to a field with a beacon must be replaced by the associated beacon.
For example, `field < value` would be replaced by `gZ_b_field < beacon_value`

### transformationFilterExpressionMulti
 * transformationFilterExpression MUST take as input
a list of BeaconVersions
an Option<ConditionExpression>,
an Option<ExpressionAttributeNameMap>,
and an Option<ExpressionAttributeValueMap>
 * transformationFilterExpression MUST return
an Option<ConditionExpression>,
an Option<ExpressionAttributeNameMap>,
and an Option<ExpressionAttributeValueMap>
 * If no  beacons versions are provided, transformationFilterExpressionMulti
MUST return the input arguments unchanged.
 * If one beacons version is provided, transformationFilterExpressionMulti
MUST return the results of transformationFilterExpression with that beacon version.
 * transformationFilterExpressionMulti MUST create a list of results by calling transformationFilterExpression with each provided Beacon Version.
 * transformationFilterExpressionMulti MUST remove duplicates from this list.
 * transformationFilterExpressionMulti MUST combine the remaining ones, individually parenthesized, with `OR`.
For example, if E1 and E2 are created and unique, return `(E1) OR (E2)`



findVersion looks at the exclusiveStartKey in a QueryInput
and returns the beacon version held therein.

### findVersion
 * findVersion MUST take as input a QueryInput object
 * findVersion MUST return both an optional version number and a boolean `hadContent` flag.
 * If the input object has no exclusiveStartKey, then findVersion MUST return (None, false)
 * If the exclusiveStartKey has a `gZ_version` field which holds a number,
the first value returned by findVersion MUST be that number, and None otherwise
 * If the exclusiveStartKey has fields other than `gZ_version`,
the second value returned by findVersion MUST be true, and false otherwise

### createKeyCondition
 * createKeyCondition MUST take as input a keyConditionExpression and a single `beacon version`
 * createKeyCondition MUST return a keyConditionExpression
 * createKeyCondition MUST replace each reference to a source field with the associated beacon and value. For example, `field < value` would be replaced by `gZ_b_field < beacon_value`
 * createKeyCondition MUST fail if and operator other than `=` is used with a beacon
configured with neither `prefix` nor `split`
 * createKeyCondition MUST fail if and operator other than `=` or `begins_with` is used with a beacon not configured with `prefix`


### createKeyConditionList
 * createKeyConditionList MUST take as input a QueryInput object
 * createKeyConditionList MUST return a list of keyConditionExpression with an associated beacon version.
 * For each beacon version, create keyConditionExpression with createKeyCondition
 * remove any duplicate keyConditionExpressions, keeping the one with the highest version number.



### transformQueryInput
 * transformQueryInput MUST take as input a QueryInput object.
 * transformQueryInput MUST return a QueryInput object.
 * transformQueryInput MUST fail if an attribute name that starts with the `gazelle prefix` is mentioned.
 * If no encrypted field is mentioned, transformQueryInput MUST return the unmodified input object.
 * The output object's `Filter Expression` must be derived from the input `Filter Expression` according to `Expression Transformation` above.
 * If the keyConditionExpression refers to no encrypted attributes, then the result
MUST be returned after only the above operations.
 * transformQueryInput MUST call `createKeyConditionList` to create a KeyConditionList
 * transformQueryInput MUST call `findVersion` to create `currentVersion` and `hadContent`
 * transformQueryInput MUST fail if `findVersion` returns (None, true)
 * if `findVersion` returns (None, false) then transformQueryInput MUST return
the keyConditionExpression with the lowest version and no exclusiveStartKey
 * if `findVersion` returns (Some(currentVersion), false), then transformQueryInput MUST return
the keyConditionExpression with lowest beacon version greater than currentVersion,
and no exclusiveStartKey
 * if `findVersion` returns (Some(currentVersion), true), then transformQueryInput MUST return
 * * the beacon version that matches currentVersion, and the exclusiveStartKey with the  gZ_version` field removed, if such a beacon version exists.
 * * the beacon with the lowest version greater than currentVersion, with no exclusiveStartKey if such a beacon version exists
 * * failure if all available beacon versions are less than the returned version.


transformQueryOutput needs the original QueryInput object,
because we need to check the result records against the values searched in the QueryInput object, which are not directly available in the QueryOutput object.

### transformQueryOutput
 * transformQueryOutput MUST take as input a QueryOutput object and a QueryInput object
 * The QueryInput object MUST be assumed to be the original query, not the result of transformQueryInput
 * transformQueryOutput MUST return an QueryOutput object.
 * transformQueryOutput MUST remove any records for which the original QueryInput does not match, that is,
if the original FilterExpression included `Src EQ "foo"` (where `Src` is a source field)
then this operation must remove any record in which the `Src` field contains something other than "foo".
 * This operation MUST return all records that match the original QueryInput.

The final step is to tag the LastEvaluatedKey

 * transformQueryOutput MUST call `createKeyConditionList` to create a keyConditionList
 * transformQueryOutput MUST use `findVersion` to retrieve the `currentVersion`
 * if `currentVersion` is None, replace it with the lowest version in keyConditionList
 * If the input object has a LastEvaluatedKey, transformQueryOutput must return a LastEvaluatedKey equal to the input LastEvaluatedKey with the addition of a number field `gZ_version= currentVersion`
 * If the input object has no LastEvaluatedKey, and `currentVersion` is greater than or equal to the highest version in the keyConditionList, then transformQueryOutput must return an object with no LastEvaluatedKey
 * Otherwise, transformQueryOutput must return a LastEvaluatedKey containing only a number field `gZ_version` set to the lowest version in keyConditionList greater than `currentVersion`


### transformScanInput
 * transformScanInput MUST take as input a ScanInput object.
 * transformScanInput MUST return a ScanInput object.
 * The object's filterExpression it must be modified according to `Expression Transformation` above.


### transformScanOutput
 * transformScanOutput MUST take as input a ScanOutput object and a ScanInput object.
 * transformScanOutput MUST return an ScanOutput object.
 * The ScanInput object MUST be assumed to be the original ScanInput object,
and not the result of transformScanInput call.
 * transformScanOutput MUST remove any records for which the original QueryInput does not match, that is,
if the original FilterExpression included `Src EQ "foo"` (where `Src` is a source field)
then this operation must remove any record in which the  `Src` field contains something other than "foo".
 * transformScanOutput MUST return all records that match the original ScanInput.


## Operational Considerations
Fully supporting FilterExpressions, will require a complete parsing of the FilterExpression,
which is sensitive to any updates that the DynamoDB team makes to the expression language, and is dependent upon the rather sketchy documentation of the semantics
of filter expressions.


