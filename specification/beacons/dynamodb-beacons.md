[//]: # "Copyright Amazon.com Inc. or its affiliates. All Rights Reserved."
[//]: # "SPDX-License-Identifier: CC-BY-SA-4.0"

# DynamoDB Beacons

## Version

1.0.0

### Changelog

## Definitions

 * See the definitions for [beacons](./beacons.md).
 * **non-beaconed field** : an encrypted field without an associated beacon
 * **gazelle prefix** : `gZ_`
 * **beacon prefix** : `gZ_b_`
 * **source field** : an encrypted DynamoDB attribute with an associated beacon
 * **beacon field** : the attribute holding the truncated HMAC of a source field

The name of the beacon field is the concatenation of
the beacon prefix and the source field name.

### Conventions used in this document

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL"
in this document are to be interpreted as described in [RFC 2119](https://tools.ietf.org/html/rfc2119).

### Overview

A `DynamoDBTableEncryptionConfig` object provides the list of Beacons
for the table associated with an operation,
and other necessary configuration information.

Various Request and Response objects are transformed, based on this configuration.

Primary keys cannot be beacons,
both because primary keys are not encrypted
and because beacons are designed to create false duplicates.

The basic user experience is this 
1. User constructs a client object, registering Gazelle intercepts
2. User calls client methods as normal
3. Gazelle interceptors might call one of the below functions to transform a request, then encrypts the request as necessary.
4. Gazelle interceptors decrypt the response as necessary, then might call one of the functions below to transform the response.
5. User receives the response.

#### Indexing

When a request is made to create a Index for a source field,
instead the index must be created on the beacon field.

When the projection contains a source field, the beacon field is also included in the projection.

It can be dangerous to specify a projection other than ALL,
because decryption requires the presence of all signed fields
that were present when the record was written.

Users might create tables and/or indexes in the console. In this case,
they must be well educated to perform these same transformations by hand.

#### Writing

Whenever a record is written, if the source field is written then the beacon field must also be written.
That is, for every encrypted attribute with a beacon, an additional attribute is written.

It is an error to attempt to write a source attribute starting with the gazelle prefix.

#### Reading

To retrieve a record based on the value of an encrypted source field,
search instead for the hash of the value in the beacon field.

 * With no beacon, and encrypted attribute cannot be searched.
 * With plain beacons, only exact matches can be supported.
 * compound beacons with a prefix can support ranged queries such as `<`, `between` and `begins_with`.
 * compound beacons with a split can support these ranged queries as well as `contains`

It is an error to attempt a query with an unsupported operation.

Because beacons might be truncated, these queries might return false positive results.
After retrieving records in this way,
the library must  examine the decrypted record and compare the source field values to the query values,
and discard any records where they don't match.

### Configuration

The DynamoBeacons object MUST contain

 * A list of table configs

*DynamoBeacons is actually a Gazelle thing, and this should be a pointer into the Gazelle spec*

A table config MUST contain

 * A name
 * A list of attributes, defining each as `ENCRYPT_AND_SIGN`, `SIGN_ONLY`, or `DO_NOTHING`.
 * A list of beacon version configurations

*A table config is actually a Gazelle thing, and this should be a pointer into the Gazelle spec*


A beacon version configuration MUST contain
 
 * A version number
 * A `magic thingy` to indicate how to get keys from the hierarchy keyring
 * A boolean `write` flag.
 * A list of [beacon configuration](./beacons.md#beacon-configuration)
 * An OPTIONAL Primary Key Definition : The name of the primary key for the table,
the partition and optional sort key to be used to create this key.
 * A list of LSI Styles : A Local Secondary Index name, along with WIDE or NARROW.

Construction of a `table config` MUST fail if
 * There is at least one `beacon version` and the number of `beacon version`s with the `write` flag set is not exactly one.

## Operations

*Note* : The object types below are referred to by the Dafny names generated by Polymorph

*Note* : When the text below says "alter the input" this should be read as
"the output should be equal to the input, but altered in this way".

### transformCreateTableInput

 * transformCreateTableInput MUST take a CreateTableInput object as input.
 * transformCreateTableInput MUST return a CreateTableInput object.
 * transformCreateTableInput MUST fail if any part of the input
object mentions an attribute name starting with the `gazelle prefix`.
 * If the Primary Key Parts are configured
 * * If no primary key is specified in the input, then a primary key
of the given name and type `Binary` must be added to the input.
 * * If a primary key is specified, and it is not exactly what would have
been added in the previous point, transformCreateTableInput MUST fail
 * If any Global or Local Secondary Index is being created that references
an encrypted field in its Key Configuration,
 * * if that field does not have a beacon configured, transformCreateTableInput MUST fail.
 * * otherwise, that field must be changed to be the beacon field, and its type changed to string.
 * If a Global Secondary Index is being created that has an explicit list
of attributes in its projection
 * * if an encrypted field is in its projection, and that field has a beacon configured,
then that beacon must be added to the projection.
 * * if an encrypted field was mentioned in the Key Configuration, then that
encrypted field must be added to the projection.

 * If a Local Secondary Index, explicitly configured as NARROW,
is being created that has an explicit list of attributes in its projection,
and an encrypted field is in its projection, and that field has a beacon configured,
then that field MUST be replaces by its beacon in the projection.
 * If a Local Secondary Index, not explicitly configured as NARROW,
is being created that has an explicit list of attributes in its projection,
 * * if an encrypted field is in its projection, and that field has a beacon configured,
then that beacon MUST also be included in the projection.
 * * if an encrypted field was mentioned in the Key Configuration, then that
encrypted field must be added to the projection.


### transformUpdateTableInput

 * transformUpdateTableInput MUST take as input an UpdateTableInput object.
 * transformUpdateTableInput MUST return an UpdateTableInput object.
 * transformUpdateTableInput MUST fail if any part of the input
object mentions an attribute name starting with the `gazelle prefix`.
 * If no Global Secondary Index is being created, the UpdateTableInput object MUST be returned unaltered.
 * If a Global Secondary Index being created but it refers to no encrypted fields,
the UpdateTableInput object MUST be returned unaltered.

 * If the Global Secondary Index being created references
an encrypted field in its Key Configuration,
 * * if that field does not have a beacon configured, transformUpdateTableInput MUST fail.
 * * otherwise, that field must be changed to be the beacon field, and its type changed to string.
 * If the Global Secondary Index being created has an explicit list
of attributes in its projection
 * * if an encrypted field is in its projection, and that field has a beacon configured,
then that beacon must be added to the projection.
 * * if an encrypted field was mentioned in the Key Configuration, then that
encrypted field must be added to the projection.


### transformPutItemInput
 * transformPutItemInput MUST take as input an PutItemInput object.
 * transformPutItemInput MUST return an PutItemInput object.
 * transformPutItemInput MUST fail if any part of the input
object mentions an attribute name starting with the `gazelle prefix`.
 * transformPutItemInput MUST use the `beacon version` with the write flag set.
 * The conditionExpression MUST be modified as per `Expression Transformation`
 * For each element in the `Item` map that specifies a source field,
 the returned `Item` map MUST also include the beacon field.
 * The name of this field MUST be the concatenation of the `beacon prefix` and the source field name.
 * The value of this field MUST be the defined [beacon](./beacons.md)

 * If the Primary Key Parts are not configured, the result MUST be returned
after applying only the above transformations.

 * If the primary key is present in the item's attributes, transformPutItemInput MUST fail.
 * transformPutItemInput MUST fail if the partition key is missing from the input attributes.
 * transformPutItemInput MUST fail if the sort key is specified, yet missing from the input attributes.
 * If only a primary key is specified, then an HMAC384 must be generated from it; otherwise,
 * an HMAC384 must be generated from the concatenation of the partition key,
a literal `_` character, and the sort key.
 * This HMAC value must be added to the item's attributes, associated with the primary key


### transformBatchWriteItemInput
 * transformBatchWriteItemInput MUST take as input a BatchWriteItemInput object.
 * transformBatchWriteItemInput MUST return a BatchWriteItemInput object.
 * Each item MUST be handled as outlined above in transformPutItemInput

### transformTransactWriteItemsInput
 * transformTransactWriteItemsInput MUST take as input a TransactWriteItemsInput object.
 * transformTransactWriteItemsInput MUST return a TransactWriteItemsInput object.
 * Each item MUST be handled as outlined above in transformPutItemInput
 * Each Condition Expression must be transformed as per `Expression Transformation`

### transformGetItemInput
 * transformGetItemInput MUST take as input a GetItemInput object.
 * transformGetItemInput MUST return the unaltered input object.

### transformBatchGetItemInput
 * transformBatchGetItemInput MUST take as input a BatchGetItem Input object.
 * transformBatchGetItemInput MUST return the unaltered input object.

### transformTransactGetItemsInput
 * transformTransactGetItemsInput MUST take as input a TransactGetItemsInput object.
 * transformTransactGetItemsInput MUST return the unaltered input object.

### transformExecuteStatementInput
 * transformExecuteStatementInput MUST take as input an ExecuteStatementInput object.
 * transformExecuteStatementInput MUST return an ExecuteStatementInput object.
 * transformExecuteStatementInput MUST fail

### transformBatchExecuteStatementInput
 * transformBatchExecuteStatementInput MUST take as input an BatchExecuteStatementInput object.
 * transformBatchExecuteStatementInput MUST return an BatchExecuteStatementInput object.
 * transformBatchExecuteStatementInput MUST fail

### transformExecuteTransactionInput
 * transformExecuteTransactionInput MUST take as input an ExecuteTransactionInput object.
 * transformExecuteTransactionInput MUST return an ExecuteTransactionInput object.
 * transformExecuteTransactionInput MUST fail

### Expression Transformation
 * this is a virtual entry point, describing the modification of a
Filter Expression or Condition Expression,
and the associated Expression Attribute Names and Expression Attribute Values.
 * This operation MUST fail if an attribute name that starts with the `gazelle prefix` is mentioned.
 * This operation MUST fail if any source field is used with a document path.
 * If no encrypted field is mentioned, the Expression MUST be returned unmodified.
 * The operations `attribute_exists`, `attribute_not_exists` and `size` are permitted
on any field.
 * All operations are permitted on unencrypted fields.
 * The operations `=`, `IN`, `attribute_exists`, `attribute_not_exists` and `size`;
as well as the boolean `AND`, `OR` and `NOT` are permitted for any type of beacon.
 * All comparators, and the `BETWEEN` and `begins_with` operations are permitted on
beacons configured with `prefix` or `split`.
 * The operation `contains` is permitted on beacons configured with `split`.
 * This operation MUST fail if a field is used with an operation that is not permitted.
 * If only a single beacon version exists, each reference to a field with a beacon must be replaced by the associated beacon.
For example, `field < value` would be replaced by `aws-ddbec-sb-field < beacon_value`
 * If multiple beacon versions exists, create a separate Expression for each version,
remove duplicates, and combine the remainsing ones, individually parenthesised, with `OR`.
For example, if E1 and E2 are created and unique, return `(E1) OR (E2)`


### transformUpdateItemInput
 * transformUpdateItemInput MUST take as input an UpdateItemInput
 * transformUpdateItemInput MUST return the unmodified input object
 * transformUpdateItemInput MUST fail if any part of the input
object mentions an attribute name starting with the `gazelle prefix`.
 * transformUpdateItemInput MUST fail if the input object attempts to modify a signed attribute.
 * The Condition Expression MUST be modified as per `Expression Transformation`

findVersion looks at the exclusiveStartKey in a QueryInput
and returns the beacon version held therein.

### findVersion
 * findVersion MUST take as input a QueryInput object
 * findVersion MUST return both an optional version number and a boolean `hadContent` flag.
 * If the input object has no exclusiveStartKey, then findVersion MUST return (None, false)
 * If the exclusiveStartKey has a `aws-ddbec-version` field which holds a number,
the first value returned by findVersion MUST be that number, and None otherwise
 * If the exclusiveStartKey has fields othe than `aws-ddbec-version`,
the first value returned by findVersion MUST be true, and false otherwise

### createKeyCondition
 * createKeyCondition MUST take as input a keyConditionExpression and a single `beacon version`
 * createKeyCondition MUST return a keyConditionExpression
 * createKeyCondition MUST replace each reference to a source field with the associated beacon and value. For example, `field < value` would be replaced by `aws-ddbec-sb-field < beacon_value`
 * createKeyCondition MUST fail if and operator other than `=` is used with a beacon
configured with neither `prefix` nor `split`
 * createKeyCondition MUST fail if and operator other than `=` or `begins_with` is used with a beacon not configured with `prefix`


### createKeyConditionList
 * createKeyConditionList MUST take as input a QueryInput object
 * createKeyConditionList MUST return a list of keyConditionExpression with an associated beacon version.
 * For each beacon version, create keyConditionExpression with createKeyCondition
 * remove any duplicate keyConditionExpressions, keeping the one with the highest version number.



### transformQueryInput
 * transformQueryInput MUST take as input a QueryInput object.
 * transformQueryInput MUST return a QueryInput object.
 * transformQueryInput MUST fail if an attribute name that starts with the `gazelle prefix` is mentioned.
 * If no encrypted field is mentioned, transformQueryInput MUST return the unmodified input object.
 * The output object's `Filter Expression` must be derived from the input `Filter Expression` according to `Expression Transformation` above.
 * If the keyConditionExpression refers to no encrypted attributes, then the result
MUST be returned after only the above operations.
 * transformQueryInput MUST call `createKeyConditionList` to create a KeyConditionList
 * transformQueryInput MUST call `findVersion` to create `currentVersion` and `hadContent`
 * transformQueryInput MUST fail if `findVersion` returns (None, true)
 * if `findVersion` returns (None, false) then transformQueryInput MUST return
the keyConditionExpression with the lowest version and no exclusiveStartKey
 * if `findVersion` returns (Some(currentVersion), false), then transformQueryInput MUST return
the keyConditionExpression with lowest beacon version greater than currentVersion,
and no exclusiveStartKey
 * if `findVersion` returns (Some(currentVersion), true), then transformQueryInput MUST return
 * * the beacon version that matches currentVersion, and the exclusiveStartKey with the `aws-ddbec-version` field removed, if such a beacon version exists.
 * * the beacon with the lowest version greater than currentVersion, with no exclusiveStartKey if such a beacon version exists
 * * failure if all available beacon versions are less than the returned version.


transformQueryOutput needs the original QueryInput object,
because we need to check the result records against the values searched in the QueryInput object, which are not directly available in the QueryOutput object.

### transformQueryOutput
 * transformQueryOutput MUST take as input a QueryOutput object and a QueryInput object
 * The QueryInput object MUST be assumed to be the original query, not the result of transformQueryInput
 * transformQueryOutput MUST return an QueryOutput object.
 * transformQueryOutput MUST remove any records for which the original QueryInput does not match, that is,
if the original FilterExpression included `Src EQ "foo"` (where `Src` is a source field)
then this operation must remove any record in which the  `Src` field contains something other than "foo".
 * This operation MUST return all records that match the original QueryInput.

The final step is to tag the LastEvaluatedKey

 * transformQueryOutput MUST call `createKeyConditionList` to create a keyConditionList
 * transformQueryOutput MUST use `findVersion` to retrieve the `currentVersion`
 * if `currentVersion` is None, replace it with the lowest version in keyConditionList
 * If the input object has a LastEvaluatedKey, transformQueryOutput must return a LastEvaluatedKey equal to the input LastEvaluatedKey with the additon of a number field `aws-ddbec-version= currentVersion`
 * If the input object has no LastEvaluatedKey, and `currentVersion` is greater than or equal to the highest version in the keyConditionList, then transformQueryOutput must return an object with no LastEvaluatedKey
 * Otherwise, transformQueryOutput must return a LastEvaluatedKey containing only a number field `aws-ddbec-version` set to the lowest version in keyConditionList greater than `currentVersion`


### transformScanInput
 * transformScanInput MUST take as input a ScanInput object.
 * transformScanInput MUST return a ScanInput object.
 * The object's filterExpression it must be modified according to `Expression Transformation` above.


### transformScanOutput
 * transformScanOutput MUST take as input a ScanOutput object and a ScanInput object.
 * transformScanOutput MUST return an ScanOutput object.
 * The ScanInput object MUST be assumed to be the original ScanInput object,
and not the result of transformScanInput call.
 * transformScanOutput MUST remove any records for which the original QueryInput does not match, that is,
if the original FilterExpression included `Src EQ "foo"` (where `Src` is a source field)
then this operation must remove any record in which the  `Src` field contains something other than "foo".
 * transformScanOutput MUST return all records that match the original ScanInput.


## Operational Considerations
Fully supporting FilterExpressions, will require a complete parsing of the FilterExpression,
which is sensitive to any updates that the DynamoDB team makes to the expression language.
