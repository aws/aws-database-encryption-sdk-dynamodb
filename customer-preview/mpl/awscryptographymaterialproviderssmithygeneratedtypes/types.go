// Code generated by smithy-go-codegen DO NOT EDIT.

package awscryptographymaterialproviderssmithygeneratedtypes

import (
	"fmt"
	"unicode/utf8"

	"github.com/aws/aws-cryptographic-material-providers-library/releases/go/mpl/awscryptographykeystoresmithygenerated"
	"github.com/aws/aws-cryptographic-material-providers-library/releases/go/mpl/awscryptographykeystoresmithygeneratedtypes"
	"github.com/aws/aws-cryptographic-material-providers-library/releases/go/primitives/awscryptographyprimitivessmithygeneratedtypes"
	"github.com/aws/aws-sdk-go-v2/service/kms"
	kmstypes "github.com/aws/aws-sdk-go-v2/service/kms/types"
)

type HKDF struct {
	Hmac awscryptographyprimitivessmithygeneratedtypes.DigestAlgorithm

	InputKeyLength int32

	OutputKeyLength int32

	SaltLength int32
}

func (input HKDF) Validate() error {
	if input.InputKeyLength < 1 {
		return fmt.Errorf("SymmetricKeyLength has a minimum of 1 but has the value of %d.", input.InputKeyLength)
	}
	if input.InputKeyLength > 32 {
		return fmt.Errorf("SymmetricKeyLength has a maximum of 32 but has the value of %d.", input.InputKeyLength)
	}
	if input.OutputKeyLength < 1 {
		return fmt.Errorf("SymmetricKeyLength has a minimum of 1 but has the value of %d.", input.OutputKeyLength)
	}
	if input.OutputKeyLength > 32 {
		return fmt.Errorf("SymmetricKeyLength has a maximum of 32 but has the value of %d.", input.OutputKeyLength)
	}
	if input.SaltLength < 0 {
		return fmt.Errorf("PositiveInteger has a minimum of 0 but has the value of %d.", input.SaltLength)
	}

	return nil
}

type IDENTITY struct {
}

func (input IDENTITY) Validate() error {

	return nil
}

type None struct {
}

func (input None) Validate() error {

	return nil
}

type DIRECT_KEY_WRAPPING struct {
}

func (input DIRECT_KEY_WRAPPING) Validate() error {

	return nil
}

type IntermediateKeyWrapping struct {
	KeyEncryptionKeyKdf DerivationAlgorithm

	MacKeyKdf DerivationAlgorithm

	PdkEncryptAlgorithm Encrypt
}

func (input IntermediateKeyWrapping) Validate() error {
	if input.KeyEncryptionKeyKdf == nil {
		return fmt.Errorf("input.KeyEncryptionKeyKdf is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_IntermediateKeyWrapping_keyEncryptionKeyKdf_Validate() != nil {
		return input.Aws_cryptography_materialProviders_IntermediateKeyWrapping_keyEncryptionKeyKdf_Validate()
	}
	if input.MacKeyKdf == nil {
		return fmt.Errorf("input.MacKeyKdf is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_IntermediateKeyWrapping_macKeyKdf_Validate() != nil {
		return input.Aws_cryptography_materialProviders_IntermediateKeyWrapping_macKeyKdf_Validate()
	}
	if input.PdkEncryptAlgorithm == nil {
		return fmt.Errorf("input.PdkEncryptAlgorithm is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_IntermediateKeyWrapping_pdkEncryptAlgorithm_Validate() != nil {
		return input.Aws_cryptography_materialProviders_IntermediateKeyWrapping_pdkEncryptAlgorithm_Validate()
	}

	return nil
}

func (input IntermediateKeyWrapping) Aws_cryptography_materialProviders_IntermediateKeyWrapping_keyEncryptionKeyKdf_Validate() error {
	if input.KeyEncryptionKeyKdf == nil {
		return nil
	}
	switch unionType := input.KeyEncryptionKeyKdf.(type) {
	case *DerivationAlgorithmMemberHKDF:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *DerivationAlgorithmMemberIDENTITY:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *DerivationAlgorithmMemberNone:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}
func (input IntermediateKeyWrapping) Aws_cryptography_materialProviders_IntermediateKeyWrapping_macKeyKdf_Validate() error {
	if input.MacKeyKdf == nil {
		return nil
	}
	switch unionType := input.MacKeyKdf.(type) {
	case *DerivationAlgorithmMemberHKDF:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *DerivationAlgorithmMemberIDENTITY:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *DerivationAlgorithmMemberNone:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}
func (input IntermediateKeyWrapping) Aws_cryptography_materialProviders_IntermediateKeyWrapping_pdkEncryptAlgorithm_Validate() error {
	if input.PdkEncryptAlgorithm == nil {
		return nil
	}
	switch unionType := input.PdkEncryptAlgorithm.(type) {
	case *EncryptMemberAES_GCM:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}

type ECDSA struct {
	Curve awscryptographyprimitivessmithygeneratedtypes.ECDSASignatureAlgorithm
}

func (input ECDSA) Validate() error {

	return nil
}

type AlgorithmSuiteInfo struct {
	BinaryId []byte

	Commitment DerivationAlgorithm

	EdkWrapping EdkWrappingAlgorithm

	Encrypt Encrypt

	Id AlgorithmSuiteId

	Kdf DerivationAlgorithm

	MessageVersion int32

	Signature SignatureAlgorithm

	SymmetricSignature SymmetricSignatureAlgorithm
}

func (input AlgorithmSuiteInfo) Validate() error {
	if input.Commitment == nil {
		return fmt.Errorf("input.Commitment is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_AlgorithmSuiteInfo_commitment_Validate() != nil {
		return input.Aws_cryptography_materialProviders_AlgorithmSuiteInfo_commitment_Validate()
	}
	if input.EdkWrapping == nil {
		return fmt.Errorf("input.EdkWrapping is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_AlgorithmSuiteInfo_edkWrapping_Validate() != nil {
		return input.Aws_cryptography_materialProviders_AlgorithmSuiteInfo_edkWrapping_Validate()
	}
	if input.Encrypt == nil {
		return fmt.Errorf("input.Encrypt is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_AlgorithmSuiteInfo_encrypt_Validate() != nil {
		return input.Aws_cryptography_materialProviders_AlgorithmSuiteInfo_encrypt_Validate()
	}
	if input.Id == nil {
		return fmt.Errorf("input.Id is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_AlgorithmSuiteInfo_id_Validate() != nil {
		return input.Aws_cryptography_materialProviders_AlgorithmSuiteInfo_id_Validate()
	}
	if input.Kdf == nil {
		return fmt.Errorf("input.Kdf is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_AlgorithmSuiteInfo_kdf_Validate() != nil {
		return input.Aws_cryptography_materialProviders_AlgorithmSuiteInfo_kdf_Validate()
	}
	if input.Signature == nil {
		return fmt.Errorf("input.Signature is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_AlgorithmSuiteInfo_signature_Validate() != nil {
		return input.Aws_cryptography_materialProviders_AlgorithmSuiteInfo_signature_Validate()
	}
	if input.SymmetricSignature == nil {
		return fmt.Errorf("input.SymmetricSignature is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_AlgorithmSuiteInfo_symmetricSignature_Validate() != nil {
		return input.Aws_cryptography_materialProviders_AlgorithmSuiteInfo_symmetricSignature_Validate()
	}

	return nil
}

func (input AlgorithmSuiteInfo) Aws_cryptography_materialProviders_AlgorithmSuiteInfo_commitment_Validate() error {
	if input.Commitment == nil {
		return nil
	}
	switch unionType := input.Commitment.(type) {
	case *DerivationAlgorithmMemberHKDF:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *DerivationAlgorithmMemberIDENTITY:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *DerivationAlgorithmMemberNone:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}
func (input AlgorithmSuiteInfo) Aws_cryptography_materialProviders_AlgorithmSuiteInfo_edkWrapping_Validate() error {
	if input.EdkWrapping == nil {
		return nil
	}
	switch unionType := input.EdkWrapping.(type) {
	case *EdkWrappingAlgorithmMemberDIRECT_KEY_WRAPPING:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *EdkWrappingAlgorithmMemberIntermediateKeyWrapping:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}
func (input AlgorithmSuiteInfo) Aws_cryptography_materialProviders_AlgorithmSuiteInfo_encrypt_Validate() error {
	if input.Encrypt == nil {
		return nil
	}
	switch unionType := input.Encrypt.(type) {
	case *EncryptMemberAES_GCM:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}
func (input AlgorithmSuiteInfo) Aws_cryptography_materialProviders_AlgorithmSuiteInfo_id_Validate() error {
	if input.Id == nil {
		return nil
	}
	switch unionType := input.Id.(type) {
	case *AlgorithmSuiteIdMemberESDK:
	case *AlgorithmSuiteIdMemberDBE:
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}
func (input AlgorithmSuiteInfo) Aws_cryptography_materialProviders_AlgorithmSuiteInfo_kdf_Validate() error {
	if input.Kdf == nil {
		return nil
	}
	switch unionType := input.Kdf.(type) {
	case *DerivationAlgorithmMemberHKDF:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *DerivationAlgorithmMemberIDENTITY:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *DerivationAlgorithmMemberNone:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}
func (input AlgorithmSuiteInfo) Aws_cryptography_materialProviders_AlgorithmSuiteInfo_signature_Validate() error {
	if input.Signature == nil {
		return nil
	}
	switch unionType := input.Signature.(type) {
	case *SignatureAlgorithmMemberECDSA:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *SignatureAlgorithmMemberNone:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}
func (input AlgorithmSuiteInfo) Aws_cryptography_materialProviders_AlgorithmSuiteInfo_symmetricSignature_Validate() error {
	if input.SymmetricSignature == nil {
		return nil
	}
	switch unionType := input.SymmetricSignature.(type) {
	case *SymmetricSignatureAlgorithmMemberHMAC:
	case *SymmetricSignatureAlgorithmMemberNone:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}

type GetClientInput struct {
	Region string
}

func (input GetClientInput) Validate() error {

	return nil
}

type KmsClientReference struct {
}

func (input KmsClientReference) Validate() error {

	return nil
}

type GetClientOutput struct {
	Client *kms.Client
}

func (input GetClientOutput) Validate() error {

	return nil
}

type DiscoveryFilter struct {
	AccountIds []string

	Partition string
}

func (input DiscoveryFilter) Validate() error {
	if input.AccountIds == nil {
		return fmt.Errorf("input.AccountIds is required but has a nil value.")
	}

	return nil
}

type CreateAwsKmsDiscoveryKeyringInput struct {
	KmsClient *kms.Client

	DiscoveryFilter *DiscoveryFilter

	GrantTokens []string
}

func (input CreateAwsKmsDiscoveryKeyringInput) Validate() error {
	if input.DiscoveryFilter != nil {
		if input.DiscoveryFilter.Validate() != nil {
			return input.DiscoveryFilter.Validate()
		}

	}

	return nil
}

type KeyringReference struct {
}

func (input KeyringReference) Validate() error {

	return nil
}

type CreateKeyringOutput struct {
	Keyring IKeyring
}

func (input CreateKeyringOutput) Validate() error {

	return nil
}

type ClientSupplierReference struct {
}

func (input ClientSupplierReference) Validate() error {

	return nil
}

type CreateAwsKmsDiscoveryMultiKeyringInput struct {
	Regions []string

	ClientSupplier IClientSupplier

	DiscoveryFilter *DiscoveryFilter

	GrantTokens []string
}

func (input CreateAwsKmsDiscoveryMultiKeyringInput) Validate() error {
	if input.Regions == nil {
		return fmt.Errorf("input.Regions is required but has a nil value.")
	}
	if input.DiscoveryFilter != nil {
		if input.DiscoveryFilter.Validate() != nil {
			return input.DiscoveryFilter.Validate()
		}

	}

	return nil
}

type KmsPrivateKeyToStaticPublicKeyInput struct {
	RecipientPublicKey []byte

	SenderKmsIdentifier string

	SenderPublicKey []byte
}

func (input KmsPrivateKeyToStaticPublicKeyInput) Validate() error {

	return nil
}

type KmsPublicKeyDiscoveryInput struct {
	RecipientKmsIdentifier string
}

func (input KmsPublicKeyDiscoveryInput) Validate() error {

	return nil
}

type CreateAwsKmsEcdhKeyringInput struct {
	CurveSpec awscryptographyprimitivessmithygeneratedtypes.ECDHCurveSpec

	KeyAgreementScheme KmsEcdhStaticConfigurations

	KmsClient *kms.Client

	GrantTokens []string
}

func (input CreateAwsKmsEcdhKeyringInput) Validate() error {
	if input.KeyAgreementScheme == nil {
		return fmt.Errorf("input.KeyAgreementScheme is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_CreateAwsKmsEcdhKeyringInput_KeyAgreementScheme_Validate() != nil {
		return input.Aws_cryptography_materialProviders_CreateAwsKmsEcdhKeyringInput_KeyAgreementScheme_Validate()
	}

	return nil
}

func (input CreateAwsKmsEcdhKeyringInput) Aws_cryptography_materialProviders_CreateAwsKmsEcdhKeyringInput_KeyAgreementScheme_Validate() error {
	if input.KeyAgreementScheme == nil {
		return nil
	}
	switch unionType := input.KeyAgreementScheme.(type) {
	case *KmsEcdhStaticConfigurationsMemberKmsPublicKeyDiscovery:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KmsEcdhStaticConfigurationsMemberKmsPrivateKeyToStaticPublicKey:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}

type BranchKeyIdSupplierReference struct {
}

func (input BranchKeyIdSupplierReference) Validate() error {

	return nil
}

type DefaultCache struct {
	EntryCapacity int32
}

func (input DefaultCache) Validate() error {
	if input.EntryCapacity < 1 {
		return fmt.Errorf("CountingNumber has a minimum of 1 but has the value of %d.", input.EntryCapacity)
	}

	return nil
}

type MultiThreadedCache struct {
	EntryCapacity int32

	EntryPruningTailSize *int32
}

func (input MultiThreadedCache) Validate() error {
	if input.EntryCapacity < 1 {
		return fmt.Errorf("CountingNumber has a minimum of 1 but has the value of %d.", input.EntryCapacity)
	}
	if input.EntryPruningTailSize != nil {
		if *input.EntryPruningTailSize < 1 {
			return fmt.Errorf("CountingNumber has a minimum of 1 but has the value of %d.", *input.EntryPruningTailSize)
		}
	}

	return nil
}

type NoCache struct {
}

func (input NoCache) Validate() error {

	return nil
}

type CryptographicMaterialsCacheReference struct {
}

func (input CryptographicMaterialsCacheReference) Validate() error {

	return nil
}

type SingleThreadedCache struct {
	EntryCapacity int32

	EntryPruningTailSize *int32
}

func (input SingleThreadedCache) Validate() error {
	if input.EntryCapacity < 1 {
		return fmt.Errorf("CountingNumber has a minimum of 1 but has the value of %d.", input.EntryCapacity)
	}
	if input.EntryPruningTailSize != nil {
		if *input.EntryPruningTailSize < 1 {
			return fmt.Errorf("CountingNumber has a minimum of 1 but has the value of %d.", *input.EntryPruningTailSize)
		}
	}

	return nil
}

type StormTrackingCache struct {
	EntryCapacity int32

	FanOut int32

	GraceInterval int32

	GracePeriod int32

	InFlightTTL int32

	SleepMilli int32

	EntryPruningTailSize *int32

	TimeUnits *TimeUnits
}

func (input StormTrackingCache) Validate() error {
	if input.EntryCapacity < 1 {
		return fmt.Errorf("CountingNumber has a minimum of 1 but has the value of %d.", input.EntryCapacity)
	}
	if input.FanOut < 1 {
		return fmt.Errorf("CountingNumber has a minimum of 1 but has the value of %d.", input.FanOut)
	}
	if input.GraceInterval < 1 {
		return fmt.Errorf("CountingNumber has a minimum of 1 but has the value of %d.", input.GraceInterval)
	}
	if input.GracePeriod < 1 {
		return fmt.Errorf("CountingNumber has a minimum of 1 but has the value of %d.", input.GracePeriod)
	}
	if input.InFlightTTL < 1 {
		return fmt.Errorf("CountingNumber has a minimum of 1 but has the value of %d.", input.InFlightTTL)
	}
	if input.SleepMilli < 1 {
		return fmt.Errorf("CountingNumber has a minimum of 1 but has the value of %d.", input.SleepMilli)
	}
	if input.EntryPruningTailSize != nil {
		if *input.EntryPruningTailSize < 1 {
			return fmt.Errorf("CountingNumber has a minimum of 1 but has the value of %d.", *input.EntryPruningTailSize)
		}
	}

	return nil
}

type KeyStoreReference struct {
}

func (input KeyStoreReference) Validate() error {

	return nil
}

type CreateAwsKmsHierarchicalKeyringInput struct {
	KeyStore *awscryptographykeystoresmithygenerated.Client

	TtlSeconds int64

	BranchKeyId *string

	BranchKeyIdSupplier IBranchKeyIdSupplier

	Cache CacheType

	PartitionId *string
}

func (input CreateAwsKmsHierarchicalKeyringInput) Validate() error {
	if input.TtlSeconds < 0 {
		return fmt.Errorf("PositiveLong has a minimum of 0 but has the value of %d.", input.TtlSeconds)
	}
	if input.Aws_cryptography_materialProviders_CreateAwsKmsHierarchicalKeyringInput_cache_Validate() != nil {
		return input.Aws_cryptography_materialProviders_CreateAwsKmsHierarchicalKeyringInput_cache_Validate()
	}

	return nil
}

func (input CreateAwsKmsHierarchicalKeyringInput) Aws_cryptography_materialProviders_CreateAwsKmsHierarchicalKeyringInput_cache_Validate() error {
	if input.Cache == nil {
		return nil
	}
	switch unionType := input.Cache.(type) {
	case *CacheTypeMemberDefault:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *CacheTypeMemberNo:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *CacheTypeMemberSingleThreaded:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *CacheTypeMemberMultiThreaded:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *CacheTypeMemberStormTracking:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *CacheTypeMemberShared:
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}

type CreateAwsKmsKeyringInput struct {
	KmsClient *kms.Client

	KmsKeyId string

	GrantTokens []string
}

func (input CreateAwsKmsKeyringInput) Validate() error {

	return nil
}

type CreateAwsKmsMrkDiscoveryKeyringInput struct {
	KmsClient *kms.Client

	Region string

	DiscoveryFilter *DiscoveryFilter

	GrantTokens []string
}

func (input CreateAwsKmsMrkDiscoveryKeyringInput) Validate() error {
	if input.DiscoveryFilter != nil {
		if input.DiscoveryFilter.Validate() != nil {
			return input.DiscoveryFilter.Validate()
		}

	}

	return nil
}

type CreateAwsKmsMrkDiscoveryMultiKeyringInput struct {
	Regions []string

	ClientSupplier IClientSupplier

	DiscoveryFilter *DiscoveryFilter

	GrantTokens []string
}

func (input CreateAwsKmsMrkDiscoveryMultiKeyringInput) Validate() error {
	if input.Regions == nil {
		return fmt.Errorf("input.Regions is required but has a nil value.")
	}
	if input.DiscoveryFilter != nil {
		if input.DiscoveryFilter.Validate() != nil {
			return input.DiscoveryFilter.Validate()
		}

	}

	return nil
}

type CreateAwsKmsMrkKeyringInput struct {
	KmsClient *kms.Client

	KmsKeyId string

	GrantTokens []string
}

func (input CreateAwsKmsMrkKeyringInput) Validate() error {

	return nil
}

type CreateAwsKmsMrkMultiKeyringInput struct {
	ClientSupplier IClientSupplier

	Generator *string

	GrantTokens []string

	KmsKeyIds []string
}

func (input CreateAwsKmsMrkMultiKeyringInput) Validate() error {

	return nil
}

type CreateAwsKmsMultiKeyringInput struct {
	ClientSupplier IClientSupplier

	Generator *string

	GrantTokens []string

	KmsKeyIds []string
}

func (input CreateAwsKmsMultiKeyringInput) Validate() error {

	return nil
}

type CreateAwsKmsRsaKeyringInput struct {
	EncryptionAlgorithm kmstypes.EncryptionAlgorithmSpec

	KmsKeyId string

	GrantTokens []string

	KmsClient *kms.Client

	PublicKey []byte
}

func (input CreateAwsKmsRsaKeyringInput) Validate() error {

	return nil
}

type CreateCryptographicMaterialsCacheInput struct {
	Cache CacheType
}

func (input CreateCryptographicMaterialsCacheInput) Validate() error {
	if input.Cache == nil {
		return fmt.Errorf("input.Cache is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_CreateCryptographicMaterialsCacheInput_cache_Validate() != nil {
		return input.Aws_cryptography_materialProviders_CreateCryptographicMaterialsCacheInput_cache_Validate()
	}

	return nil
}

func (input CreateCryptographicMaterialsCacheInput) Aws_cryptography_materialProviders_CreateCryptographicMaterialsCacheInput_cache_Validate() error {
	if input.Cache == nil {
		return nil
	}
	switch unionType := input.Cache.(type) {
	case *CacheTypeMemberDefault:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *CacheTypeMemberNo:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *CacheTypeMemberSingleThreaded:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *CacheTypeMemberMultiThreaded:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *CacheTypeMemberStormTracking:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *CacheTypeMemberShared:
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}

type CreateCryptographicMaterialsCacheOutput struct {
	MaterialsCache ICryptographicMaterialsCache
}

func (input CreateCryptographicMaterialsCacheOutput) Validate() error {

	return nil
}

type CreateDefaultClientSupplierInput struct {
}

func (input CreateDefaultClientSupplierInput) Validate() error {

	return nil
}

type CreateDefaultClientSupplierOutput struct {
	Client IClientSupplier
}

func (input CreateDefaultClientSupplierOutput) Validate() error {

	return nil
}

type CryptographicMaterialsManagerReference struct {
}

func (input CryptographicMaterialsManagerReference) Validate() error {

	return nil
}

type CreateCryptographicMaterialsManagerOutput struct {
	MaterialsManager ICryptographicMaterialsManager
}

func (input CreateCryptographicMaterialsManagerOutput) Validate() error {

	return nil
}

type CreateDefaultCryptographicMaterialsManagerInput struct {
	Keyring IKeyring
}

func (input CreateDefaultCryptographicMaterialsManagerInput) Validate() error {

	return nil
}

type CreateMultiKeyringInput struct {
	ChildKeyrings []IKeyring

	Generator IKeyring
}

func (input CreateMultiKeyringInput) Validate() error {
	if input.ChildKeyrings == nil {
		return fmt.Errorf("input.ChildKeyrings is required but has a nil value.")
	}

	return nil
}

type CreateRawAesKeyringInput struct {
	KeyName string

	KeyNamespace string

	WrappingAlg AesWrappingAlg

	WrappingKey []byte
}

func (input CreateRawAesKeyringInput) Validate() error {

	return nil
}

type EphemeralPrivateKeyToStaticPublicKeyInput struct {
	RecipientPublicKey []byte
}

func (input EphemeralPrivateKeyToStaticPublicKeyInput) Validate() error {

	return nil
}

type PublicKeyDiscoveryInput struct {
	RecipientStaticPrivateKey []byte
}

func (input PublicKeyDiscoveryInput) Validate() error {

	return nil
}

type RawPrivateKeyToStaticPublicKeyInput struct {
	RecipientPublicKey []byte

	SenderStaticPrivateKey []byte
}

func (input RawPrivateKeyToStaticPublicKeyInput) Validate() error {

	return nil
}

type CreateRawEcdhKeyringInput struct {
	CurveSpec awscryptographyprimitivessmithygeneratedtypes.ECDHCurveSpec

	KeyAgreementScheme RawEcdhStaticConfigurations
}

func (input CreateRawEcdhKeyringInput) Validate() error {
	if input.KeyAgreementScheme == nil {
		return fmt.Errorf("input.KeyAgreementScheme is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_CreateRawEcdhKeyringInput_KeyAgreementScheme_Validate() != nil {
		return input.Aws_cryptography_materialProviders_CreateRawEcdhKeyringInput_KeyAgreementScheme_Validate()
	}

	return nil
}

func (input CreateRawEcdhKeyringInput) Aws_cryptography_materialProviders_CreateRawEcdhKeyringInput_KeyAgreementScheme_Validate() error {
	if input.KeyAgreementScheme == nil {
		return nil
	}
	switch unionType := input.KeyAgreementScheme.(type) {
	case *RawEcdhStaticConfigurationsMemberPublicKeyDiscovery:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *RawEcdhStaticConfigurationsMemberRawPrivateKeyToStaticPublicKey:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *RawEcdhStaticConfigurationsMemberEphemeralPrivateKeyToStaticPublicKey:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}

type CreateRawRsaKeyringInput struct {
	KeyName string

	KeyNamespace string

	PaddingScheme PaddingScheme

	PrivateKey []byte

	PublicKey []byte
}

func (input CreateRawRsaKeyringInput) Validate() error {

	return nil
}

type CreateRequiredEncryptionContextCMMInput struct {
	RequiredEncryptionContextKeys []string

	Keyring IKeyring

	UnderlyingCMM ICryptographicMaterialsManager
}

func (input CreateRequiredEncryptionContextCMMInput) Validate() error {
	if input.RequiredEncryptionContextKeys == nil {
		return fmt.Errorf("input.RequiredEncryptionContextKeys is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_CreateRequiredEncryptionContextCMMInput_requiredEncryptionContextKeys_Validate() != nil {
		return input.Aws_cryptography_materialProviders_CreateRequiredEncryptionContextCMMInput_requiredEncryptionContextKeys_Validate()
	}

	return nil
}

func (input CreateRequiredEncryptionContextCMMInput) Aws_cryptography_materialProviders_CreateRequiredEncryptionContextCMMInput_requiredEncryptionContextKeys_Validate() error {
	for _, item := range input.RequiredEncryptionContextKeys {
		if !utf8.ValidString(item) {
			return fmt.Errorf("Invalid UTF bytes %s ", item)
		}
	}

	return nil
}

type CreateRequiredEncryptionContextCMMOutput struct {
	MaterialsManager ICryptographicMaterialsManager
}

func (input CreateRequiredEncryptionContextCMMOutput) Validate() error {

	return nil
}

type EncryptedDataKey struct {
	Ciphertext []byte

	KeyProviderId string

	KeyProviderInfo []byte
}

func (input EncryptedDataKey) Validate() error {
	if !utf8.ValidString(input.KeyProviderId) {
		return fmt.Errorf("Invalid UTF bytes %s ", input.KeyProviderId)
	}

	return nil
}

type DecryptMaterialsInput struct {
	AlgorithmSuiteId AlgorithmSuiteId

	CommitmentPolicy CommitmentPolicy

	EncryptedDataKeys []EncryptedDataKey

	EncryptionContext map[string]string

	ReproducedEncryptionContext map[string]string
}

func (input DecryptMaterialsInput) Validate() error {
	if input.AlgorithmSuiteId == nil {
		return fmt.Errorf("input.AlgorithmSuiteId is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_DecryptMaterialsInput_algorithmSuiteId_Validate() != nil {
		return input.Aws_cryptography_materialProviders_DecryptMaterialsInput_algorithmSuiteId_Validate()
	}
	if input.CommitmentPolicy == nil {
		return fmt.Errorf("input.CommitmentPolicy is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_DecryptMaterialsInput_commitmentPolicy_Validate() != nil {
		return input.Aws_cryptography_materialProviders_DecryptMaterialsInput_commitmentPolicy_Validate()
	}
	if input.EncryptedDataKeys == nil {
		return fmt.Errorf("input.EncryptedDataKeys is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_DecryptMaterialsInput_encryptedDataKeys_Validate() != nil {
		return input.Aws_cryptography_materialProviders_DecryptMaterialsInput_encryptedDataKeys_Validate()
	}
	if input.EncryptionContext == nil {
		return fmt.Errorf("input.EncryptionContext is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_DecryptMaterialsInput_encryptionContext_Validate() != nil {
		return input.Aws_cryptography_materialProviders_DecryptMaterialsInput_encryptionContext_Validate()
	}
	if input.Aws_cryptography_materialProviders_DecryptMaterialsInput_reproducedEncryptionContext_Validate() != nil {
		return input.Aws_cryptography_materialProviders_DecryptMaterialsInput_reproducedEncryptionContext_Validate()
	}

	return nil
}

func (input DecryptMaterialsInput) Aws_cryptography_materialProviders_DecryptMaterialsInput_algorithmSuiteId_Validate() error {
	if input.AlgorithmSuiteId == nil {
		return nil
	}
	switch unionType := input.AlgorithmSuiteId.(type) {
	case *AlgorithmSuiteIdMemberESDK:
	case *AlgorithmSuiteIdMemberDBE:
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}
func (input DecryptMaterialsInput) Aws_cryptography_materialProviders_DecryptMaterialsInput_commitmentPolicy_Validate() error {
	if input.CommitmentPolicy == nil {
		return nil
	}
	switch unionType := input.CommitmentPolicy.(type) {
	case *CommitmentPolicyMemberESDK:
	case *CommitmentPolicyMemberDBE:
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}
func (input DecryptMaterialsInput) Aws_cryptography_materialProviders_DecryptMaterialsInput_encryptedDataKeys_Validate() error {
	for _, item := range input.EncryptedDataKeys {
		if item.Validate() != nil {
			return item.Validate()
		}
	}

	return nil
}
func (input DecryptMaterialsInput) Aws_cryptography_materialProviders_DecryptMaterialsInput_encryptionContext_Validate() error {
	for key, value := range input.EncryptionContext {
		if !utf8.ValidString(key) {
			return fmt.Errorf("Invalid UTF bytes %s ", key)
		}
		if !utf8.ValidString(value) {
			return fmt.Errorf("Invalid UTF bytes %s ", value)
		}
	}

	return nil
}
func (input DecryptMaterialsInput) Aws_cryptography_materialProviders_DecryptMaterialsInput_reproducedEncryptionContext_Validate() error {
	for key, value := range input.ReproducedEncryptionContext {
		if !utf8.ValidString(key) {
			return fmt.Errorf("Invalid UTF bytes %s ", key)
		}
		if !utf8.ValidString(value) {
			return fmt.Errorf("Invalid UTF bytes %s ", value)
		}
	}

	return nil
}

type DecryptionMaterials struct {
	AlgorithmSuite AlgorithmSuiteInfo

	EncryptionContext map[string]string

	RequiredEncryptionContextKeys []string

	PlaintextDataKey []byte

	SymmetricSigningKey []byte

	VerificationKey []byte
}

func (input DecryptionMaterials) Validate() error {
	if input.AlgorithmSuite.Validate() != nil {
		return input.AlgorithmSuite.Validate()
	}
	if input.EncryptionContext == nil {
		return fmt.Errorf("input.EncryptionContext is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_DecryptionMaterials_encryptionContext_Validate() != nil {
		return input.Aws_cryptography_materialProviders_DecryptionMaterials_encryptionContext_Validate()
	}
	if input.RequiredEncryptionContextKeys == nil {
		return fmt.Errorf("input.RequiredEncryptionContextKeys is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_DecryptionMaterials_requiredEncryptionContextKeys_Validate() != nil {
		return input.Aws_cryptography_materialProviders_DecryptionMaterials_requiredEncryptionContextKeys_Validate()
	}

	return nil
}

func (input DecryptionMaterials) Aws_cryptography_materialProviders_DecryptionMaterials_encryptionContext_Validate() error {
	for key, value := range input.EncryptionContext {
		if !utf8.ValidString(key) {
			return fmt.Errorf("Invalid UTF bytes %s ", key)
		}
		if !utf8.ValidString(value) {
			return fmt.Errorf("Invalid UTF bytes %s ", value)
		}
	}

	return nil
}
func (input DecryptionMaterials) Aws_cryptography_materialProviders_DecryptionMaterials_requiredEncryptionContextKeys_Validate() error {
	for _, item := range input.RequiredEncryptionContextKeys {
		if !utf8.ValidString(item) {
			return fmt.Errorf("Invalid UTF bytes %s ", item)
		}
	}

	return nil
}

type DecryptMaterialsOutput struct {
	DecryptionMaterials DecryptionMaterials
}

func (input DecryptMaterialsOutput) Validate() error {
	if input.DecryptionMaterials.Validate() != nil {
		return input.DecryptionMaterials.Validate()
	}

	return nil
}

type GetEncryptionMaterialsInput struct {
	CommitmentPolicy CommitmentPolicy

	EncryptionContext map[string]string

	AlgorithmSuiteId AlgorithmSuiteId

	MaxPlaintextLength *int64

	RequiredEncryptionContextKeys []string
}

func (input GetEncryptionMaterialsInput) Validate() error {
	if input.CommitmentPolicy == nil {
		return fmt.Errorf("input.CommitmentPolicy is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_GetEncryptionMaterialsInput_commitmentPolicy_Validate() != nil {
		return input.Aws_cryptography_materialProviders_GetEncryptionMaterialsInput_commitmentPolicy_Validate()
	}
	if input.EncryptionContext == nil {
		return fmt.Errorf("input.EncryptionContext is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_GetEncryptionMaterialsInput_encryptionContext_Validate() != nil {
		return input.Aws_cryptography_materialProviders_GetEncryptionMaterialsInput_encryptionContext_Validate()
	}
	if input.Aws_cryptography_materialProviders_GetEncryptionMaterialsInput_algorithmSuiteId_Validate() != nil {
		return input.Aws_cryptography_materialProviders_GetEncryptionMaterialsInput_algorithmSuiteId_Validate()
	}
	if input.Aws_cryptography_materialProviders_GetEncryptionMaterialsInput_requiredEncryptionContextKeys_Validate() != nil {
		return input.Aws_cryptography_materialProviders_GetEncryptionMaterialsInput_requiredEncryptionContextKeys_Validate()
	}

	return nil
}

func (input GetEncryptionMaterialsInput) Aws_cryptography_materialProviders_GetEncryptionMaterialsInput_commitmentPolicy_Validate() error {
	if input.CommitmentPolicy == nil {
		return nil
	}
	switch unionType := input.CommitmentPolicy.(type) {
	case *CommitmentPolicyMemberESDK:
	case *CommitmentPolicyMemberDBE:
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}
func (input GetEncryptionMaterialsInput) Aws_cryptography_materialProviders_GetEncryptionMaterialsInput_encryptionContext_Validate() error {
	for key, value := range input.EncryptionContext {
		if !utf8.ValidString(key) {
			return fmt.Errorf("Invalid UTF bytes %s ", key)
		}
		if !utf8.ValidString(value) {
			return fmt.Errorf("Invalid UTF bytes %s ", value)
		}
	}

	return nil
}
func (input GetEncryptionMaterialsInput) Aws_cryptography_materialProviders_GetEncryptionMaterialsInput_algorithmSuiteId_Validate() error {
	if input.AlgorithmSuiteId == nil {
		return nil
	}
	switch unionType := input.AlgorithmSuiteId.(type) {
	case *AlgorithmSuiteIdMemberESDK:
	case *AlgorithmSuiteIdMemberDBE:
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}
func (input GetEncryptionMaterialsInput) Aws_cryptography_materialProviders_GetEncryptionMaterialsInput_requiredEncryptionContextKeys_Validate() error {
	for _, item := range input.RequiredEncryptionContextKeys {
		if !utf8.ValidString(item) {
			return fmt.Errorf("Invalid UTF bytes %s ", item)
		}
	}

	return nil
}

type EncryptionMaterials struct {
	AlgorithmSuite AlgorithmSuiteInfo

	EncryptedDataKeys []EncryptedDataKey

	EncryptionContext map[string]string

	RequiredEncryptionContextKeys []string

	PlaintextDataKey []byte

	SigningKey []byte

	SymmetricSigningKeys [][]byte
}

func (input EncryptionMaterials) Validate() error {
	if input.AlgorithmSuite.Validate() != nil {
		return input.AlgorithmSuite.Validate()
	}
	if input.EncryptedDataKeys == nil {
		return fmt.Errorf("input.EncryptedDataKeys is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_EncryptionMaterials_encryptedDataKeys_Validate() != nil {
		return input.Aws_cryptography_materialProviders_EncryptionMaterials_encryptedDataKeys_Validate()
	}
	if input.EncryptionContext == nil {
		return fmt.Errorf("input.EncryptionContext is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_EncryptionMaterials_encryptionContext_Validate() != nil {
		return input.Aws_cryptography_materialProviders_EncryptionMaterials_encryptionContext_Validate()
	}
	if input.RequiredEncryptionContextKeys == nil {
		return fmt.Errorf("input.RequiredEncryptionContextKeys is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_EncryptionMaterials_requiredEncryptionContextKeys_Validate() != nil {
		return input.Aws_cryptography_materialProviders_EncryptionMaterials_requiredEncryptionContextKeys_Validate()
	}

	return nil
}

func (input EncryptionMaterials) Aws_cryptography_materialProviders_EncryptionMaterials_encryptedDataKeys_Validate() error {
	for _, item := range input.EncryptedDataKeys {
		if item.Validate() != nil {
			return item.Validate()
		}
	}

	return nil
}
func (input EncryptionMaterials) Aws_cryptography_materialProviders_EncryptionMaterials_encryptionContext_Validate() error {
	for key, value := range input.EncryptionContext {
		if !utf8.ValidString(key) {
			return fmt.Errorf("Invalid UTF bytes %s ", key)
		}
		if !utf8.ValidString(value) {
			return fmt.Errorf("Invalid UTF bytes %s ", value)
		}
	}

	return nil
}
func (input EncryptionMaterials) Aws_cryptography_materialProviders_EncryptionMaterials_requiredEncryptionContextKeys_Validate() error {
	for _, item := range input.RequiredEncryptionContextKeys {
		if !utf8.ValidString(item) {
			return fmt.Errorf("Invalid UTF bytes %s ", item)
		}
	}

	return nil
}

type GetEncryptionMaterialsOutput struct {
	EncryptionMaterials EncryptionMaterials
}

func (input GetEncryptionMaterialsOutput) Validate() error {
	if input.EncryptionMaterials.Validate() != nil {
		return input.EncryptionMaterials.Validate()
	}

	return nil
}

type GetAlgorithmSuiteInfoInput struct {
	BinaryId []byte
}

func (input GetAlgorithmSuiteInfoInput) Validate() error {

	return nil
}

type InitializeDecryptionMaterialsInput struct {
	AlgorithmSuiteId AlgorithmSuiteId

	EncryptionContext map[string]string

	RequiredEncryptionContextKeys []string
}

func (input InitializeDecryptionMaterialsInput) Validate() error {
	if input.AlgorithmSuiteId == nil {
		return fmt.Errorf("input.AlgorithmSuiteId is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_InitializeDecryptionMaterialsInput_algorithmSuiteId_Validate() != nil {
		return input.Aws_cryptography_materialProviders_InitializeDecryptionMaterialsInput_algorithmSuiteId_Validate()
	}
	if input.EncryptionContext == nil {
		return fmt.Errorf("input.EncryptionContext is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_InitializeDecryptionMaterialsInput_encryptionContext_Validate() != nil {
		return input.Aws_cryptography_materialProviders_InitializeDecryptionMaterialsInput_encryptionContext_Validate()
	}
	if input.RequiredEncryptionContextKeys == nil {
		return fmt.Errorf("input.RequiredEncryptionContextKeys is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_InitializeDecryptionMaterialsInput_requiredEncryptionContextKeys_Validate() != nil {
		return input.Aws_cryptography_materialProviders_InitializeDecryptionMaterialsInput_requiredEncryptionContextKeys_Validate()
	}

	return nil
}

func (input InitializeDecryptionMaterialsInput) Aws_cryptography_materialProviders_InitializeDecryptionMaterialsInput_algorithmSuiteId_Validate() error {
	if input.AlgorithmSuiteId == nil {
		return nil
	}
	switch unionType := input.AlgorithmSuiteId.(type) {
	case *AlgorithmSuiteIdMemberESDK:
	case *AlgorithmSuiteIdMemberDBE:
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}
func (input InitializeDecryptionMaterialsInput) Aws_cryptography_materialProviders_InitializeDecryptionMaterialsInput_encryptionContext_Validate() error {
	for key, value := range input.EncryptionContext {
		if !utf8.ValidString(key) {
			return fmt.Errorf("Invalid UTF bytes %s ", key)
		}
		if !utf8.ValidString(value) {
			return fmt.Errorf("Invalid UTF bytes %s ", value)
		}
	}

	return nil
}
func (input InitializeDecryptionMaterialsInput) Aws_cryptography_materialProviders_InitializeDecryptionMaterialsInput_requiredEncryptionContextKeys_Validate() error {
	for _, item := range input.RequiredEncryptionContextKeys {
		if !utf8.ValidString(item) {
			return fmt.Errorf("Invalid UTF bytes %s ", item)
		}
	}

	return nil
}

type InitializeEncryptionMaterialsInput struct {
	AlgorithmSuiteId AlgorithmSuiteId

	EncryptionContext map[string]string

	RequiredEncryptionContextKeys []string

	SigningKey []byte

	VerificationKey []byte
}

func (input InitializeEncryptionMaterialsInput) Validate() error {
	if input.AlgorithmSuiteId == nil {
		return fmt.Errorf("input.AlgorithmSuiteId is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_InitializeEncryptionMaterialsInput_algorithmSuiteId_Validate() != nil {
		return input.Aws_cryptography_materialProviders_InitializeEncryptionMaterialsInput_algorithmSuiteId_Validate()
	}
	if input.EncryptionContext == nil {
		return fmt.Errorf("input.EncryptionContext is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_InitializeEncryptionMaterialsInput_encryptionContext_Validate() != nil {
		return input.Aws_cryptography_materialProviders_InitializeEncryptionMaterialsInput_encryptionContext_Validate()
	}
	if input.RequiredEncryptionContextKeys == nil {
		return fmt.Errorf("input.RequiredEncryptionContextKeys is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_InitializeEncryptionMaterialsInput_requiredEncryptionContextKeys_Validate() != nil {
		return input.Aws_cryptography_materialProviders_InitializeEncryptionMaterialsInput_requiredEncryptionContextKeys_Validate()
	}

	return nil
}

func (input InitializeEncryptionMaterialsInput) Aws_cryptography_materialProviders_InitializeEncryptionMaterialsInput_algorithmSuiteId_Validate() error {
	if input.AlgorithmSuiteId == nil {
		return nil
	}
	switch unionType := input.AlgorithmSuiteId.(type) {
	case *AlgorithmSuiteIdMemberESDK:
	case *AlgorithmSuiteIdMemberDBE:
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}
func (input InitializeEncryptionMaterialsInput) Aws_cryptography_materialProviders_InitializeEncryptionMaterialsInput_encryptionContext_Validate() error {
	for key, value := range input.EncryptionContext {
		if !utf8.ValidString(key) {
			return fmt.Errorf("Invalid UTF bytes %s ", key)
		}
		if !utf8.ValidString(value) {
			return fmt.Errorf("Invalid UTF bytes %s ", value)
		}
	}

	return nil
}
func (input InitializeEncryptionMaterialsInput) Aws_cryptography_materialProviders_InitializeEncryptionMaterialsInput_requiredEncryptionContextKeys_Validate() error {
	for _, item := range input.RequiredEncryptionContextKeys {
		if !utf8.ValidString(item) {
			return fmt.Errorf("Invalid UTF bytes %s ", item)
		}
	}

	return nil
}

type OnDecryptInput struct {
	EncryptedDataKeys []EncryptedDataKey

	Materials DecryptionMaterials
}

func (input OnDecryptInput) Validate() error {
	if input.EncryptedDataKeys == nil {
		return fmt.Errorf("input.EncryptedDataKeys is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_OnDecryptInput_encryptedDataKeys_Validate() != nil {
		return input.Aws_cryptography_materialProviders_OnDecryptInput_encryptedDataKeys_Validate()
	}
	if input.Materials.Validate() != nil {
		return input.Materials.Validate()
	}

	return nil
}

func (input OnDecryptInput) Aws_cryptography_materialProviders_OnDecryptInput_encryptedDataKeys_Validate() error {
	for _, item := range input.EncryptedDataKeys {
		if item.Validate() != nil {
			return item.Validate()
		}
	}

	return nil
}

type OnDecryptOutput struct {
	Materials DecryptionMaterials
}

func (input OnDecryptOutput) Validate() error {
	if input.Materials.Validate() != nil {
		return input.Materials.Validate()
	}

	return nil
}

type OnEncryptInput struct {
	Materials EncryptionMaterials
}

func (input OnEncryptInput) Validate() error {
	if input.Materials.Validate() != nil {
		return input.Materials.Validate()
	}

	return nil
}

type OnEncryptOutput struct {
	Materials EncryptionMaterials
}

func (input OnEncryptOutput) Validate() error {
	if input.Materials.Validate() != nil {
		return input.Materials.Validate()
	}

	return nil
}

type ValidateCommitmentPolicyOnDecryptInput struct {
	Algorithm AlgorithmSuiteId

	CommitmentPolicy CommitmentPolicy
}

func (input ValidateCommitmentPolicyOnDecryptInput) Validate() error {
	if input.Algorithm == nil {
		return fmt.Errorf("input.Algorithm is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_ValidateCommitmentPolicyOnDecryptInput_algorithm_Validate() != nil {
		return input.Aws_cryptography_materialProviders_ValidateCommitmentPolicyOnDecryptInput_algorithm_Validate()
	}
	if input.CommitmentPolicy == nil {
		return fmt.Errorf("input.CommitmentPolicy is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_ValidateCommitmentPolicyOnDecryptInput_commitmentPolicy_Validate() != nil {
		return input.Aws_cryptography_materialProviders_ValidateCommitmentPolicyOnDecryptInput_commitmentPolicy_Validate()
	}

	return nil
}

func (input ValidateCommitmentPolicyOnDecryptInput) Aws_cryptography_materialProviders_ValidateCommitmentPolicyOnDecryptInput_algorithm_Validate() error {
	if input.Algorithm == nil {
		return nil
	}
	switch unionType := input.Algorithm.(type) {
	case *AlgorithmSuiteIdMemberESDK:
	case *AlgorithmSuiteIdMemberDBE:
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}
func (input ValidateCommitmentPolicyOnDecryptInput) Aws_cryptography_materialProviders_ValidateCommitmentPolicyOnDecryptInput_commitmentPolicy_Validate() error {
	if input.CommitmentPolicy == nil {
		return nil
	}
	switch unionType := input.CommitmentPolicy.(type) {
	case *CommitmentPolicyMemberESDK:
	case *CommitmentPolicyMemberDBE:
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}

type ValidateCommitmentPolicyOnEncryptInput struct {
	Algorithm AlgorithmSuiteId

	CommitmentPolicy CommitmentPolicy
}

func (input ValidateCommitmentPolicyOnEncryptInput) Validate() error {
	if input.Algorithm == nil {
		return fmt.Errorf("input.Algorithm is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_ValidateCommitmentPolicyOnEncryptInput_algorithm_Validate() != nil {
		return input.Aws_cryptography_materialProviders_ValidateCommitmentPolicyOnEncryptInput_algorithm_Validate()
	}
	if input.CommitmentPolicy == nil {
		return fmt.Errorf("input.CommitmentPolicy is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_ValidateCommitmentPolicyOnEncryptInput_commitmentPolicy_Validate() != nil {
		return input.Aws_cryptography_materialProviders_ValidateCommitmentPolicyOnEncryptInput_commitmentPolicy_Validate()
	}

	return nil
}

func (input ValidateCommitmentPolicyOnEncryptInput) Aws_cryptography_materialProviders_ValidateCommitmentPolicyOnEncryptInput_algorithm_Validate() error {
	if input.Algorithm == nil {
		return nil
	}
	switch unionType := input.Algorithm.(type) {
	case *AlgorithmSuiteIdMemberESDK:
	case *AlgorithmSuiteIdMemberDBE:
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}
func (input ValidateCommitmentPolicyOnEncryptInput) Aws_cryptography_materialProviders_ValidateCommitmentPolicyOnEncryptInput_commitmentPolicy_Validate() error {
	if input.CommitmentPolicy == nil {
		return nil
	}
	switch unionType := input.CommitmentPolicy.(type) {
	case *CommitmentPolicyMemberESDK:
	case *CommitmentPolicyMemberDBE:
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}

type ValidDecryptionMaterialsTransitionInput struct {
	Start DecryptionMaterials

	Stop DecryptionMaterials
}

func (input ValidDecryptionMaterialsTransitionInput) Validate() error {
	if input.Start.Validate() != nil {
		return input.Start.Validate()
	}
	if input.Stop.Validate() != nil {
		return input.Stop.Validate()
	}

	return nil
}

type ValidEncryptionMaterialsTransitionInput struct {
	Start EncryptionMaterials

	Stop EncryptionMaterials
}

func (input ValidEncryptionMaterialsTransitionInput) Validate() error {
	if input.Start.Validate() != nil {
		return input.Start.Validate()
	}
	if input.Stop.Validate() != nil {
		return input.Stop.Validate()
	}

	return nil
}

type GetBranchKeyIdInput struct {
	EncryptionContext map[string]string
}

func (input GetBranchKeyIdInput) Validate() error {
	if input.EncryptionContext == nil {
		return fmt.Errorf("input.EncryptionContext is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_GetBranchKeyIdInput_encryptionContext_Validate() != nil {
		return input.Aws_cryptography_materialProviders_GetBranchKeyIdInput_encryptionContext_Validate()
	}

	return nil
}

func (input GetBranchKeyIdInput) Aws_cryptography_materialProviders_GetBranchKeyIdInput_encryptionContext_Validate() error {
	for key, value := range input.EncryptionContext {
		if !utf8.ValidString(key) {
			return fmt.Errorf("Invalid UTF bytes %s ", key)
		}
		if !utf8.ValidString(value) {
			return fmt.Errorf("Invalid UTF bytes %s ", value)
		}
	}

	return nil
}

type GetBranchKeyIdOutput struct {
	BranchKeyId string
}

func (input GetBranchKeyIdOutput) Validate() error {

	return nil
}

type DeleteCacheEntryInput struct {
	Identifier []byte
}

func (input DeleteCacheEntryInput) Validate() error {

	return nil
}

type GetCacheEntryInput struct {
	Identifier []byte

	BytesUsed *int64
}

func (input GetCacheEntryInput) Validate() error {

	return nil
}

type GetCacheEntryOutput struct {
	BytesUsed int32

	CreationTime int64

	ExpiryTime int64

	Materials Materials

	MessagesUsed int32
}

func (input GetCacheEntryOutput) Validate() error {
	if input.BytesUsed < 0 {
		return fmt.Errorf("PositiveInteger has a minimum of 0 but has the value of %d.", input.BytesUsed)
	}
	if input.CreationTime < 0 {
		return fmt.Errorf("PositiveLong has a minimum of 0 but has the value of %d.", input.CreationTime)
	}
	if input.ExpiryTime < 0 {
		return fmt.Errorf("PositiveLong has a minimum of 0 but has the value of %d.", input.ExpiryTime)
	}
	if input.Materials == nil {
		return fmt.Errorf("input.Materials is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_GetCacheEntryOutput_materials_Validate() != nil {
		return input.Aws_cryptography_materialProviders_GetCacheEntryOutput_materials_Validate()
	}
	if input.MessagesUsed < 0 {
		return fmt.Errorf("PositiveInteger has a minimum of 0 but has the value of %d.", input.MessagesUsed)
	}

	return nil
}

func (input GetCacheEntryOutput) Aws_cryptography_materialProviders_GetCacheEntryOutput_materials_Validate() error {
	if input.Materials == nil {
		return nil
	}
	switch unionType := input.Materials.(type) {
	case *MaterialsMemberEncryption:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *MaterialsMemberDecryption:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *MaterialsMemberBranchKey:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *MaterialsMemberBeaconKey:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}

type PutCacheEntryInput struct {
	CreationTime int64

	ExpiryTime int64

	Identifier []byte

	Materials Materials

	BytesUsed *int32

	MessagesUsed *int32
}

func (input PutCacheEntryInput) Validate() error {
	if input.CreationTime < 0 {
		return fmt.Errorf("PositiveLong has a minimum of 0 but has the value of %d.", input.CreationTime)
	}
	if input.ExpiryTime < 0 {
		return fmt.Errorf("PositiveLong has a minimum of 0 but has the value of %d.", input.ExpiryTime)
	}
	if input.Materials == nil {
		return fmt.Errorf("input.Materials is required but has a nil value.")
	}
	if input.Aws_cryptography_materialProviders_PutCacheEntryInput_materials_Validate() != nil {
		return input.Aws_cryptography_materialProviders_PutCacheEntryInput_materials_Validate()
	}
	if input.BytesUsed != nil {
		if *input.BytesUsed < 0 {
			return fmt.Errorf("PositiveInteger has a minimum of 0 but has the value of %d.", *input.BytesUsed)
		}
	}
	if input.MessagesUsed != nil {
		if *input.MessagesUsed < 0 {
			return fmt.Errorf("PositiveInteger has a minimum of 0 but has the value of %d.", *input.MessagesUsed)
		}
	}

	return nil
}

func (input PutCacheEntryInput) Aws_cryptography_materialProviders_PutCacheEntryInput_materials_Validate() error {
	if input.Materials == nil {
		return nil
	}
	switch unionType := input.Materials.(type) {
	case *MaterialsMemberEncryption:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *MaterialsMemberDecryption:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *MaterialsMemberBranchKey:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *MaterialsMemberBeaconKey:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}

type UpdateUsageMetadataInput struct {
	BytesUsed int32

	Identifier []byte
}

func (input UpdateUsageMetadataInput) Validate() error {
	if input.BytesUsed < 0 {
		return fmt.Errorf("PositiveInteger has a minimum of 0 but has the value of %d.", input.BytesUsed)
	}

	return nil
}

type DdbClientReference struct {
}

func (input DdbClientReference) Validate() error {

	return nil
}

type MaterialProvidersConfig struct {
}

func (input MaterialProvidersConfig) Validate() error {

	return nil
}

// AlgorithmSuiteIdMemberDBE
// AlgorithmSuiteIdMemberESDK
type AlgorithmSuiteId interface {
	isAlgorithmSuiteId()
}

type AlgorithmSuiteIdMemberDBE struct {
	Value DBEAlgorithmSuiteId
}

func (*AlgorithmSuiteIdMemberDBE) isAlgorithmSuiteId() {}

type AlgorithmSuiteIdMemberESDK struct {
	Value ESDKAlgorithmSuiteId
}

func (*AlgorithmSuiteIdMemberESDK) isAlgorithmSuiteId() {}

// CacheTypeMemberDefault
// CacheTypeMemberMultiThreaded
// CacheTypeMemberNo
// CacheTypeMemberShared
// CacheTypeMemberSingleThreaded
// CacheTypeMemberStormTracking
type CacheType interface {
	isCacheType()
}

type CacheTypeMemberDefault struct {
	Value DefaultCache
}

func (*CacheTypeMemberDefault) isCacheType() {}

type CacheTypeMemberMultiThreaded struct {
	Value MultiThreadedCache
}

func (*CacheTypeMemberMultiThreaded) isCacheType() {}

type CacheTypeMemberNo struct {
	Value NoCache
}

func (*CacheTypeMemberNo) isCacheType() {}

type CacheTypeMemberShared struct {
	Value ICryptographicMaterialsCache
}

func (*CacheTypeMemberShared) isCacheType() {}

type CacheTypeMemberSingleThreaded struct {
	Value SingleThreadedCache
}

func (*CacheTypeMemberSingleThreaded) isCacheType() {}

type CacheTypeMemberStormTracking struct {
	Value StormTrackingCache
}

func (*CacheTypeMemberStormTracking) isCacheType() {}

// CommitmentPolicyMemberDBE
// CommitmentPolicyMemberESDK
type CommitmentPolicy interface {
	isCommitmentPolicy()
}

type CommitmentPolicyMemberDBE struct {
	Value DBECommitmentPolicy
}

func (*CommitmentPolicyMemberDBE) isCommitmentPolicy() {}

type CommitmentPolicyMemberESDK struct {
	Value ESDKCommitmentPolicy
}

func (*CommitmentPolicyMemberESDK) isCommitmentPolicy() {}

// DerivationAlgorithmMemberHKDF
// DerivationAlgorithmMemberIDENTITY
// DerivationAlgorithmMemberNone
type DerivationAlgorithm interface {
	isDerivationAlgorithm()
}

type DerivationAlgorithmMemberHKDF struct {
	Value HKDF
}

func (*DerivationAlgorithmMemberHKDF) isDerivationAlgorithm() {}

type DerivationAlgorithmMemberIDENTITY struct {
	Value IDENTITY
}

func (*DerivationAlgorithmMemberIDENTITY) isDerivationAlgorithm() {}

type DerivationAlgorithmMemberNone struct {
	Value None
}

func (*DerivationAlgorithmMemberNone) isDerivationAlgorithm() {}

// EdkWrappingAlgorithmMemberDIRECT_KEY_WRAPPING
// EdkWrappingAlgorithmMemberIntermediateKeyWrapping
type EdkWrappingAlgorithm interface {
	isEdkWrappingAlgorithm()
}

type EdkWrappingAlgorithmMemberDIRECT_KEY_WRAPPING struct {
	Value DIRECT_KEY_WRAPPING
}

func (*EdkWrappingAlgorithmMemberDIRECT_KEY_WRAPPING) isEdkWrappingAlgorithm() {}

type EdkWrappingAlgorithmMemberIntermediateKeyWrapping struct {
	Value IntermediateKeyWrapping
}

func (*EdkWrappingAlgorithmMemberIntermediateKeyWrapping) isEdkWrappingAlgorithm() {}

// EncryptMemberAES_GCM
type Encrypt interface {
	isEncrypt()
}

type EncryptMemberAES_GCM struct {
	Value awscryptographyprimitivessmithygeneratedtypes.AES_GCM
}

func (*EncryptMemberAES_GCM) isEncrypt() {}

// KeyAgreementSchemeMemberStaticConfiguration
type KeyAgreementScheme interface {
	isKeyAgreementScheme()
}

type KeyAgreementSchemeMemberStaticConfiguration struct {
	Value StaticConfigurations
}

func (*KeyAgreementSchemeMemberStaticConfiguration) isKeyAgreementScheme() {}

// KmsEcdhStaticConfigurationsMemberKmsPrivateKeyToStaticPublicKey
// KmsEcdhStaticConfigurationsMemberKmsPublicKeyDiscovery
type KmsEcdhStaticConfigurations interface {
	isKmsEcdhStaticConfigurations()
}

type KmsEcdhStaticConfigurationsMemberKmsPrivateKeyToStaticPublicKey struct {
	Value KmsPrivateKeyToStaticPublicKeyInput
}

func (*KmsEcdhStaticConfigurationsMemberKmsPrivateKeyToStaticPublicKey) isKmsEcdhStaticConfigurations() {
}

type KmsEcdhStaticConfigurationsMemberKmsPublicKeyDiscovery struct {
	Value KmsPublicKeyDiscoveryInput
}

func (*KmsEcdhStaticConfigurationsMemberKmsPublicKeyDiscovery) isKmsEcdhStaticConfigurations() {}

// MaterialsMemberBeaconKey
// MaterialsMemberBranchKey
// MaterialsMemberDecryption
// MaterialsMemberEncryption
type Materials interface {
	isMaterials()
}

type MaterialsMemberBeaconKey struct {
	Value awscryptographykeystoresmithygeneratedtypes.BeaconKeyMaterials
}

func (*MaterialsMemberBeaconKey) isMaterials() {}

type MaterialsMemberBranchKey struct {
	Value awscryptographykeystoresmithygeneratedtypes.BranchKeyMaterials
}

func (*MaterialsMemberBranchKey) isMaterials() {}

type MaterialsMemberDecryption struct {
	Value DecryptionMaterials
}

func (*MaterialsMemberDecryption) isMaterials() {}

type MaterialsMemberEncryption struct {
	Value EncryptionMaterials
}

func (*MaterialsMemberEncryption) isMaterials() {}

// RawEcdhStaticConfigurationsMemberEphemeralPrivateKeyToStaticPublicKey
// RawEcdhStaticConfigurationsMemberPublicKeyDiscovery
// RawEcdhStaticConfigurationsMemberRawPrivateKeyToStaticPublicKey
type RawEcdhStaticConfigurations interface {
	isRawEcdhStaticConfigurations()
}

type RawEcdhStaticConfigurationsMemberEphemeralPrivateKeyToStaticPublicKey struct {
	Value EphemeralPrivateKeyToStaticPublicKeyInput
}

func (*RawEcdhStaticConfigurationsMemberEphemeralPrivateKeyToStaticPublicKey) isRawEcdhStaticConfigurations() {
}

type RawEcdhStaticConfigurationsMemberPublicKeyDiscovery struct {
	Value PublicKeyDiscoveryInput
}

func (*RawEcdhStaticConfigurationsMemberPublicKeyDiscovery) isRawEcdhStaticConfigurations() {}

type RawEcdhStaticConfigurationsMemberRawPrivateKeyToStaticPublicKey struct {
	Value RawPrivateKeyToStaticPublicKeyInput
}

func (*RawEcdhStaticConfigurationsMemberRawPrivateKeyToStaticPublicKey) isRawEcdhStaticConfigurations() {
}

// SignatureAlgorithmMemberECDSA
// SignatureAlgorithmMemberNone
type SignatureAlgorithm interface {
	isSignatureAlgorithm()
}

type SignatureAlgorithmMemberECDSA struct {
	Value ECDSA
}

func (*SignatureAlgorithmMemberECDSA) isSignatureAlgorithm() {}

type SignatureAlgorithmMemberNone struct {
	Value None
}

func (*SignatureAlgorithmMemberNone) isSignatureAlgorithm() {}

// StaticConfigurationsMemberAWS_KMS_ECDH
// StaticConfigurationsMemberRAW_ECDH
type StaticConfigurations interface {
	isStaticConfigurations()
}

type StaticConfigurationsMemberAWS_KMS_ECDH struct {
	Value KmsEcdhStaticConfigurations
}

func (*StaticConfigurationsMemberAWS_KMS_ECDH) isStaticConfigurations() {}

type StaticConfigurationsMemberRAW_ECDH struct {
	Value RawEcdhStaticConfigurations
}

func (*StaticConfigurationsMemberRAW_ECDH) isStaticConfigurations() {}

// SymmetricSignatureAlgorithmMemberHMAC
// SymmetricSignatureAlgorithmMemberNone
type SymmetricSignatureAlgorithm interface {
	isSymmetricSignatureAlgorithm()
}

type SymmetricSignatureAlgorithmMemberHMAC struct {
	Value awscryptographyprimitivessmithygeneratedtypes.DigestAlgorithm
}

func (*SymmetricSignatureAlgorithmMemberHMAC) isSymmetricSignatureAlgorithm() {}

type SymmetricSignatureAlgorithmMemberNone struct {
	Value None
}

func (*SymmetricSignatureAlgorithmMemberNone) isSymmetricSignatureAlgorithm() {}

type AwsCryptographicMaterialProvidersBaseException interface {
	// This is a dummy method to allow type assertion since Go empty interfaces
	// aren't useful for type assertion checks. No concrete class is expected to implement
	// this method. This is also not exported.
	interfaceBindingMethod()
}

type IBranchKeyIdSupplier interface {
	GetBranchKeyId(GetBranchKeyIdInput) (*GetBranchKeyIdOutput, error)
}

type IClientSupplier interface {
	GetClient(GetClientInput) (kms.Client, error)
}

type ICryptographicMaterialsCache interface {
	PutCacheEntry(PutCacheEntryInput) error

	GetCacheEntry(GetCacheEntryInput) (*GetCacheEntryOutput, error)

	UpdateUsageMetadata(UpdateUsageMetadataInput) error

	DeleteCacheEntry(DeleteCacheEntryInput) error
}

type ICryptographicMaterialsManager interface {
	GetEncryptionMaterials(GetEncryptionMaterialsInput) (*GetEncryptionMaterialsOutput, error)

	DecryptMaterials(DecryptMaterialsInput) (*DecryptMaterialsOutput, error)
}

type IKeyring interface {
	OnEncrypt(OnEncryptInput) (*OnEncryptOutput, error)

	OnDecrypt(OnDecryptInput) (*OnDecryptOutput, error)
}
